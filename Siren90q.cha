<?xml version="1.0"?><st-source><component-created><name>DLLCC</name> <type>package</type></component-created><parcel-loaded><name>DLLCC</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'dllcc' 'DLLCC.pcl'))</filename></parcel-loaded><component-created><name>AT Parser Compiler</name> <type>package</type></component-created><parcel-loaded><name>AT Parser Compiler</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATParserCompiler.pcl'))</filename></parcel-loaded><component-created><name>AT Parser Example</name> <type>package</type></component-created><parcel-loaded><name>AT Parser Example</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATParserExample.pcl'))</filename></parcel-loaded><component-created><name>AT MetaNumerics</name> <type>package</type></component-created><parcel-loaded><name>AT MetaNumerics</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATMetaNumerics.pcl'))</filename></parcel-loaded><component-created><name>AT Menu Support</name> <type>package</type></component-created><parcel-loaded><name>AT Menu Support</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATMenuSupport.pcl'))</filename></parcel-loaded><component-created><name>AT Support</name> <type>package</type></component-created><parcel-loaded><name>AT Support</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATSupport.pcl'))</filename></parcel-loaded><component-created><name>AT Benchmarks</name> <type>package</type></component-created><parcel-loaded><name>AT Benchmarks</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATBenchmarks.pcl'))</filename></parcel-loaded><component-created><name>AT System Analysis</name> <type>package</type></component-created><parcel-loaded><name>AT System Analysis</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATSystemAnalysis.pcl'))</filename></parcel-loaded><component-created><name>AT Profiling Core</name> <type>package</type></component-created><parcel-loaded><name>AT Profiling Core</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATProfilingCore.pcl'))</filename></parcel-loaded><component-created><name>AT Profiling UI</name> <type>package</type></component-created><parcel-loaded><name>AT Profiling UI</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATProfilingUI.pcl'))</filename></parcel-loaded><component-created><name>AT Integer Extensions</name> <type>package</type></component-created><parcel-loaded><name>AT Integer Extensions</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'ATIntegerExtensions.pcl'))</filename></parcel-loaded><component-created><name>All Advanced Tools</name> <type>package</type></component-created><parcel-loaded><name>All Advanced Tools</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'advanced' 'AllAdvancedTools.pcl'))</filename></parcel-loaded><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := (ColorValue lightYellow blendWith: ColorValue white) blendWith: ColorValue white.	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: background;			matchAt: SymbolicPaint inactiveBackground put: ColorValue white;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray	].	self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.	self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue white;		matchAt: SymbolicPaint selectionBackground put: ColorValue black.</body></methods><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><methods><class-id>UI.BorderDecorationPolicy</class-id> <category>private - regions</category><body package="UIBuilder-Support" selector="verticalScrollRegionFor:">verticalScrollRegionFor: aDecorator	"Answer a layout frame for aDecorator's vertical scrollbar."	"Compensate for the overlapping borders of the scroll bar and the data region."	| layout |"	layout := LayoutFrame new		topFraction: 0 offset: (self topOffsetFor: aDecorator);		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator);		leftFraction: 1 offset: (self rightOffsetFor: aDecorator);		rightFraction: 1 offset: 0."	layout := LayoutFrame new		topFraction: 0 offset: (self topOffsetFor: aDecorator);		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator);		leftFraction: 0 offset: 0;		rightFraction: 0 offset: (self rightOffsetFor: aDecorator) negated.	aDecorator hasHorizontalScrollbar		ifTrue: [ layout bottomOffset: layout bottomOffset + 1 ].	^layout</body></methods><methods><class-id>UI.BorderDecorationPolicy</class-id> <category>private - regions</category><body package="UIBuilder-Support" selector="leftOffsetFor:">leftOffsetFor: aDecorator	"Compute the distance from the left of the container to the left of the 	data area"	^aDecorator hasVerticalScrollbar ifTrue: [(UI.Skins.SkinRegistry current scrollbarArtistForView: nil) width] ifFalse: [0]</body></methods><methods><class-id>UI.BorderDecorationPolicy</class-id> <category>private - regions</category><body package="UIBuilder-Support" selector="dataRegionFor:">dataRegionFor: aDecorator	"Answer a layout frame for aDecorator's data area"	| vdelta hdelta b |	b := aDecorator hasBorder.	hdelta := (b and: [aDecorator hasHorizontalScrollbar]) ifTrue: [1] ifFalse: [0].	vdelta := (b and: [aDecorator hasVerticalScrollbar]) ifTrue: [1] ifFalse: [0].	"^LayoutFrame new		leftOffset: (self leftOffsetFor: aDecorator);		rightFraction: 1 offset: (self rightOffsetFor: aDecorator) + vdelta;		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator) + hdelta;		topOffset: (self topOffsetFor: aDecorator)"				^LayoutFrame new			leftOffset: (self leftOffsetFor: aDecorator);			rightFraction: 1 offset: vdelta;			bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator) + hdelta;			topOffset: (self topOffsetFor: aDecorator)</body></methods><do-it>Metaclass instanceCount</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '7:31:54 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:31:54 PM on May 20, 2020."</do-it><component-created><name>DLLCC</name> <type>package</type></component-created><parcel-loaded><name>DLLCC</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'dllcc' 'DLLCC.pcl'))</filename></parcel-loaded><component-created><name>DLLCC-Tools</name> <type>package</type></component-created><parcel-loaded><name>DLLCC-Tools</name> <filename>(OS.PortableFilename fromComponents: #('$(VISUALWORKS)' 'dllcc' 'DLLCC-Tools.pcl'))</filename></parcel-loaded><component-created><name>OldBrowsers</name> <type>package</type></component-created><parcel-loaded><name>OldBrowsers</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Content' 'Code' 'Smalltalk' 'Siren9' 'OldBrowsers.pcl'))</filename></parcel-loaded><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '7:33:45 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:33:45 PM on May 20, 2020."</do-it><methods><class-id>UI.BorderDecorationPolicy</class-id> <category>private - regions</category><body package="UIBuilder-Support" selector="verticalScrollRegionFor:">verticalScrollRegionFor: aDecorator	"Answer a layout frame for aDecorator's vertical scrollbar."	"Compensate for the overlapping borders of the scroll bar and the data region."	| layout |"	layout := LayoutFrame new		topFraction: 0 offset: (self topOffsetFor: aDecorator);		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator);		leftFraction: 1 offset: (self rightOffsetFor: aDecorator);		rightFraction: 1 offset: 0."	layout := LayoutFrame new		topFraction: 0 offset: (self topOffsetFor: aDecorator);		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator);		leftFraction: 0 offset: 0;		rightFraction: 0 offset: (self rightOffsetFor: aDecorator) negated.	aDecorator hasHorizontalScrollbar		ifTrue: [ layout bottomOffset: layout bottomOffset + 1 ].	^layout</body></methods><methods><class-id>UI.BorderDecorationPolicy</class-id> <category>private - regions</category><body package="UIBuilder-Support" selector="leftOffsetFor:">leftOffsetFor: aDecorator	"Compute the distance from the left of the container to the left of the 	data area"	^aDecorator hasVerticalScrollbar ifTrue: [(UI.Skins.SkinRegistry current scrollbarArtistForView: nil) width] ifFalse: [0]</body></methods><methods><class-id>UI.BorderDecorationPolicy</class-id> <category>private - regions</category><body package="UIBuilder-Support" selector="dataRegionFor:">dataRegionFor: aDecorator	"Answer a layout frame for aDecorator's data area"	| vdelta hdelta b |	b := aDecorator hasBorder.	hdelta := (b and: [aDecorator hasHorizontalScrollbar]) ifTrue: [1] ifFalse: [0].	vdelta := (b and: [aDecorator hasVerticalScrollbar]) ifTrue: [1] ifFalse: [0].	"^LayoutFrame new		leftOffset: (self leftOffsetFor: aDecorator);		rightFraction: 1 offset: (self rightOffsetFor: aDecorator) + vdelta;		bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator) + hdelta;		topOffset: (self topOffsetFor: aDecorator)"				^LayoutFrame new			leftOffset: (self leftOffsetFor: aDecorator);			rightFraction: 1 offset: vdelta;			bottomFraction: 1 offset: (self bottomOffsetFor: aDecorator) + hdelta;			topOffset: (self topOffsetFor: aDecorator)</body></methods><do-it>'From VisualWorksÂ® Personal Use Edition, 8.3 of July 28, 2017 on May 9, 2020 at 10:44:32 AM'</do-it><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := ((ColorValue lightYellow blendWith: ColorValue white) 				blendWith: ColorValue white) "blendWith: ColorValue veryLightGray".	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: (background blendWith: ColorValue gray);			matchAt: SymbolicPaint inactiveBackground put: ColorValue white;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray	].	self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.	self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue white;		matchAt: SymbolicPaint selectionBackground put: ColorValue black</body></methods><do-it>WidgetPolicy initialize.	WidgetPolicy subclasses do: [ :class | class initialize].	Screen default flushPaintPreferencesCache.	ScheduledControllers restore</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '7:34:40 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:34:40 PM on May 20, 2020."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>doItMenu</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>doItMenu</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>N</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>N</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>PitchClassDo</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>PitchClassDo</staticKey> <definitionChange>added</definitionChange></component_static_change><component-created><name>Siren</name> <type>package</type></component-created><parcel-loaded><name>Siren</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Content' 'Code' 'Smalltalk' 'Siren9' 'Siren9.0m.pcl'))</filename></parcel-loaded><do-it>Siren.DisplayListView constants at: #StdNoteIcons put: IdentityDictionary new.(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/32' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/8' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/2' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -15)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/16' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/4' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); yourself) offset: -6@ -16)</do-it><do-it>Siren.DisplayListView constants at: #StdRestIcons put: IdentityDictionary new.(Siren.DisplayListView constants at: #StdRestIcons) at: '1/32' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/1' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -7@ -9)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/8' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/2' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -9)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/16' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/4' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); yourself) offset: -6@ -9)</do-it><do-it>Siren.DisplayListView constants at: #forms put: IdentityDictionary new.(Siren.DisplayListView constants at: #forms) at: 'hand' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 26 112 0 0 38 72 0 0 38 74 0 0 18 77 0 0 18 73 0 0 104 9 0 0 152 1 0 0 136 2 0 0 64 2 0 0 32 2 0 0 16 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 26 112 0 0 38 72 0 0 38 74 0 0 18 77 0 0 18 73 0 0 104 9 0 0 152 1 0 0 136 2 0 0 64 2 0 0 32 2 0 0 16 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'normal' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 248 0 0 0 248 0 0 0 152 0 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 248 0 0 0 248 0 0 0 152 0 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'origin' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 255 255 0 0 213 85 0 0 234 170 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 213 85 0 0 234 170 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'corner' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 85 87 0 0 170 171 0 0 255 255 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 85 87 0 0 170 171 0 0 255 255 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wholeRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'z2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'mordent' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 32 0 0 19 16 0 0 17 144 0 0 8 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 32 0 0 19 16 0 0 17 144 0 0 8 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'caret' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 1 128 0 0 3 192 0 0 7 224 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 1 128 0 0 3 192 0 0 7 224 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wholeNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'hole' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bassClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 1 252 0 0 2 14 96 0 6 15 96 0 7 135 0 0 7 135 0 0 7 135 0 0 3 7 96 0 0 7 96 0 0 7 0 0 0 6 0 0 0 14 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 1 128 0 0 7 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 1 252 0 0 2 14 96 0 6 15 96 0 7 135 0 0 7 135 0 0 7 135 0 0 3 7 96 0 0 7 96 0 0 7 0 0 0 6 0 0 0 14 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 1 128 0 0 7 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'eighthNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bar' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'xeq' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 16 0 0 192 16 0 0 224 56 0 0 241 255 0 0 248 198 0 0 252 68 0 0 254 124 0 0 248 108 0 0 248 198 0 0 152 130 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 16 0 0 192 16 0 0 224 56 0 0 241 255 0 0 248 198 0 0 252 68 0 0 254 124 0 0 248 108 0 0 248 198 0 0 152 130 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'scroll' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[8 0 0 0 12 0 0 0 14 0 0 0 15 0 0 0 15 128 0 0 15 192 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[8 0 0 0 12 0 0 0 14 0 0 0 15 0 0 0 15 128 0 0 15 192 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'read' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 6 0 0 18 9 0 0 18 9 0 0 32 16 0 0 64 32 0 0 251 224 0 0 132 32 0 0 132 32 0 0 181 160 0 0 123 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 6 0 0 18 9 0 0 18 9 0 0 32 16 0 0 64 32 0 0 251 224 0 0 132 32 0 0 132 32 0 0 181 160 0 0 123 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'spot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'topRight' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 255 255 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'roll' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bottomLeft' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 255 255 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 255 255 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thirtySecondRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'marker' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 128 0 0 3 224 0 0 255 248 0 0 255 254 0 0 255 248 0 0 3 224 0 0 3 128 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 128 0 0 3 224 0 0 255 248 0 0 255 254 0 0 255 248 0 0 3 224 0 0 3 128 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'spec' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'blank' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'halfRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'dot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'crossHair' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'quarterRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bull' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 7 192 0 0 25 48 0 0 33 8 0 0 65 4 0 0 65 4 0 0 129 2 0 0 129 2 0 0 255 254 0 0 129 2 0 0 129 2 0 0 65 4 0 0 65 4 0 0 33 8 0 0 25 48 0 0 7 192 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 25 48 0 0 33 8 0 0 65 4 0 0 65 4 0 0 129 2 0 0 129 2 0 0 255 254 0 0 129 2 0 0 129 2 0 0 65 4 0 0 65 4 0 0 33 8 0 0 25 48 0 0 7 192 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'flat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 224 0 0 3 48 0 0 2 48 0 0 2 48 0 0 2 48 0 0 2 96 0 0 2 192 0 0 3 0 0 0 2 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 224 0 0 3 48 0 0 2 48 0 0 2 48 0 0 2 48 0 0 2 96 0 0 2 192 0 0 3 0 0 0 2 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trebClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@40 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 6 128 0 0 12 128 0 0 12 128 0 0 8 128 0 0 8 128 0 0 9 128 0 0 9 128 0 0 11 128 0 0 15 0 0 0 15 0 0 0 30 0 0 0 28 0 0 0 60 0 0 0 116 0 0 0 116 0 0 0 247 128 0 0 231 224 0 0 207 240 0 0 206 120 0 0 202 56 0 0 202 56 0 0 201 56 0 0 97 48 0 0 49 96 0 0 31 192 0 0 1 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 24 128 0 0 60 128 0 0 60 128 0 0 25 0 0 0 14 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@40 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 6 128 0 0 12 128 0 0 12 128 0 0 8 128 0 0 8 128 0 0 9 128 0 0 9 128 0 0 11 128 0 0 15 0 0 0 15 0 0 0 30 0 0 0 28 0 0 0 60 0 0 0 116 0 0 0 116 0 0 0 247 128 0 0 231 224 0 0 207 240 0 0 206 120 0 0 202 56 0 0 202 56 0 0 201 56 0 0 97 48 0 0 49 96 0 0 31 192 0 0 1 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 24 128 0 0 60 128 0 0 60 128 0 0 25 0 0 0 14 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sharp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 128 0 0 0 128 0 0 8 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 128 0 0 8 0 0 0 8 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 128 0 0 0 128 0 0 8 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 128 0 0 8 0 0 0 8 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'signe2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 5 64 0 0 13 96 0 0 13 96 0 0 63 248 0 0 13 96 0 0 13 96 0 0 5 64 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 5 64 0 0 13 96 0 0 13 96 0 0 63 248 0 0 13 96 0 0 13 96 0 0 5 64 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'triangle' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'down' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'z1' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'box' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'line' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'halfNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'quarterNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'doubleFlat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 11 64 0 0 15 224 0 0 11 96 0 0 11 96 0 0 11 64 0 0 13 128 0 0 9 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 11 64 0 0 15 224 0 0 11 96 0 0 11 96 0 0 11 64 0 0 13 128 0 0 9 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trill2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 128 0 0 4 196 0 0 14 232 0 0 23 240 0 0 34 160 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 128 0 0 4 196 0 0 14 232 0 0 23 240 0 0 34 160 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'altoClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 13 0 0 0 13 12 0 0 13 30 0 0 13 51 0 0 13 121 128 0 13 121 192 0 13 49 192 0 13 1 192 0 13 1 192 0 13 17 192 0 13 25 128 0 13 55 0 0 13 119 0 0 13 55 0 0 13 25 128 0 13 17 192 0 13 1 192 0 13 1 192 0 13 49 192 0 13 121 192 0 13 121 128 0 13 51 0 0 13 30 0 0 13 12 0 0 13 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 13 0 0 0 13 12 0 0 13 30 0 0 13 51 0 0 13 121 128 0 13 121 192 0 13 49 192 0 13 1 192 0 13 1 192 0 13 17 192 0 13 25 128 0 13 55 0 0 13 119 0 0 13 55 0 0 13 25 128 0 13 17 192 0 13 1 192 0 13 1 192 0 13 49 192 0 13 121 192 0 13 121 128 0 13 51 0 0 13 30 0 0 13 12 0 0 13 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'up' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thirtySecondNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'signe' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 9 8 0 0 8 16 0 0 12 32 0 0 6 64 0 0 3 144 0 0 9 192 0 0 2 96 0 0 4 48 0 0 8 16 0 0 16 144 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 9 8 0 0 8 16 0 0 12 32 0 0 6 64 0 0 3 144 0 0 9 192 0 0 2 96 0 0 4 48 0 0 8 16 0 0 16 144 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'repeat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 48 0 0 12 96 0 0 0 192 0 0 1 128 0 0 3 0 0 0 6 0 0 0 12 96 0 0 24 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 48 0 0 12 96 0 0 0 192 0 0 1 128 0 0 3 0 0 0 6 0 0 0 12 96 0 0 24 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sixteenthNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'natural' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'circle' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thumbsDown' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[15 240 0 0 8 8 0 0 31 7 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 16 131 0 0 15 140 0 0 0 136 0 0 0 136 0 0 0 120 0 0 0 72 0 0 0 104 0 0 0 16 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 240 0 0 8 8 0 0 31 7 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 16 131 0 0 15 140 0 0 0 136 0 0 0 136 0 0 0 120 0 0 0 72 0 0 0 104 0 0 0 16 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'write' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 6 0 0 0 15 0 0 0 22 0 0 0 36 0 0 0 72 0 0 0 144 0 0 1 32 0 0 2 67 0 0 4 130 0 0 9 6 0 0 18 8 0 0 36 8 0 0 120 72 0 0 80 184 0 0 97 128 0 0 255 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 6 0 0 0 15 0 0 0 22 0 0 0 36 0 0 0 72 0 0 0 144 0 0 1 32 0 0 2 67 0 0 4 130 0 0 9 6 0 0 18 8 0 0 36 8 0 0 120 72 0 0 80 184 0 0 97 128 0 0 255 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'garbage' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[15 224 0 0 16 24 0 0 16 4 0 0 15 228 0 0 31 248 0 0 23 232 0 0 16 8 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 8 16 0 0 7 224 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 224 0 0 16 24 0 0 16 4 0 0 15 228 0 0 31 248 0 0 23 232 0 0 16 8 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 8 16 0 0 7 224 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'diamond' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'eighthRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'doubleSharp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 192 0 0 6 192 0 0 1 0 0 0 6 192 0 0 6 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 192 0 0 6 192 0 0 1 0 0 0 6 192 0 0 6 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'scrollButton' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 3 192 0 0 7 224 0 0 1 128 0 0 1 128 0 0 33 132 0 0 97 134 0 0 255 255 0 0 255 255 0 0 97 134 0 0 33 132 0 0 1 128 0 0 1 128 0 0 7 224 0 0 3 192 0 0 1 128 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 3 192 0 0 7 224 0 0 1 128 0 0 1 128 0 0 33 132 0 0 97 134 0 0 255 255 0 0 255 255 0 0 97 134 0 0 33 132 0 0 1 128 0 0 1 128 0 0 7 224 0 0 3 192 0 0 1 128 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bDot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sixteenthRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trill' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 68 0 0 14 232 0 0 23 112 0 0 34 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 68 0 0 14 232 0 0 23 112 0 0 34 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wait' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 128 1 0 0 64 2 0 0 32 4 0 0 28 56 0 0 15 112 0 0 6 224 0 0 3 192 0 0 3 192 0 0 5 160 0 0 8 144 0 0 17 136 0 0 35 68 0 0 79 242 0 0 191 253 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 128 1 0 0 64 2 0 0 32 4 0 0 28 56 0 0 15 112 0 0 6 224 0 0 3 192 0 0 3 192 0 0 5 160 0 0 8 144 0 0 17 136 0 0 35 68 0 0 79 242 0 0 191 253 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'note' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thumbsUp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 16 0 0 0 104 0 0 0 72 0 0 0 120 0 0 0 136 0 0 0 136 0 0 15 140 0 0 16 131 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 31 7 0 0 8 8 0 0 15 240 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 16 0 0 0 104 0 0 0 72 0 0 0 120 0 0 0 136 0 0 0 136 0 0 15 140 0 0 16 131 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 31 7 0 0 8 8 0 0 15 240 0 0]); yourself)</do-it><do-it>Siren.DisplayListView constants at: #NoteIcons put: OrderedCollection new.(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>Siren.DisplayListView constants at: #StdNoteIcons put: IdentityDictionary new.(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/32' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/8' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/2' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -15)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/16' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/4' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); yourself) offset: -6@ -16)</do-it><do-it>Siren.DisplayListView constants at: #StdRestIcons put: IdentityDictionary new.(Siren.DisplayListView constants at: #StdRestIcons) at: '1/32' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/1' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -7@ -9)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/8' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/2' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -9)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/16' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/4' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); yourself) offset: -6@ -9)</do-it><do-it>Siren.DisplayListView constants at: #forms put: IdentityDictionary new.(Siren.DisplayListView constants at: #forms) at: 'hand' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 26 112 0 0 38 72 0 0 38 74 0 0 18 77 0 0 18 73 0 0 104 9 0 0 152 1 0 0 136 2 0 0 64 2 0 0 32 2 0 0 16 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 26 112 0 0 38 72 0 0 38 74 0 0 18 77 0 0 18 73 0 0 104 9 0 0 152 1 0 0 136 2 0 0 64 2 0 0 32 2 0 0 16 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'normal' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 248 0 0 0 248 0 0 0 152 0 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 248 0 0 0 248 0 0 0 152 0 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'origin' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 255 255 0 0 213 85 0 0 234 170 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 213 85 0 0 234 170 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'corner' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 85 87 0 0 170 171 0 0 255 255 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 85 87 0 0 170 171 0 0 255 255 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wholeRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'z2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'mordent' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 32 0 0 19 16 0 0 17 144 0 0 8 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 32 0 0 19 16 0 0 17 144 0 0 8 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'caret' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 1 128 0 0 3 192 0 0 7 224 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 1 128 0 0 3 192 0 0 7 224 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wholeNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'hole' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bassClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 1 252 0 0 2 14 96 0 6 15 96 0 7 135 0 0 7 135 0 0 7 135 0 0 3 7 96 0 0 7 96 0 0 7 0 0 0 6 0 0 0 14 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 1 128 0 0 7 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 1 252 0 0 2 14 96 0 6 15 96 0 7 135 0 0 7 135 0 0 7 135 0 0 3 7 96 0 0 7 96 0 0 7 0 0 0 6 0 0 0 14 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 1 128 0 0 7 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'eighthNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bar' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'xeq' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 16 0 0 192 16 0 0 224 56 0 0 241 255 0 0 248 198 0 0 252 68 0 0 254 124 0 0 248 108 0 0 248 198 0 0 152 130 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 16 0 0 192 16 0 0 224 56 0 0 241 255 0 0 248 198 0 0 252 68 0 0 254 124 0 0 248 108 0 0 248 198 0 0 152 130 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'scroll' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[8 0 0 0 12 0 0 0 14 0 0 0 15 0 0 0 15 128 0 0 15 192 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[8 0 0 0 12 0 0 0 14 0 0 0 15 0 0 0 15 128 0 0 15 192 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'read' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 6 0 0 18 9 0 0 18 9 0 0 32 16 0 0 64 32 0 0 251 224 0 0 132 32 0 0 132 32 0 0 181 160 0 0 123 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 6 0 0 18 9 0 0 18 9 0 0 32 16 0 0 64 32 0 0 251 224 0 0 132 32 0 0 132 32 0 0 181 160 0 0 123 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'spot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'topRight' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 255 255 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'roll' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bottomLeft' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 255 255 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 255 255 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thirtySecondRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'marker' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 128 0 0 3 224 0 0 255 248 0 0 255 254 0 0 255 248 0 0 3 224 0 0 3 128 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 128 0 0 3 224 0 0 255 248 0 0 255 254 0 0 255 248 0 0 3 224 0 0 3 128 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'spec' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'blank' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'halfRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'dot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'crossHair' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'quarterRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bull' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 7 192 0 0 25 48 0 0 33 8 0 0 65 4 0 0 65 4 0 0 129 2 0 0 129 2 0 0 255 254 0 0 129 2 0 0 129 2 0 0 65 4 0 0 65 4 0 0 33 8 0 0 25 48 0 0 7 192 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 25 48 0 0 33 8 0 0 65 4 0 0 65 4 0 0 129 2 0 0 129 2 0 0 255 254 0 0 129 2 0 0 129 2 0 0 65 4 0 0 65 4 0 0 33 8 0 0 25 48 0 0 7 192 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'flat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 224 0 0 3 48 0 0 2 48 0 0 2 48 0 0 2 48 0 0 2 96 0 0 2 192 0 0 3 0 0 0 2 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 224 0 0 3 48 0 0 2 48 0 0 2 48 0 0 2 48 0 0 2 96 0 0 2 192 0 0 3 0 0 0 2 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trebClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@40 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 6 128 0 0 12 128 0 0 12 128 0 0 8 128 0 0 8 128 0 0 9 128 0 0 9 128 0 0 11 128 0 0 15 0 0 0 15 0 0 0 30 0 0 0 28 0 0 0 60 0 0 0 116 0 0 0 116 0 0 0 247 128 0 0 231 224 0 0 207 240 0 0 206 120 0 0 202 56 0 0 202 56 0 0 201 56 0 0 97 48 0 0 49 96 0 0 31 192 0 0 1 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 24 128 0 0 60 128 0 0 60 128 0 0 25 0 0 0 14 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@40 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 6 128 0 0 12 128 0 0 12 128 0 0 8 128 0 0 8 128 0 0 9 128 0 0 9 128 0 0 11 128 0 0 15 0 0 0 15 0 0 0 30 0 0 0 28 0 0 0 60 0 0 0 116 0 0 0 116 0 0 0 247 128 0 0 231 224 0 0 207 240 0 0 206 120 0 0 202 56 0 0 202 56 0 0 201 56 0 0 97 48 0 0 49 96 0 0 31 192 0 0 1 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 24 128 0 0 60 128 0 0 60 128 0 0 25 0 0 0 14 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sharp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 128 0 0 0 128 0 0 8 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 128 0 0 8 0 0 0 8 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 128 0 0 0 128 0 0 8 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 128 0 0 8 0 0 0 8 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'signe2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 5 64 0 0 13 96 0 0 13 96 0 0 63 248 0 0 13 96 0 0 13 96 0 0 5 64 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 5 64 0 0 13 96 0 0 13 96 0 0 63 248 0 0 13 96 0 0 13 96 0 0 5 64 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'triangle' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'down' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'z1' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'box' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'line' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'halfNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'quarterNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'doubleFlat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 11 64 0 0 15 224 0 0 11 96 0 0 11 96 0 0 11 64 0 0 13 128 0 0 9 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 11 64 0 0 15 224 0 0 11 96 0 0 11 96 0 0 11 64 0 0 13 128 0 0 9 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trill2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 128 0 0 4 196 0 0 14 232 0 0 23 240 0 0 34 160 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 128 0 0 4 196 0 0 14 232 0 0 23 240 0 0 34 160 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'altoClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 13 0 0 0 13 12 0 0 13 30 0 0 13 51 0 0 13 121 128 0 13 121 192 0 13 49 192 0 13 1 192 0 13 1 192 0 13 17 192 0 13 25 128 0 13 55 0 0 13 119 0 0 13 55 0 0 13 25 128 0 13 17 192 0 13 1 192 0 13 1 192 0 13 49 192 0 13 121 192 0 13 121 128 0 13 51 0 0 13 30 0 0 13 12 0 0 13 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 13 0 0 0 13 12 0 0 13 30 0 0 13 51 0 0 13 121 128 0 13 121 192 0 13 49 192 0 13 1 192 0 13 1 192 0 13 17 192 0 13 25 128 0 13 55 0 0 13 119 0 0 13 55 0 0 13 25 128 0 13 17 192 0 13 1 192 0 13 1 192 0 13 49 192 0 13 121 192 0 13 121 128 0 13 51 0 0 13 30 0 0 13 12 0 0 13 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'up' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thirtySecondNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'signe' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 9 8 0 0 8 16 0 0 12 32 0 0 6 64 0 0 3 144 0 0 9 192 0 0 2 96 0 0 4 48 0 0 8 16 0 0 16 144 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 9 8 0 0 8 16 0 0 12 32 0 0 6 64 0 0 3 144 0 0 9 192 0 0 2 96 0 0 4 48 0 0 8 16 0 0 16 144 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'repeat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 48 0 0 12 96 0 0 0 192 0 0 1 128 0 0 3 0 0 0 6 0 0 0 12 96 0 0 24 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 48 0 0 12 96 0 0 0 192 0 0 1 128 0 0 3 0 0 0 6 0 0 0 12 96 0 0 24 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sixteenthNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'natural' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'circle' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thumbsDown' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[15 240 0 0 8 8 0 0 31 7 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 16 131 0 0 15 140 0 0 0 136 0 0 0 136 0 0 0 120 0 0 0 72 0 0 0 104 0 0 0 16 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 240 0 0 8 8 0 0 31 7 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 16 131 0 0 15 140 0 0 0 136 0 0 0 136 0 0 0 120 0 0 0 72 0 0 0 104 0 0 0 16 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'write' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 6 0 0 0 15 0 0 0 22 0 0 0 36 0 0 0 72 0 0 0 144 0 0 1 32 0 0 2 67 0 0 4 130 0 0 9 6 0 0 18 8 0 0 36 8 0 0 120 72 0 0 80 184 0 0 97 128 0 0 255 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 6 0 0 0 15 0 0 0 22 0 0 0 36 0 0 0 72 0 0 0 144 0 0 1 32 0 0 2 67 0 0 4 130 0 0 9 6 0 0 18 8 0 0 36 8 0 0 120 72 0 0 80 184 0 0 97 128 0 0 255 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'garbage' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[15 224 0 0 16 24 0 0 16 4 0 0 15 228 0 0 31 248 0 0 23 232 0 0 16 8 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 8 16 0 0 7 224 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 224 0 0 16 24 0 0 16 4 0 0 15 228 0 0 31 248 0 0 23 232 0 0 16 8 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 8 16 0 0 7 224 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'diamond' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'eighthRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'doubleSharp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 192 0 0 6 192 0 0 1 0 0 0 6 192 0 0 6 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 192 0 0 6 192 0 0 1 0 0 0 6 192 0 0 6 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'scrollButton' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 3 192 0 0 7 224 0 0 1 128 0 0 1 128 0 0 33 132 0 0 97 134 0 0 255 255 0 0 255 255 0 0 97 134 0 0 33 132 0 0 1 128 0 0 1 128 0 0 7 224 0 0 3 192 0 0 1 128 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 3 192 0 0 7 224 0 0 1 128 0 0 1 128 0 0 33 132 0 0 97 134 0 0 255 255 0 0 255 255 0 0 97 134 0 0 33 132 0 0 1 128 0 0 1 128 0 0 7 224 0 0 3 192 0 0 1 128 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bDot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sixteenthRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trill' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 68 0 0 14 232 0 0 23 112 0 0 34 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 68 0 0 14 232 0 0 23 112 0 0 34 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wait' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 128 1 0 0 64 2 0 0 32 4 0 0 28 56 0 0 15 112 0 0 6 224 0 0 3 192 0 0 3 192 0 0 5 160 0 0 8 144 0 0 17 136 0 0 35 68 0 0 79 242 0 0 191 253 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 128 1 0 0 64 2 0 0 32 4 0 0 28 56 0 0 15 112 0 0 6 224 0 0 3 192 0 0 3 192 0 0 5 160 0 0 8 144 0 0 17 136 0 0 35 68 0 0 79 242 0 0 191 253 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'note' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thumbsUp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 16 0 0 0 104 0 0 0 72 0 0 0 120 0 0 0 136 0 0 0 136 0 0 15 140 0 0 16 131 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 31 7 0 0 8 8 0 0 15 240 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 16 0 0 0 104 0 0 0 72 0 0 0 120 0 0 0 136 0 0 0 136 0 0 15 140 0 0 16 131 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 31 7 0 0 8 8 0 0 15 240 0 0]); yourself)</do-it><do-it>Siren.DisplayListView constants at: #NoteIcons put: OrderedCollection new.(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>ListWorkBook open</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '8:48:37 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 8:48:37 PM on May 20, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '8:52:10 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 8:52:10 PM on May 20, 2020."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>doItMenu</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>doItMenu</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>N</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>N</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>PitchClassDo</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>PitchClassDo</staticKey> <definitionChange>added</definitionChange></component_static_change><component-created><name>Siren</name> <type>package</type></component-created><parcel-loaded><name>Siren</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Content' 'Code' 'Smalltalk' 'Siren9' 'Siren9.0m.pcl'))</filename></parcel-loaded><do-it>Siren.DisplayListView constants at: #StdNoteIcons put: IdentityDictionary new.(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/32' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/8' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/2' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -15)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/16' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -4@ -16)</do-it><do-it>(Siren.DisplayListView constants at: #StdNoteIcons) at: '1/4' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); yourself) offset: -6@ -16)</do-it><do-it>Siren.DisplayListView constants at: #StdRestIcons put: IdentityDictionary new.(Siren.DisplayListView constants at: #StdRestIcons) at: '1/32' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/1' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -7@ -9)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/8' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/2' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -6@ -9)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/16' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself) offset: -7@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #StdRestIcons) at: '1/4' asSymbol put: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); yourself) offset: -6@ -9)</do-it><do-it>Siren.DisplayListView constants at: #forms put: IdentityDictionary new.(Siren.DisplayListView constants at: #forms) at: 'hand' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 26 112 0 0 38 72 0 0 38 74 0 0 18 77 0 0 18 73 0 0 104 9 0 0 152 1 0 0 136 2 0 0 64 2 0 0 32 2 0 0 16 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 26 112 0 0 38 72 0 0 38 74 0 0 18 77 0 0 18 73 0 0 104 9 0 0 152 1 0 0 136 2 0 0 64 2 0 0 32 2 0 0 16 4 0 0 16 4 0 0 8 8 0 0 4 8 0 0 4 8 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'normal' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 248 0 0 0 248 0 0 0 152 0 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 248 0 0 0 248 0 0 0 152 0 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'origin' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 255 255 0 0 213 85 0 0 234 170 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 213 85 0 0 234 170 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0 208 0 0 0 224 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'corner' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 85 87 0 0 170 171 0 0 255 255 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 0 7 0 0 0 11 0 0 85 87 0 0 170 171 0 0 255 255 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wholeRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 240 0 0 7 224 0 0 7 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'z2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'mordent' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 32 0 0 19 16 0 0 17 144 0 0 8 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 32 0 0 19 16 0 0 17 144 0 0 8 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'caret' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 1 128 0 0 3 192 0 0 7 224 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 1 128 0 0 3 192 0 0 7 224 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wholeNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 128 0 0 9 192 0 0 12 192 0 0 14 64 0 0 7 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'hole' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bassClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 1 252 0 0 2 14 96 0 6 15 96 0 7 135 0 0 7 135 0 0 7 135 0 0 3 7 96 0 0 7 96 0 0 7 0 0 0 6 0 0 0 14 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 1 128 0 0 7 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 1 252 0 0 2 14 96 0 6 15 96 0 7 135 0 0 7 135 0 0 7 135 0 0 3 7 96 0 0 7 96 0 0 7 0 0 0 6 0 0 0 14 0 0 0 12 0 0 0 24 0 0 0 48 0 0 0 224 0 0 1 128 0 0 7 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'eighthNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 128 0 0 1 128 0 0 1 192 0 0 1 96 0 0 1 48 0 0 1 16 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 1 8 0 0 31 16 0 0 63 0 0 0 63 0 0 0 63 0 0 0 30 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bar' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'xeq' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 16 0 0 192 16 0 0 224 56 0 0 241 255 0 0 248 198 0 0 252 68 0 0 254 124 0 0 248 108 0 0 248 198 0 0 152 130 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 16 0 0 192 16 0 0 224 56 0 0 241 255 0 0 248 198 0 0 252 68 0 0 254 124 0 0 248 108 0 0 248 198 0 0 152 130 0 0 12 0 0 0 12 0 0 0 6 0 0 0 6 0 0 0 3 0 0 0 3 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'scroll' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[8 0 0 0 12 0 0 0 14 0 0 0 15 0 0 0 15 128 0 0 15 192 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[8 0 0 0 12 0 0 0 14 0 0 0 15 0 0 0 15 128 0 0 15 192 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'read' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 6 0 0 18 9 0 0 18 9 0 0 32 16 0 0 64 32 0 0 251 224 0 0 132 32 0 0 132 32 0 0 181 160 0 0 123 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 6 0 0 18 9 0 0 18 9 0 0 32 16 0 0 64 32 0 0 251 224 0 0 132 32 0 0 132 32 0 0 181 160 0 0 123 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'spot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'topRight' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 255 255 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0 0 3 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'roll' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 48 0 0 1 192 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bottomLeft' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 255 255 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 255 255 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thirtySecondRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 96 0 0 3 128 0 0 0 128 0 0 24 128 0 0 24 128 0 0 7 0 0 0 1 0 0 0 49 0 0 0 49 0 0 0 14 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 4 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'marker' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 128 0 0 3 224 0 0 255 248 0 0 255 254 0 0 255 248 0 0 3 224 0 0 3 128 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 128 0 0 3 224 0 0 255 248 0 0 255 254 0 0 255 248 0 0 3 224 0 0 3 128 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'spec' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'blank' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'halfRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 224 0 0 7 224 0 0 15 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'dot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'crossHair' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'quarterRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 1 0 0 0 0 128 0 0 0 192 0 0 0 192 0 0 1 192 0 0 3 128 0 0 7 0 0 0 7 0 0 0 6 0 0 0 2 0 0 0 1 0 0 0 1 128 0 0 7 192 0 0 6 0 0 0 6 0 0 0 3 0 0 0 1 0 0 0 0 128 0 0 0 128 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bull' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 7 192 0 0 25 48 0 0 33 8 0 0 65 4 0 0 65 4 0 0 129 2 0 0 129 2 0 0 255 254 0 0 129 2 0 0 129 2 0 0 65 4 0 0 65 4 0 0 33 8 0 0 25 48 0 0 7 192 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 25 48 0 0 33 8 0 0 65 4 0 0 65 4 0 0 129 2 0 0 129 2 0 0 255 254 0 0 129 2 0 0 129 2 0 0 65 4 0 0 65 4 0 0 33 8 0 0 25 48 0 0 7 192 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'flat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 224 0 0 3 48 0 0 2 48 0 0 2 48 0 0 2 48 0 0 2 96 0 0 2 192 0 0 3 0 0 0 2 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 0 0 0 2 224 0 0 3 48 0 0 2 48 0 0 2 48 0 0 2 48 0 0 2 96 0 0 2 192 0 0 3 0 0 0 2 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trebClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@40 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 6 128 0 0 12 128 0 0 12 128 0 0 8 128 0 0 8 128 0 0 9 128 0 0 9 128 0 0 11 128 0 0 15 0 0 0 15 0 0 0 30 0 0 0 28 0 0 0 60 0 0 0 116 0 0 0 116 0 0 0 247 128 0 0 231 224 0 0 207 240 0 0 206 120 0 0 202 56 0 0 202 56 0 0 201 56 0 0 97 48 0 0 49 96 0 0 31 192 0 0 1 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 24 128 0 0 60 128 0 0 60 128 0 0 25 0 0 0 14 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@40 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 6 128 0 0 12 128 0 0 12 128 0 0 8 128 0 0 8 128 0 0 9 128 0 0 9 128 0 0 11 128 0 0 15 0 0 0 15 0 0 0 30 0 0 0 28 0 0 0 60 0 0 0 116 0 0 0 116 0 0 0 247 128 0 0 231 224 0 0 207 240 0 0 206 120 0 0 202 56 0 0 202 56 0 0 201 56 0 0 97 48 0 0 49 96 0 0 31 192 0 0 1 128 0 0 0 128 0 0 0 128 0 0 0 128 0 0 24 128 0 0 60 128 0 0 60 128 0 0 25 0 0 0 14 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sharp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 128 0 0 0 128 0 0 8 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 128 0 0 8 0 0 0 8 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 128 0 0 0 128 0 0 8 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 192 0 0 11 192 0 0 15 128 0 0 30 128 0 0 24 128 0 0 8 128 0 0 8 0 0 0 8 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'signe2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 5 64 0 0 13 96 0 0 13 96 0 0 63 248 0 0 13 96 0 0 13 96 0 0 5 64 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 5 64 0 0 13 96 0 0 13 96 0 0 63 248 0 0 13 96 0 0 13 96 0 0 5 64 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'triangle' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'down' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 12 0 0 0 252 0 0 0 124 0 0 0 60 0 0 0 28 0 0 0 12 0 0 0 4 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'z1' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'box' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 127 254 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 96 6 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'line' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'halfNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 14 64 0 0 12 192 0 0 9 192 0 0 7 128 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'quarterNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 64 0 0 7 192 0 0 15 192 0 0 15 192 0 0 15 192 0 0 7 128 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'doubleFlat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 11 64 0 0 15 224 0 0 11 96 0 0 11 96 0 0 11 64 0 0 13 128 0 0 9 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 9 0 0 0 11 64 0 0 15 224 0 0 11 96 0 0 11 96 0 0 11 64 0 0 13 128 0 0 9 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trill2' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 128 0 0 4 196 0 0 14 232 0 0 23 240 0 0 34 160 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 128 0 0 0 128 0 0 4 196 0 0 14 232 0 0 23 240 0 0 34 160 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'altoClef' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 13 0 0 0 13 12 0 0 13 30 0 0 13 51 0 0 13 121 128 0 13 121 192 0 13 49 192 0 13 1 192 0 13 1 192 0 13 17 192 0 13 25 128 0 13 55 0 0 13 119 0 0 13 55 0 0 13 25 128 0 13 17 192 0 13 1 192 0 13 1 192 0 13 49 192 0 13 121 192 0 13 121 128 0 13 51 0 0 13 30 0 0 13 12 0 0 13 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 13 0 0 0 13 12 0 0 13 30 0 0 13 51 0 0 13 121 128 0 13 121 192 0 13 49 192 0 13 1 192 0 13 1 192 0 13 17 192 0 13 25 128 0 13 55 0 0 13 119 0 0 13 55 0 0 13 25 128 0 13 17 192 0 13 1 192 0 13 1 192 0 13 49 192 0 13 121 192 0 13 121 128 0 13 51 0 0 13 30 0 0 13 12 0 0 13 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'up' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0 192 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thirtySecondNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 3 112 0 0 3 176 0 0 2 208 0 0 2 112 0 0 2 48 0 0 62 16 0 0 126 16 0 0 126 32 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'signe' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 9 8 0 0 8 16 0 0 12 32 0 0 6 64 0 0 3 144 0 0 9 192 0 0 2 96 0 0 4 48 0 0 8 16 0 0 16 144 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 9 8 0 0 8 16 0 0 12 32 0 0 6 64 0 0 3 144 0 0 9 192 0 0 2 96 0 0 4 48 0 0 8 16 0 0 16 144 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'repeat' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 48 0 0 12 96 0 0 0 192 0 0 1 128 0 0 3 0 0 0 6 0 0 0 12 96 0 0 24 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 48 0 0 12 96 0 0 0 192 0 0 1 128 0 0 3 0 0 0 6 0 0 0 12 96 0 0 24 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sixteenthNote' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 3 0 0 0 3 0 0 0 3 128 0 0 2 192 0 0 3 96 0 0 3 160 0 0 2 208 0 0 2 112 0 0 2 48 0 0 2 16 0 0 2 16 0 0 2 16 0 0 62 32 0 0 126 0 0 0 126 0 0 0 126 0 0 0 60 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'natural' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[2 0 0 0 2 0 0 0 2 0 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 2 16 0 0 2 112 0 0 3 240 0 0 3 144 0 0 2 16 0 0 0 16 0 0 0 16 0 0 0 16 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'circle' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thumbsDown' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[15 240 0 0 8 8 0 0 31 7 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 16 131 0 0 15 140 0 0 0 136 0 0 0 136 0 0 0 120 0 0 0 72 0 0 0 104 0 0 0 16 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 240 0 0 8 8 0 0 31 7 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 16 131 0 0 15 140 0 0 0 136 0 0 0 136 0 0 0 120 0 0 0 72 0 0 0 104 0 0 0 16 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'write' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 6 0 0 0 15 0 0 0 22 0 0 0 36 0 0 0 72 0 0 0 144 0 0 1 32 0 0 2 67 0 0 4 130 0 0 9 6 0 0 18 8 0 0 36 8 0 0 120 72 0 0 80 184 0 0 97 128 0 0 255 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 6 0 0 0 15 0 0 0 22 0 0 0 36 0 0 0 72 0 0 0 144 0 0 1 32 0 0 2 67 0 0 4 130 0 0 9 6 0 0 18 8 0 0 36 8 0 0 120 72 0 0 80 184 0 0 97 128 0 0 255 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'garbage' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[15 224 0 0 16 24 0 0 16 4 0 0 15 228 0 0 31 248 0 0 23 232 0 0 16 8 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 8 16 0 0 7 224 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 224 0 0 16 24 0 0 16 4 0 0 15 228 0 0 31 248 0 0 23 232 0 0 16 8 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 18 72 0 0 8 16 0 0 7 224 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'diamond' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 255 255 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'eighthRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 128 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'doubleSharp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 192 0 0 6 192 0 0 1 0 0 0 6 192 0 0 6 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 192 0 0 6 192 0 0 1 0 0 0 6 192 0 0 6 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'scrollButton' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[1 128 0 0 3 192 0 0 7 224 0 0 1 128 0 0 1 128 0 0 33 132 0 0 97 134 0 0 255 255 0 0 255 255 0 0 97 134 0 0 33 132 0 0 1 128 0 0 1 128 0 0 7 224 0 0 3 192 0 0 1 128 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 3 192 0 0 7 224 0 0 1 128 0 0 1 128 0 0 33 132 0 0 97 134 0 0 255 255 0 0 255 255 0 0 97 134 0 0 33 132 0 0 1 128 0 0 1 128 0 0 7 224 0 0 3 192 0 0 1 128 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'bDot' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'sixteenthRest' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 6 0 0 0 6 48 0 0 1 224 0 0 0 32 0 0 0 32 0 0 12 64 0 0 12 64 0 0 3 192 0 0 0 128 0 0 0 128 0 0 0 128 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'trill' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 68 0 0 14 232 0 0 23 112 0 0 34 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 68 0 0 14 232 0 0 23 112 0 0 34 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'wait' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[255 255 0 0 128 1 0 0 64 2 0 0 32 4 0 0 28 56 0 0 15 112 0 0 6 224 0 0 3 192 0 0 3 192 0 0 5 160 0 0 8 144 0 0 17 136 0 0 35 68 0 0 79 242 0 0 191 253 0 0 255 255 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 128 1 0 0 64 2 0 0 32 4 0 0 28 56 0 0 15 112 0 0 6 224 0 0 3 192 0 0 3 192 0 0 5 160 0 0 8 144 0 0 17 136 0 0 35 68 0 0 79 242 0 0 191 253 0 0 255 255 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'note' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself)</do-it><do-it>(Siren.DisplayListView constants at: #forms) at: 'thumbsUp' asSymbol put: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 16 0 0 0 104 0 0 0 72 0 0 0 120 0 0 0 136 0 0 0 136 0 0 15 140 0 0 16 131 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 31 7 0 0 8 8 0 0 15 240 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 16 0 0 0 104 0 0 0 72 0 0 0 120 0 0 0 136 0 0 0 136 0 0 15 140 0 0 16 131 0 0 32 0 0 0 63 0 0 0 32 0 0 0 63 0 0 0 32 0 0 0 31 7 0 0 8 8 0 0 15 240 0 0]); yourself)</do-it><do-it>Siren.DisplayListView constants at: #NoteIcons put: OrderedCollection new.(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 6 96 0 0 12 48 0 0 12 48 0 0 6 96 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 3 0 0 0 7 128 0 0 7 192 0 0 15 224 0 0 15 240 0 0 31 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 192 0 0 3 224 0 0 7 240 0 0 15 248 0 0 31 248 0 0 31 248 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 192 0 0 7 224 0 0 12 48 0 0 24 24 0 0 48 12 0 0 48 12 0 0 24 24 0 0 12 48 0 0 7 224 0 0 3 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 31 240 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 63 248 0 0 7 192 0 0 3 128 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 120 60 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 7 192 0 0 24 48 0 0 32 8 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 32 8 0 0 24 48 0 0 7 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><do-it>(Siren.DisplayListView constants at: #NoteIcons) add: (Siren.DisplayVisual visual: (Graphics.OpaqueImage basicNew instVarAt: 1 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); instVarAt: 2 put: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]); yourself) offset: -8@ -8)</do-it><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="buildMenuBar">buildMenuBar	| menu |	menu := self class menuBar."	(menu atNameKey: #toggleStatusBar) indicationSelector: #statusBarVisible."	menu 		augmentFrom: self class		to: AbstractWorkspace		menuName: #menuBar		for: self.	^menu</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>actions</category><body package="Tools-Workspace" selector="toggleToolbar">toggleToolbar	| menuItem |	menuItem := self menuBar atNameKey: #toolbar."	self builder window toolbarVisible: menuItem isOn not."	menuItem indication: menuItem isOn not</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>actions</category><body package="Tools-Workspace" selector="toggleToolbar">toggleToolbar	| menuItem |	menuItem := self menuBar atNameKey: #toolbar."	self builder window toolbarVisible: menuItem isOn not.	menuItem indication: menuItem isOn not"</body></methods><do-it>self pages</do-it><do-it>	aWorkspacePage workspace: self.</do-it><methods><class-id>Tools.Workbook</class-id> <category>accessing</category><body package="Tools-Workspace" selector="addPage:">addPage: aWorkspacePage	"The Variables page always remains the last, so any new page	always ends up being one before the last."	| inspectorPage |	inspectorPage := self pages last.	aWorkspacePage workspace: self.	self pages add: aWorkspacePage beforeIndex: self pages."	self pages add: aWorkspacePage before: nil inspectorPage"</body></methods><do-it>self pages</do-it><methods><class-id>Tools.Workbook</class-id> <category>accessing</category><body package="Tools-Workspace" selector="addPage:">addPage: aWorkspacePage	"The Variables page always remains the last, so any new page	always ends up being one before the last.""	| inspectorPage |	inspectorPage := self pages last."	aWorkspacePage workspace: self.	self pages add: aWorkspacePage beforeIndex: self pages."	self pages add: aWorkspacePage before: nil inspectorPage"</body></methods><do-it> self pages size.</do-it><methods><class-id>Tools.Workbook</class-id> <category>accessing</category><body package="Tools-Workspace" selector="addPage:">addPage: aWorkspacePage	"The Variables page always remains the last, so any new page	always ends up being one before the last.""	| inspectorPage |	inspectorPage := self pages last."	aWorkspacePage workspace: self.	self pages add: aWorkspacePage beforeIndex: self pages size + 1."	self pages add: aWorkspacePage before: nil inspectorPage"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '9:00:48 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 9:00:48 PM on May 20, 2020."</do-it><methods><class-id>Tools.BrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="augmentMenuBarMenu:">augmentMenuBarMenu: menu	menu menuItems do: 		[ :item |  | aModule action |		aModule := self  menuHeader."		item truePerformerBlock: [ :cont | cont performer truePerformerFor: aModule ]."		item submenu == nil			ifFalse: [ self augmentMenuBarMenu: item submenu ].		action := item value.		action isSymbol			ifTrue: 				[ item value:	[:cont | cont performer browser module: aModule action: action ] ]		]</body></methods><do-it>DefaultVoiceClass</do-it><methods><class-id>Core.Association</class-id> <category>copying</category><body package="Siren" selector=",">, anAssociation 	"Answer a Dictionary with of the receiver and the argument as its elements."	"(#a -&gt; 1), (#b -&gt; 2)"		| dict |	dict := Dictionary new.	dict add: self.	dict add: anAssociation.	^dict</body></methods><methods><class-id>Core.Association</class-id> <category>copying</category><body package="Siren" selector=",">, anAssociation 	"Answer a Dictionary with of the receiver and the argument as its elements."	"(#a -&gt; 1), (#b -&gt; 2)"	| dict |	dict := Dictionary new.	dict add: self.	dict add: anAssociation.	^dict</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="Hertz">Hertz	"Answer a HertzPitch whose value is the receiver."	^Siren.HertzPitch value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="Hz">Hz	"Answer a HertzPitch whose value is the receiver."	^Siren.HertzPitch value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="ampl">ampl	"Answer a loudness whose value is the receiver."	^Siren.Amplitude value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="beat">beat	"Answer a ratio duration whose value is the receiver."	^Siren.RatioDuration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="dB">dB	"Answer a deciBel loudness whose value is the receiver."	^Siren.DBLoudness value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="dur">dur	"Answer a duration whose value is the receiver."	^Siren.Duration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="duration">duration	"Answer a duration whose value is the receiver."	^Siren.Duration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="loudness">loudness	"Answer a loudness whose value is the receiver."	^Siren.Amplitude value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="measures">measures	"Answer a duration whose value is the receiver."	^Siren.MeasureDuration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="mostGeneral">mostGeneral	^self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="msec">msec	"Answer a duration whose value is the receiver." 	^Siren.MSecondDuration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="note">note	"Answer a MIDI pitch whose value is the receiver."	^Siren.MIDIPitch value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="pitch">pitch	"Answer a pitch whose value is the receiver."	^Siren.Pitch value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="sec">sec	"Answer a duration whose value is the receiver."	^Siren.SecondDuration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="seconds">seconds	"Answer a duration whose value is the receiver."	^Siren.SecondDuration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="usec">usec	"Answer a duration whose value is the receiver." 	^Siren.USecondDuration value: self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="value">value	"Answer the 'value' of the receiver (i.e., itself)."	^self</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Kernel-Objects" selector="velocity">velocity	"Answer a MIDI loudness whose value is the receiver."	^Siren.MIDIVelocity value: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="hasItems">hasItems	"Answer whether or not the receiver has items or components."	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isAssociation">isAssociation	"Return true if the receiver is an association.	Note: Do not override in any class except association."	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isCPointer">isCPointer	"Coerces CPointers to true and everything else to false."	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isDisplayItem">isDisplayItem	"Answer whether the receiver is a kind of DisplayItem"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isEvent">isEvent	"Coerces Events to true and everything else to false.  Event	overrides with ^true"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isEventList">isEventList	"Coerces EventLists to true and everything else to false.  EventList	overrides with ^true"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isMusicMagnitude">isMusicMagnitude	"Answer false for anything but a real MusicMagnitude."	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isPoint">isPoint	"Coerces Points to true and everything else to false. Point overrides with ^true"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isTreeNode">isTreeNode	"Answer whether the receiver is a tree node."	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isUnitGenerator">isUnitGenerator	"Answer Whether the receiver is a kind of CSL UnitGenerator"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isVoice">isVoice	"Answer false"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>associating</category><body package="Kernel-Objects" selector="=&gt;">=&gt; anObject	"Answer an EventAssociation between the receiver and the argument."	"1.234 =&gt; (DurationEvent dur: 250 msec voice: #flute)"	^Siren.EventAssociation new key: self value: anObject</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isCPointer">isCPointer	"Coerces CPointers to true and everything else to false."	^false</body></methods><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isCPointer</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Kernel-Objects</name> <type>package</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isCPointer</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>package</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isCPointer</selector> <definitionChange>added</definitionChange></component_selector_change><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '9:15:41 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 9:15:41 PM on May 20, 2020."</do-it><do-it>SystemUtils getEnvironmentVariable: 'VISUALWORKS'</do-it><do-it>SystemUtils getEnvironmentVariable: 'VISUALWORKS'</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>file support</category><body package="Siren" selector="findDir:tryHard:">findDir: dir tryHard: aggressive	"Try to locate the requested directory either locally or globally"	"SirenUtility findDir: 'Data' tryHard: false"	"SirenUtility findDir: 'Frameworks' tryHard: true"	"SirenUtility findDir: '3-Credo' tryHard: true"	| fsep home ddr |	dir asFilename existsSafely ifTrue: [^dir].								"if local"	fsep := Filename separatorString.	(fsep, dir) asFilename existsSafely ifTrue: [^(fsep, dir)].					"if at /X"	home := SystemUtils getEnvironmentVariable: 'HOME'.	(home, fsep, dir) asFilename existsSafely ifTrue: [^(home, fsep, dir)].	"if in $HOME"	(Filename filesMatching: '*')											"if in *"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	ddr := DataDir.	ddr ifNil: [ddr := SystemUtils getEnvironmentVariable: 'VISUALWORKS'].	((ddr, fsep, dir) asFilename existsSafely)		ifTrue: [^ddr, fsep, dir].	aggressive ifFalse: [^nil].	(Filename filesMatching: home, fsep, '*')								"if in ~/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: fsep, 'Smalltalk', fsep, '*')					"if in /Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: home, fsep, 'Smalltalk', fsep, '*')				"if in ~/Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	^nil</body></methods><do-it>SirenUtility findDir: 'Data' tryHard: false</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>file support</category><body package="Siren" selector="findDir:tryHard:">findDir: dir tryHard: aggressive	"Try to locate the requested directory either locally or globally"	"SirenUtility findDir: 'Data' tryHard: false"	"SirenUtility findDir: 'Frameworks' tryHard: true"	"SirenUtility findDir: '3-Credo' tryHard: true"	| fsep home ddr |	dir asFilename existsSafely ifTrue: [^dir].								"if local"	fsep := Filename separatorString.	(fsep, dir) asFilename existsSafely ifTrue: [^(fsep, dir)].					"if at /X"	home := SystemUtils getEnvironmentVariable: 'HOME'.	(home, fsep, dir) asFilename existsSafely ifTrue: [^(home, fsep, dir)].	"if in $HOME"	(Filename filesMatching: '*')											"if in *"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	ddr := DataDir.	ddr ifNil: [ddr := SystemUtils getEnvironmentVariable: 'VISUALWORKS'].	((ddr, fsep, dir) asFilename existsSafely)		ifTrue: [^ddr, fsep, dir].	aggressive ifFalse: [^nil].	(Filename filesMatching: home, fsep, '*')								"if in ~/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: fsep, 'Smalltalk', fsep, '*')					"if in /Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: home, fsep, 'Smalltalk', fsep, '*')				"if in ~/Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	^nil</body></methods><do-it>sirenDir := SirenUtility findDir: 'Siren9.0' tryHard: false.</do-it><do-it>SirenUtility findDir: 'Siren9.0' tryHard: false.</do-it><do-it>SirenUtility findDir: 'Siren9' tryHard: false.</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>class initialization</category><body package="Siren" selector="initialize">initialize	"Edit these to taste for your installation."	"SirenUtility initialize. SirenSession initialize"	"SirenUtility dataDir"	"SirenSession eventLists"	"SirenUtility findFile: 'tuba'"	"See also system-dependent setup in SirenUtility&gt;&gt;playSoundFile" 	| sirenDir |	DefaultMIDIIn := 1.			"Tune these to your setup"	DefaultMIDIOut := 2.	DefaultOSCHost := #[127 0 0 1].	DefaultOSCPort := 54321.	PortModel initialize.	Verbosity := 1.				"0 = pretty silent;								 1 = medium-verbose; 								 2 = full scheduler and interface logging"	LoggingStream = nil.			"logging output file"								"Look for Siren data and set search paths"	sirenDir := SirenUtility findDir: 'Siren9' tryHard: false.	sirenDir ifNil: [self error: 'Cannot find Siren release folder'].	sirenDir := sirenDir, Filename separatorString.	ScoreDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Scores"	self addDir: 'Scores' to: ScoreDir.	self addDir: 'MIDI' to: ScoreDir.	SoundDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Sound files"	self addDir: 'Sound' to: SoundDir.	self addDir: 'Samples' to: SoundDir.	self addDir: 'SHARC/*' to: SoundDir.					"You can add using wildcards""	self addDir: 'Databases/*' to: SoundDir."				"STP-specific"	DataDir := OrderedCollection new.	DataDir addAll: ScoreDir.	DataDir addAll: SoundDir.	DataDir :=   DataDir asSet asOrderedCollection.	SirenSession initialize								"Session setup"</body></methods><do-it>SystemUtils getEnvironmentVariable: 'VISUALWORKS'</do-it><do-it>SystemUtils getEnvironmentVariable: 'VISUALWORKS'</do-it><do-it>Filename named: (SystemUtils getEnvironmentVariable: 'VISUALWORKS')</do-it><do-it>self directory</do-it><do-it>Filename named: (SystemUtils getEnvironmentVariable: 'VISUALWORKS')</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>file support</category><body package="Siren" selector="findDir:tryHard:">findDir: dir tryHard: aggressive	"Try to locate the requested directory either locally or globally"	"SirenUtility findDir: 'Data' tryHard: false"	"SirenUtility findDir: 'Frameworks' tryHard: true"	"SirenUtility findDir: '3-Credo' tryHard: true"	| fsep home ddr |	dir asFilename existsSafely ifTrue: [^dir].								"if local"	fsep := Filename separatorString.	(fsep, dir) asFilename existsSafely ifTrue: [^(fsep, dir)].					"if at /X"	home := SystemUtils getEnvironmentVariable: 'HOME'.	(home, fsep, dir) asFilename existsSafely ifTrue: [^(home, fsep, dir)].	"if in $HOME"	(Filename filesMatching: '*')											"if in *"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	ddr := DataDir.	ddr ifNil: [ddr := SystemUtils getEnvironmentVariable: 'VISUALWORKS'].	((ddr, fsep, dir) asFilename existsSafely)		ifTrue: [^ddr, fsep, dir].	ddr := ddr asFilename directory asString.	((ddr, fsep, dir) asFilename existsSafely)		ifTrue: [^ddr, fsep, dir].	aggressive ifFalse: [^nil].	(Filename filesMatching: home, fsep, '*')								"if in ~/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: fsep, 'Smalltalk', fsep, '*')					"if in /Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: home, fsep, 'Smalltalk', fsep, '*')				"if in ~/Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	^nil</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>class initialization</category><body package="Siren" selector="initialize">initialize	"Edit these to taste for your installation."	"SirenUtility initialize. SirenSession initialize"	"SirenUtility dataDir"	"SirenSession eventLists"	"SirenUtility findFile: 'tuba'"	"See also system-dependent setup in SirenUtility&gt;&gt;playSoundFile" 	| sirenDir |	DefaultMIDIIn := 1.			"Tune these to your setup"	DefaultMIDIOut := 2.	DefaultOSCHost := #[127 0 0 1].	DefaultOSCPort := 54321.	PortModel initialize.	Verbosity := 1.				"0 = pretty silent;								 1 = medium-verbose; 								 2 = full scheduler and interface logging"	LoggingStream = nil.			"logging output file"	DataDir := ''.								"Look for Siren data and set search paths"	sirenDir := SirenUtility findDir: 'Siren9' tryHard: false.	sirenDir ifNil: [self error: 'Cannot find Siren release folder'].	sirenDir := sirenDir, Filename separatorString.	ScoreDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Scores"	self addDir: 'Scores' to: ScoreDir.	self addDir: 'MIDI' to: ScoreDir.	SoundDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Sound files"	self addDir: 'Sound' to: SoundDir.	self addDir: 'Samples' to: SoundDir.	self addDir: 'SHARC/*' to: SoundDir.					"You can add using wildcards""	self addDir: 'Databases/*' to: SoundDir."				"STP-specific"	DataDir := OrderedCollection new.	DataDir addAll: ScoreDir.	DataDir addAll: SoundDir.	DataDir :=   DataDir asSet asOrderedCollection.	SirenSession initialize								"Session setup"</body></methods><do-it>Filename named: (SystemUtils getEnvironmentVariable: 'VISUALWORKS')</do-it><do-it>(Filename named: (SystemUtils getEnvironmentVariable: 'VISUALWORKS')) directory asString.</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>class initialization</category><body package="Siren" selector="initialize">initialize	"Edit these to taste for your installation."	"SirenUtility initialize. SirenSession initialize"	"SirenUtility dataDir"	"SirenSession eventLists"	"SirenUtility findFile: 'tuba'"	"See also system-dependent setup in SirenUtility&gt;&gt;playSoundFile" 	| sirenDir |	DefaultMIDIIn := 1.			"Tune these to your setup"	DefaultMIDIOut := 2.	DefaultOSCHost := #[127 0 0 1].	DefaultOSCPort := 54321.	PortModel initialize.	Verbosity := 1.				"0 = pretty silent;								 1 = medium-verbose; 								 2 = full scheduler and interface logging"	LoggingStream = nil.			"logging output file"	DataDir := (Filename named: (SystemUtils getEnvironmentVariable: 'VISUALWORKS')) directory asString.								"Look for Siren data and set search paths"	sirenDir := SirenUtility findDir: 'Siren9' tryHard: false.	sirenDir ifNil: [self error: 'Cannot find Siren release folder'].	sirenDir := sirenDir, Filename separatorString.	ScoreDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Scores"	self addDir: 'Scores' to: ScoreDir.	self addDir: 'MIDI' to: ScoreDir.	SoundDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Sound files"	self addDir: 'Sound' to: SoundDir.	self addDir: 'Samples' to: SoundDir.	self addDir: 'SHARC/*' to: SoundDir.					"You can add using wildcards""	self addDir: 'Databases/*' to: SoundDir."				"STP-specific"	DataDir := OrderedCollection new.	DataDir addAll: ScoreDir.	DataDir addAll: SoundDir.	DataDir :=   DataDir asSet asOrderedCollection.	SirenSession initialize								"Session setup"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '9:30:51 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 9:30:51 PM on May 20, 2020."</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ClusterEditor</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ClusterEditor</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '9:36:12 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 9:36:12 PM on May 20, 2020."</do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 96 dur: 0.112 amp: #ppp chan: 1. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: #p chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch: 84 dur: 0.1 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch:66 dur: 0.1 amp: 8 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch:66 dur: 0.2 amp: 8 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch:66 dur: 0.3 amp: 8 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch: 84 dur: 0.1 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 96 dur: 0.112 amp: #ppp chan: 1. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 96 dur: 0.112 amp: #ppp chan: 1. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch: 84 dur: 0.02 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch:66 dur: 0.3 amp: 8 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch: 84 dur: 0.02 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 96 dur: 0.112 amp: #ppp chan: 1. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch:66 dur: 0.3 amp: 8 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 200 pitch: 84 dur: 0.07 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 84 dur: 0.12 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: 20 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: 40 chan: 3. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 84 dur: 0.12 amp: 8 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 96 dur: 0.11 amp: #ppp chan: 1. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 84 dur: 0.12 amp: 6 chan: 2. </do-it><do-it>	MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: 40 chan: 3. </do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 200 pitch: 96 dur: 0.11 amp: #ppp chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice randomWalk: 200 pitch: 80 dur: 0.09 amp: 6 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 200 pitch: 66 dur: 0.08 amp: 30 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 200 pitch: 66 dur: 0.08 amp: 40 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 200 pitch: 66 dur: 0.08 amp: 40 chan: 3]</body></methods><do-it>	MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: 40 chan: 3. </do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			dur := block value.			players at: num put:				 [[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					dur := block value]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 200 pitch: 96 dur: 0.11 amp: 18 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 84 dur: 0.1 amp: #ppp chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice randomWalk: 100 pitch: 80 dur: 0.09 amp: 6 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 66 dur: 0.08 amp: 40 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.11 amp: 18 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 18 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 24 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 24 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: #ppp chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 16 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 66 dur: 0.085 amp: 45 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 12 chan: 1]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '10:06:38 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:06:38 PM on May 20, 2020."</do-it><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar doItMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Siren" selector="doTestMessage">doTestMessage	"Perform the user's selected test message; edit the message if shift-down."	&lt;menuItem: #(#fileBrowser #menus 'File Browser' )		icon: #doTestIcon		nameKey: #doTest		menu: #(#launcherToolBar)		position: 90.01		helpText: #(#OpenAFileBrowser #menus 'Perform (or edit) the test message')&gt;			| sel |	doItMenu ifNil: [doItMenu := Menu labelArray: #(#flush 'add item') values: #(#flushDoItMenu addToDoItMenu)].	sel := doItMenu startUp.	(sel == 0)		ifTrue: [^self].	(sel == #flushDoItMenu)		ifTrue: [doItMenu := Menu labelArray: #(#flush 'add item') values: #(#flushDoItMenu addToDoItMenu).			^self].	(sel == #addToDoItMenu)		ifTrue: [ | answer |			answer := Dialog				request: 'What''s the test message'				initialAnswer: 'Transcript cr; show:100 factorial printString; cr'				onCancel: ['']				windowLabel: 'Test Message Dialog'				for: Dialog defaultParentWindow.			answer isEmpty ifTrue: [^self].			doItMenu addItem: ((MenuItem labeled: answer) value: answer asSymbol) atPosition: doItMenu menuItems size.			^self].	self builder window controller sensor shiftDown		ifTrue: [doItMenu removeItem: (doItMenu menuItemLabeled: sel).			^self].	Compiler new		evaluate: sel asSymbol		in: nil		allowReceiver: false		receiver: nil		environment: Smalltalk		notifying: nil		ifFail: [^self]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '10:08:44 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:08:44 PM on May 20, 2020."</do-it><do-it>Tools.UIPainter new openOnClass: self andSelector: #windowSpec</do-it><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeAutoSave true #positionAutoSave true #sizeType #lastSavedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Cluster/Ostinato Editor' 			#min: #(#{Core.Point} 526 255 ) 			#max: #(#{Core.Point} 526 255 ) 			#bounds: #(#{Graphics.Rectangle} 866 582 1392 837 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 6130 6974 7421 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 29 0 53 0 125 0 71 0 ) 					#name: #voiceMenu 					#model: #defaultVoiceClass 					#label: 'MIDI' 					#menu: #voiceMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 29 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Voice' 					#style: #systemDefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 115 0 124 0 133 0 ) 					#name: #ActionButton1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6655 8191 5119 ) ) 					#model: #testMIDI 					#label: 'Test MIDI I/O' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 84 0 124 0 102 0 ) 					#name: #configMIDI 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 6655 5119 ) ) 					#model: #configureMIDI 					#label: 'Configure MIDI' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 146 0 124 0 164 0 ) 					#name: #testOSC 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 					#model: #testOSCout 					#label: 'Test OSC' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 177 0 124 0 195 0 ) 					#name: #ActionButton3 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 8191 8191 ) ) 					#model: #stopMIDI 					#label: 'Stop MIDI' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 200 0 45 0 242 0 69 0 ) 					#name: #minPitchField 					#model: #minPitch 					#style: #systemDefault 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 277 0 45 0 319 0 69 0 ) 					#name: #maxPitchField 					#model: #maxPitch 					#style: #systemDefault 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} 171 0 100 0 318 0 121 0 ) 					#name: #scale 					#model: #scale 					#label: 'Pentatonic' 					#menu: #scaleMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 3 0 ) 					#name: #Label7 					#label: 'Output' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 354 0 121 0 ) 					#name: #Label2 					#label: 'Thread' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 142 0 3 0 ) 					#name: #Label3 					#label: 'Contents' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 160 0 29 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Pitches' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 169 0 49 0 ) 					#name: #Label5 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 249 0 49 0 ) 					#name: #Label8 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 170 0 71 0 319 0 95 0 ) 					#name: #pitchLidtField 					#model: #pitchList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 118 0 516 0 139 0 ) 					#name: #startButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #startStop 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 380 0 145 0 ) 					#name: #clusterButton1 					#model: #mode 					#label: 'Cluster' 					#select: #cluster ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 380 0 168 0 ) 					#name: #ostButton 					#model: #mode 					#label: 'Ostinato' 					#select: #ostinato ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 155 0 127 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Durations' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 164 0 149 0 ) 					#name: #Label9 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 190 0 146 0 237 0 166 0 ) 					#name: #minDurField 					#model: #minDur 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 244 0 149 0 ) 					#name: #Label10 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 271 0 146 0 318 0 165 0 ) 					#name: #maxDurField 					#model: #maxDur 					#style: #systemDefault 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 219 0 12 0 276 0 33 0 ) 					#name: #AddButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) ) 					#model: #addPitch 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 275 0 12 0 332 0 33 0 ) 					#name: #removeButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 8191 5119 ) ) 					#model: #removePitch 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 380 0 189 0 ) 					#name: #cloudButton 					#model: #mode 					#label: 'Cloud' 					#select: #cloud ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 433 0 231 0 490 0 249 0 ) 					#name: #loadButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5119 5119 ) ) 					#model: #load 					#label: 'Load' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 377 0 231 0 434 0 249 0 ) 					#name: #saveButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6655 5119 8191 ) ) 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 154 0 191 0 ) 					#name: #Label11 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Amplitudes' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 163 0 213 0 ) 					#name: #Label12 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 189 0 210 0 236 0 229 0 ) 					#name: #minAmplField 					#model: #minAmpl 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 243 0 213 0 ) 					#name: #Label13 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 270 0 210 0 317 0 229 0 ) 					#name: #maxAmplField 					#model: #maxAmpl 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 355 0 29 0 ) 					#name: #Label14 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Voices' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 364 0 47 0 ) 					#name: #Label15 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 390 0 43 0 437 0 67 0 ) 					#name: #minVoiceField 					#model: #minVoice 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 444 0 47 0 ) 					#name: #Label16 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 471 0 43 0 518 0 67 0 ) 					#name: #maxVoiceField 					#model: #maxVoice 					#style: #systemDefault 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 169 0 166 0 318 0 190 0 ) 					#name: #durationListField 					#model: #durationList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 168 0 230 0 317 0 254 0 ) 					#name: #amplListField 					#model: #amplList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 369 0 68 0 518 0 92 0 ) 					#name: #voiceListField 					#model: #voiceList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 436 0 13 0 471 0 31 0 ) 					#name: #ActionButton2 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) ) 					#model: #addEvent 					#label: '+' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 470 0 13 0 505 0 31 0 ) 					#name: #ActionButton4 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 8191 5119 ) ) 					#model: #removeEvent 					#label: '-' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 404 0 12 0 434 0 36 0 ) 					#name: #numEventsField 					#model: #numEvents 					#style: #systemDefault 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 335 0 82 0 348 0 241 0 ) 					#name: #tempoSlider 					#model: #tempo 					#orientation: #vertical 					#start: 0.125 					#stop: 2 ) ) ) )</body></methods><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeAutoSave true #positionAutoSave true #sizeType #lastSavedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Cluster/Ostinato Editor' 			#min: #(#{Core.Point} 527 264 ) 			#max: #(#{Core.Point} 527 264 ) 			#bounds: #(#{Graphics.Rectangle} 866 582 1393 846 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 4137 5250 6364 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 29 0 53 0 125 0 71 0 ) 					#name: #voiceMenu 					#model: #defaultVoiceClass 					#label: 'MIDI' 					#menu: #voiceMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 29 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Voice' 					#style: #systemDefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 115 0 124 0 133 0 ) 					#name: #ActionButton1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6655 8191 5119 ) ) 					#model: #testMIDI 					#label: 'Test MIDI I/O' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 84 0 124 0 102 0 ) 					#name: #configMIDI 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 6655 5119 ) ) 					#model: #configureMIDI 					#label: 'Configure MIDI' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 146 0 124 0 164 0 ) 					#name: #testOSC 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 					#model: #testOSCout 					#label: 'Test OSC' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 28 0 177 0 124 0 195 0 ) 					#name: #ActionButton3 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 8191 8191 ) ) 					#model: #stopMIDI 					#label: 'Stop MIDI' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 200 0 45 0 242 0 69 0 ) 					#name: #minPitchField 					#model: #minPitch 					#style: #systemDefault 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 277 0 45 0 319 0 69 0 ) 					#name: #maxPitchField 					#model: #maxPitch 					#style: #systemDefault 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} 171 0 100 0 318 0 121 0 ) 					#name: #scale 					#model: #scale 					#label: 'Pentatonic' 					#menu: #scaleMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 3 0 ) 					#name: #Label7 					#label: 'Output' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 354 0 121 0 ) 					#name: #Label2 					#label: 'Thread' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 142 0 3 0 ) 					#name: #Label3 					#label: 'Contents' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 160 0 29 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Pitches' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 169 0 49 0 ) 					#name: #Label5 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 249 0 49 0 ) 					#name: #Label8 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 170 0 71 0 319 0 95 0 ) 					#name: #pitchLidtField 					#model: #pitchList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 414 0 118 0 516 0 139 0 ) 					#name: #startButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #startStop 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 380 0 145 0 ) 					#name: #clusterButton1 					#model: #mode 					#label: 'Cluster' 					#select: #cluster ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 380 0 168 0 ) 					#name: #ostButton 					#model: #mode 					#label: 'Ostinato' 					#select: #ostinato ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 155 0 127 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Durations' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 164 0 149 0 ) 					#name: #Label9 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 190 0 146 0 237 0 166 0 ) 					#name: #minDurField 					#model: #minDur 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 244 0 149 0 ) 					#name: #Label10 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 271 0 146 0 318 0 165 0 ) 					#name: #maxDurField 					#model: #maxDur 					#style: #systemDefault 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 219 0 12 0 276 0 33 0 ) 					#name: #AddButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) ) 					#model: #addPitch 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 275 0 12 0 332 0 33 0 ) 					#name: #removeButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 8191 5119 ) ) 					#model: #removePitch 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 380 0 189 0 ) 					#name: #cloudButton 					#model: #mode 					#label: 'Cloud' 					#select: #cloud ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 433 0 231 0 490 0 249 0 ) 					#name: #loadButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5119 5119 ) ) 					#model: #load 					#label: 'Load' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 377 0 231 0 434 0 249 0 ) 					#name: #saveButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6655 5119 8191 ) ) 					#model: #save 					#label: 'Save' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 154 0 191 0 ) 					#name: #Label11 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Amplitudes' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 163 0 213 0 ) 					#name: #Label12 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 189 0 210 0 236 0 229 0 ) 					#name: #minAmplField 					#model: #minAmpl 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 243 0 213 0 ) 					#name: #Label13 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 270 0 210 0 317 0 229 0 ) 					#name: #maxAmplField 					#model: #maxAmpl 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 355 0 29 0 ) 					#name: #Label14 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 0 4096 8191 ) ) 					#label: 'Voices' 					#style: #systemDefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 364 0 47 0 ) 					#name: #Label15 					#label: 'Min' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 390 0 43 0 437 0 67 0 ) 					#name: #minVoiceField 					#model: #minVoice 					#style: #systemDefault 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 444 0 47 0 ) 					#name: #Label16 					#label: 'Max' 					#style: #systemDefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 471 0 43 0 518 0 67 0 ) 					#name: #maxVoiceField 					#model: #maxVoice 					#style: #systemDefault 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 169 0 166 0 318 0 190 0 ) 					#name: #durationListField 					#model: #durationList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 168 0 230 0 317 0 254 0 ) 					#name: #amplListField 					#model: #amplList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 369 0 68 0 518 0 92 0 ) 					#name: #voiceListField 					#model: #voiceList 					#style: #systemDefault 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 436 0 13 0 471 0 31 0 ) 					#name: #ActionButton2 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 6655 8191 ) ) 					#model: #addEvent 					#label: '+' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 470 0 13 0 505 0 31 0 ) 					#name: #ActionButton4 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 8191 5119 ) ) 					#model: #removeEvent 					#label: '-' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 404 0 12 0 434 0 36 0 ) 					#name: #numEventsField 					#model: #numEvents 					#style: #systemDefault 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 335 0 82 0 348 0 241 0 ) 					#name: #tempoSlider 					#model: #tempo 					#orientation: #vertical 					#start: 0.125 					#stop: 2 ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '10:15:19 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:15:19 PM on May 20, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '10:18:10 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:18:10 PM on May 20, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '10:18:31 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:18:31 PM on May 20, 2020."</do-it><do-it>int first</do-it><methods><class-id>Core.Interval</class-id> <category>accessing</category><body package="Siren" selector="stop">stop	"Answer the last element of the arithmetic progression."	^stop</body></methods><methods><class-id>Core.Interval</class-id> <category>accessing</category><body package="Collections-Sequenceable" selector="size">size	"Answer how many elements the receiver contains."	"E.g. what is the distance between start and stop measured in step units."	"In the case of floating-point intervals, simply answer stop - start"	^step &lt; 0		ifTrue: [start &lt; stop			ifTrue: [0]			ifFalse: [stop - start // step + 1]]		ifFalse: [(start isInteger and: [stop isInteger])			ifTrue: [stop &lt; start				ifTrue: [0]				ifFalse: [stop - start // step + 1]]			ifFalse: [stop - start]]</body></methods><methods><class-id>Core.Interval</class-id> <category>testing</category><body package="Collections-Sequenceable" selector="includes:">includes: aNumber 	"Answer whether aNumber is within the receiver's bounds."	^((aNumber &gt; self first) and: [aNumber &lt;= self stop])</body></methods><do-it>	OSCVoice vxFadeExample1: 8 </do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 20, 2020' '10:36:24 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:36:24 PM on May 20, 2020."</do-it><do-it>1/4 beat</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 21, 2020' '10:08:44 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:08:44 AM on May 21, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 21, 2020' '10:10:04 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:10:04 AM on May 21, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="startStop">startStop	"start/stop the event-generating process."	| t0 v0  |	running ifTrue:		[running := false.		Transcript show: 'Stop'; cr.		process terminate.		(self builder componentAt: #startButton) component component setLabelString: 'Start'.		events := nil.		^self].	Transcript show: 'Start'; cr.	(self builder componentAt: #startButton) component component setLabelString: 'Stop'.	self generateEvents.	running := true.	t0 := Time microsecondClock usec.	v0 := MIDIVoice default.	v0 channel: 4."Special thread for clusters"	mode value == #cluster ifTrue:		[ | durs |		durs := self stringToList: durationList value.		process := [[running] whileTrue: 			[ | t1 ev te |			te := self tempo value.			ev := events atRandom copy.			ev scaleDuration: 2.0 / te.			ev playOn: v0 at: t0.			t1 := durs atRandom sec asUsec value * te.			t0 := t0 + t1.			(Delay forMicroseconds: t1) wait]] fork.		Processor yield.  			"give proc a chance to run"		^self].	mode value == #cloud ifTrue:		[events scaleStartTimesBy: self tempo value.		events scaleDurationsBy: (2.0 / self tempo value).		events playOn: v0 at: t0.		(self builder componentAt: #startButton) component component setLabelString: 'Start'.		^self].	process := [[running] whileTrue: 		[ | t1 |		events copy playOn: v0 at: t0.		t1 := events duration asUsec value.		t0 := t0 + t1.		(Delay forMicroseconds: t1) wait]] fork "At: 5".	Processor yield</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="generateEvents">generateEvents	"Create the event list, a cluster, ostinato or cloud"	| pits durs amps voxs |	pits := self stringToList: pitchList value.	durs := self stringToList: durationList value.	amps := self stringToList: amplList value.	voxs := self stringToList: voiceList value.	mode value == #cluster ifTrue:		[events :=  EventList new.		0 to: numEvents value - 1 do:			[ :ind | | evt |			evt := MusicEvent dur: (durs at: (ind \\ durs size + 1))						pitch: (pits at: (ind \\ pits size + 1)) 						ampl: (amps at: (ind \\ amps size + 1)) 						"voice: (voxs at: (ind \\ voxs size + 1))".			events add: evt at: 0].		events scaleStartTimesBy: tScale.		^self].	mode value == #ostinato ifTrue:		[ | t1 |		events :=  EventList new.		t1 := 0.0.		0 to: numEvents value - 1 do:			[ :ind | | evt |			evt := MusicEvent dur: (durs at: (ind \\ durs size + 1))						pitch: (pits at: (ind \\ pits size + 1)) 						ampl: (amps at: (ind \\ amps size + 1)) 						voice: (voxs at: (ind \\ voxs size + 1)).			events add: evt at: t1.			t1 := t1 + evt duration asSec value].		events scaleStartTimesBy: tScale.		^self].	mode value == #cloud ifTrue:		[ | cl |		cl := Cloud fromDictionary: ((#duration -&gt; 10000), 			(#pitch -&gt; (minPitch value to: maxPitch value)),			(#loudness -&gt; (minAmpl value to: maxAmpl value)), 			(#voice -&gt; (minVoice value to: maxVoice value))).		cl density: 2.		events := cl eventList.		events scaleStartTimesBy: tScale]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="generateEvents">generateEvents	"Create the event list, a cluster, ostinato or cloud"	| pits durs amps voxs |	pits := self stringToList: pitchList value.	durs := self stringToList: durationList value.	amps := self stringToList: amplList value.	voxs := self stringToList: voiceList value.	mode value == #cluster ifTrue:		[events :=  EventList new.		0 to: numEvents value - 1 do:			[ :ind | | evt |			evt := MusicEvent dur: (durs at: (ind \\ durs size + 1))						pitch: (pits at: (ind \\ pits size + 1)) 						ampl: (amps at: (ind \\ amps size + 1)) 						voice: (voxs at: (ind \\ voxs size + 1)).			events add: evt at: 0].		events scaleStartTimesBy: tScale.		^self].	mode value == #ostinato ifTrue:		[ | t1 |		events :=  EventList new.		t1 := 0.0.		0 to: numEvents value - 1 do:			[ :ind | | evt |			evt := MusicEvent dur: (durs at: (ind \\ durs size + 1))						pitch: (pits at: (ind \\ pits size + 1)) 						ampl: (amps at: (ind \\ amps size + 1)) 						voice: (voxs at: (ind \\ voxs size + 1)).			events add: evt at: t1.			t1 := t1 + evt duration asSec value].		events scaleStartTimesBy: tScale.		^self].	mode value == #cloud ifTrue:		[ | cl |		cl := Cloud fromDictionary: ((#duration -&gt; 10000), 			(#pitch -&gt; (minPitch value to: maxPitch value)),			(#loudness -&gt; (minAmpl value to: maxAmpl value)), 			(#voice -&gt; (minVoice value to: maxVoice value))).		cl density: 2.		events := cl eventList.		events scaleStartTimesBy: tScale]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>initialize-release</category><body package="Siren" selector="initialize">initialize	"Set up the default values."	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	"self open"	minPitch := 72 asValue.	maxPitch := 84 asValue.	minDur := (1/2) asValue.	maxDur := (1/6) asValue.	minAmpl := 20 asValue.	maxAmpl := 34 asValue.	minVoice := 1 asValue.	maxVoice := 1 asValue.	pitchList := '84 85 86 87 88' asValue.	durationList := '1/1 1/1 1/1 1/2' asValue.	amplList := '20 20 24 24' asValue.	voiceList := '4' asValue.	mode := #cluster asValue.	scale := #Pentatonic asValue.	process := nil.	events := nil.	numEvents := 8 asValue.	running := false.	tempo := 1.0 asValue.	tScale := 1.0.	players := Array new: 10 withAll: nil.	playerStates := Array new: 10 withAll: false.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 21, 2020' '10:39:02 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:39:02 AM on May 21, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 21, 2020' '10:44:10 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:44:10 AM on May 21, 2020."</do-it><do-it> | c |	c := (Cloud dur: 6			"lasts 6 sec."		pitch: (48 to: 60)  		"with pitches in this range"		ampl: (80 to: 120) 		"and amplitudes in this range"		voice: (1 to: 1)			"select from these voices"		density: 5) eventList.	"play 5 notes per sec. and get the event list"	c open</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 21, 2020' '11:48:46 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 11:48:46 AM on May 21, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale evList voice  pitches |	scale := OrderedCollection new.						"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	evList := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: evList events size do: 							"plug in instruments 40-48"		[ :ind | | ev |					ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	evList computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.			"plug in the parameter map"	evList voice: voice.	evList play.											"play"	^evList duration</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 22, 2020' '10:41:35 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:41:35 AM on May 22, 2020."</do-it><do-it>((0 =&gt; (1/2 beat, 'd3' pitch, 'mf' ampl)), 	  (0 =&gt; (1/2 beat, 'fs3' pitch, 'mf' ampl)), 	  (0 =&gt; (1/2 beat, 'a4' pitch, 'mf' ampl))) open</do-it><do-it>(EventList scaleFrom: 48 to: 60 in: 1.5) open</do-it><do-it>(DynamicCloud dur: 6  		pitch: #((30 to: 49) (60 to: 60))	"given starting and ending selection ranges"		ampl: #((20 to: 40) (90 to: 120))		voice: #((1) (1))		density: 12) open</do-it><do-it>N re</do-it><do-it>	((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList play.</do-it><do-it>	((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList play.</do-it><do-it>	((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 4).</do-it><do-it>	((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 4).</do-it><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="updateListFull">updateListFull	| protocolList target newList |	protocolList := self protocols.	target := self targetClassOrNameSpace.	(target isNil or: [protocolList isNil])		ifTrue: [^module setNewList: List new].	 protocolList isEmpty		ifTrue: [protocolList := target organization categories].	newList := (target organization listAtCategoriesNamed: protocolList) asSortedCollection.	target isForNameSpace		ifTrue: [ newList := newList select: [ :key | ( target bindingFor: key ) isForGeneral ] ].	module setNewList: newList asList</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 23, 2020' '12:21:29 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 12:21:29 AM on May 23, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 23, 2020' '11:24:19 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 11:24:19 AM on May 23, 2020."</do-it><do-it>FullSystemBrowser instanceCount</do-it><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>accepting</category><body package="Browser-BrowserUI" selector="accept:from:">accept: aText from: aController self halt.	modified := nil.	[self compileMethodText: aText from: aController] 		ensure: [modified := false]</body></methods><methods><class-id>Siren.PortModel class</class-id> <category>class var accessing</category><body package="Siren" selector="devices">devices	^devices</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>accepting</category><body package="Browser-BrowserUI" selector="accept:from:">accept: aText from: aController 	modified := nil.	[self compileMethodText: aText from: aController] 		ensure: [modified := false]</body></methods><methods><class-id>Refactory.Browser.BrowserTextTool</class-id> <category>accepting</category><body package="Browser-BrowserUI" selector="accept:from:">accept: aText from: aControllerself halt.	^self subclassResponsibility</body></methods><methods><class-id>Siren.PortModel class</class-id> <category>class var accessing</category><body package="Siren" selector="devices">devices	^devices</body></methods><methods><class-id>Refactory.Browser.BrowserTextTool</class-id> <category>accepting</category><body package="Browser-BrowserUI" selector="accept:from:">accept: aText from: aController	^self subclassResponsibility</body></methods><do-it>self closeEvent: nil</do-it><do-it>self closeEvent: nil</do-it><do-it>self closeEvent: nil</do-it><do-it>self closeEvent: nil</do-it><do-it>self closeAndUnschedule</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 23, 2020' '11:56:47 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 11:56:47 AM on May 23, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 23, 2020' '12:00:26 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 12:00:26 PM on May 23, 2020."</do-it><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>=&gt;</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>ampl</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>dB</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>beat</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>dur</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>duration</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>Hertz</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>Hz</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>OldBrowsers</name> <type>parcel</type><definitionName>Root.Smalltalk.Tools.SelectorBrowserHelper</definitionName> <meta>false</meta> <selector>updateListFull</selector> <definitionChange>removed</definitionChange></component_selector_change><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 23, 2020' '12:06:49 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 12:06:49 PM on May 23, 2020."</do-it><do-it>((Roll length: 2 rhythm: 100 note: 48) ampl: 100) eventList edit</do-it><do-it>(Roll length: 2 rhythm: 50 note: 60) ampl: 80</do-it><do-it>self eventList</do-it><do-it>Roll length: 2 rhythm: 50 note: 60</do-it><do-it>aLength / (aDuration / 1000).</do-it><do-it> aLength / (aDuration / 1000).</do-it><methods><class-id>Siren.Roll</class-id> <category>initialize</category><body package="Siren" selector="length:rhythm:note:">length: aLength rhythm: aDuration note: aNote	"make a new roll of the specified length..."	delta := aDuration.	noteDuration := aDuration.	number := aLength / (aDuration / 1000).	self pitch: (Pitch value: aNote).	^self</body></methods><do-it>((Roll length: 2 rhythm: 100 note: 48) ampl: 100) eventList edit</do-it><methods><class-id>Siren.Roll class</class-id> <category>examples</category><body package="Siren" selector="rollExample">rollExample	"Create and edit/play a few rolls."	"((Roll length: 2 rhythm: 100 note: 48) ampl: 100) eventList"	"((Roll length: 2 rhythm: 100 note: 48) ampl: 100) eventList edit"	((Roll length: 4 rhythm: 50 note: 60) ampl: 80) eventList play."	MIDIPort allNotesOff."</body></methods><do-it>Siren.Roll class reorganizeFromString: '(''instance creation'' #length:rhythm:note: #number:rhythm:note:)(''examples'' #rollExample)'</do-it><methods><class-id>Siren.Roll class</class-id> <category>instance creation</category><body package="Siren" selector="length:rhythm:note:">length: aNumber rhythm: aDuration note: aNote	"return a new roll of the specified length..."	"aNumberis dur in secs, aDuratoion is in msec, aNote is a MIDI key #"	^self new length: aNumber rhythm: aDuration note: aNote</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isDisplayItem">isDisplayItem	"Answer whether the receiver is a kind of DisplayItem"	^false</body></methods><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isDisplayItem</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Kernel-Objects</name> <type>package</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isDisplayItem</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>package</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isDisplayItem</selector> <definitionChange>added</definitionChange></component_selector_change><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Kernel-Objects" selector="isEvent">isEvent	"Coerces Events to true and everything else to false.  Event	overrides with ^true"	^false</body></methods><component_selector_change><name>Siren</name> <type>parcel</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isEvent</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Kernel-Objects</name> <type>package</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isEvent</selector> <definitionChange>removed</definitionChange></component_selector_change><component_selector_change><name>Siren</name> <type>package</type><definitionName>Root.Smalltalk.Core.Object</definitionName> <meta>false</meta> <selector>isEvent</selector> <definitionChange>added</definitionChange></component_selector_change><methods><class-id>Siren.SirenSession class</class-id> <category>resources</category><body package="Siren" selector="midiTestMenu">midiTestMenu	"Tools.MenuEditor new openOnClass: self andSelector: #midiTestMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'test input' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'start input' 							#value: 1 ) 						#(#{UI.MenuItem} 							#rawLabel: 'stop input' 							#value: 2 ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'test output' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'single note' 							#value: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'scale' 							#value: 4 ) 						#(#{UI.MenuItem} 							#rawLabel: 'roll' 							#value: 5 ) 						#(#{UI.MenuItem} 							#rawLabel: 'clouds' 							#value: 6 ) 						) #(3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><do-it>Tools.MenuEditor new openOnClass: self andSelector: #midiTestMenu</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''interface opening'' #open #openTransport #openUtility)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)(''instance creation'' #instance #new #refresh #release)'</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''interface opening'' #open #openTransport #openUtility)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)(''instance creation'' #instance #new #refresh #release)'</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''interface opening'' #open #openTransport #openUtility)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)(''instance creation'' #instance #new #refresh #release)'</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''instance creation'' #instance #new #refresh #release)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''interface opening'' #open #openTransport #openUtility)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)'</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''instance creation'' #instance #new #refresh #release)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''interface opening'' #open #openTransport #openUtility)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)'</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''instance creation'' #instance #new #refresh #release)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''interface opening'' #open #openTransport #openUtility)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)'</do-it><do-it>Siren.SirenSession class reorganizeFromString: '(''class initialization'' #flushTempEventLists #initialize #initializeEventLists #initializeSounds #initializeVoices #update:with:from:)(''instance creation'' #instance #new #refresh #release)(''interface specs'' #transportButtonSpec #transportWindowSpec #utilWindowSpec)(''interface opening'' #open #openTransport #openUtility)(''resources'' #blocksizeMenu #chMenu #clockMenu #forwardButton #midiPortMenu #midiTestMenu #playButton #rateMenu #recordButton #rewindButton #scheduleMenu #soundPortMenu #stopButton #timerMenu #verbosityMenu)(''class var accessing'' #atVoice:put: #eventList: #eventList:put: #eventListNamed: #eventLists #schedule #sound: #sound:put: #soundNamed: #sounds #voice:put: #voiceNamed: #voices)(''data load/store'' #data:in:put: #dataAt:in: #loadDemoData)'</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (90 to: 110))			voice: #((0) (0))			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (38 to: 40))			ampl: #((80 to: 100) (60 to: 120))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: MIDIVoice default</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: #((0) (0))			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><do-it>Tools.MenuEditor new openOnClass: self andSelector: #midiTestMenu</do-it><methods><class-id>Siren.SirenSession class</class-id> <category>resources</category><body package="Siren" selector="midiTestMenu">midiTestMenu	"Tools.MenuEditor new openOnClass: self andSelector: #midiTestMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'test input' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'start input' 							#value: 1 ) 						#(#{UI.MenuItem} 							#rawLabel: 'stop input' 							#value: 2 ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'test output' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'single note' 							#value: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'scale' 							#value: 4 ) 						#(#{UI.MenuItem} 							#rawLabel: 'roll' 							#value: 5 ) 						#(#{UI.MenuItem} 							#rawLabel: 'clouds' 							#value: 6 ) ) #(3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Siren.SirenSession class</class-id> <category>resources</category><body package="Siren" selector="midiTestMenu">midiTestMenu	"Tools.MenuEditor new openOnClass: self andSelector: #midiTestMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'test input' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'start input' 							#value: 1 ) 						#(#{UI.MenuItem} 							#rawLabel: 'stop input' 							#value: 2 ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'test output' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'single note' 							#value: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'scale' 							#value: 4 ) 						#(#{UI.MenuItem} 							#rawLabel: 'roll' 							#value: 5 ) 						#(#{UI.MenuItem} 							#rawLabel: 'clouds' 							#value: 6 ) ) #(4 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 5 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (90 to: 110))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (68 to: 90))			ampl: #((80 to: 100) (60 to: 120))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: MIDIVoice default</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 5 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (90 to: 110))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (68 to: 90))			ampl: #((80 to: 100) (60 to: 120))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIin">testMIDIin	"Unused - see testMIDI"	MIDIPort testInput</body></methods><do-it>MIDIVoice default</do-it><do-it>(MIDIVoice default) channel: 2</do-it><methods><class-id>Siren.MIDIPort class</class-id> <category>output tests</category><body package="Siren" selector="testANote">testANote	"Open MIDI, play a note."	"MIDIPort release"	"MIDIPort testANote"	| inst |	inst := MIDIPort new.	inst openOutput: self concreteClass out.	inst play: 60 dur: 500 amp: 80 voice: 2.	1 wait.	inst close.</body></methods><do-it>MIDIPort testANote</do-it><methods><class-id>Siren.MIDIPort class</class-id> <category>output tests</category><body package="Siren" selector="testANote">testANote	"Open MIDI, play a note."	"MIDIPort release"	"MIDIPort testANote"	| inst |	inst := MIDIPort new.	inst openOutput: self concreteClass out.	inst play: 60 dur: 500 amp: 80 voice: 1.	1 wait.	inst close.</body></methods><do-it>MIDIPort testANote</do-it><methods><class-id>Siren.MIDIPort class</class-id> <category>output tests</category><body package="Siren" selector="testANote">testANote	"Open MIDI, play a note."	"MIDIPort release"	"MIDIPort testANote"	| inst |	inst := MIDIPort new.	inst openOutput: self concreteClass out.	inst play: 60 dur: 500 amp: 80 voice: 0.	1 wait.	inst close.</body></methods><do-it>MIDIPort testANote</do-it><do-it>((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><do-it>(Roll length: 2 rhythm: 50 note: 60) ampl: 80</do-it><methods><class-id>Siren.Roll class</class-id> <category>instance creation</category><body package="Siren" selector="length:rhythm:note:">length: aNumber rhythm: aDuration note: aNote	"return a new roll of the specified length..."	"(Roll length: 2 rhythm: 50 note: 60) ampl: 80 - length is in secs, rhy is note dur in msec"	^self new length: aNumber rhythm: aDuration note: aNote</body></methods><methods><class-id>Siren.Roll class</class-id> <category>instance creation</category><body package="Siren" selector="rollLen:noteLen:notePitch:ampl:">rollLen: aNumber noteLen: aDuration notePitch: aNote ampl: anAmpl	"return a new roll of the specified length..."	"(Roll rollLen: 2 noteLen 50 pitch: 60) ampl: 80 - length is in secs, rhy is note dur in msec"	^self new length: aNumber rhythm: aDuration note: aNote ampl: anAmpl</body></methods><methods><class-id>Siren.Roll</class-id> <category>initialize</category><body package="Siren" selector="length:rhythm:note:ampl:">length: aLength rhythm: aDuration note: aNote ampl: anAmpl	"make a new roll of the specified length..."	delta := aDuration.	noteDuration := aDuration.	number := aLength / aDuration.	self pitch: (Pitch value: aNote).	^self</body></methods><do-it>Siren.Roll reorganizeFromString: '(''initialize'' #length:rhythm:note: #length:rhythm:note:ampl: #number:rhythm:note:)(''accessing'' #duration)(''playing'' #eventList)'</do-it><methods><class-id>Siren.Roll</class-id> <category>initialize</category><body package="Siren" selector="length:rhythm:note:ampl:">length: aLength rhythm: aDuration note: aNote ampl: anAmpl	"make a new roll of the specified length..."	delta := aDuration.	noteDuration := aDuration.	number := aLength / aDuration.	self pitch: (Pitch value: aNote).	self ampl: anAmpl.	^self</body></methods><methods><class-id>Siren.Roll class</class-id> <category>instance creation</category><body package="Siren" selector="rollLen:noteLen:pitch:ampl:">rollLen: aNumber noteLen: aDuration pitch: aNote ampl: anAmpl	"return a new roll of the specified length..."	"(Roll rollLen: 2 noteLen 50 pitch: 60) ampl: 80 - length is in secs, rhy is note dur in msec"	^self new length: aNumber rhythm: aDuration note: aNote ampl: anAmpl</body></methods><do-it>Roll rollLen: 2 noteLen: 50 pitch: 60 ampl: 80</do-it><do-it>(Roll rollLen: 2 noteLen: 50 pitch: 60 ampl: 80) eventList</do-it><methods><class-id>Siren.Roll</class-id> <category>initialize</category><body package="Siren" selector="length:rhythm:note:ampl:">length: aLength rhythm: aDuration note: aNote ampl: anAmpl	"make a new roll of the specified length..."	duration := aLength asSec.	delta := aDuration.	noteDuration := aDuration.	number := aLength / aDuration.	self pitch: (Pitch value: aNote).	self ampl: anAmpl.	^self</body></methods><do-it>aLength sec.</do-it><methods><class-id>Siren.Roll</class-id> <category>initialize</category><body package="Siren" selector="length:rhythm:note:ampl:">length: aLength rhythm: aDuration note: aNote ampl: anAmpl	"make a new roll of the specified length..."	duration := aLength sec.	delta := aDuration.	noteDuration := aDuration.	number := aLength / aDuration.	self pitch: (Pitch value: aNote).	self ampl: anAmpl.	^self</body></methods><methods><class-id>Siren.Roll</class-id> <category>initialize</category><body package="Siren" selector="length:rhythm:note:ampl:">length: aLength rhythm: aDuration note: aNote ampl: anAmpl	"make a new roll of the specified length..."	duration := aLength sec.	delta := aDuration.	noteDuration := aDuration.	number := aLength / (aDuration / 1000).	self pitch: (Pitch value: aNote).	self ampl: anAmpl.	^self</body></methods><do-it>(Roll rollLen: 2 noteLen: 50 pitch: 60 ampl: 80) eventList</do-it><remove-selector><class-id>Siren.Roll class</class-id> <selector>rollLen:noteLen:notePitch:ampl:</selector></remove-selector><methods><class-id>Siren.Roll class</class-id> <category>instance creation</category><body package="Siren" selector="number:duration:pitch:">number: aNumber duration: aDuration pitch: aNote	"return a new roll with the specified number of events..."	^self new number: aNumber rhythm: aDuration note: aNote</body></methods><remove-selector><class-id>Siren.Roll class</class-id> <selector>number:rhythm:note:</selector></remove-selector><do-it>(Roll rollLen: 2 noteLen: 50 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><do-it>(Roll rollLen: 2 noteLen: 50 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><do-it>^(Roll rollLen: 2 noteLen: 100 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><do-it>^(Roll rollLen: 2 noteLen: 100 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><do-it>^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (90 to: 110))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (68 to: 90))			ampl: #((80 to: 100) (60 to: 120))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (40 to: 50))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (68 to: 90))			ampl: #((40 to: 60) (60 to: 80))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (30 to: 50))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (48 to: 70))			ampl: #((30 to: 60) (60 to: 80))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (30 to: 50))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (48 to: 50))			ampl: #((30 to: 60) (60 to: 82))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 25, 2020' '12:04:39 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 12:04:39 PM on May 25, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 25, 2020' '12:06:10 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 12:06:10 PM on May 25, 2020."</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: #((0) (0))			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: #((0) (0))			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (30 to: 50))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (48 to: 50))			ampl: #((30 to: 60) (60 to: 82))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	"Put up the MIDI test menu and process the results"	| lis sel |	sel := (SirenSession midiTestMenu) startUp."Process results"	sel ifNil: [^self].	sel == 0 ifTrue: [^self]."Input tests"	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop]."Output tests use different channels; edit to taste"	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)]."Cloud is last test"	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (30 to: 50))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (48 to: 50))			ampl: #((30 to: 60) (60 to: 82))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><do-it>^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)</do-it><do-it>^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	"Put up the MIDI test menu and process the results"	| lis sel |	sel := (SirenSession midiTestMenu) startUp."Process results"	sel ifNil: [^self].	sel == 0 ifTrue: [^self]."Input tests"	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop]."Output tests use different channels; edit to taste"	sel == 3 ifTrue: [^MIDIPort testANote]. 			"uses channel 1"	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)]."Cloud is last test"	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (30 to: 50))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (48 to: 50))			ampl: #((30 to: 60) (60 to: 82))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: 2)</body></methods><do-it>SirenUtility fileoutCategories</do-it><do-it>Siren.EventScheduler class reorganizeFromString: '(''instance creation'' #default #instance)(''instance control'' #addClient: #addClient:at: #addClient:in: #addClient:in:loop: #addTimer: #addTimer:interval: #clients #clock #flush #interrupt #isRunning #resetClock #run #timers)(''class initialization'' #initialize #release)(''examples'' #scheduleExample #scheduleExample2 #timerExample)'</do-it><do-it>Siren.EventScheduler class reorganizeFromString: '(''class initialization'' #initialize #release)(''instance creation'' #default #instance)(''instance control'' #addClient: #addClient:at: #addClient:in: #addClient:in:loop: #addTimer: #addTimer:interval: #clients #clock #flush #interrupt #isRunning #resetClock #run #timers)(''examples'' #scheduleExample #scheduleExample2 #timerExample)'</do-it><do-it>Siren.SirenUtility class reorganizeFromString: '(''class initialization'' #initialize #initialize0 #postLoad:)(''class var accessing'' #dataDir #defaultMIDIIn #defaultMIDIIn: #defaultMIDIOut #defaultMIDIOut: #defaultOSCHost #defaultOSCHost: #defaultOSCPort #defaultOSCPort: #scoreDir #soundDir)(''scripts'' #audiofileInsertsToUpdate:to: #collectGenreHistogramsStartingAt: #compareFileLists:and:to: #convertAFInserts: #convertEtDrScore: #dropColumn1From:to: #dropColumnsFrom2:to:drop: #dropColumnsFrom:to:drop: #dropTo2ColumnsFrom:to: #dropToNumColumnsFrom:to: #exploreRecommendationFor: #featureNameDictionary #fileBrokenNames:to: #filterGenresFrom2:to:keep: #filterGenresFrom:to:keep: #genreHistogram2Of:into: #genreHistogramFrom: #genreHistogramOf: #genreHistogramOf:into: #insertAsTable: #insertToDel2:to: #insertToDel:to: #insertToUpdate:to: #iso226Tables #ldaAsTable:toks: #meLogData0: #meLogData2: #meLogData: #mergeLines:with: #pcaToConf2: #pcaToConf3: #pcaToConf4: #pcaToConf4b: #pcaToConf5: #pcaToConf6: #pcaToConf6:title: #pcaToConf: #printRatios #removeDblLines:to: #renameFiles: #scrambleFileLines #selectFileLines:to:base:every: #sqlAsSanity2:from: #sqlAsSanity:from: #sqlAsTable1: #sqlAsTable2: #sqlAsTable3: #sqlAsTable4: #sqlAsTable5: #sqlAsTable: #timingsTable: #weightsToScale:)(''utilities'' #categoryList #fileoutCategories #playSoundFile: #writeSirenManual #writeSirenManualToHTML:)(''example access'' #formNamed: #musicConstants)(''logging'' #log: #log:level: #verbosity #verbosity:)(''file support'' #addDir:to: #createS7: #findDir: #findDir:tryHard: #findFile: #findFile:in: #findFiles: #findFiles:in:into: #listS7: #nextName:type:)'</do-it><do-it>Siren.SirenUtility class reorganizeFromString: '(''class initialization'' #initialize #initialize0 #postLoad:)(''class var accessing'' #dataDir #defaultMIDIIn #defaultMIDIIn: #defaultMIDIOut #defaultMIDIOut: #defaultOSCHost #defaultOSCHost: #defaultOSCPort #defaultOSCPort: #scoreDir #soundDir)(''example access'' #formNamed: #musicConstants)(''scripts'' #audiofileInsertsToUpdate:to: #collectGenreHistogramsStartingAt: #compareFileLists:and:to: #convertAFInserts: #convertEtDrScore: #dropColumn1From:to: #dropColumnsFrom2:to:drop: #dropColumnsFrom:to:drop: #dropTo2ColumnsFrom:to: #dropToNumColumnsFrom:to: #exploreRecommendationFor: #featureNameDictionary #fileBrokenNames:to: #filterGenresFrom2:to:keep: #filterGenresFrom:to:keep: #genreHistogram2Of:into: #genreHistogramFrom: #genreHistogramOf: #genreHistogramOf:into: #insertAsTable: #insertToDel2:to: #insertToDel:to: #insertToUpdate:to: #iso226Tables #ldaAsTable:toks: #meLogData0: #meLogData2: #meLogData: #mergeLines:with: #pcaToConf2: #pcaToConf3: #pcaToConf4: #pcaToConf4b: #pcaToConf5: #pcaToConf6: #pcaToConf6:title: #pcaToConf: #printRatios #removeDblLines:to: #renameFiles: #scrambleFileLines #selectFileLines:to:base:every: #sqlAsSanity2:from: #sqlAsSanity:from: #sqlAsTable1: #sqlAsTable2: #sqlAsTable3: #sqlAsTable4: #sqlAsTable5: #sqlAsTable: #timingsTable: #weightsToScale:)(''utilities'' #categoryList #fileoutCategories #playSoundFile: #writeSirenManual #writeSirenManualToHTML:)(''logging'' #log: #log:level: #verbosity #verbosity:)(''file support'' #addDir:to: #createS7: #findDir: #findDir:tryHard: #findFile: #findFile:in: #findFiles: #findFiles:in:into: #listS7: #nextName:type:)'</do-it><do-it>Siren.SirenUtility class reorganizeFromString: '(''class initialization'' #initialize #initialize0 #postLoad:)(''class var accessing'' #dataDir #defaultMIDIIn #defaultMIDIIn: #defaultMIDIOut #defaultMIDIOut: #defaultOSCHost #defaultOSCHost: #defaultOSCPort #defaultOSCPort: #scoreDir #soundDir)(''example access'' #formNamed: #musicConstants)(''utilities'' #categoryList #fileoutCategories #playSoundFile: #writeSirenManual #writeSirenManualToHTML:)(''logging'' #log: #log:level: #verbosity #verbosity:)(''file support'' #addDir:to: #createS7: #findDir: #findDir:tryHard: #findFile: #findFile:in: #findFiles: #findFiles:in:into: #listS7: #nextName:type:)(''scripts'' #audiofileInsertsToUpdate:to: #collectGenreHistogramsStartingAt: #compareFileLists:and:to: #convertAFInserts: #convertEtDrScore: #dropColumn1From:to: #dropColumnsFrom2:to:drop: #dropColumnsFrom:to:drop: #dropTo2ColumnsFrom:to: #dropToNumColumnsFrom:to: #exploreRecommendationFor: #featureNameDictionary #fileBrokenNames:to: #filterGenresFrom2:to:keep: #filterGenresFrom:to:keep: #genreHistogram2Of:into: #genreHistogramFrom: #genreHistogramOf: #genreHistogramOf:into: #insertAsTable: #insertToDel2:to: #insertToDel:to: #insertToUpdate:to: #iso226Tables #ldaAsTable:toks: #meLogData0: #meLogData2: #meLogData: #mergeLines:with: #pcaToConf2: #pcaToConf3: #pcaToConf4: #pcaToConf4b: #pcaToConf5: #pcaToConf6: #pcaToConf6:title: #pcaToConf: #printRatios #removeDblLines:to: #renameFiles: #scrambleFileLines #selectFileLines:to:base:every: #sqlAsSanity2:from: #sqlAsSanity:from: #sqlAsTable1: #sqlAsTable2: #sqlAsTable3: #sqlAsTable4: #sqlAsTable5: #sqlAsTable: #timingsTable: #weightsToScale:)'</do-it><do-it>Siren.Timer reorganizeFromString: '(''accessing'' #accumulator #accumulator: #interval #interval: #lastUpdate #lastUpdate: #name #name: #running #running: #startTime #startTime:)(''control'' #play #reset #restart #scheduleAt: #start #stop)'</do-it><do-it>Siren.EventAssociation reorganizeFromString: '(''comparing'' #&lt; #=)(''accessing'' #, #event #start #start: #stop #time)(''printing'' #printOn:)'</do-it><do-it>Siren.EventAssociation reorganizeFromString: '(''comparing'' #&lt; #=)(''accessing'' #, #event #start #start: #stop #time)(''printing'' #printOn:)'</do-it><do-it>Siren.EventAssociation reorganizeFromString: '(''accessing'' #, #event #start #start: #stop #time)(''comparing'' #&lt; #=)(''printing'' #printOn:)'</do-it><do-it>Siren.EventScheduler reorganizeFromString: '(''accessing'' #addClient: #addClient:at: #addClient:at:loop: #addClient:in: #addClient:in:loop: #addClient:loop: #addTimer: #addTimer:interval: #clientNamed: #clients #clock #delay #delay: #dontWait #isRunning #removeClient: #removeClientNamed: #removeTimer: #removeTimerNamed: #resetClock #timerNamed: #timers #wait)(''updating'' #update:)(''running'' #callNextAppointment #flush #interrupt #processEvent:at: #run #run:)(''initialize release'' #initialize #release)'</do-it><do-it>Siren.EventScheduler reorganizeFromString: '(''initialize release'' #initialize #release)(''accessing'' #addClient: #addClient:at: #addClient:at:loop: #addClient:in: #addClient:in:loop: #addClient:loop: #addTimer: #addTimer:interval: #clientNamed: #clients #clock #delay #delay: #dontWait #isRunning #removeClient: #removeClientNamed: #removeTimer: #removeTimerNamed: #resetClock #timerNamed: #timers #wait)(''updating'' #update:)(''running'' #callNextAppointment #flush #interrupt #processEvent:at: #run #run:)'</do-it><do-it>Siren.PortModel reorganizeFromString: '(''initialize-release'' #initialize)(''mutex support'' #critical:)(''accessing'' #device #device: #in #in: #name #name: #out #out: #status #status:)'</do-it><do-it>Siren.PortModel reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #device #device: #in #in: #name #name: #out #out: #status #status:)(''mutex support'' #critical:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions--transport'' #forward #play #record #rewind #stop)(''initialize release'' #initialize #release)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''updating'' #executeAutoSave #update:with:from:)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions--transport'' #forward #play #record #rewind #stop)(''initialize release'' #initialize #release)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''updating'' #executeAutoSave #update:with:from:)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions--transport'' #forward #play #record #rewind #stop)(''initialize release'' #initialize #release)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''initialize release'' #initialize #release)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''initialize release'' #initialize #release)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''initialize release'' #initialize #release)(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''initialize release'' #initialize #release)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''initialize release'' #initialize #release)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''interface opening'' #postOpenWith:)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''initialize release'' #initialize #release)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''interface opening'' #postOpenWith:)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''initialize release'' #initialize #release)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''interface opening'' #postOpenWith:)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''updating'' #executeAutoSave #update:with:from:)'</do-it><do-it>Siren.AbstractEvent reorganizeFromString: '(''accessing'' #, #date #date: #inspect #name #open #species #version #version:)(''comparing'' #=)(''testing'' #isEvent #isSound)(''private'' #propCheck)(''initialize-release'' #initialize #release)(''scheduling'' #scheduleOn:)(''printing'' #display:field:on: #displayField:on: #printOn: #storeOn: #templateFields)(''properties'' #at: #at:ifAbsent: #at:put: #doesNotUnderstand: #hasProperty: #properties #respondsTo:)'</do-it><do-it>Siren.AbstractEvent reorganizeFromString: '(''initialize-release'' #initialize #release)(''accessing'' #, #date #date: #inspect #name #open #species #version #version:)(''comparing'' #=)(''testing'' #isEvent #isSound)(''private'' #propCheck)(''scheduling'' #scheduleOn:)(''printing'' #display:field:on: #displayField:on: #printOn: #storeOn: #templateFields)(''properties'' #at: #at:ifAbsent: #at:put: #doesNotUnderstand: #hasProperty: #properties #respondsTo:)'</do-it><do-it>Siren.AbstractEvent reorganizeFromString: '(''initialize-release'' #initialize #release)(''accessing'' #, #date #date: #inspect #name #open #species #version #version:)(''properties'' #at: #at:ifAbsent: #at:put: #doesNotUnderstand: #hasProperty: #properties #respondsTo:)(''comparing'' #=)(''testing'' #isEvent #isSound)(''private'' #propCheck)(''scheduling'' #scheduleOn:)(''printing'' #display:field:on: #displayField:on: #printOn: #storeOn: #templateFields)'</do-it><do-it>Siren.AbstractEvent reorganizeFromString: '(''initialize-release'' #initialize #release)(''accessing'' #, #date #date: #inspect #name #open #species #version #version:)(''properties'' #at: #at:ifAbsent: #at:put: #doesNotUnderstand: #hasProperty: #properties #respondsTo:)(''comparing'' #=)(''printing'' #display:field:on: #displayField:on: #printOn: #storeOn: #templateFields)(''testing'' #isEvent #isSound)(''private'' #propCheck)(''scheduling'' #scheduleOn:)'</do-it><do-it>Siren.AbstractEvent reorganizeFromString: '(''initialize-release'' #initialize #release)(''accessing'' #, #date #date: #inspect #name #open #species #version #version:)(''properties'' #at: #at:ifAbsent: #at:put: #doesNotUnderstand: #hasProperty: #properties #respondsTo:)(''comparing'' #=)(''testing'' #isEvent #isSound)(''printing'' #display:field:on: #displayField:on: #printOn: #storeOn: #templateFields)(''private'' #propCheck)(''scheduling'' #scheduleOn:)'</do-it><do-it>Siren.AbstractEvent reorganizeFromString: '(''initialize-release'' #initialize #release)(''accessing'' #, #date #date: #inspect #name #open #species #version #version:)(''properties'' #at: #at:ifAbsent: #at:put: #doesNotUnderstand: #hasProperty: #properties #respondsTo:)(''comparing'' #=)(''testing'' #isEvent #isSound)(''printing'' #display:field:on: #displayField:on: #printOn: #storeOn: #templateFields)(''scheduling'' #scheduleOn:)(''private'' #propCheck)'</do-it><do-it>Siren.ActionEvent reorganizeFromString: '(''accessing'' #action #action:)(''scheduling'' #play #playAt:)'</do-it><do-it>Siren.DurationEvent reorganizeFromString: '(''accessing'' #ampl #dur #dur: #duration #duration: #index: #order #order: #pitch #scaleDuration: #scaleDurationBy: #voice #voice:)(''comparing'' #=)(''scheduling'' #isActive #nextTime: #play #playAt: #playOn:at: #reset #scheduleAt:)(''printing'' #printOn: #storeOn:)(''initialize-release'' #initialize)'</do-it><do-it>Siren.DurationEvent reorganizeFromString: '(''accessing'' #ampl #dur #dur: #duration #duration: #index: #order #order: #pitch #scaleDuration: #scaleDurationBy: #voice #voice:)(''initialize-release'' #initialize)(''comparing'' #=)(''scheduling'' #isActive #nextTime: #play #playAt: #playOn:at: #reset #scheduleAt:)(''printing'' #printOn: #storeOn:)'</do-it><do-it>Siren.MusicEvent reorganizeFromString: '(''accessing'' #ampl #ampl: #amplitude #amplitude: #loudness #loudness: #pitch #pitch: #voice #voice:)(''comparing'' #=)(''scheduling'' #playOn:at:)(''printing'' #printOn: #printTerseOn: #printVerboseOn: #readDataFrom:size: #storeDataOn: #storeOn:)(''processing'' #transposeBy:)'</do-it><do-it>Siren.EventModifier reorganizeFromString: '(''accessing'' #function #function: #index #index: #scale #scale: #selector #selector: #start #start: #stop #stop:)(''application'' #applyTo: #valueIn:at:)'</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 25, 2020' '1:11:25 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 1:11:25 PM on May 25, 2020."</do-it><do-it>SimpleWorkspace openSystemWorkspace.</do-it><do-it>SimpleWorkspace openInstallationWorkspace.</do-it><do-it>self openGettingStartedWorkspace.</do-it><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := ((ColorValue lightYellow blendWith: ColorValue white) 				blendWith: ColorValue white) "blendWith: ColorValue veryLightGray".	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: (background blendWith: ColorValue gray);			matchAt: SymbolicPaint inactiveBackground put: ColorValue red;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray	].	self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.	self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue white;		matchAt: SymbolicPaint selectionBackground put: ColorValue black</body></methods><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := ((ColorValue lightYellow blendWith: ColorValue white) 				blendWith: ColorValue white) "blendWith: ColorValue veryLightGray".	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: (background blendWith: ColorValue gray);			matchAt: SymbolicPaint inactiveBackground put: ColorValue red;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray	].	self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.	self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue red;		matchAt: SymbolicPaint selectionBackground put: ColorValue black</body></methods><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := ((ColorValue lightYellow blendWith: ColorValue white) 				)"blendWith: ColorValue white) blendWith: ColorValue veryLightGray".	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: (background blendWith: ColorValue gray);			matchAt: SymbolicPaint inactiveBackground put: ColorValue red;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray	].	self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.	self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue red;		matchAt: SymbolicPaint selectionBackground put: ColorValue black</body></methods><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := ((ColorValue lightYellow blendWith: ColorValue white) 				blendWith: ColorValue white) "blendWith: ColorValue veryLightGray".	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: (background blendWith: ColorValue gray);			matchAt: SymbolicPaint inactiveBackground put: ColorValue red;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray	].	self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.	self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue red;		matchAt: SymbolicPaint selectionBackground put: ColorValue black</body></methods><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><methods><class-id>UI.WidgetPolicy class</class-id> <category>private-initializing</category><body package="UIBuilder-Support" selector="initializeDefaultGenericColors">initializeDefaultGenericColors	"	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore "	| background |	background := ((ColorValue lightYellow blendWith: ColorValue white) 				blendWith: ColorValue white) "blendWith: ColorValue veryLightGray".	self allPreferencesDo: [ :preferences | 		preferences			matchAt: SymbolicPaint border put: ColorValue lightGray;			matchAt: SymbolicPaint foreground put: ColorValue black;			matchAt: SymbolicPaint background put: background;			matchAt: SymbolicPaint selectionForeground put: ColorValue black;			matchAt: SymbolicPaint selectionBackground put: (background blendWith: ColorValue gray);			matchAt: SymbolicPaint inactiveBackground put: ColorValue red;			matchAt: SymbolicPaint inactiveForeground put: ColorValue gray;			matchAt: SymbolicPaint inactiveSelectionBackground put: ColorValue lightGray;			matchAt: SymbolicPaint hilite put: preferences backgroundColor asHiliteColor;			matchAt: SymbolicPaint shadow put: preferences backgroundColor asShadowColor;			matchAt: SymbolicPaint separator put: ColorValue gray;			matchAt: SymbolicPaint traversalHilite put: ColorValue gray].		self defaultGrayWidgetColors		matchAt: SymbolicPaint selectionBackground put: ColorValue lightGray.			self defaultMonochromeWidgetColors		matchAt: SymbolicPaint selectionForeground put: ColorValue white;		matchAt: SymbolicPaint selectionBackground put: ColorValue black</body></methods><do-it>	WidgetPolicy initialize.		WidgetPolicy subclasses do: [ :class | class initialize].		Screen default flushPaintPreferencesCache.		ScheduledControllers restore </do-it><methods><class-id>Tools.Workbook class</class-id> <category>interface specs</category><body package="Tools-Workspace" selector="windowSpecList">windowSpecList	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecList"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Workspace 				#defaultString: 'Workspace' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 250 100 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 474 368 1024 768 ) 			#flags: 4 			#menu: #menuBarHolder 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -25 1 ) 					#name: #pages 					#model: #pageHolder 					#tabable: true 					#labels: #() ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -24 1 -41 1 0 1 )					#name: #pageExplanation 					#model: #pageExplanationHolder 					#tabable: false 					#helpText: #(#{Kernel.UserMessage} #key: #ExplainCurrentPage #defaultString: 'Explanation of the current page' #catalogID: #labels) 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 -24 1 0 1 0 1 ) 					#name: #importSummary 					#model: #importSummaryHolder 					#tabable: false 					#helpText: #(#{Kernel.UserMessage} #key: #NamespacesImportedHere #defaultString: 'Namespaces imported by this workspace' #catalogID: #labels) 					#isReadOnly: true ) ) ) )</body></methods><do-it>Tools.UIPainter new openOnClass: self andSelector: #windowSpecList</do-it><methods><class-id>Tools.Workbook</class-id> <category>private-pages</category><body package="Tools-Workspace" selector="installPage:">installPage: aWorkspacePage	lastInstalledPage := aWorkspacePage.	aWorkspacePage builder: nil.	self halt.	self tabControl		client: aWorkspacePage		spec: #windowSpec		builder: builder newSubBuilder.	self updatePage.	aWorkspacePage refresh</body></methods><methods><class-id>Tools.Workbook</class-id> <category>private-pages</category><body package="Tools-Workspace" selector="installPage:">installPage: aWorkspacePage	lastInstalledPage := aWorkspacePage.	aWorkspacePage builder: nil.	self tabControl		client: aWorkspacePage		spec: #windowSpec		builder: builder newSubBuilder.	self updatePage.	aWorkspacePage refresh</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'May 25, 2020' '1:36:56 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 1:36:56 PM on May 25, 2020."</do-it><do-it>'/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename contentsOfEntireFile</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream binary.	w1 := true.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | s1 s2 |		f1 through: $, .		s1 := f1 through: $, .		f2 through: $, .		s2 := f2 through: $, .self halt]	</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1 ifTrue: [out nextPutAll: f1, ', ']			ifFalse: [out nextPutAll: f2, ', '].		cnt := cnt +1.		self halt]</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1 ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		self halt]</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		self halt]</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		self halt]</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd and: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '4:44:51 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 4:44:51 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[[f1 atEnd or: [f2 atEnd]] or: [cnt &gt; 8000]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '4:48:39 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 4:48:39 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[(f1 atEnd or: [f2 atEnd]) or: [cnt &gt; 8000]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '4:50:28 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 4:50:28 PM on July 12, 2020."</do-it><do-it>SirenUtility egcProcessing</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[(f1 atEnd or: [f2 atEnd]) or: []] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '4:51:34 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 4:51:34 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 through: $, .		v1 := f1 upTo: $, .		k2 := f2 through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '4:51:52 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 4:51:52 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false].					Transcript show: cnt printString; cr]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true].					Transcript show: cnt printString; cr].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>k1 first == $1</do-it><do-it>k1 first</do-it><do-it>k2 first == $1</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '4:56:27 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 4:56:27 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.dat' asFilename writeStream.	w1 := true.	cnt := 1.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [out nextPutAll: v1, ', ']			ifFalse: [out nextPutAll: v2, ', '].		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it>	f1 close.	f2 close.	out close.</do-it><do-it>	f1 close.	f2 close.	out close.</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream.	w1 := true.	cnt := 1.	Transcript clear.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2].		out nextPutAll: fval, ', '.		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream.	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream.	w1 := true.	cnt := 1.	Transcript clear.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2].		out nextPutAll: fval, ', '.		cnt := cnt +1.		cnt &gt; 8000 ifTrue: [self halt]].	f1 close.	f2 close.	out close.	Transcript show: 'End at line ', cnt printString; cr</body></methods><do-it> '0.1' asNumber </do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1.	Transcript clear.	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: (fval asNumber * 16384) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd.</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 first == $1)				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 first == $1)				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: (fval asNumber * 16384) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '5:21:27 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 5:21:27 PM on July 12, 2020."</do-it><do-it>f1 atEnd</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: (fval asNumber * 16384) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: (fval asNumber * 16384) asInteger."		cnt := cnt +1.""		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: (fval asNumber * 16384) asInteger."		cnt := cnt +1.""		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '5:24:08 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 5:24:08 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: (fval asNumber * 16384) asInteger."		cnt := cnt +1.""		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd arr |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := OrderedCollection new.	w1 := true.	cnt := 1."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out addLast: fval asNumber."		cnt := cnt +1.""		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a scaled int sample array"	arr := Array new: out size.	1 to: out size do:		[ :j | arr at: j put: ((out at: j) * 16384) asInteger]."Create a snd file"	snd := SampledSound fromData: arr rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>Filename separator</do-it><do-it>fil first == Filename separator</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>file support</category><body package="Siren" selector="findFile:">findFile: fil	"Try to locate the requested file in the data directories, being smart about s7 files"	"SirenUtility findFile: 'b.snd'"	"SirenUtility findFile: '1.1a.aiff'"	| nam ans base s7 |	fil asFilename exists ifTrue: [^fil asFilename asAbsoluteFilename asString].	fil first == Filename separator ifTrue: [^fil].	DataDir ifNil: [^fil].	DataDir isString		ifTrue: [nam := (DataDir, Filename separatorString, fil).			nam asFilename exists ifTrue: [^nam]]		ifFalse: [DataDir do:			[ :dir |			ans := self findFile: fil in: dir.			ans isEmpty ifFalse: [^ans]]].	((fil findString: '.s7' startingAt: 1) = 0) ifFalse: [^nil].	(fil includes: $.) ifTrue:							"if not found, look for an s7 folder"		[base := fil asFilename base asString.		s7 := base, 's7'.		s7 := self findFile: s7.		s7 ifNotNil:			[nam := (s7, Filename separatorString, fil).			nam asFilename exists ifTrue: [^nam]].		base := base copyFrom: 1 to: base size - 1.		"try again removing the next-to-last suffix"		s7 := base asFilename base asString, 's7'.		s7 := self findFile: s7.		s7 ifNotNil:			[nam := (s7, Filename separatorString, fil).			nam asFilename exists ifTrue: [^nam]]].	^nil</body></methods><do-it>SirenUtility egcProcessing</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000.	w1 := true.	cnt := 1."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out at: cnt put: (fval asNumber + 0.5 * 32767.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '5:44:14 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 5:44:14 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000.	w1 := true.	cnt := 1."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1]			ifFalse: [fval := v2]."		out nextPutAll: fval, ', '."		out at: cnt put: (fval asNumber + 0.5 * 20000.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd mn mx |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000.	w1 := true.	cnt := 1.	mn := 10000.	mx := 0."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		out at: cnt put: (fval + 0.5 * 20000.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr.	Transcript show: 'Range: ', mn printString, ' - ', mx printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '5:48:39 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 5:48:39 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd mn mx |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000.	w1 := true.	cnt := 1.	mn := 10000.	mx := 0."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		out at: cnt put: (fval + 1.0 * 16384.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr.	Transcript show: 'Range: ', mn printString, ' - ', mx printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd mn mx |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000.	w1 := true.	cnt := 1.	mn := 10000.	mx := 0."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		out at: cnt put: (fval + 1.0 * 10000.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr.	Transcript show: 'Range: ', mn printString, ' - ', mx printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>Array new: 1500000 withAll: 0.0.</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd mn mx |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000 withAll: 16384.	w1 := true.	cnt := 1.	mn := 10000.	mx := 0."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		out at: cnt put: (fval + 1.0 * 10000.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; cr.	Transcript show: 'Range: ', mn printString, ' - ', mx printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>SirenUtility egcProcessing</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 out w1 cnt snd mn mx |"Open the files"	f1 := '/Users/stp/Desktop/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	out := Array new: 1500000 withAll: 16384.	w1 := true.	cnt := 1.	mn := 100000.	mx := 0."	Transcript clear.""Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, .				w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false."					Transcript show: cnt printString; cr"]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true."					Transcript show: cnt printString; cr"]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		out at: cnt put: (fval + 1.0 * 10000.0) asInteger.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; tab; show: 'Range: ', mn printString, ' - ', mx printString; cr."Create a snd file"	snd := SampledSound fromData: out rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ecg.aiff') saveSound: snd</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '5:55:17 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 5:55:17 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 arr1 arr2 w1 cnt snd mn mx sum |"Open the files"	f1 := '/Users/stp/Desktop/ECG/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	arr1 := Array new: 1500000 withAll: 0.0.	w1 := true.	cnt := 1.	mn := 100000.	mx := 0.	sum := 0.0.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, ."Switch between files"		w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		sum := sum + fval.		arr1 at: cnt put: fval.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; tab; show: 'Range: ', mn printString, ' - ', mx printString; cr."Normalize"	sum := sum / cnt asFloat.	arr2 := Array new: cnt withAll: 0.	1 to: cnt do:		[ : j |		arr2 at: j put: (((arr1 at: j) + sum + 1.0 * 10000.0) asInteger)]."Create a snd file"	snd := SampledSound fromData: arr2 rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ECG/ecg2.aiff') saveSound: snd</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '8:08:33 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 8:08:33 PM on July 12, 2020."</do-it><do-it>SirenUtility egcProcessing</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 arr1 arr2 w1 cnt snd mn mx sum |"Open the files"	f1 := '/Users/stp/Desktop/ECG/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	arr1 := Array new: 1500000 withAll: 0.0.	w1 := true.	cnt := 1.	mn := 100000.	mx := 0.	sum := 0.0.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, ."Switch between files"		w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		sum := sum + fval.		arr1 at: cnt put: fval.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; tab; show: 'Range: ', mn printString, ' - ', mx printString; cr."Normalize"	sum := sum / cnt asFloat.	arr2 := Array new: cnt withAll: 0.	1 to: cnt do:		[ : j |		arr2 at: j put: (((arr1 at: j) - sum + 1.0 * 10000.0) asInteger)]."Create a snd file"	snd := SampledSound fromData: arr2 rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ECG/ecg2.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 arr1 arr2 w1 cnt snd mn mx sum |"Open the files"	f1 := '/Users/stp/Desktop/ECG/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	arr1 := Array new: 1500000 withAll: 0.0.	w1 := true.	cnt := 1.	mn := 100000.	mx := 0.	sum := 0.0.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, ."Switch between files"		w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		sum := sum + fval.		arr1 at: cnt put: fval.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; tab; show: 'Range: ', mn printString, ' - ', mx printString; cr."Normalize"	sum := sum / cnt asFloat.	arr2 := Array new: cnt withAll: 0.	1 to: cnt do:		[ : j |		arr2 at: j put: (((arr1 at: j) - sum + 1.0 * 10000.0) asInteger)]."Create a snd file"	snd := SampledSound fromData: arr2 rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ECG/ecg2.aiff') saveSound: snd</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcProcessing">egcProcessing	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 arr1 arr2 w1 cnt snd mn mx sum |"Open the files"	f1 := '/Users/stp/Desktop/ECG/North Sympathetic ECG 1.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/North Parasympathetic ECG 1.txt' asFilename readStream."	out := '/Users/stp/Desktop/NorthMerged.txt' asFilename writeStream."	arr1 := Array new: 1500000 withAll: 0.0.	w1 := true.	cnt := 1.	mn := 100000.	mx := 0.	sum := 0.0.	Transcript clear."Loop over the files"	[f1 atEnd or: [f2 atEnd]] whileFalse:		[ | k1 k2 v1 v2 fval |		k1 := f1 skipSeparators; through: $, .		v1 := f1 upTo: $, .		k2 := f2 skipSeparators; through: $, .		v2 := f2 upTo: $, ."Switch between files"		w1	ifTrue: [(k1 size &gt; 0 and: [k1 first == $1])				ifFalse: [w1 := false.					Transcript show: cnt printString; cr]]			ifFalse: [(k2 size &gt; 0 and: [k2 first == $1])				ifFalse: [w1 := true.					Transcript show: cnt printString; cr]].		w1	ifTrue: [fval := v1 asNumber]			ifFalse: [fval := v2 asNumber]."		out nextPutAll: fval, ', '."		(fval &lt; mn) ifTrue: [mn := fval].		(fval &gt; mx) ifTrue: [mx := fval].		sum := sum + fval.		arr1 at: cnt put: fval.		cnt := cnt +1."		cnt &gt; 8000 ifTrue: [self halt]"].	f1 close.	f2 close.	Transcript show: 'End at line ', cnt printString; tab; show: 'Range: ', mn printString, ' - ', mx printString; cr."Normalize"	sum := sum / cnt asFloat.	arr2 := Array new: cnt withAll: 0.	1 to: cnt do:		[ : j |		arr2 at: j put: (((arr1 at: j) - sum + 1.0 * 10000.0) asInteger)]."Create a snd file"	snd := SampledSound fromData: arr2 rate: 44100 channels: 1 format: #lin16Bit.	(SoundFile named: '/Users/stp/Desktop/ECG/ecg3.aiff') saveSound: snd</body></methods><do-it>SirenUtility egcProcessing</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 12, 2020' '8:16:38 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 8:16:38 PM on July 12, 2020."</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcMarkers">egcMarkers	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcProcessing"	| f1 f2 m1 m2 cnt |"Open the files"	f1 := '/Users/stp/Desktop/ECG/markers.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/m2.txt' asFilename writeStream.	f2 nextPutAll: 'Marker file version: 1Time format: Time'; cr.	cnt := 1."Loop over the files"	m1 := f1 upTo: Character cr.	[f1 atEnd] whileFalse:		[ | v1 v2 |		m2 := f1 skipSeparators; upTo: Character cr.		v1 := m1 asNumber / 44100.0.		v2 := m2 asNumber / 44100.0.		f2 nextPutAll: 'Region ', cnt printString, '		00:00:' , v1 printString, '		00:00:' , v2 printString; cr.		cnt := cnt +1].	f1 close.	f2 close.</body></methods><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcMarkers">egcMarkers	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcMarkers"	| f1 f2 m1 m2 cnt |"Open the files"	f1 := '/Users/stp/Desktop/ECG/markers.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/m2.txt' asFilename writeStream.	f2 nextPutAll: 'Marker file version: 1Time format: Time'; cr.	cnt := 1."Loop over the files"	m1 := f1 upTo: Character cr.	[f1 atEnd] whileFalse:		[ | v1 v2 |		m2 := f1 skipSeparators; upTo: Character cr.		v1 := m1 asNumber / 44100.0.		v2 := m2 asNumber / 44100.0.		f2 nextPutAll: 'Region ', cnt printString, '		00:00:' , v1 printString, '		00:00:' , v2 printString; cr.		cnt := cnt +1].	f1 close.	f2 close.</body></methods><do-it>SirenUtility egcMarkers</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcMarkers">egcMarkers	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcMarkers"	| f1 f2 m1 m2 cnt |"Open the files"	f1 := '/Users/stp/Desktop/ECG/markers.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/m2.txt' asFilename writeStream.	f2 nextPutAll: 'Marker file version: 1Time format: Time'; cr.	cnt := 1."Loop over the files"	m1 := f1 upTo: Character cr.	[f1 atEnd] whileFalse:		[ | v1 v2 |		m2 := f1 skipSeparators; upTo: Character cr.		v1 := m1 asNumber / 44100.0.		v2 := m2 asNumber / 44100.0.		f2 nextPutAll: 'Region ', cnt printString, '		00:00:' , v1 printString, '		00:00:' , v2 printString; cr.		cnt := cnt +1.		m1 := f1 skipSeparators; upTo: Character cr].	f1 close.	f2 close.</body></methods><do-it>SirenUtility egcMarkers</do-it><methods><class-id>Siren.SirenUtility class</class-id> <category>scripts</category><body package="Siren" selector="egcMarkers">egcMarkers	"Load and merge the 2 ECG files; save as a raw data file."	"SirenUtility egcMarkers"	| f1 f2 m1 m2 cnt |"Open the files"	f1 := '/Users/stp/Desktop/ECG/markers.txt' asFilename readStream.	f2 := '/Users/stp/Desktop/ECG/m2.txt' asFilename writeStream.	f2 nextPutAll: 'Marker file version: 1Time format: Time'; cr.	cnt := 1."Loop over the files"	m1 := f1 upTo: Character cr.	[f1 atEnd] whileFalse:		[ | v1 v2 |		m2 := f1 skipSeparators; upTo: Character cr.		v1 := m1 asNumber / 44100.0.		v2 := m2 asNumber / 44100.0.		f2 nextPutAll: 'Region ', cnt printString, '	00:00:' , v1 printString, '	00:00:' , v2 printString; cr.		cnt := cnt +1.		m1 := f1 skipSeparators; upTo: Character cr].	f1 close.	f2 close.</body></methods><do-it>SirenUtility egcMarkers</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '12:41:30 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 12:41:30 AM on July 13, 2020."</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: #((1 to: 4) (1 to: 4))"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: #((1 to: 4) (1 to: 4))"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: #(1 to: 4)"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><methods><class-id>Siren.DynamicCloud</class-id> <category>playing</category><body package="Siren" selector="eventList">eventList	"make the cloud's events--assume that the receiver's pitch, loudness and durations are actually ARRAYS of two intervals (for the start and end ranges)"	| pattern rand number length start percent pRange p1 p2 p3 p4 		amplRange a1 a2 a3 a4 v1 v2 v3 v4 vRange |	pattern := EventList new.	rand := Random new.	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	(self pitch value isMemberOf: Array)		ifTrue: [pRange := self pitch value first.			p1 := self pitch value first first.			p2 := self pitch value first last.			p3 := self pitch value last first - p1.			p4 := self pitch value last last - p2]		ifFalse: [pRange := self pitch value].	(self loudness value isMemberOf: Array)		ifTrue: [amplRange := self loudness value first.			a1 := self loudness value first first.			a2 := self loudness value first last.			a3 := self loudness value last first - a1.			a4 := self loudness value last last - a2]		ifFalse: [amplRange := self loudness value].	(self voice isMemberOf: Array)		ifTrue: [vRange := self voice first.			v1 := self voice first first.			v2 := self voice first last.			v3 := self voice last first - v1.			v4 := self voice last last - v2]		ifFalse: [vRange := self voice].self halt.	1 to: number truncated do:		[ :count |		pattern add: (MusicEvent 			dur: (length * 2 + (length * rand next) rounded)			pitch: ((pRange first rounded) + 					((rand next * (pRange last - pRange first)) rounded))			ampl: ((amplRange first rounded) + 					((rand next * (amplRange last - amplRange first)) rounded))			voice: (self voice == nil 						ifTrue: [nil] 						ifFalse: [(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)]))			at: start.		start := start + length.	percent := count / number.	(self pitch value isMemberOf: Array)		ifTrue: [pRange := p1 + (p3 * percent) to: p2 + (p4 * percent)].	(self loudness value isMemberOf: Array)		ifTrue: [amplRange := a1 + (a3 * percent) to: a2 + (a4 * percent)].	(self voice isMemberOf: Array)		ifTrue: [vRange := v1 + (v3 * percent) to: v2 + (v4 * percent)]].	^pattern</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><do-it>(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)</do-it><do-it>(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)</do-it><do-it>(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)</do-it><do-it>(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)</do-it><methods><class-id>Siren.DynamicCloud</class-id> <category>playing</category><body package="Siren" selector="eventList">eventList	"make the cloud's events--assume that the receiver's pitch, loudness and durations are actually ARRAYS of two intervals (for the start and end ranges)"	| pattern rand number length start percent pRange p1 p2 p3 p4 		amplRange a1 a2 a3 a4 v1 v2 v3 v4 vRange |	pattern := EventList new.	rand := Random new.	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	(self pitch value isMemberOf: Array)		ifTrue: [pRange := self pitch value first.			p1 := self pitch value first first.			p2 := self pitch value first last.			p3 := self pitch value last first - p1.			p4 := self pitch value last last - p2]		ifFalse: [pRange := self pitch value].	(self loudness value isMemberOf: Array)		ifTrue: [amplRange := self loudness value first.			a1 := self loudness value first first.			a2 := self loudness value first last.			a3 := self loudness value last first - a1.			a4 := self loudness value last last - a2]		ifFalse: [amplRange := self loudness value].	(self voice isMemberOf: Array)		ifTrue: [vRange := self voice first.			v1 := self voice first first.			v2 := self voice first last.			v3 := self voice last first - v1.			v4 := self voice last last - v2]		ifFalse: [vRange := self voice].	1 to: number truncated do:		[ :count |		pattern add: (MusicEvent 			dur: (length * 2 + (length * rand next) rounded)			pitch: ((pRange first rounded) + 					((rand next * (pRange last - pRange first)) rounded))			ampl: ((amplRange first rounded) + 					((rand next * (amplRange last - amplRange first)) rounded))			voice: (self voice == nil 						ifTrue: [nil] 						ifFalse: [(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)]))			at: start.		start := start + length.	percent := count / number.	(self pitch value isMemberOf: Array)		ifTrue: [pRange := p1 + (p3 * percent) to: p2 + (p4 * percent)].	(self loudness value isMemberOf: Array)		ifTrue: [amplRange := a1 + (a3 * percent) to: a2 + (a4 * percent)].	(self voice isMemberOf: Array)		ifTrue: [vRange := v1 + (v3 * percent) to: v2 + (v4 * percent)]].	^pattern</body></methods><do-it>(DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 8) eventList</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>anEvent</do-it><do-it>self mapVoice: anEvent voice.</do-it><do-it> self mapVoice: anEvent voice.</do-it><do-it>channel isInteger</do-it><do-it>Random new next</do-it><do-it>(channel first rounded) + 					((Random new next * (channel last - channel first)) rounded)</do-it><do-it>(channel first rounded) + 					((Random new next * (channel last - channel first)) rounded)</do-it><methods><class-id>Siren.MIDIVoice</class-id> <category>accessing</category><body package="Siren" selector="number">number	"Answer my channel or icon number"	^channel isInteger		ifTrue: [channel]		ifFalse: [^(channel first rounded) + 				((Random new next * (channel last - channel first)) rounded)]"	| n |	n := Number readFrom: (ReadStream on: name).	n := Number readFrom: (ReadStream on: stream).	n = 0 ifTrue: [^1].	^n"</body></methods><do-it> self mapVoice: anEvent voice.</do-it><do-it>self mapVoice: anEvent voice.</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '6:54:15 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 6:54:15 PM on July 13, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '6:55:14 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 6:55:14 PM on July 13, 2020."</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 1 "(1 to: 4)")</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 1 "(1 to: 4)")</do-it><do-it>singleton := MIDIVoice on: (MIDIDevice on: MIDIPort default)</do-it><do-it>(MIDIVoice default) channel: 1 "(1 to: 4)"</do-it><do-it>EventList scaleFrom: 48 to: 72 in: 1.5</do-it><do-it>self playOn: ((MIDIVoice default) channel: 1)</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><methods><class-id>Siren.MIDIVoice</class-id> <category>accessing</category><body package="Siren" selector="number">number	"Answer my channel or icon number"	^channel isInteger		ifTrue: [channel]		ifFalse: [^(channel first rounded) + 				((Random new next * (channel last - channel first)) rounded)]"	| n |	n := Number readFrom: (ReadStream on: name).	n := Number readFrom: (ReadStream on: stream).	n = 0 ifTrue: [^1].	^n"</body></methods><methods><class-id>Siren.MIDIVoice</class-id> <category>accessing</category><body package="Siren" selector="number">number	"Answer my channel or icon number"self halt.	^channel isInteger		ifTrue: [channel]		ifFalse: [^(channel first rounded) + 				((Random new next * (channel last - channel first)) rounded)]"	| n |	n := Number readFrom: (ReadStream on: name).	n := Number readFrom: (ReadStream on: stream).	n = 0 ifTrue: [^1].	^n"</body></methods><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>EventList scaleFrom: 48 to: 72 in: 1.5</do-it><do-it>self playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><methods><class-id>Siren.MusicEvent</class-id> <category>scheduling</category><body package="Siren" selector="playOn:at:">playOn: aVoice at: aTime	"Play the receiver on the voice then."self halt.	aVoice == nil		ifTrue: [^Voice default playEvent: self at: aTime].	aVoice isVoice		ifTrue: [aVoice playEvent: self at: aTime].	(SirenSession voices includesKey: aVoice)			ifTrue: [^(SirenSession voices at: aVoice) playEvent: self at: aTime].	aVoice isInteger			ifTrue: [Voice default playEvent: self at: aTime]</body></methods><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>	theEvent := self events at: index.</do-it><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy. self halt.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self pitch))].	(self at: #loudness) == nil 			"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)].	^anE</body></methods><do-it>	theEvent := self events at: index.</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy. self halt.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)]		ifTrue: [(self tempo) == nil			ifFalse: [aTime := aTime * ((self tempo) at: aTime).				anE duration: anE duration * ((self tempo) at: anE duration)]].	(self at: #voice) == nil 			"or have a voice"		ifFalse: [anE voice: (self at: #voice)]		ifTrue: [(self voice) == nil			ifFalse: [anE voice: self voice]].	^anE</body></methods><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy. self halt.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)]		ifTrue: [(self tempo) == nil			ifFalse: [aTime := aTime * ((self tempo) at: aTime).				anE duration: anE duration * ((self tempo) at: anE duration)]].	(self at: #voice) == nil 			"or have a voice"		ifFalse: [anE voice: (self at: #voice)]		ifTrue: [(self voice) == nil			ifFalse: [anE voice: self voice]].	^anE</body></methods><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '7:32:38 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:32:38 PM on July 13, 2020."</do-it><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy. self halt.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)].	(self at: #voice) == nil 			"or have a voice"		ifFalse: [anE voice: (self at: #voice)]		ifTrue: [(self voice) == nil			ifFalse: [anE voice: self voice]].	^anE</body></methods><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)].	(self at: #voice) == nil 			"or have a voice"		ifFalse: [anE voice: (self at: #voice)]		ifTrue: [(self voice) == nil			ifFalse: [anE voice: self voice]].	^anE</body></methods><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '7:38:47 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:38:47 PM on July 13, 2020."</do-it><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)]. self halt.	(self at: #voice) == nil 			"or have a voice"		ifFalse: [anE voice: (self at: #voice)]		ifTrue: [(self voice) == nil			ifFalse: [anE voice: self voice]].	^anE</body></methods><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)]. self halt.	(self at: #voice) == nil 			"or have a voice"		ifFalse: [anE voice: (self at: #voice)]		ifTrue: [(self voice) == nil			ifFalse: [anE voice: self voice]].	^anE</body></methods><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><methods><class-id>Siren.EventList</class-id> <category>private</category><body package="Siren" selector="map:at:">map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self at: #pitch))]		ifTrue: [(self pitch) == nil			ifFalse: [anE pitch: (anE pitch + (self pitch))]].	(self at: #loudness) == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))]		ifTrue: [(self loudness) == nil 			ifFalse: [anE loudness: (anE loudness + (self loudness))]].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)]. 	^anE</body></methods><do-it>Siren.MIDIDevice organization classify: #play:on: under: #'note events'</do-it><do-it>(channel first rounded) + 				((Random new next * (channel last - channel first)) rounded)</do-it><methods><class-id>Siren.MIDIVoice</class-id> <category>accessing</category><body package="Siren" selector="number">number	"Answer my channel or icon number"	^channel isInteger		ifTrue: [channel]		ifFalse: [^(channel first rounded) + 				((Random new next * (channel last - channel first)) rounded)]"	| n |	n := Number readFrom: (ReadStream on: name).	n := Number readFrom: (ReadStream on: stream).	n = 0 ifTrue: [^1].	^n"</body></methods><do-it>MStream</do-it><do-it>MStream nextPutAll: 					aTime value printString, ' ', p printString, ' ', 					d printString,' ', a printString,' ', v printString; cr</do-it><methods><class-id>Siren.MusicEvent</class-id> <category>scheduling</category><body package="Siren" selector="playOn:at:">playOn: aVoice at: aTime	"Play the receiver on the voice then."	aVoice == nil		ifTrue: [^Voice default playEvent: self at: aTime].	aVoice isVoice		ifTrue: [aVoice playEvent: self at: aTime].	(SirenSession voices includesKey: aVoice)			ifTrue: [^(SirenSession voices at: aVoice) playEvent: self at: aTime].	aVoice isInteger			ifTrue: [Voice default playEvent: self at: aTime]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '7:51:44 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:51:44 PM on July 13, 2020."</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>EventList scaleFrom: 48 to: 72 in: 1.5</do-it><methods><class-id>Siren.EventList class</class-id> <category>examples</category><body package="Siren" selector="scaleFrom:to:in:">scaleFrom: start to: stop in: dur	"Answer an event list with a scale."	"(EventList scaleFrom: 48 to: 60 in: 1.5) open"	"(EventList scaleFrom: 36 to: 84 in: 2) play"	| size arr4 ndur |	size := (stop - start) abs.	ndur := (dur / size).	arr4 := Array new: size + 1.	start &gt; stop		ifTrue: [0 to: size do: [ :i | arr4 at: i+1 put: (start - i)]]		ifFalse: [0 to: size do: [ :i | arr4 at: i+1 put: (start + i)]].	^EventList named: EventList nextName  		fromSelectors: #(duration: loudness: pitch:) 		values: (Array with: ndur with: 100 with: arr4)</body></methods><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '7:54:04 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 7:54:04 PM on July 13, 2020."</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: 3)</body></methods><do-it>(DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: (1 to: 4)"			voice: #((0) (0))"			density: 9) eventList</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (80 to: 100))			voice: nil			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: nil			density: 9) eventList)].	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>(DynamicCloud  dur: 6  			pitch: #((22 to: 40) (38 to: 40))			ampl: #((80 to: 100) (60 to: 100))			voice: nil			density: 9) eventList</do-it><methods><class-id>Siren.EventList</class-id> <category>scheduling</category><body package="Siren" selector="scheduleAt:">scheduleAt: aTime 	"Expand an eventList for the appointment scheduler."	| theEvent |	self events isEmpty ifTrue: [^nil].	index ifNil: 		[index := 1.		startedAt := Time microsecondClock].	index &gt; self events size		ifTrue: [index := nil. ^nil].	theEvent := self events at: index.	theEvent := self map: theEvent at: aTime.	theEvent voice ifNil:		[self halt. theEvent voice: voice].	theEvent play.			"play the next event"	index := index + 1.	index &gt; self events size		ifTrue: [^theEvent duration isNil			ifTrue: [startedAt + duration asUsec value]			ifFalse: [aTime + theEvent duration asUsec value]].	^self nextTime: aTime</body></methods><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><methods><class-id>Siren.EventList</class-id> <category>scheduling</category><body package="Siren" selector="scheduleAt:">scheduleAt: aTime 	"Expand an eventList for the appointment scheduler."	| theEvent |	self events isEmpty ifTrue: [^nil].	index ifNil: 		[index := 1.		startedAt := Time microsecondClock].	index &gt; self events size		ifTrue: [index := nil. ^nil].self halt. 	theEvent := self events at: index.	theEvent := self map: theEvent at: aTime.	theEvent voice ifNil:		[theEvent voice: voice].	theEvent play.			"play the next event"	index := index + 1.	index &gt; self events size		ifTrue: [^theEvent duration isNil			ifTrue: [startedAt + duration asUsec value]			ifFalse: [aTime + theEvent duration asUsec value]].	^self nextTime: aTime</body></methods><methods><class-id>Siren.EventList</class-id> <category>scheduling</category><body package="Siren" selector="playOn:">playOn: aVoice	"Play the event list on the voice by expanding its events"self halt.	voice := aVoice.	self play"	self playOn: aVoice at: Time microsecondClock"</body></methods><do-it>(MIDIVoice default) channel: (1 to: 4)</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((50 to: 64) (78 to: 80))		ampl: #((60 to: 80) (80 to: 100))		voice: nil		density: 8) eventList) .	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((22 to: 40) (38 to: 40))		ampl: #((80 to: 100) (60 to: 100))		voice: nil		density: 9) eventList).	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	"Put up the MIDI test menu and process the results"	| lis sel |	sel := (SirenSession midiTestMenu) startUp."Process results"	sel ifNil: [^self].	sel == 0 ifTrue: [^self]."Input tests"	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop]."Output tests use different channels; edit to taste"	sel == 3 ifTrue: [^MIDIPort testANote]. 			"uses channel 1"	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 4)].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)]."Cloud is last test"	lis := EventList newAnonymous.	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((50 to: 64) (78 to: 80))		ampl: #((60 to: 80) (30 to: 50))		voice: nil		density: 8) eventList).	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((22 to: 48) (48 to: 50))		ampl: #((30 to: 60) (60 to: 82))		voice: nil		density: 9) eventList).	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '8:10:18 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 8:10:18 PM on July 13, 2020."</do-it><methods><class-id>Siren.EventList</class-id> <category>scheduling</category><body package="Siren" selector="playOn:">playOn: aVoice	"Play the event list on the voice by expanding its events"	voice := aVoice.	self play"	self playOn: aVoice at: Time microsecondClock"</body></methods><methods><class-id>Siren.EventList</class-id> <category>scheduling</category><body package="Siren" selector="scheduleAt:">scheduleAt: aTime 	"Expand an eventList for the appointment scheduler."	| theEvent |	self events isEmpty ifTrue: [^nil].	index ifNil: 		[index := 1.		startedAt := Time microsecondClock].	index &gt; self events size		ifTrue: [index := nil. ^nil].	theEvent := self events at: index.	theEvent := self map: theEvent at: aTime.	theEvent voice ifNil:		[theEvent voice: voice].	theEvent play.			"play the next event"	index := index + 1.	index &gt; self events size		ifTrue: [^theEvent duration isNil			ifTrue: [startedAt + duration asUsec value]			ifFalse: [aTime + theEvent duration asUsec value]].	^self nextTime: aTime</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	"Put up the MIDI test menu and process the results"	| lis sel |	sel := (SirenSession midiTestMenu) startUp."Process results"	sel ifNil: [^self].	sel == 0 ifTrue: [^self]."Input tests"	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop]."Output tests use different channels; edit to taste"	sel == 3 ifTrue: [^MIDIPort testANote]. 			"uses channel 1"	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 5 ifTrue: [^(Roll rollLen: 2 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)]."Cloud is last test"	lis := EventList newAnonymous.	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((50 to: 64) (78 to: 80))		ampl: #((60 to: 80) (30 to: 50))		voice: nil		density: 8) eventList).	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((22 to: 48) (48 to: 50))		ampl: #((30 to: 60) (60 to: 82))		voice: nil		density: 9) eventList).	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	"Put up the MIDI test menu and process the results"	| lis sel |	sel := (SirenSession midiTestMenu) startUp."Process results"	sel ifNil: [^self].	sel == 0 ifTrue: [^self]."Input tests"	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop]."Output tests use different channels; edit to taste"	sel == 3 ifTrue: [^MIDIPort testANote]. 			"uses channel 1"	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 5 ifTrue: [^(Roll rollLen: 4 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)]."Cloud is last test"	lis := EventList newAnonymous.	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((50 to: 64) (78 to: 80))		ampl: #((60 to: 80) (30 to: 50))		voice: nil		density: 8) eventList).	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((22 to: 48) (48 to: 50))		ampl: #((30 to: 60) (60 to: 82))		voice: nil		density: 9) eventList).	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '11:28:09 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 11:28:09 PM on July 13, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 13, 2020' '11:28:24 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 11:28:24 PM on July 13, 2020."</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDI">testMIDI	"Put up the MIDI test menu and process the results"	| lis sel |	sel := (SirenSession midiTestMenu) startUp."Process results"	sel ifNil: [^self].	sel == 0 ifTrue: [^self]."Input tests"	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop]."Output tests use different channels; edit to taste"	sel == 3 ifTrue: [^MIDIPort testANote]. 			"uses channel 1"	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: 3 "(1 to: 4)")].	sel == 5 ifTrue: [^(Roll rollLen: 4 noteLen: 80 pitch: 60 ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)]."Cloud is last test"	lis := EventList newAnonymous.	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((50 to: 64) (78 to: 80))		ampl: #((60 to: 80) (30 to: 50))		voice: nil		density: 8) eventList).	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((22 to: 48) (48 to: 50))		ampl: #((30 to: 60) (60 to: 82))		voice: nil		density: 9) eventList).	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testMIDIout">testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: ((MIDIVoice default) channel: (1 to: 4))].	sel == 3 ifTrue: [^((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList playOn: ((MIDIVoice default) channel: 3)].	lis := EventList newAnonymous. 	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((50 to: 64) (78 to: 80))		ampl: #((60 to: 80) (80 to: 100))		voice: nil		density: 8) eventList) .	lis addAll: ((DynamicCloud  dur: 6  		pitch: #((22 to: 40) (38 to: 40))		ampl: #((80 to: 100) (60 to: 100))		voice: nil		density: 9) eventList).	lis playOn: ((MIDIVoice default) channel: (1 to: 4))</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '10:12:52 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 10:12:52 AM on July 14, 2020."</do-it><do-it>Tools.UIPainter new openOnClass: self andSelector: #buttonSpec</do-it><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="buttonSpec">buttonSpec	"Tools.UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Player Control' 			#min: #(#{Core.Point} 288 332 ) 			#max: #(#{Core.Point} 288 332 ) 			#bounds: #(#{Graphics.Rectangle} 865 582 1153 914 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 15 0 ) 					#name: #Label7 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 14 0 177 0 35 0 ) 					#name: #start1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #start1 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 14 0 281 0 35 0 ) 					#name: #refresh1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #refresh1 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 47 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 46 0 177 0 67 0 ) 					#name: #start2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #start2 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 46 0 281 0 67 0 ) 					#name: #refresh2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #refresh2 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 80 0 ) 					#name: #Label5 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 79 0 177 0 100 0 ) 					#name: #start3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #start3 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 79 0 281 0 100 0 ) 					#name: #refresh3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #refresh3 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 303 0 ) 					#name: #Label8 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 4' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 302 0 177 0 323 0 ) 					#name: #start10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #start10 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 302 0 281 0 323 0 ) 					#name: #refresh10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #refresh10 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 271 0 ) 					#name: #Label9 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 3' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 270 0 177 0 291 0 ) 					#name: #start9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #start9 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 270 0 281 0 291 0 ) 					#name: #refresh9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #refresh9 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 239 0 ) 					#name: #Label10 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 238 0 177 0 259 0 ) 					#name: #start8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #start8 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 238 0 281 0 259 0 ) 					#name: #refresh8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #refresh8 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 207 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 206 0 177 0 227 0 ) 					#name: #start7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #start7 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 206 0 281 0 227 0 ) 					#name: #refresh7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #refresh7 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 175 0 ) 					#name: #Label2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 174 0 177 0 195 0 ) 					#name: #start6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #start6 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 174 0 281 0 195 0 ) 					#name: #refresh6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #refresh6 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 143 0 ) 					#name: #Label3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 142 0 177 0 163 0 ) 					#name: #start5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #start5 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 142 0 281 0 163 0 ) 					#name: #refresh5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #refresh5 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 110 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 109 0 177 0 130 0 ) 					#name: #start4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #start4 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 109 0 281 0 130 0 ) 					#name: #refresh4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #refresh4 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 19 0 524 0 32 0 ) 					#name: #Slider1 					#model: #volume1 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 243 0 524 0 256 0 ) 					#name: #Slider8 					#model: #volume8 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 211 0 524 0 224 0 ) 					#name: #Slider7 					#model: #volume7 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 179 0 524 0 192 0 ) 					#name: #Slider6 					#model: #volume6 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 147 0 524 0 160 0 ) 					#name: #Slider5 					#model: #volume5 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 115 0 524 0 128 0 ) 					#name: #Slider4 					#model: #volume4 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 83 0 524 0 96 0 ) 					#name: #Slider3 					#model: #volume3 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 51 0 524 0 64 0 ) 					#name: #Slider2 					#model: #volume2 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 275 0 524 0 288 0 ) 					#name: #Slider9 					#model: #volume9 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 307 0 524 0 320 0 ) 					#name: #Slider10 					#model: #volume10 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) ) ) )</body></methods><class><name>ClusterEditor</name><environment>Siren</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mode scale process events tScale numEvents running defaultVoiceClass players playerStates durationList maxPitch minDur minPitch pitchList maxDur pitchRange durRange voiceRange amplRange minAmpl minVoice maxVoice amplList maxAmpl voiceList tempo volume7 volume9 volume8 volume5 volume3 volume4 volume2 volume10 volume6 volume1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicUI-Editors</category><attributes><package>Siren</package></attributes></class><do-it>Siren defineClass: #ClusterEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'mode scale process events tScale numEvents running defaultVoiceClass players playerStates durationList maxPitch minDur minPitch pitchList maxDur pitchRange durRange voiceRange amplRange minAmpl minVoice maxVoice amplList maxAmpl voiceList tempo  volume7 volume9 volume8 volume5 volume3 volume4 volume2 volume10 volume6 volume1 '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume7">volume7	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume7 isNil		ifTrue:			[volume7 := 0 asValue]		ifFalse:			[volume7]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume9">volume9	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume9 isNil		ifTrue:			[volume9 := 0 asValue]		ifFalse:			[volume9]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume8">volume8	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume8 isNil		ifTrue:			[volume8 := 0 asValue]		ifFalse:			[volume8]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume5">volume5	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume5 isNil		ifTrue:			[volume5 := 0 asValue]		ifFalse:			[volume5]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume3">volume3	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume3 isNil		ifTrue:			[volume3 := 0 asValue]		ifFalse:			[volume3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume4">volume4	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume4 isNil		ifTrue:			[volume4 := 0 asValue]		ifFalse:			[volume4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume2">volume2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume2 isNil		ifTrue:			[volume2 := 0 asValue]		ifFalse:			[volume2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume10">volume10	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume10 isNil		ifTrue:			[volume10 := 0 asValue]		ifFalse:			[volume10]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume6">volume6	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume6 isNil		ifTrue:			[volume6 := 0 asValue]		ifFalse:			[volume6]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume1">volume1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume1 isNil		ifTrue:			[volume1 := 0 asValue]		ifFalse:			[volume1]</body></methods><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="buttonSpec">buttonSpec	"Tools.UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Player Control' 			#min: #(#{Core.Point} 543 337 ) 			#max: #(#{Core.Point} 543 337 ) 			#bounds: #(#{Graphics.Rectangle} 864 581 1407 918 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 15 0 ) 					#name: #Label7 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 14 0 177 0 35 0 ) 					#name: #start1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #start1 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 14 0 281 0 35 0 ) 					#name: #refresh1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #refresh1 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 47 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 46 0 177 0 67 0 ) 					#name: #start2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #start2 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 46 0 281 0 67 0 ) 					#name: #refresh2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #refresh2 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 80 0 ) 					#name: #Label5 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 79 0 177 0 100 0 ) 					#name: #start3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #start3 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 79 0 281 0 100 0 ) 					#name: #refresh3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #refresh3 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 303 0 ) 					#name: #Label8 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 4' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 302 0 177 0 323 0 ) 					#name: #start10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #start10 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 302 0 281 0 323 0 ) 					#name: #refresh10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #refresh10 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 271 0 ) 					#name: #Label9 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 3' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 270 0 177 0 291 0 ) 					#name: #start9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #start9 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 270 0 281 0 291 0 ) 					#name: #refresh9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #refresh9 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 239 0 ) 					#name: #Label10 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 238 0 177 0 259 0 ) 					#name: #start8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #start8 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 238 0 281 0 259 0 ) 					#name: #refresh8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #refresh8 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 207 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 206 0 177 0 227 0 ) 					#name: #start7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #start7 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 206 0 281 0 227 0 ) 					#name: #refresh7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #refresh7 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 175 0 ) 					#name: #Label2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 174 0 177 0 195 0 ) 					#name: #start6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #start6 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 174 0 281 0 195 0 ) 					#name: #refresh6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #refresh6 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 143 0 ) 					#name: #Label3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 142 0 177 0 163 0 ) 					#name: #start5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #start5 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 142 0 281 0 163 0 ) 					#name: #refresh5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #refresh5 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 110 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 109 0 177 0 130 0 ) 					#name: #start4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #start4 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 109 0 281 0 130 0 ) 					#name: #refresh4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #refresh4 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 19 0 524 0 32 0 ) 					#name: #Slider1 					#model: #volume1 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 243 0 524 0 256 0 ) 					#name: #Slider8 					#model: #volume8 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 211 0 524 0 224 0 ) 					#name: #Slider7 					#model: #volume7 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 179 0 524 0 192 0 ) 					#name: #Slider6 					#model: #volume6 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 147 0 524 0 160 0 ) 					#name: #Slider5 					#model: #volume5 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 115 0 524 0 128 0 ) 					#name: #Slider4 					#model: #volume4 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 83 0 524 0 96 0 ) 					#name: #Slider3 					#model: #volume3 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 51 0 524 0 64 0 ) 					#name: #Slider2 					#model: #volume2 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 275 0 524 0 288 0 ) 					#name: #Slider9 					#model: #volume9 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 307 0 524 0 320 0 ) 					#name: #Slider10 					#model: #volume10 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) ) ) )</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume1">volume1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume1 isNil		ifTrue:			[volume1 := 0.75 asValue]		ifFalse:			[volume1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume10">volume10	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume10 isNil		ifTrue:			[volume10 := 0.75 asValue]		ifFalse:			[volume10]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume2">volume2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume2 isNil		ifTrue:			[volume2 := 0.75 asValue]		ifFalse:			[volume2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume3">volume3	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume3 isNil		ifTrue:			[volume3 := 0.75 asValue]		ifFalse:			[volume3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume4">volume4	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume4 isNil		ifTrue:			[volume4 := 0.75 asValue]		ifFalse:			[volume4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume5">volume5	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume5 isNil		ifTrue:			[volume5 := 0.75 asValue]		ifFalse:			[volume5]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume6">volume6	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume6 isNil		ifTrue:			[volume6 := 0.75 asValue]		ifFalse:			[volume6]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume7">volume7	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume7 isNil		ifTrue:			[volume7 := 0.75 asValue]		ifFalse:			[volume7]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume8">volume8	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume8 isNil		ifTrue:			[volume8 := 0.75 asValue]		ifFalse:			[volume8]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume9">volume9	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume9 isNil		ifTrue:			[volume9 := 0.75 asValue]		ifFalse:			[volume9]</body></methods><do-it>Tools.UIPainter new openOnClass: self andSelector: #buttonSpec</do-it><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="buttonSpec">buttonSpec	"Tools.UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Player Control' 			#min: #(#{Core.Point} 543 337 ) 			#max: #(#{Core.Point} 543 337 ) 			#bounds: #(#{Graphics.Rectangle} 863 581 1406 918 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5938 5054 5057 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 15 0 ) 					#name: #Label7 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 14 0 177 0 35 0 ) 					#name: #start1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #start1 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 14 0 281 0 35 0 ) 					#name: #refresh1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #refresh1 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 47 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 46 0 177 0 67 0 ) 					#name: #start2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #start2 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 46 0 281 0 67 0 ) 					#name: #refresh2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #refresh2 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 80 0 ) 					#name: #Label5 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 79 0 177 0 100 0 ) 					#name: #start3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #start3 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 79 0 281 0 100 0 ) 					#name: #refresh3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #refresh3 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 303 0 ) 					#name: #Label8 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 4' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 302 0 177 0 323 0 ) 					#name: #start10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #start10 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 302 0 281 0 323 0 ) 					#name: #refresh10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #refresh10 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 271 0 ) 					#name: #Label9 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 3' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 270 0 177 0 291 0 ) 					#name: #start9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #start9 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 270 0 281 0 291 0 ) 					#name: #refresh9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #refresh9 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 239 0 ) 					#name: #Label10 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 238 0 177 0 259 0 ) 					#name: #start8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #start8 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 238 0 281 0 259 0 ) 					#name: #refresh8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #refresh8 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 207 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 206 0 177 0 227 0 ) 					#name: #start7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #start7 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 206 0 281 0 227 0 ) 					#name: #refresh7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #refresh7 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 175 0 ) 					#name: #Label2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 174 0 177 0 195 0 ) 					#name: #start6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #start6 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 174 0 281 0 195 0 ) 					#name: #refresh6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #refresh6 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 143 0 ) 					#name: #Label3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 142 0 177 0 163 0 ) 					#name: #start5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #start5 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 142 0 281 0 163 0 ) 					#name: #refresh5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #refresh5 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 110 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 109 0 177 0 130 0 ) 					#name: #start4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #start4 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 109 0 281 0 130 0 ) 					#name: #refresh4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #refresh4 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 19 0 524 0 32 0 ) 					#name: #Slider1 					#model: #volume1 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 243 0 524 0 256 0 ) 					#name: #Slider8 					#model: #volume8 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 211 0 524 0 224 0 ) 					#name: #Slider7 					#model: #volume7 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 179 0 524 0 192 0 ) 					#name: #Slider6 					#model: #volume6 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 147 0 524 0 160 0 ) 					#name: #Slider5 					#model: #volume5 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 115 0 524 0 128 0 ) 					#name: #Slider4 					#model: #volume4 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 83 0 524 0 96 0 ) 					#name: #Slider3 					#model: #volume3 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 51 0 524 0 64 0 ) 					#name: #Slider2 					#model: #volume2 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 275 0 524 0 288 0 ) 					#name: #Slider9 					#model: #volume9 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 307 0 524 0 320 0 ) 					#name: #Slider10 					#model: #volume10 					#orientation: #horizontal 					#start: 0 					#stop: 1 ) ) ) )</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol1 to: self.	self volume2 onChangeSend: #newVol2 to: self.	self volume3 onChangeSend: #newVol3 to: self.	self volume4 onChangeSend: #newVol4 to: self.	self volume5 onChangeSend: #newVol5 to: self.	self volume6 onChangeSend: #newVol6 to: self.	self volume7 onChangeSend: #newVol7 to: self.	self volume8 onChangeSend: #newVol8 to: self.	self volume9 onChangeSend: #newVol9 to: self.	self volume10 onChangeSend: #newVol10 to: self.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1">newVol1	"Accept a new volume value from the slider"	| val |	val := self volume1 value.	val := val * val.</body></methods><do-it>ClusterEditor openWithSpec: #buttonSpec</do-it><do-it>OSCVoice stringExample: 1 to: 2</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="stringExample:to:">stringExample: oct1 to: oct2	"Play a long merged list of random notes on the CSL plucked string instrument"	"OSCVoice stringExample2"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL StringInstrument has args: ampl, c_fr, pos"	| scale evList voice  pitches |	scale := OrderedCollection new.					"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N re) notes) collect: [ : ea | ea name asLowercase].	oct1 to: oct2 do: [ :oct |		1 to: pitches size do: [ :ind |			scale add: (Pitch value: (pitches at: ind), oct printString) asHertz]].	evList := (EventList randomExample: 30 				"create the event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: 30 			"add in the 2nd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: 30 			"add in the 3rd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: evList events size do: 						"plug in instruments 1-16"		[ :ind | | ev |					ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	evList computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLString.			"plug in the parameter map"	evList voice: voice.	evList play.									"play"	^evList duration</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start1">start1	"Start player 1 runnning a string thread"	"ClusterEditor openWithSpec: #buttonSpec"	| player1 |	player1 := self startPlayer: 1 with: [OSCVoice stringExample: 1 to: 2]</body></methods><class><name>ClusterEditor</name><environment>Siren</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mode scale process events tScale numEvents running defaultVoiceClass players playerStates playerVoices durationList maxPitch minDur minPitch pitchList maxDur pitchRange durRange voiceRange amplRange minAmpl minVoice maxVoice amplList maxAmpl voiceList tempo volume7 volume9 volume8 volume5 volume3 volume4 volume2 volume10 volume6 volume1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicUI-Editors</category><attributes><package>Siren</package></attributes></class><do-it>Smalltalk.Siren defineClass: #ClusterEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'mode scale process events tScale numEvents running defaultVoiceClass players playerStates playerVoices durationList maxPitch minDur minPitch pitchList maxDur pitchRange durRange voiceRange amplRange minAmpl minVoice maxVoice amplList maxAmpl voiceList tempo volume7 volume9 volume8 volume5 volume3 volume4 volume2 volume10 volume6 volume1 '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>initialize-release</category><body package="Siren" selector="initialize">initialize	"Set up the default values."	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	"self open"	minPitch := 72 asValue.	maxPitch := 84 asValue.	minDur := (1/2) asValue.	maxDur := (1/6) asValue.	minAmpl := 20 asValue.	maxAmpl := 34 asValue.	minVoice := 1 asValue.	maxVoice := 1 asValue.	pitchList := '84 85 86 87 88' asValue.	durationList := '1/1 1/1 1/1 1/2' asValue.	amplList := '20 20 24 24' asValue.	voiceList := '4' asValue.	mode := #cluster asValue.	scale := #Pentatonic asValue.	process := nil.	events := nil.	numEvents := 8 asValue.	running := false.	tempo := 1.0 asValue.	tScale := 1.0.	players := Array new: 10 withAll: nil.	playerStates := Array new: 10 withAll: false.	playerVoices := Array new: 10 withAll: nil.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [								"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |				"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				 [[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					dur := block value first]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [								"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				 [[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					dur := block value first]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [								"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				 [[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					dur := block value first]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start1">start1	"Start player 1 runnning a string thread"	"ClusterEditor openWithSpec: #buttonSpec"	self startPlayer: 1 with: [OSCVoice stringExample: 1 to: 2]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="sndExample3">sndExample3	"Play random notes on the CSL sound file instruments"	"OSCVoice sndExample3"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	voice := self default.	voice parameterMap: self pMapForCSLSndSimple.			"plug in the parameter map"													"load 4 sound files""	sndDir := '/Content/Code/CSL6/Data/'.	voice send: '/i17/fi' args: (Array with: (sndDir, 'moon.snd')).	voice send: '/i18/fi' args: (Array with: (sndDir, 'wet.snd')).	voice send: '/i19/fi' args: (Array with: (sndDir, 'round.snd')).	voice send: '/i20/fi' args: (Array with: (sndDir, 'shine.snd'))."	rand := Random new.								"create an event list that plays the sound files with long pauses"	events := EventList new.	20 timesRepeat:		[ | in |		in := rand nextIntFrom: 17 to: 20.		events add: (MusicEvent new duration: (rand nextFrom: 1.0 to: 5.0); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.5 to: 1.5); 				pos: (rand nextFrom: -1.0 to: 1.0))].	events computeDuration.	events voice: voice.									"plug in the OSC voice"	events play.										"play it"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.						"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 							"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.			"plug in the parameter map"	events voice: voice.	events play.											"play"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.						"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 							"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.										"play"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.MIDIVoice class</class-id> <category>examples</category><body package="Siren" selector="randomWalk:pitch:dur:amp:chan:">randomWalk: num pitch: pitch1 dur: dur amp: am chan: ch	"Play a random walk on a voice on a device on a port."	"MIDIVoice randomWalk: 100 pitch: 96 dur: 0.12 amp: #ppp"	| eList voice pit steps du ampl |	eList := EventList new.	pit := pitch1.	steps := #(0 0 0 0 1 -1).	du := dur sec.	ampl := am ampl.	num timesRepeat: 		[eList add: (du, pit pitch, ampl).		pit := pit + steps atRandom].	eList computeDuration.	voice := MIDIVoice default.	voice channel: ch.	eList playOn: voice.	^Array with: eList duration with: voice</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume1">volume1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume1 isNil		ifTrue:			[volume1 := 1.0 asValue]		ifFalse:			[volume1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume10">volume10	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume10 isNil		ifTrue:			[volume10 := 1.0 asValue]		ifFalse:			[volume10]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume2">volume2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume2 isNil		ifTrue:			[volume2 := 1.0 asValue]		ifFalse:			[volume2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume3">volume3	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume3 isNil		ifTrue:			[volume3 := 1.0 asValue]		ifFalse:			[volume3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume4">volume4	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume4 isNil		ifTrue:			[volume4 := 1.0 asValue]		ifFalse:			[volume4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume5">volume5	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume5 isNil		ifTrue:			[volume5 := 1.0 asValue]		ifFalse:			[volume5]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume6">volume6	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume6 isNil		ifTrue:			[volume6 := 1.0 asValue]		ifFalse:			[volume6]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume7">volume7	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume7 isNil		ifTrue:			[volume7 := 1.0 asValue]		ifFalse:			[volume7]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume8">volume8	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume8 isNil		ifTrue:			[volume8 := 1.0 asValue]		ifFalse:			[volume8]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume9">volume9	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume9 isNil		ifTrue:			[volume9 := 1.0 asValue]		ifFalse:			[volume9]</body></methods><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="buttonSpec">buttonSpec	"Tools.UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Player Control' 			#min: #(#{Core.Point} 543 337 ) 			#max: #(#{Core.Point} 543 337 ) 			#bounds: #(#{Graphics.Rectangle} 863 581 1406 918 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5938 5054 5057 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 15 0 ) 					#name: #Label7 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 14 0 177 0 35 0 ) 					#name: #start1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #start1 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 14 0 281 0 35 0 ) 					#name: #refresh1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #refresh1 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 47 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 46 0 177 0 67 0 ) 					#name: #start2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #start2 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 46 0 281 0 67 0 ) 					#name: #refresh2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #refresh2 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 80 0 ) 					#name: #Label5 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 79 0 177 0 100 0 ) 					#name: #start3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #start3 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 79 0 281 0 100 0 ) 					#name: #refresh3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #refresh3 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 303 0 ) 					#name: #Label8 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 4' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 302 0 177 0 323 0 ) 					#name: #start10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #start10 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 302 0 281 0 323 0 ) 					#name: #refresh10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #refresh10 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 271 0 ) 					#name: #Label9 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 3' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 270 0 177 0 291 0 ) 					#name: #start9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #start9 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 270 0 281 0 291 0 ) 					#name: #refresh9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #refresh9 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 239 0 ) 					#name: #Label10 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 238 0 177 0 259 0 ) 					#name: #start8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #start8 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 238 0 281 0 259 0 ) 					#name: #refresh8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #refresh8 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 207 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 206 0 177 0 227 0 ) 					#name: #start7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #start7 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 206 0 281 0 227 0 ) 					#name: #refresh7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #refresh7 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 175 0 ) 					#name: #Label2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 174 0 177 0 195 0 ) 					#name: #start6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #start6 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 174 0 281 0 195 0 ) 					#name: #refresh6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #refresh6 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 143 0 ) 					#name: #Label3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 142 0 177 0 163 0 ) 					#name: #start5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #start5 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 142 0 281 0 163 0 ) 					#name: #refresh5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #refresh5 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 110 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 109 0 177 0 130 0 ) 					#name: #start4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #start4 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 109 0 281 0 130 0 ) 					#name: #refresh4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #refresh4 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 19 0 524 0 32 0 ) 					#name: #Slider1 					#model: #volume1 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 243 0 524 0 256 0 ) 					#name: #Slider8 					#model: #volume8 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 211 0 524 0 224 0 ) 					#name: #Slider7 					#model: #volume7 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 179 0 524 0 192 0 ) 					#name: #Slider6 					#model: #volume6 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 147 0 524 0 160 0 ) 					#name: #Slider5 					#model: #volume5 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 115 0 524 0 128 0 ) 					#name: #Slider4 					#model: #volume4 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 83 0 524 0 96 0 ) 					#name: #Slider3 					#model: #volume3 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 51 0 524 0 64 0 ) 					#name: #Slider2 					#model: #volume2 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 275 0 524 0 288 0 ) 					#name: #Slider9 					#model: #volume9 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 307 0 524 0 320 0 ) 					#name: #Slider10 					#model: #volume10 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) ) ) )</body></methods><do-it>Tools.UIPainter new openOnClass: self andSelector: #buttonSpec</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol: to: self.	self volume2 onChangeSend: #newVol2 to: self.	self volume3 onChangeSend: #newVol3 to: self.	self volume4 onChangeSend: #newVol4 to: self.	self volume5 onChangeSend: #newVol5 to: self.	self volume6 onChangeSend: #newVol6 to: self.	self volume7 onChangeSend: #newVol7 to: self.	self volume8 onChangeSend: #newVol8 to: self.	self volume9 onChangeSend: #newVol9 to: self.	self volume10 onChangeSend: #newVol10 to: self.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol:for:">newVol: val for: ind	"Accept a new volume"	self halt.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol:for: to: self.	self volume2 onChangeSend: #newVol2 to: self.	self volume3 onChangeSend: #newVol3 to: self.	self volume4 onChangeSend: #newVol4 to: self.	self volume5 onChangeSend: #newVol5 to: self.	self volume6 onChangeSend: #newVol6 to: self.	self volume7 onChangeSend: #newVol7 to: self.	self volume8 onChangeSend: #newVol8 to: self.	self volume9 onChangeSend: #newVol9 to: self.	self volume10 onChangeSend: #newVol10 to: self.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol1 to: self.	self volume2 onChangeSend: #newVol2 to: self.	self volume3 onChangeSend: #newVol3 to: self.	self volume4 onChangeSend: #newVol4 to: self.	self volume5 onChangeSend: #newVol5 to: self.	self volume6 onChangeSend: #newVol6 to: self.	self volume7 onChangeSend: #newVol7 to: self.	self volume8 onChangeSend: #newVol8 to: self.	self volume9 onChangeSend: #newVol9 to: self.	self volume10 onChangeSend: #newVol10 to: self.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val |	val := vModel value.	val := val * val.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol1:for: to: self.	self volume2 onChangeSend: #newVol2 to: self.	self volume3 onChangeSend: #newVol3 to: self.	self volume4 onChangeSend: #newVol4 to: self.	self volume5 onChangeSend: #newVol5 to: self.	self volume6 onChangeSend: #newVol6 to: self.	self volume7 onChangeSend: #newVol7 to: self.	self volume8 onChangeSend: #newVol8 to: self.	self volume9 onChangeSend: #newVol9 to: self.	self volume10 onChangeSend: #newVol10 to: self.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val |	val := vModel value.	val := val * val.self halt</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 1.	pv ifNil: [^self].self halt</body></methods><methods><class-id>Siren.EventScheduler</class-id> <category>running</category><body package="Siren" selector="run">run	"Set up the first meetings and then run them all till no one wants a meeting anymore."	| proc |	running ifTrue: [^nil].	startTime := Time microsecondClock.	self run: true.						"set flag"	threads isEmpty not		ifTrue: [threads do: [ :pr | pr terminate]].	threads := OrderedCollection new.		"enforce single-threading for now"									"LOOP: as long as on, try next appt or timer"	proc := [[running] whileTrue: [self callNextAppointment]] forkAt: (Processor userBackgroundPriority - 1).	threads add: proc.	self changed: #running with: true</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '3:01:16 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 3:01:16 PM on July 14, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="stringExample:to:">stringExample: oct1 to: oct2	"Play a long merged list of random notes on the CSL plucked string instrument"	"OSCVoice stringExample2"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL StringInstrument has args: ampl, c_fr, pos"	| scale evList voice  pitches |	scale := OrderedCollection new.					"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N re) notes) collect: [ : ea | ea name asLowercase].	oct1 to: oct2 do: [ :oct |		1 to: pitches size do: [ :ind |			scale add: (Pitch value: (pitches at: ind), oct printString) asHertz]].	evList := (EventList randomExample: 30 				"create the event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: 30 			"add in the 2nd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: 30 			"add in the 3rd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: evList events size do: 						"plug in instruments 1-16"		[ :ind | | ev |					ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	evList computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLString.			"plug in the parameter map"	evList voice: voice.	evList play.									"play"	^Array with: evList duration with: voice</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				 [[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					dur := block value first]] fork]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '3:03:37 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 3:03:37 PM on July 14, 2020."</do-it><class><name>OSCVoice</name><environment>Siren</environment><super>Siren.NotelistVoice</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>port ampl </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicIO-OSC</category><attributes><package>Siren</package></attributes></class><do-it>Smalltalk.Siren defineClass: #OSCVoice	superclass: #{Siren.NotelistVoice}	indexedType: #objects	private: false	instanceVariableNames: 'port ampl'	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'</do-it><class><name>Voice</name><environment>Siren</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name instrument stream ampl </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicIO-Voices</category><attributes><package>Siren</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Voice	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'name instrument stream ampl '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'</do-it><class><name>OSCVoice</name><environment>Siren</environment><super>Siren.NotelistVoice</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicIO-OSC</category><attributes><package>Siren</package></attributes></class><do-it>Smalltalk.Siren defineClass: #OSCVoice	superclass: #{Siren.NotelistVoice}	indexedType: #objects	private: false	instanceVariableNames: 'port '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'</do-it><class><name>Voice</name><environment>Siren</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name instrument stream loudness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicIO-Voices</category><attributes><package>Siren</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Voice	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'name instrument stream loudness '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'</do-it><methods><class-id>Siren.Voice</class-id> <category>accessing</category><body package="Siren" selector="loudness">loudness	"Answer my loudness."	^loudness</body></methods><methods><class-id>Siren.Voice</class-id> <category>accessing</category><body package="Siren" selector="loudness:">loudness: aValue	"Set my loudness."	^loudness := aValue</body></methods><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="oscMessageFrom:">oscMessageFrom: event 	"Answer a message for the given event by passing it to my parameter-mapper block"	| msg |	msg := parameterMap value: event.	^msg</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 220.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 0.8)), 			(#modIndex: -&gt; (0.0 to: 8.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="playAssociation:in:">playAssociation: ass in: list 	"Play the association..."	| realTime |	realTime := ass key asMsec value.	self waitTill: realTime.	port send: (parameterMap value: ass value value: self).	^self"	stream := OrderedCollection new.	parameterMap do: [ :item | self			mapProperty: item			of: ass			within: list].	stream size = 0 ifTrue: [^self].	stream size = 1 ifTrue: [^port send: (stream at: 1)]."</body></methods><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="oscMessageFrom:">oscMessageFrom: event 	"Answer a message for the given event by passing it to my parameter-mapper block"	| msg |	msg := parameterMap value: event value: self.	^msg</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLString">pMapForCSLString	"Answer the default parameterMap for use with the CSL plucked string example instrument."	"CSL StringInstrument has args: ampl, c_fr, pos"	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 3.				"set up the parameter map"	v loudness isNil		ifTrue: [arr at: 1 put: e ampl value]		ifFalse: [arr at: 1 put: e ampl value * v loudness value].	arr at: 2 put: e pitch asHz value.	arr at: 3 put: e pos."	Transcript show: arr printString; cr."	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 16 ifTrue: [cnt := 1].	TypedOSCMessage for: inst with: arr]</body></methods><do-it>	0.5 value</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 1.	pv ifNil: [^self].	pv loudness: val</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '3:16:31 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 3:16:31 PM on July 14, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '3:17:56 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 3:17:56 PM on July 14, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol2:for:">newVol2: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 2.	pv ifNil: [^self].	pv loudness: val</body></methods><remove-selector><class-id>Siren.ClusterEditor</class-id> <selector>newVol1</selector></remove-selector><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol1:for: to: self.	self volume2 onChangeSend: #newVol2:for: to: self.	self volume3 onChangeSend: #newVol3:for: to: self.	self volume4 onChangeSend: #newVol4:for: to: self.	self volume5 onChangeSend: #newVol5:for: to: self.	self volume6 onChangeSend: #newVol6:for: to: self.	self volume7 onChangeSend: #newVol7:for: to: self.	self volume8 onChangeSend: #newVol8:for: to: self.	self volume9 onChangeSend: #newVol9:for: to: self.	self volume10 onChangeSend: #newVol10:for: to: self.</body></methods><remove-selector><class-id>Siren.ClusterEditor</class-id> <selector>newVol:for:</selector></remove-selector><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol2:for:">newVol2: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 2.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol3:for:">newVol3: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 3.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol4:for:">newVol4: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 4.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol5:for:">newVol5: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 5.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol6:for:">newVol6: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 6.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol7:for:">newVol7: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 7.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol8:for:">newVol8: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 8.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol9:for:">newVol9: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 9.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol10:for:">newVol10: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 10.	pv ifNil: [^self].	pv loudness: val</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '3:21:41 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 3:21:41 PM on July 14, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLSnd">pMapForCSLSnd	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL SndFileInstrument has args: ampl, pos, start, stop"	^[ :e :v | | arr |	arr := Array new: 4.				"set up the parameter map"	v loudness isNil		ifTrue: [arr at: 1 put: e ampl value]		ifFalse: [arr at: 1 put: e ampl value * v loudness value].	arr at: 2 put: e pos.	arr at: 3 put: e start.	arr at: 4 put: e stop."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLSnd">pMapForCSLSnd	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL SndFileInstrument has args: ampl, pos, start, stop"	^[ :e :v | | arr |	arr := Array new: 4.				"set up the parameter map"	v loudness isNil		ifTrue: [arr at: 1 put: e ampl value]		ifFalse: [arr at: 1 put: e ampl value * v loudness value].	arr at: 2 put: e pos.	arr at: 3 put: e start.	arr at: 4 put: e stop."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="sndExample3">sndExample3	"Play random notes on the CSL sound file instruments"	"OSCVoice sndExample3"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	voice := self default.	voice parameterMap: self pMapForCSLSndSimple.			"plug in the parameter map"															"load 4 sound files""	sndDir := '/Content/Code/CSL6/Data/'.	voice send: '/i17/fi' args: (Array with: (sndDir, 'moon.snd')).	voice send: '/i18/fi' args: (Array with: (sndDir, 'wet.snd')).	voice send: '/i19/fi' args: (Array with: (sndDir, 'round.snd')).	voice send: '/i20/fi' args: (Array with: (sndDir, 'shine.snd'))."	rand := Random new.									"create an event list that plays the sound files with long pauses"	events := EventList new.	20 timesRepeat:		[ | in |		in := rand nextIntFrom: 17 to: 20.		events add: (MusicEvent new duration: (rand nextFrom: 1.0 to: 5.0); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.5 to: 1.5); 				pos: (rand nextFrom: -1.0 to: 1.0))].	events computeDuration.	events voice: voice.										"plug in the OSC voice"	events play.												"play it"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="sndExample3">sndExample3	"Play random notes on the CSL sound file instruments"	"OSCVoice sndExample3"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	voice := self default.	voice parameterMap: self pMapForCSLSndSimple.			"plug in the parameter map"															"load 4 sound files""	sndDir := '/Content/Code/CSL6/Data/'.	voice send: '/i17/fi' args: (Array with: (sndDir, 'moon.snd')).	voice send: '/i18/fi' args: (Array with: (sndDir, 'wet.snd')).	voice send: '/i19/fi' args: (Array with: (sndDir, 'round.snd')).	voice send: '/i20/fi' args: (Array with: (sndDir, 'shine.snd'))."	rand := Random new.									"create an event list that plays the sound files with long pauses"	events := EventList new.	20 timesRepeat:		[ | in |		in := rand nextIntFrom: 17 to: 20.		events add: (MusicEvent new duration: (rand nextFrom: 1.0 to: 5.0); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.5 to: 1.5); 				pos: (rand nextFrom: -1.0 to: 1.0))].	events computeDuration.	events voice: voice.										"plug in the OSC voice"	events play.												"play it"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLVSOS">pMapForCSLVSOS	"Answer the default parameterMap for use with the CSL vector SOS example instrument."	"CSL vector SOS Instrument has args: dur, ampl, frq, pos"	^[ :e :v | | arr |	arr := Array new: 4.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl asRatio value]		ifFalse: [arr at: 2 put: e ampl asRatio value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>MIDIVoice default.</do-it><methods><class-id>Siren.MIDIVoice</class-id> <category>events</category><body package="Siren" selector="playEvent:at:">playEvent: anEvent at: aTime	"Send the given event to the instrument."	loudness ifNotNil: [anEvent loudness: anEvent loudness * loudness value].	aTime isNil		ifTrue: [instrument play: anEvent at: 0]		ifFalse: [instrument play: anEvent at: aTime usec value]</body></methods><do-it>ClusterEditor allInstances</do-it><do-it>self terminate</do-it><do-it>self terminate</do-it><do-it>self terminate</do-it><do-it>Siren.ClusterEditor organization addCategory: #'interface closing' before: nil</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>interface closing</category><body package="Siren" selector="closeRequest">closeRequest	"Shut down gracefully"	players do:		[ :pl |		pl ifNotNil: [pl terminate]]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>interface closing</category><body package="Siren" selector="closeRequest">closeRequest	"Shut down gracefully"	running ifTrue: [self stop].	players do:		[ :pl |		pl ifNotNil: [pl terminate]]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="startStop">startStop	"start/stop the event-generating process."	| t0 v0  |	running ifTrue: [^self stop].	Transcript show: 'Start'; cr.	(self builder componentAt: #startButton) component component setLabelString: 'Stop'.	self generateEvents.	running := true.	t0 := Time microsecondClock usec.	v0 := MIDIVoice default.	v0 channel: 4."Special thread for clusters"	mode value == #cluster ifTrue:		[ | durs |		durs := self stringToList: durationList value.		process := [[running] whileTrue: 			[ | t1 ev te |			te := self tempo value.			ev := events atRandom copy.			ev scaleDuration: 2.0 / te.			ev playOn: v0 at: t0.			t1 := durs atRandom sec asUsec value * te.			t0 := t0 + t1.			(Delay forMicroseconds: t1) wait]] fork.		Processor yield.  			"give proc a chance to run"		^self].	mode value == #cloud ifTrue:		[events scaleStartTimesBy: self tempo value.		events scaleDurationsBy: (2.0 / self tempo value).		events playOn: v0 at: t0.		(self builder componentAt: #startButton) component component setLabelString: 'Start'.		^self].	process := [[running] whileTrue: 		[ | t1 |		events copy playOn: v0 at: t0.		t1 := events duration asUsec value.		t0 := t0 + t1.		(Delay forMicroseconds: t1) wait]] fork "At: 5".	Processor yield</body></methods><class><name>ClusterEditor</name><environment>Siren</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mode scale process events tScale numEvents running defaultVoiceClass players playerStates playerVoices durationList maxPitch minDur minPitch pitchList maxDur minAmpl minVoice maxVoice amplList maxAmpl voiceList tempo volume7 volume9 volume8 volume5 volume3 volume4 volume2 volume10 volume6 volume1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MusicUI-Editors</category><attributes><package>Siren</package></attributes></class><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90n.im' 'July 14, 2020' '3:38:53 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90n.im was created at 3:38:53 PM on July 14, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLSndSimple">pMapForCSLSndSimple	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL SndFileInstrument has args: ampl, pos"	^[ :e :v | | arr |	arr := Array new: 2.				"set up the parameter map"	v loudness isNil		ifTrue: [arr at: 1 put: e ampl value]		ifFalse: [arr at: 1 put: e ampl value * v loudness value].	arr at: 2 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="stop">stop	"start/stop the event-generating process."	running := false.	Transcript show: 'Stop'; cr.	process ifNotNil: [process terminate].	(self builder componentAt: #startButton) component component setLabelString: 'Start'.	events := nil.</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="stop">stop	"start/stop the event-generating process."	running := false.	Transcript show: 'Stop'; cr.	process		ifNotNil: [process terminate].	(self builder componentAt: #startButton)		ifNotNil: [(self builder componentAt: #startButton) component component setLabelString: 'Start'].	events := nil.</body></methods><do-it>ClusterEditor allInstances do: [ :in | in stop]</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>interface opening</category><body package="Siren" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	"ClusterEditor allInstances do: [ :in | in stop]"	self scale onChangeSend: #newScale to: self.	self defaultVoiceClass onChangeSend: #chVoiceClass to: self.	self tempo onChangeSend: #newTempo to: self.	self volume1 onChangeSend: #newVol1:for: to: self.	self volume2 onChangeSend: #newVol2:for: to: self.	self volume3 onChangeSend: #newVol3:for: to: self.	self volume4 onChangeSend: #newVol4:for: to: self.	self volume5 onChangeSend: #newVol5:for: to: self.	self volume6 onChangeSend: #newVol6:for: to: self.	self volume7 onChangeSend: #newVol7:for: to: self.	self volume8 onChangeSend: #newVol8:for: to: self.	self volume9 onChangeSend: #newVol9:for: to: self.	self volume10 onChangeSend: #newVol10:for: to: self.</body></methods><do-it>ClusterEditor allInstances</do-it><do-it>self terminate</do-it><do-it>self terminate</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="sndExample3">sndExample3	"Play random notes on the CSL sound file instruments"	"OSCVoice sndExample3"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	voice := self default.	voice parameterMap: self pMapForCSLSndSimple.				"plug in the parameter map"														"load 4 sound files""	sndDir := '/Content/Code/CSL6/Data/'.	voice send: '/i17/fi' args: (Array with: (sndDir, 'moon.snd')).	voice send: '/i18/fi' args: (Array with: (sndDir, 'wet.snd')).	voice send: '/i19/fi' args: (Array with: (sndDir, 'round.snd')).	voice send: '/i20/fi' args: (Array with: (sndDir, 'shine.snd'))."	rand := Random new.									"create an event list that plays the sound files with long pauses"	events := EventList new.	20 timesRepeat:		[ | in |		in := rand nextIntFrom: 17 to: 20.		events add: (MusicEvent new duration: (rand nextFrom: 1.0 to: 5.0); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.5 to: 1.5); 				pos: (rand nextFrom: -1.0 to: 1.0))].	events computeDuration.	events voice: voice.										"plug in the OSC voice"	events play.											"play it"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 					"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.					"plug in the parameter map"	events voice: voice.	events play.											"play"	^Array with: events duration with: voice</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 14, 2020' '3:56:13 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 3:56:13 PM on July 14, 2020."</do-it><do-it>Siren.SirenSession reorganizeFromString: '(''initialize release'' #initialize #release)(''accessing'' #objectFor: #selectedObject #selectedObjectName #transport)(''aspects'' #blockSize #clock #defaultVoiceClass #eventList #inChannels #midiPort #oscAddress #outChannels #sampleRate #scheduleList #scheduleListText #scheduleListText0 #sound #soundPort #timer #updateClock #updateScheduleList #updateTimer #verbosity #verbosityLabel #voice)(''actions'' #allOff #cleanUp #configureMIDI #freeLists #inspectSession #loadAll #openSirenUtility #openTransport #resetSound #stopMIDI #stopSound)(''actions--change'' #chBlockSize #chInChans #chListSelection #chOSCAddr #chOutChans #chSRate #chVerbosity #chVoiceClass #newEventList #newMIDIPort #newSound #newSoundPort #newTimer #newVoice)(''actions--menu'' #deleteItem #playItem #spawnItem #zeroTimer)(''interface opening'' #postOpenWith:)(''actions--transport'' #forward #play #record #rewind #stop)(''actions--tests'' #testMIDI #testMIDIin #testMIDIout #testOSCout #testSndFileIn #testSoundIn #testSoundOut)(''resources'' #addItemsFrom:to:path: #listMenu #soundMenu #timerMenu #voiceMenu)(''updating'' #executeAutoSave #update:with:from:)'</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFM">pMapForCSLFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| inst cnt |	cnt := 33.	^[ :e :v | | arr |	arr := Array new: 14.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pitch asHz value * e ratio.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos.	arr at: 7 put: e att.	arr at: 8 put: e dec.	arr at: 9 put: e sus.	arr at: 10 put: e rel.	arr at: 11 put: e iatt.	arr at: 12 put: e idec.	arr at: 13 put: e isus.	arr at: 14 put: e irel."	Transcript show: arr printString; cr."	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 39 ifTrue: [cnt := 33].	TypedOSCMessage for: inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array			with: e duration asSec value			with: e pitch asHz value			with: (v loudness isNil				ifTrue: [e ampl asRatio value]				ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/note' with: arr]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 14, 2020' '11:54:29 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 11:54:29 PM on July 14, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '7:41:08 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 7:41:08 AM on July 15, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="stringExample:to:">stringExample: oct1 to: oct2	"Play a long merged list of random notes on the CSL plucked string instrument"	"OSCVoice stringExample2"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL StringInstrument has args: ampl, c_fr, pos"	| num scale evList voice  pitches |	num := 10.	scale := OrderedCollection new.						"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N re) notes) collect: [ : ea | ea name asLowercase].	oct1 to: oct2 do: [ :oct |		1 to: pitches size do: [ :ind |			scale add: (Pitch value: (pitches at: ind), oct printString) asHertz]].	evList := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: num 		"add in the 2nd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: num 		"add in the 3rd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: evList events size do: 							"plug in instruments 1-16"		[ :ind | | ev |					ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	evList computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLString.			"plug in the parameter map"	evList voice: voice.	evList play.									"play"	^Array with: evList duration with: voice</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol2:for:">newVol2: ignored for: vModel	"Respond to a change to the volume 2 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 2.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol3:for:">newVol3: ignored for: vModel	"Respond to a change to the volume 3 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 3.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol4:for:">newVol4: ignored for: vModel	"Respond to a change to the volume 4 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 4.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol5:for:">newVol5: ignored for: vModel	"Respond to a change to the volume 5 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 5.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol6:for:">newVol6: ignored for: vModel	"Respond to a change to the volume 6 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 6.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol10:for:">newVol10: ignored for: vModel	"Respond to a change to the volume 10 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 10.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol7:for:">newVol7: ignored for: vModel	"Respond to a change to the volume 7 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 7.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol8:for:">newVol8: ignored for: vModel	"Respond to a change to the volume 8 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 8.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol9:for:">newVol9: ignored for: vModel	"Respond to a change to the volume 9 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 9.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				 [[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					arr := block value.					dur := arr first.					playerVoices at: num put: arr last]] fork]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '11:47:08 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 11:47:08 AM on July 15, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				[ | vol pv |				[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					vol := (playerVoices at: num) loudness.					arr := block value.					dur := arr first.					pv := arr last.					pv loudness: vol.					playerVoices at: num put: pv]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol10:for:">newVol10: ignored for: vModel	"Respond to a change to the volume 10 slider"	| pv |	pv := playerVoices at: 10.	pv ifNil: [^self].	pv loudness: vModel value</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol9:for:">newVol9: ignored for: vModel	"Respond to a change to the volume 9 slider"	| pv |	pv := playerVoices at: 190.	pv ifNil: [^self].	pv loudness: vModel value</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol8:for:">newVol8: ignored for: vModel	"Respond to a change to the volume 8 slider"	| pv |	pv := playerVoices at: 8.	pv ifNil: [^self].	pv loudness: vModel value</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol7:for:">newVol7: ignored for: vModel	"Respond to a change to the volume 7 slider"	| pv |	pv := playerVoices at: 7.	pv ifNil: [^self].	pv loudness: vModel value</body></methods><do-it>6 ampl.</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice randomWalk: 100 pitch: 80 dur: 0.09 amp: 40 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 40 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 40 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 66 dur: 0.085 amp: 45 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 80 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 80 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice randomWalk: 100 pitch: 80 dur: 0.09 amp: 80 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 66 dur: 0.085 amp: 80 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 66 dur: 0.085 amp: 80 chan: 4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice randomWalk: 100 pitch: 80 dur: 0.09 amp: 80 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 80 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol9:for:">newVol9: ignored for: vModel	"Respond to a change to the volume 9 slider"	| pv |	pv := playerVoices at: 9.	pv ifNil: [^self].	pv loudness: vModel value</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '12:16:47 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 12:16:47 PM on July 15, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '12:16:57 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 12:16:57 PM on July 15, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 50 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 90 chan: 1]</body></methods><methods><class-id>UI.SliderView</class-id> <category>updating</category><body package="UIBasics-Components" selector="setValueFromModel">setValueFromModelself halt.	self controller requestValueChange		ifTrue: 			[| mappedValue |			mappedValue := rangeMap						ifNil: [model value]						ifNotNil: [rangeMap map: model value].			mappedValue ~= value				ifTrue: 					[self triggerEvent: #changing.					value := mappedValue.					self invalidate.					self controller valueChange.					self triggerEvent: #changed]]</body></methods><methods><class-id>UI.SliderView</class-id> <category>updating</category><body package="UIBasics-Components" selector="setValueFromModel">setValueFromModel	self controller requestValueChange		ifTrue: 			[| mappedValue |			mappedValue := rangeMap						ifNil: [model value]						ifNotNil: [rangeMap map: model value].			mappedValue ~= value				ifTrue: 					[self triggerEvent: #changing.					value := mappedValue.					self invalidate.					self controller valueChange.					self triggerEvent: #changed]]</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		^(self isVisible and: (([self isEnabled or: [aMouseEvent isMotionEvent]]) or: [aMouseEvent isMouseWheelEvent]))		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil]</body></methods><do-it>self isVisible</do-it><do-it>self isEnabled</do-it><do-it>aMouseEvent isMotionEvent</do-it><do-it>self isEnabled or: [aMouseEvent isMotionEvent]</do-it><do-it>[self isEnabled or: [aMouseEvent isMotionEvent]]</do-it><do-it>self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]]</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		^(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil]</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		^(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [self halt. super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil]</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		^(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil]</body></methods><do-it>self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]]</do-it><do-it>view containsMouseEvent: aMouseEvent</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler |	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].		self halt.	^handler</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler |	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].		self safeHalt.	^handler</body></methods><do-it>InputState default shiftDown</do-it><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="Kernel-Objects" selector="safeHalt">safeHalt	"This is a simple message to use for inserting breakpoints during debugging.	The debugger is opened by raising a signal. This gives a chance to restore	invariants related to multiple processes."	InputState default shiftDown ifTrue: [self halt]</body></methods><do-it>self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]]</do-it><do-it> super handlerForMouseEvent: aMouseEvent</do-it><do-it>self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]]</do-it><do-it>ctrl handlerForMouseEvent: aMouseEvent</do-it><do-it>ctrl handlerForMouseEvent: aMouseEvent</do-it><do-it>view containsMouseEvent: aMouseEvent</do-it><do-it>self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]]</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].		self safeHalt.	^[ctrl handlerForMouseEvent: aMouseEvent].</body></methods><do-it>ctrl handlerForMouseEvent: aMouseEvent</do-it><do-it>(self absOrigin extent: extent)		containsPoint: evPt</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	self safeHalt.	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |		self safeHalt.	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	self safeHalt.	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><do-it>aMouseEvent isMouseWheelEvent</do-it><do-it>DraggablePartTrackingViewBehavior</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [^self dispatch: aMouseEvent to: self getController].	self safeHalt.	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [^self getController handleEvent: aMouseEvent].	self safeHalt.	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [self halt. ^self getController handleEvent: aMouseEvent].	self safeHalt.	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.1 amp: 50 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 90 chan: 1]</body></methods><methods><class-id>UI.SliderView</class-id> <category>updating</category><body package="UIBasics-Components" selector="setValueFromModel">setValueFromModel	self controller requestValueChange		ifTrue: 			[| mappedValue |			mappedValue := rangeMap						ifNil: [model value]						ifNotNil: [rangeMap map: model value].			mappedValue ~= value				ifTrue: 					[self triggerEvent: #changing.					value := mappedValue.					self invalidate.					self controller valueChange.					self triggerEvent: #changed]]</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="Kernel-Objects" selector="safeHalt">safeHalt	"This is a simple message to use for inserting breakpoints during debugging.	The debugger is opened by raising a signal. This gives a chance to restore	invariants related to multiple processes."	InputState default shiftDown ifTrue: [self halt]</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [self halt. ^self getController handleEvent: aMouseEvent].	self safeHalt.	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [self safeHalt. ^self getController handleEvent: aMouseEvent].	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [self safeHalt.].	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '1:25:07 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 1:25:07 PM on July 15, 2020."</do-it><do-it>InputState default shiftDown</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		|  handler ctrl |	aMouseEvent isMouseWheelEvent		ifTrue: [self halt.].	(self isVisible and: [(self isEnabled or: [aMouseEvent isMotionEvent]) or: [aMouseEvent isMouseWheelEvent]])		ifTrue: [handler := super handlerForMouseEvent: aMouseEvent]		ifFalse: [handler := nil].	handler ifNotNil: [^handler].	ctrl := self getController.	ctrl isNil ifTrue: [^nil].	^ctrl handlerForMouseEvent: aMouseEvent</body></methods><do-it>model value.</do-it><do-it>rangeMap rangeStop - rangeMap rangeStart.</do-it><do-it> (rangeMap rangeStop - rangeMap rangeStart) / 50.0.</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				^model setValue: val].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '1:39:05 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 1:39:05 PM on July 15, 2020."</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				self halt.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>aMouseEvent up </do-it><do-it>val := val - del</do-it><do-it>val := val - del</do-it><do-it>model setValue: val.</do-it><do-it>model setValue: val.</do-it><do-it>				self setValueFromModel.</do-it><do-it>				self setValueFromModel.</do-it><do-it>				self setValueFromModel.</do-it><do-it>				self setValueFromModel.</do-it><do-it>				self setValueFromModel.</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				self setValueFromModel.				self safeHalt.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [^self. " |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				self setValueFromModel.				self safeHalt.				^nil"].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [^self halt. " |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				self setValueFromModel.				self safeHalt.				^nil"].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>aMouseEvent up </do-it><do-it>(self absOrigin extent: extent)		containsPoint: evPt</do-it><do-it>self absOrigin extent: extent</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				self setValueFromModel.				Transcript show: val printString; cr.				self safeHalt.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				value := val.				self setValueFromModel.				Transcript show: val printString; cr.				self safeHalt.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				value := val.				self setValueFromModel."				Transcript show: val printString; cr.				self safeHalt."				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '1:50:37 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 1:50:37 PM on July 15, 2020."</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val.				value := val.				self setValueFromModel.				Transcript show: val printString; cr.				self safeHalt.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ |  val del |			val := model value.			del := (rangeMap rangeStop - rangeMap rangeStart) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].				model setValue: val."				value := val."				self setValueFromModel.				Transcript show: val printString; cr.				self safeHalt.				^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '2:01:04 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 2:01:04 PM on July 15, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 0.8)), 			(#modIndex: -&gt; (0.0 to: 18.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 0.8)), 			(#modIndex: -&gt; (0.0 to: 200.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 0.8)), 			(#modIndex: -&gt; (100.0 to: 300.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 0.8)), 			(#modIndex: -&gt; (1.0 to: 30.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 0.8)), 			(#modIndex: -&gt; (1.0 to: 10.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.2 to: 1.0)), 			(#modIndex: -&gt; (0.0 to: 10.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.8 to: 5.0)),			(#ampl: -&gt; (0.25 to: 1.0)), 			(#modIndex: -&gt; (0.0 to: 10.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.5)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.5 to: 2.0)),			(#ampl: -&gt; (0.25 to: 1.0)), 			(#modIndex: -&gt; (0.0 to: 10.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.1)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample1">fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 						"create the event list"		from: ((#duration: -&gt; (0.2 to: 0.75)), 			(#pitch: -&gt; (110.1 to: 440.1)), 			(#ratio: -&gt; (0.5 to: 2.0)),			(#ampl: -&gt; (0.25 to: 1.0)), 			(#modIndex: -&gt; (0.0 to: 10.0)), 			(#pos: -&gt; (-0.7 to: 0.7)),			(#att: -&gt; (0.01 to: 0.05)),			(#dec: -&gt; (0.03 to: 0.05)),			(#sus: -&gt; (0.3 to: 0.7)),			(#rel: -&gt; (0.1 to: 0.15)),			(#iatt: -&gt; (0.05 to: 0.15)),			(#idec: -&gt; 0.005),			(#isus: -&gt; 1.0),			(#irel: -&gt; 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '3:44:45 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 3:44:45 PM on July 15, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '3:44:56 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 3:44:56 PM on July 15, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |self halt.	val := vModel value.	val := val * val.	pv := playerVoices at: 1.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val &gt; mx ifTrue: [val := mx].			val &lt; mn ifTrue: [val := mn].			model setValue: val."			value := val."			self setValueFromModel.			aMouseEvent wasHandled: true.			Transcript show: val printString; cr.			self safeHalt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			model setValue: val."			value := val."			self setValueFromModel.			aMouseEvent wasHandled: true.			Transcript show: val printString; cr.			self safeHalt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		aMouseEvent isMouseWheelEvent		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self safeHalt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self safeHalt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self halt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>			self bounds</do-it><do-it>			self topComponent sensor cursorPointFor: aMouseEvent. </do-it><do-it>			self topComponent bounds</do-it><do-it>self topComponent sensor cursorPointFor: aMouseEvent. </do-it><do-it>			self topComponent bounds containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent).</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		self topComponent bounds containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent)		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self halt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(self topComponent bounds containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent))		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self halt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(self topComponent bounds containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent))		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self halt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |self halt.	val := vModel value.	val := val * val.	pv := playerVoices at: 1.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |self halt.	val := vModel value.	val := val * val.	pv := playerVoices at: 1.	pv ifNil: [^self].	pv loudness: val</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(self topComponent bounds containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent))		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr.			self halt.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '4:25:17 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 4:25:17 PM on July 15, 2020."</do-it><do-it>self topComponent bounds containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent)</do-it><do-it>aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not]</do-it><do-it>self topComponent sensor cursorPointFor: aMouseEvent</do-it><do-it>self bounds</do-it><do-it>self localPointToGlobal: Point zero.</do-it><do-it>self topComponent sensor cursorPointFor: aMouseEvent</do-it><do-it>self bounds</do-it><do-it>self containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent)</do-it><do-it>self containsMouseEvent: aMouseEvent</do-it><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"	(self containsMouseEvent: aMouseEvent)"	(self containsPoint: (self topComponent sensor cursorPointFor: aMouseEvent))"		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val."			value := val."			self setValueFromModel.			Transcript show: val printString; cr."			self halt."			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"	(self containsMouseEvent: aMouseEvent)		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val.			self setValueFromModel."			Transcript show: val printString; cr."			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(self isVisible and: [self isEnabled and: [self containsMouseEvent: aMouseEvent]])		ifFalse: [^nil].	(aMouseEvent isMouseWheelEvent and: [aMouseEvent wasHandled not])		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val.			self setValueFromModel."			Transcript show: val printString; cr."			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(self isVisible and: [self isEnabled and: [(self containsMouseEvent: aMouseEvent) and: [aMouseEvent wasHandled not]]])		ifFalse: [^nil].	aMouseEvent isMouseWheelEvent		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 50.0.			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val.			self setValueFromModel.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><methods><class-id>UI.SliderView</class-id> <category>event driven</category><body package="UIBasics-Components" selector="handlerForMouseEvent:">handlerForMouseEvent: aMouseEvent	"Added handling for mouse wheel events"		(self isVisible and: [self isEnabled and: [(self containsMouseEvent: aMouseEvent) and: [aMouseEvent wasHandled not]]])		ifFalse: [^nil].	aMouseEvent isMouseWheelEvent		ifTrue: [ | mn mx val del |			mn := rangeMap  rangeStart.			mx := rangeMap rangeStop.			val := model value.			del := (mx - mn) / 33.0.		"scale for 3% steps"			aMouseEvent up 				ifTrue: [val := val + del]				ifFalse: [val := val - del].			val := val min: mx.			val := val max: mn.			aMouseEvent wasHandled: true.			model setValue: val.			self setValueFromModel.			^nil].	^(self isVisible and: [self isEnabled or: [aMouseEvent isMotionEvent]])		ifTrue: [super handlerForMouseEvent: aMouseEvent]		ifFalse: [nil].</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '4:42:16 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 4:42:16 PM on July 15, 2020."</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [e ampl asRatio value]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/note' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [e ampl asRatio value]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '1' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [e ampl asRatio value]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/i1' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [e ampl asRatio value]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/i1/pn' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="midiScaleExample">midiScaleExample	"OSCVoice midiScaleExample"	 | list voice |	list := EventList scaleFrom: 48 to: 72 in: 2.5.	voice := self default.	list voice: voice.	list play.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '4:53:33 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 4:53:33 PM on July 15, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>actions</category><body package="Siren" selector="newVol1:for:">newVol1: ignored for: vModel	"Respond to a change to the volume 1 slider"	| val pv |	val := vModel value.	val := val * val.	pv := playerVoices at: 1.	pv ifNil: [^self].	pv loudness: val</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '4:54:46 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 4:54:46 PM on July 15, 2020."</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.25 amp: 50 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.25 amp: 80 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.2 amp: 80 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 96 dur: 0.12 amp: 80 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 120 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice randomWalk: 100 pitch: 80 dur: 0.09 amp: 70 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 66 dur: 0.085 amp: 100 chan: 4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 72 dur: 0.085 amp: 100 chan: 4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice randomWalk: 100 pitch: 108 dur: 0.11 amp: 120 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 72 dur: 0.085 amp: 90 chan: 4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 89 dur: 0.115 amp:90 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice randomWalk: 100 pitch: 89 dur: 0.115 amp:90 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'."			(self builder componentAt: symb) component component"			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				[ | vol pv |				[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					vol := (playerVoices at: num) loudness.					arr := block value.					dur := arr first.					pv := arr last.					pv loudness: vol.					playerVoices at: num put: pv]] fork]</body></methods><do-it>Tools.UIPainter new openOnClass: self andSelector: #buttonSpec</do-it><methods><class-id>Siren.ClusterEditor class</class-id> <category>interface specs</category><body package="Siren" selector="buttonSpec">buttonSpec	"Tools.UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Player Control' 			#min: #(#{Core.Point} 543 337 ) 			#max: #(#{Core.Point} 543 337 ) 			#bounds: #(#{Graphics.Rectangle} 863 580 1406 917 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5938 5054 5057 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 6144 6144 5632 ) 				#setBorderColor: #(#{Graphics.ColorValue} #lightGray ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 15 0 ) 					#name: #Label7 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 14 0 177 0 35 0 ) 					#name: #start1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) 						#setSelectionForegroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#model: #start1 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 14 0 281 0 35 0 ) 					#name: #refresh1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 5119 8191 ) ) 					#model: #refresh1 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17.0 0 47 0 ) 					#name: #Label6 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Strings 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 46 0 177 0 67 0 ) 					#name: #start2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #start2 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 46 0 281 0 67 0 ) 					#name: #refresh2 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5119 2048 8191 ) ) 					#model: #refresh2 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 80 0 ) 					#name: #Label5 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 79 0 177 0 100 0 ) 					#name: #start3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #start3 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 79 0 281 0 100 0 ) 					#name: #refresh3 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6440 5302 7585 ) ) 					#model: #refresh3 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 303 0 ) 					#name: #Label8 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 4' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 302 0 177 0 323 0 ) 					#name: #start10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #start10 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 302 0 281 0 323 0 ) 					#name: #refresh10 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7437 7437 0 ) ) 					#model: #refresh10 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 271 0 ) 					#name: #Label9 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 3' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 270 0 177 0 291 0 ) 					#name: #start9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #start9 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 270 0 281 0 291 0 ) 					#name: #refresh9 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #refresh9 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 239 0 ) 					#name: #Label10 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 238 0 177 0 259 0 ) 					#name: #start8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #start8 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 238 0 281 0 259 0 ) 					#name: #refresh8 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 1671 1671 ) ) 					#model: #refresh8 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 29.4619 0 207 0 ) 					#name: #Label1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Walk 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 206 0 177 0 227 0 ) 					#name: #start7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #start7 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 206 0 281 0 227 0 ) 					#name: #refresh7 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6422 3213 0 ) ) 					#model: #refresh7 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 175 0 ) 					#name: #Label2 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 174 0 177 0 195 0 ) 					#name: #start6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #start6 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 174 0 281 0 195 0 ) 					#name: #refresh6 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7061 0 3532 ) ) 					#model: #refresh6 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20.1104 0 143 0 ) 					#name: #Label3 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Vector 1' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 142 0 177 0 163 0 ) 					#name: #start5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #start5 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 142 0 281 0 163 0 ) 					#name: #refresh5 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6684 2921 4798 ) ) 					#model: #refresh5 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 25.5518 0 110 0 ) 					#name: #Label4 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 5529 0 33 ) ) 					#label: 'Voice 2' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 77 0 109 0 177 0 130 0 ) 					#name: #start4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #start4 					#tabable: false 					#label: 'Start' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 109 0 281 0 130 0 ) 					#name: #refresh4 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6659 946 979 ) ) 					#model: #refresh4 					#tabable: false 					#label: 'Refresh' 					#style: #large ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 19 0 524 0 32 0 ) 					#name: #Slider1 					#model: #volume1 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 243 0 524 0 256 0 ) 					#name: #Slider8 					#model: #volume8 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 211 0 524 0 224 0 ) 					#name: #Slider7 					#model: #volume7 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 179 0 524 0 192 0 ) 					#name: #Slider6 					#model: #volume6 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 147 0 524 0 160 0 ) 					#name: #Slider5 					#model: #volume5 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 115 0 524 0 128 0 ) 					#name: #Slider4 					#model: #volume4 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 83 0 524 0 96 0 ) 					#name: #Slider3 					#model: #volume3 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 51 0 524 0 64 0 ) 					#name: #Slider2 					#model: #volume2 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 275 0 524 0 288 0 ) 					#name: #Slider9 					#model: #volume9 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 307 0 524 0 320 0 ) 					#name: #Slider10 					#model: #volume10 					#orientation: #horizontal 					#start: 0 					#stop: 1.5 ) ) ) )</body></methods><do-it>ActionButtonSpec</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.self halt."			(self builder componentAt: symb) component component"			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				[ | vol pv |				[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					vol := (playerVoices at: num) loudness.					arr := block value.					dur := arr first.					pv := arr last.					pv loudness: vol.					playerVoices at: num put: pv]] fork]</body></methods><do-it>(self builder componentAt: symb) component component</do-it><do-it>(self builder componentAt: symb) component </do-it><do-it>(self builder componentAt: symb) spec</do-it><do-it>(self builder componentAt: symb) spec colors</do-it><do-it>			(self builder componentAt: symb) spec colors setBackgroundColor: ColorValue blue</do-it><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			(self builder componentAt: symb) spec colors setBackgroundColor: ColorValue lightGray.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			(self builder componentAt: symb) spec colors setBackgroundColor: ColorValue blue.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				[ | vol pv |				[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					vol := (playerVoices at: num) loudness.					arr := block value.					dur := arr first.					pv := arr last.					pv loudness: vol.					playerVoices at: num put: pv]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			(self builder componentAt: symb) spec colors setBackgroundColor: ColorValue lightGray.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			(self builder componentAt: symb) spec colors setBackgroundColor: ColorValue blue.			(self builder componentAt: symb) spec colors setForegroundColor: ColorValue red.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				[ | vol pv |				[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					vol := (playerVoices at: num) loudness.					arr := block value.					dur := arr first.					pv := arr last.					pv loudness: vol.					playerVoices at: num put: pv]] fork]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="startPlayer:with:">startPlayer: num with: block	"Start a player runnning a new thread"	| symb |	symb := ('start', num printString) asSymbol.	(playerStates at: num)		ifTrue: [							"if playing, stop"			(self builder componentAt: symb) component component setLabelString: 'Start'.			(self builder componentAt: symb) spec colors setForegroundColor: ColorValue black.			playerStates at: num put: false.			(players at: num) terminate.			players at: num put: nil.			Transcript show: 'Stopping player ', num printString; cr]		ifFalse: [ | arr dur |					"if not playing, start"			(self builder componentAt: symb) component component setLabelString: 'Stop'.			(self builder componentAt: symb) spec colors setForegroundColor: ColorValue red.			Transcript show: 'Starting player ', num printString; cr.			playerStates at: num put: true.			arr := block value.				"block returns an array with a duration and a voice"			dur := arr first.			playerVoices at: num put: arr last.			players at: num put:				[ | vol pv |				[playerStates at: num] whileTrue:					[(Delay forSeconds: dur asSec value) wait.					vol := (playerVoices at: num) loudness.					arr := block value.					dur := arr first.					pv := arr last.					pv loudness: vol.					playerVoices at: num put: pv]] fork]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="sndExample3">sndExample3	"Play random notes on the CSL sound file instruments"	"OSCVoice sndExample3"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	voice := self default.	voice parameterMap: self pMapForCSLSndSimple.				"plug in the parameter map"														"load 4 sound files""	sndDir := '/Content/Code/CSL6/Data/'.	voice send: '/i17/fi' args: (Array with: (sndDir, 'moon.snd')).	voice send: '/i18/fi' args: (Array with: (sndDir, 'wet.snd')).	voice send: '/i19/fi' args: (Array with: (sndDir, 'round.snd')).	voice send: '/i20/fi' args: (Array with: (sndDir, 'shine.snd'))."	rand := Random new.									"create an event list that plays the sound files with long pauses"	events := EventList new.	10 timesRepeat:		[ | in |		in := rand nextIntFrom: 17 to: 20.		events add: (MusicEvent new duration: (rand nextFrom: 1.0 to: 5.0); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.5 to: 1.5); 				pos: (rand nextFrom: -1.0 to: 1.0))].	events computeDuration.	events voice: voice.										"plug in the OSC voice"	events play.											"play it"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="stringExample:to:">stringExample: oct1 to: oct2	"Play a long merged list of random notes on the CSL plucked string instrument"	"OSCVoice stringExample2"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL StringInstrument has args: ampl, c_fr, pos"	| num scale evList voice  pitches |	num := 10.	scale := OrderedCollection new.						"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N re) notes) collect: [ : ea | ea name asLowercase].	oct1 to: oct2 do: [ :oct |		1 to: pitches size do: [ :ind |			scale add: (Pitch value: (pitches at: ind), oct printString) asHertz]].	evList := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: num 		"add in the 2nd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: num 		"add in the 3rd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: evList events size do: 							"plug in instruments 1-16"		[ :ind | | ev |					ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	evList computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLString.			"plug in the parameter map"	evList voice: voice.	evList play.											"play"	^Array with: evList duration with: voice</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume1">volume1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume1 isNil		ifTrue:			[volume1 := 0.6 asValue]		ifFalse:			[volume1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume2">volume2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume2 isNil		ifTrue:			[volume2 := 0.6 asValue]		ifFalse:			[volume2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume7">volume7	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume7 isNil		ifTrue:			[volume7 := 0.75 asValue]		ifFalse:			[volume7]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume8">volume8	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume8 isNil		ifTrue:			[volume8 := 0.75 asValue]		ifFalse:			[volume8]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume9">volume9	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume9 isNil		ifTrue:			[volume9 := 0.75 asValue]		ifFalse:			[volume9]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume10">volume10	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume10 isNil		ifTrue:			[volume10 := 1.0 asValue]		ifFalse:			[volume10]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume10">volume10	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume10 isNil		ifTrue:			[volume10 := 0.75 asValue]		ifFalse:			[volume10]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume5">volume5	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume5 isNil		ifTrue:			[volume5 := 0.9 asValue]		ifFalse:			[volume5]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>aspects</category><body package="Siren" selector="volume6">volume6	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^volume6 isNil		ifTrue:			[volume6 := 0.9 asValue]		ifFalse:			[volume6]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '5:49:49 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 5:49:49 PM on July 15, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '5:49:56 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 5:49:56 PM on July 15, 2020."</do-it><methods><class-id>Siren.SirenSession</class-id> <category>actions--tests</category><body package="Siren" selector="testOSCout">testOSCout	| sel |	sel := (Menu labelArray: #('Random FM example' 'String scale example')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^OSCVoice fmExample1].		^OSCVoice midiScaleExample</body></methods><methods><class-id>Siren.EventList class</class-id> <category>examples</category><body package="Siren" selector="scaleFrom:to:in:">scaleFrom: start to: stop in: dur	"Answer an event list with a scale."	"(EventList scaleFrom: 48 to: 60 in: 1.5) open"	"(EventList scaleFrom: 36 to: 84 in: 2) play"	| size arr4 ndur |	size := (stop - start) abs.	ndur := (dur / size).	arr4 := Array new: size + 1.	start &gt; stop		ifTrue: [0 to: size do: [ :i | arr4 at: i+1 put: (start - i)]]		ifFalse: [0 to: size do: [ :i | arr4 at: i+1 put: (start + i)]].	^EventList named: EventList nextName  		fromSelectors: #(duration: loudness: pitch:) 		values: (Array with: ndur with: 120 with: arr4)</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [100 "e ampl asRatio value"]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/i1/pn' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [1.0 "e ampl asRatio value"]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/i1/pn' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e :v  |  | arr |	arr := Array		with: e duration asSec value		with: e pitch asHz value		with: (v loudness isNil			ifTrue: [2.0 "e ampl asRatio value"]			ifFalse: [e ampl asRatio value * v loudness value]).	TypedOSCMessage for: '/i1/pn' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	"CSL string: amp, frq, pos"	^[ :e :v  |  | arr |	arr := Array		with: (v loudness isNil			ifTrue: [e ampl asRatio value]			ifFalse: [e ampl asRatio value * v loudness value])		with: e pitch asHz value		with: 0.0.	TypedOSCMessage for: '/i1/pn' with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="defaultPMap">defaultPMap	"Answer the default parameterMap for use with OSC."	"CSL string: amp, frq, pos"	^[ :e :v  |  | arr |	arr := Array		with: (v loudness isNil			ifTrue: [e ampl asRatio value]			ifFalse: [e ampl asRatio value * v loudness value])		with: e pitch asHz value		with: Random new next.	TypedOSCMessage for: '/i1/pn' with: arr]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '6:00:36 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 6:00:36 PM on July 15, 2020."</do-it><methods><class-id>Siren.MIDIVoice class</class-id> <category>examples</category><body package="Siren" selector="walk:pitch:dur:amp:chan:">walk: num pitch: pitch1 dur: dur amp: am chan: ch	"Play a random walk on a voice on a device on a port."	"MIDIVoice randomWalk: 100 pitch: 96 dur: 0.12 amp: #ppp"	| eList voice pit steps du ampl |	eList := EventList new.	pit := pitch1.	steps := #(0 0 0 0 1 -1).	du := dur sec.	ampl := am ampl.	num timesRepeat: 		[eList add: (du, pit pitch, ampl).		pit := pit + steps atRandom].	eList computeDuration.	voice := MIDIVoice default.	voice channel: ch.	eList playOn: voice.	^Array with: eList duration with: voice</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start7">start7	"Start player 7 runnning a MIDI random walk thread"	self startPlayer: 7 with: [MIDIVoice walk: 100 pitch: 108 dur: 0.11 amp: 120 chan: 1]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start8">start8	"Start player 8 runnning a MIDI random walk thread"	self startPlayer: 8 with: [MIDIVoice walk: 100 pitch: 89 dur: 0.115 amp:90 chan: 2]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start9">start9	"Start player 9 runnning a MIDI random walk thread"	self startPlayer: 9 with: [MIDIVoice walk: 100 pitch: 80 dur: 0.09 amp: 70 chan: 3]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice randomWalk: 100 pitch: 72 dur: 0.085 amp: 90 chan: 4]</body></methods><methods><class-id>Siren.ClusterEditor</class-id> <category>players</category><body package="Siren" selector="start10">start10	self startPlayer: 10 with: [MIDIVoice walk: 100 pitch: 72 dur: 0.085 amp: 90 chan: 4]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 15, 2020' '6:15:34 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 6:15:34 PM on July 15, 2020."</do-it><do-it>	Date today weekday size odd printString</do-it><do-it> | me |	me := Siren.Duration value: 1/8.	Transcript cr; show: me printString, ' = ',		me asSec printString, ' = ',		me asUsec printString; cr</do-it><do-it>440 Hz, (1/4 beat), 44 dB</do-it><do-it> | c |	c := (Cloud dur: 6			"lasts 6 sec."		pitch: (48 to: 60)  		"with pitches in this range"		ampl: (80 to: 120) 		"and amplitudes in this range"		voice: (1 to: 1)			"select from these voices"		density: 5) eventList.	"play 5 notes per sec. and get the event list"	c open</do-it><do-it>(DynamicCloud dur: 6  		pitch: #((30 to: 49) (60 to: 60))	"given starting and ending selection ranges"		ampl: #((20 to: 40) (90 to: 120))		voice: #((1) (1))		density: 12) open</do-it><do-it>(SelectionCloud dur: 4  		pitch: ((NeapolitanMinor root: N do) asPitchesInOctave: 4)		ampl: #(80 40 120)		voice: #(1)		density: 12) open</do-it><do-it> | c |	c := (DynamicSelectionCloud dur: 6		pitch: #( #(53 50 52) #(72 74 75) )	"starting and ending pitch sets"		ampl: #(40 60 30)		voice: #(1)		density: 12) eventList.	c addAll: (DynamicSelectionCloud dur: 6		pitch: #( #(76 78 80) #(60 62 64) )	"starting and ending pitch sets"		ampl: #(40 60 30)		voice: #(1)		density: 16) eventList.	c open</do-it><do-it>DisplayListView colorClassListExample</do-it><do-it>Duration generalize: (100 msec) and: ((1/4) beat)</do-it><do-it>PortMidiInterface</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 17, 2020' '12:53:26 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 12:53:26 PM on July 17, 2020."</do-it><class><name>Score11</name><environment>Siren</environment><super>Siren.EventList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-Events</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventList}	indexedType: #none	private: false	instanceVariableNames: ' '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'</do-it><class><name>Score11</name><environment>Siren</environment><super>Siren.EventList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-Events</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventList}	indexedType: #none	private: false	instanceVariableNames: 'generators'	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'</do-it><do-it>#(1.0 1.0 5.0)</do-it><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; block)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)In Smalltalk,	s11 := (Score11 instrument: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4'));		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'));		add: #p5 -&gt; #(1.0 1.0 5.0));		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 events playKeywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)In Smalltalk,	s11 := (Score11 instrument: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4'));		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'));		add: #p5 -&gt; #(1.0 1.0 5.0));		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 events playKeywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><do-it>Siren.Score11 class organization addCategory: #'instance creation' before: nil</do-it><methods><class-id>Siren.Score11 class</class-id> <category>instance creation</category><body package="(none)" selector="instrument:from:to:">instrument: iNum from: start to: stop	"Answer an initialize instance of Score11"	^(self new initialize) instrument: iNum; from: start; to: stop</body></methods><class><name>Score11</name><environment>Siren</environment><super>Siren.EventList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generators instrument start stop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-Events</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventList}	indexedType: #none	private: false	instanceVariableNames: 'generators instrument start stop'	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'</do-it><do-it>Siren.Score11 organization addCategory: #accessing before: nil</do-it><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="instrument:">instrument: inst	instrument := inst</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="start:">start: val	start := val</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="stop:">stop: val	stop := val</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="add:">add: instAssoc	"Add a generator clause to the receiver"	generators at: instAssoc key put: instAssoc value</body></methods><do-it>Siren.Score11 organization addCategory: #'initialize-release' before: nil</do-it><methods><class-id>Siren.Score11</class-id> <category>initialize-release</category><body package="(none)" selector="initialize">initialize	"Initialize an instance with default state."	generators := Dictionary new</body></methods><do-it> (Score11 instrument: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).</do-it><do-it>Siren.Score11 organization addCategory: #generators before: #'initialize-release'</do-it><do-it>Siren.Score11 reorganizeFromString: '(''generators'')(''initialize-release'' #initialize)(''accessing'' #add: #instrument: #start: #stop:)'</do-it><do-it>Siren.Score11 reorganizeFromString: '(''generators'')(''initialize-release'' #initialize)(''accessing'' #add: #instrument: #start: #stop:)'</do-it><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #instrument: #start: #stop:)(''generators'')'</do-it><class><name>Score11</name><environment>Siren</environment><super>Siren.EventGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generators instrument start stop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-Events</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: 'generators instrument start stop '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'</do-it><do-it>Siren.Score11 organization addCategory: #playing before: nil</do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList |	eList := EventList new.	^eList</body></methods><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #instrument: #start: #stop:)(''playing'' #eventList)(''generators'')'</do-it><do-it>Siren.Score11 organization renameCategory: #generators to: #'private-generators'</do-it><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)In Smalltalk,	s11 := (Score11 instrument: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 eventsKeywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param |	eList := EventList new.	param := generators at: #p3.	param ifNil: [].	param isAssociation ifFalse: [].		^eList</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>instance creation</category><body package="(none)" selector="instr:from:to:">instr: iNum from: start to: stop	"Answer an initialize instance of Score11"	^(self new initialize) instrument: iNum; from: start; to: stop</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param |	eList := EventList new.	param := generators at: #p3.	param ifNil: [self error: 'No duration data?'].	self writeRH: eList.		^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: param into: eList		"Parse and process the RH keyword to generate events"	param isAssociation ifFalse: [].</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param |	eList := EventList new.	param := generators at: #p3.	param ifNil: [self error: 'No duration data?'].	self writeRH: param into: eList.		^eList</body></methods><do-it>(1 -&gt; 2) isAssociation</do-it><do-it>1 isAssociation</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: param into: eList		"Parse and process the RH keyword to generate events"	| key val |	param isAssociation ifFalse:		"handle non-rh arrays"		[].	key := param key.	val := param value.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3:into:">writeP3: param into: eList		"Parse and process the RH keyword to generate events"	| key val |	param isAssociation ifFalse:		"handle non-rh arrays"		[].	key := param key.	val := param value.</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param |	eList := EventList new.	param := generators at: #p3.	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.		^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3:into:">writeP3: param into: eList		"Parse and process the RH keyword to generate events"	| key val |	param isAssociation ifFalse:		"handle non-rh arrays"		[^self writeRMov: param into: eList].	key := param key.	val := param value.	key == #rh ifTrue: [^self writeRH: val into: eList].</body></methods><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)Smalltalk example	s11 := (Score11 instr: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 eventsKeywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><do-it>1 to: 5</do-it><do-it>1 to: 5</do-it><do-it>1 to: 5</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>self atRandom</do-it><do-it>100 timesRepeat: [Transcript show: self atRandom printString; cr]</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRandRH:into:">writeRandRH: array into: eList		"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| tim rnd |	tim := start. 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[| rng |		rng := (array at: 2) to: (array last).		[tim &lt;= stop] whileTrue:			[ | dur |			dur := rng atRandom: rnd.			eList add: (MusicEvent dur: dur).			tim := tim + dur]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRandRH:into:">writeRandRH: array into: eList		"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| tim rnd |	tim := start. 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | rng |		rng := (array at: 2) to: (array last).		[tim &lt;= stop] whileTrue:			[ | dur |			dur := rng atRandom: rnd.			eList add: (MusicEvent dur: dur).			tim := tim + dur].		^self].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3:into:">writeP3: param into: eList		"Parse and process the RH keyword to generate events"	| key val |	param isAssociation ifFalse:		"handle non-rh arrays"		[^self writeRandRH: param into: eList].	key := param key.	val := param value.	key == #rh ifTrue: [^self writeRH: val into: eList].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: param into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4');"	| key val |	param isAssociation ifFalse:		"handle non-rh arrays"		[].	key := param key.	val := param value.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: param into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4');"	| key val |	param isAssociation ifFalse:		"expect rh assoc"		[self error: 'Mal-formed duration data?'].	key := param key.	val := param value.</body></methods><do-it>'4/8*6/4' isString</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| ind val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	ind := 1.	val := vString copyUpTo: $/.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm ind val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	ind := 1.	val := strm upTo: $/.	val := val asNumber.</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Score11</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Score11</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '2:28:22 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 2:28:22 PM on July 22, 2020."</do-it><do-it>((Siren.Score11 instr: 1 from: 0 to: 10) add: #p3 -&gt; (#rh -&gt; '4/8*6/4'); add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); add: #p5 -&gt; #(1.0 1.0 5.0); add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) events</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[strm atEnd and: [tim &lt;= stop]] whileFalse:		[val := strm upTo: $/.		val = '/' ifFalse: [num := val asNumber].		eList add: (MusicEvent dur: num).		tim := tim + num]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[strm atEnd and: [tim &lt;= stop]] whileFalse:		[val := strm upTo: $/.		val = '/' ifFalse: [num := val asNumber].		eList add: (MusicEvent dur: num).		tim := tim + num]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRandRH:into:">writeRandRH: array into: eList		"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| tim rnd |	tim := start. 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | rng |		rng := (array at: 2) to: (array last).		[tim &lt;= stop] whileTrue:			[ | dur |			dur := rng atRandom: rnd.			eList add: (MusicEvent dur: dur voice: instrument).			tim := tim + dur].		^self].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[strm atEnd and: [tim &lt;= stop]] whileFalse:		[val := strm upTo: $/.		val = '/' ifFalse: [num := val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num]</body></methods><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)Smalltalk example	s11 := (Score11 instr: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 events((Siren.Score11 instr: 1 from: 0 to: 10) add: #p3 -&gt; (#rh -&gt; '4//8////4//'); add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); add: #p5 -&gt; #(1.0 1.0 5.0); add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) eventListKeywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><comment><class-id>Siren.Score11</class-id><body>instr: iNum from: start to: stop	"Answer an initialize instance of Score11"	^(self new initialize) instrument: iNum; start: start; stop: stop</body></comment><remove-selector><class-id>Siren.Score11 class</class-id> <selector>instrument:from:to:</selector></remove-selector><do-it>Siren.Score11 instr: 1 from: 0 to: 10</do-it><do-it>Siren.Score11 instr: 1 from: 0 to: 10</do-it><do-it>self new initialize</do-it><do-it>(self new initialize) instrument: iNum</do-it><methods><class-id>Siren.Score11 class</class-id> <category>instance creation</category><body package="(none)" selector="instr:from:to:">instr: iNum from: start to: stop	"Answer an initialize instance of Score11"	"((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	^(self new initialize) instrument: iNum; start: start; stop: stop</body></methods><do-it>Siren.Score11 instr: 1 from: 0 to: 10</do-it><do-it>(Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].self halt.	strm := ReadStream on: vString.	tim := start.	[strm atEnd and: [tim &lt;= stop]] whileFalse:		[val := strm upTo: $/.		val = '/' ifFalse: [num := val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num]</body></methods><do-it>val = '/' </do-it><do-it>MusicEvent dur: num voice: instrument</do-it><do-it>strm upTo: $/.</do-it><do-it>strm upTo: $/.</do-it><do-it>strm upTo: $/.</do-it><do-it> strm upTo: $/.</do-it><do-it>	strm := ReadStream on: vString.</do-it><do-it>	strm := ReadStream on: vString.</do-it><do-it>strm := ReadStream on: vString.</do-it><do-it>[strm atEnd and: [tim &lt;= stop]] whileFalse:		[val := strm upTo: $/.		Transcript show: val printString; cr.		val isEmpty ifTrue: [val := strm upTo: $/.			Transcript show: val printString; cr]].</do-it><do-it>	eList := EventList new.</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[strm atEnd and: [tim &lt;= stop]] whileFalse:		[val := strm upTo: $/.		val isEmpty ifFalse: [num := val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[strm atEnd or: [tim &gt; stop]] whileFalse:		[val := strm upTo: $/.		val isEmpty ifFalse: [num := val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[strm atEnd or: [tim &gt; stop]] whileFalse:		[val := strm upTo: $/.		val isEmpty ifFalse: [num := 1.0 / val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num]</body></methods><do-it>((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num tim val |	vString isString ifFalse:		"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.		val isEmpty ifFalse: [num := 1.0 / val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num.		strm atEnd ifTrue: [strm := ReadStream on: vString]]</body></methods><do-it>((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num cnt tim val |	vString isString ifFalse:				"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.				"read to next $/ "		(val includes: $*) ifTrue: [self halt.].		" handle * expressions"		val isEmpty ifFalse: [num := 1.0 / val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num.		strm atEnd ifTrue: [strm := ReadStream on: vString]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num cnt tim val |	vString isString ifFalse:					"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*) ifTrue: [self halt.].	"handle * expressions"		val isEmpty ifFalse: [num := 1.0 / val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num.		strm atEnd ifTrue: [strm := ReadStream on: vString]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num cnt tim val |	vString isString ifFalse:						"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*) ifTrue: 			[ | str2 | self halt.			str2 := ReadStream on: val.			num := 1.0 / (str2 upTo: $*) asNumber.			str2 skip: 1.			cnt := str2 upToEnd asNumber].		"handle * expressions"		val isEmpty ifFalse: [num := 1.0 / val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num.		strm atEnd ifTrue: [strm := ReadStream on: vString]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num cnt tim val |	vString isString ifFalse:						"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*) ifTrue: 			[ | str2 | self halt.			str2 := ReadStream on: val.			num := 1.0 / (str2 upTo: $*) asNumber.			"str2 skip: 1"			cnt := str2 upToEnd asNumber].		"handle * expressions"		val isEmpty ifFalse: [num := 1.0 / val asNumber].		eList add: (MusicEvent dur: num voice: instrument).		tim := tim + num.		strm atEnd ifTrue: [strm := ReadStream on: vString]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: vString into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*6/4' isString);"	| strm num cnt tim val |	vString isString ifFalse:						"expect rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: vString.	tim := start.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [val isEmpty ifFalse: [num := 1.0 / val asNumber].			eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num.			strm atEnd ifTrue: [strm := ReadStream on: vString]]]</body></methods><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8*4/4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*5/4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*34/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '4:31:25 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 4:31:25 PM on July 22, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: key required: isReq as: property into: eList	"Execute the generator for the given key and property"	| param |	param := generators at: #key.	(isReq and: [param isNil])		ifTrue: [self error: 'No duration data?'].	self writeP3: param into: eList.	</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>instance creation</category><body package="(none)" selector="instr:from:to:">instr: iNum from: start to: stop	"Answer an initialize instance of Score11"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	^(self new initialize) instrument: iNum; start: start; stop: stop</body></methods><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)Smalltalk example	s11 := (Score11 instr: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 events((Siren.Score11 instr: 1 from: 0 to: 10) add: #p3 -&gt; (#rh -&gt; '4//8////4//'); add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); add: #p5 -&gt; #(1.0 1.0 5.0); add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) eventList	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"Keywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><methods><class-id>Siren.Score11 class</class-id> <category>instance creation</category><body package="(none)" selector="instr:from:to:">instr: iNum from: start to: stop	"Answer an initialize instance of Score11"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	^(self new initialize) instrument: iNum; start: start; stop: stop</body></methods><do-it>((Siren.Score11 instr: 1 from: 0 to: 10) add: #p3 -&gt; (#rh -&gt; '4//8////4//'); add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); add: #p5 -&gt; #(1.0 1.0 5.0); add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) eventList</do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList new.						"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness into: eList.	keys remove: #p5 ifAbsent: [nil].	^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: key required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList."	| param |	param := generators at: #key.	(isReq and: [param isNil])		ifTrue: [self error: 'No data for ', property, '?'].	</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: key required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0);   "	| param |	param := generators at: #key.	(isReq and: [param isNil])		ifTrue: [self error: 'No data for ', property, '?'].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0);   "	| item key val |	item := generators at: #param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | rng |		rng := (array at: 2) to: (array last).		eList eventsDo:			[ :evt | 			evt perform: property with: (rng atRandom: rnd)].		^self].self halt.</body></methods><do-it>	item := generators at: param.</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0);   "	| item key val |	item := generators at: #param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSequential:from:into:">writeSequential: property from: val into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "self halt.</body></methods><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)Smalltalk examples	s11 := (Score11 instr: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 events	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"Keywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSequential:from:into:">writeSequential: property from: vString into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts |	strm := ReadStream on: vString.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | val cnt evt num | 		evt := (evts at: ind) event.		val := strm upTo: $/.					"read to next $/ "		(val includes: $*)					"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := (str2 upTo: $*).				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[evt perform: property with: num.					ind := ind + 1.					evt := (evts at: ind) event]]			ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0);   "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList]</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList new.						"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	^eList</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TimeSequenceView</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>TimeSequenceView</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>(Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))</do-it><do-it>((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><class><name>Score11</name><environment>Siren</environment><super>Siren.EventGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generators paramMap instrument start stop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-EventGenerators</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: 'generators paramMap instrument start stop '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'</do-it><methods><class-id>Siren.Score11</class-id> <category>initialize-release</category><body package="(none)" selector="initialize">initialize	"Initialize an instance with default state."	generators := Dictionary new.	paramMap := Dictionary new</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="assign:to:">assign: param to: property	"Add a parameter map clause to the receiver"	paramMap at: param put: property</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)).	s11 assign: #p6 to: #position:.	s11 eventList inspect </do-it><do-it>#ss, ':'</do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList new.						"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList new.						"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	^eList</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)).	s11 assign: #p6 to: #position:.	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p5 -&gt; #(1.0 1.0 5.0);   "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].</body></methods><comment><class-id>Siren.Score11</class-id><body>Score11 is a port of a Score11 instrument; see https://www.esm.rochester.edu/ears/docs/score11/index.htmlInstance Variables:	generators	&lt;Dictionary of (prop-name -&gt; data)&gt;	the parameter blocks of the score11 instrumentExamples:instrument 1 0 10;	&lt; Instrument 1 starts at time 0 and plays for 10 beats.	parameter 3 1; 	&lt; Each note lasts 1 beatend;          			&lt; This finishes the I-blocki1 0 5;	p3 rh 4/8*6/4;	p4 no c4/d/e/f/g/a/b/c5;	p5 1.0 1.0 5.0;    			&lt; 100% of values between 1.0 and 5.0	p6 mo 5 1000 2000;		&lt; move from 1000 to 2000 in 5 beatsend;Standard parameter maps -- the SCORE-11 constant parameter meanings are:      p1 = Instrument number      p2 = Starting time for this note (in beats) (not normally used)      p3 = Duration for this note (in beats)      p4 = Pitch (or frequency)      p5 = Amplitude value (0 - 32000)Smalltalk examples	s11 := (Score11 instr: 1 from: 0 to: 10)		add: #p3 -&gt; (#rh -&gt; '4/8*6/4');		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5');		add: #p5 -&gt; #(1.0 1.0 5.0);		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000)).	s11 events	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	"TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList"	[ | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)).	s11 assign: #p6 to: #position:.	s11 eventList inspect ]Keywords requiring a parameter number:	1. funcs	2. move	3. movex	4. notes	5. numbers	6. rhythms	7. rlist	8. rnotes	9. setsKeywords not using a parameter number:	1. ampfac	2. beat	3. duty_factor	4. end	5. instrument (valid as 'i')	6. parameter (valid as 'p')	7. rdeviation	8. rrests	9. rseed	10. tempo	11. tfactor</body></comment><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	| evts |	evts := eList events.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | v0 v1 vDiff t0 t1 tDiff |		v0 := array at: 2.		v1 := array last.		vDiff := v1 - v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			tScale := (tn - t0) / tDiff.			val := v0 + (vDiff * tScale).			eAss event perform: property with: val].		^self].self halt.</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)).	s11 assign: #p6 to: #position:.	s11 eventList inspect </do-it><do-it>(-1.0 to: 1.0) atRandom</do-it><do-it>(-1.0 to: 1.0) atRandom</do-it><do-it>(-1.0 to: 1.0) atRandom</do-it><do-it>(-1.0 to: 1.0) atRandom</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | rng |		rng := (array at: 2) to: (array last).		eList eventsDo:			[ :evt | 			evt perform: property with: (rng atRandom: rnd)].		^self].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[eList eventsDo:			[ :evt | 			evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].		^self].self halt.</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)).	s11 assign: #p6 to: #position:.	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd ranges | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[eList eventsDo:			[ :evt | 			evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].		^self].	ranges := self parseRanges: array.	eList eventsDo:		[ :evt | | val |		val := rnd next.		evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '6:49:26 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 6:49:26 PM on July 22, 2020."</do-it><do-it>7 \\ 3</do-it><do-it>6 \\ 3</do-it><do-it>6 \\ 3 == 0</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="parseRanges:">parseRanges: array	"Parse  random lists into a list of interval associations"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| ranges sum scale | 	array size \\ 3 == 0 ifTrue:			"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	ranges := OrderedCollection new.	sum := 0.0.	1 to: array size by: 3 do:		[ :cnt | | rat lo hi |		rat := array at: cnt.		lo := array at: cnt + 1.		hi := array at: cnt + 2.		ranges addLast: (rat -&gt; (lo to: hi)).		sum := sum + rat].	scale := 1.0 / sum.					"scale ranges"	sum := 0.0.	ranges do:		[ :ass | | rat |		rat := ass key.		ass key: sum.		sum := sum + (rat * scale)].	</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd ranges | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[eList eventsDo:			[ :evt | 			evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].		^self].	ranges := self parseRanges: array.	eList eventsDo:		[ :evt | | val rng |		val := rnd next.				"get a rand 0-1 to select which range we'll use"		ranges do: [ :ass |			ass key &lt; val ifFalse: [rng := ass value]].		evt perform: property with: (rnd nextFrom: rng start to: rng stop)].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd ranges | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[eList eventsDo:			[ :evt | 			evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].		^self].	ranges := self parseRanges: array.	eList eventsDo:		[ :evt | | val rng |		val := rnd next.				"get a rand 0-1 to select which range we'll use"		ranges do: [ :ass |			ass key &lt; val ifFalse: [rng := ass value]].		evt perform: property with: (rnd nextFrom: rng start to: rng stop)].</body></methods><do-it>array size \\ 3</do-it><do-it>array size \\ 3 = 0</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="parseRanges:">parseRanges: array	"Parse  random lists into a list of interval associations"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| ranges sum scale | 	array size \\ 3 = 0 ifFalse:			"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	ranges := OrderedCollection new.	sum := 0.0.	1 to: array size by: 3 do:		[ :cnt | | rat lo hi |		rat := array at: cnt.		lo := array at: cnt + 1.		hi := array at: cnt + 2.		ranges addLast: (rat -&gt; (lo to: hi)).		sum := sum + rat].	scale := 1.0 / sum.					"scale ranges"	sum := 0.0.	ranges do:		[ :ass | | rat |		rat := ass key.		ass key: sum.		sum := sum + (rat * scale)].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="parseRanges:">parseRanges: array	"Parse  random lists into a list of interval associations"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| ranges sum scale | 	array size \\ 3 = 0 ifFalse:			"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	ranges := OrderedCollection new.	sum := 0.0.	1 to: array size by: 3 do:		[ :cnt | | rat lo hi |		rat := array at: cnt.		lo := array at: cnt + 1.		hi := array at: cnt + 2.		ranges addLast: (rat -&gt; (lo to: hi)).		sum := sum + rat].	scale := 1.0 / sum.					"scale ranges"	sum := 0.0.	ranges do:		[ :ass | | rat |		rat := ass key.		ass key: sum.		sum := sum + (rat * scale)].	^ranges</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="parseRanges:">parseRanges: array	"Parse  random lists into a list of interval associations"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| ranges sum scale | 	array size \\ 3 = 0 ifFalse:			"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	ranges := OrderedCollection new.	sum := 0.0.	1 to: array size by: 3 do:		[ :cnt | | rat lo hi |		rat := array at: cnt.		lo := array at: cnt + 1.		hi := array at: cnt + 2.		ranges addLast: (rat -&gt; (lo to: hi)).		sum := sum + rat].	scale := 1.0 / sum.					"scale ranges"	sum := ranges first key * scale.	ranges do:		[ :ass | | rat |		rat := ass key.		ass key: sum.		sum := sum + (rat * scale)].	^ranges</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="parseRanges:">parseRanges: array	"Parse  random lists into a list of interval associations"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| ranges sum scale | 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	ranges := OrderedCollection new.	sum := 0.0.	1 to: array size by: 3 do:		[ :cnt | | rat lo hi |		rat := array at: cnt.		lo := array at: cnt + 1.		hi := array at: cnt + 2.		ranges addLast: (rat -&gt; (lo to: hi)).		sum := sum + rat].	scale := 1.0 / sum.					"scale ranges"	sum := ranges first key * scale.	ranges do:		[ :ass | | rat |		rat := ass key.		ass key: sum.		sum := sum + (rat * scale)].	^ranges</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd ranges | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[eList eventsDo:			[ :evt | 			evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].		^self].	ranges := self parseRanges: array.	eList eventsDo:		[ :evt | | val rng |		val := rnd next.				"get a rand 0-1 to select which range we'll use"		ranges do: [ :ass |			ass key &lt; val ifTrue: [rng := ass value]].		evt perform: property with: (rnd nextFrom: rng first to: rng stop)].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="parseRanges:">parseRanges: array	"Parse  random lists into a list of interval associations"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| ranges sum scale | 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	ranges := OrderedCollection new.	sum := 0.0.	1 to: array size by: 3 do:		[ :cnt | | rat lo hi |		rat := array at: cnt.		lo := array at: cnt + 1.		hi := array at: cnt + 2.		ranges addLast: (rat -&gt; (lo to: hi)).		sum := sum + rat].	scale := 1.0 / sum.					"scale ranges"	sum := 0.0. "ranges first key * scale."	ranges do:		[ :ass | | rat |		rat := ass key.		ass key: sum.		sum := sum + (rat * scale)].	^ranges</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1.0 2.0  0.5 0.1 0.2)).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 10 100))"	| evts |	evts := eList events.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | v0 v1 vDiff t0 t1 tDiff |		v0 := array at: 2.		v1 := array last.		vDiff := v1 - v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			tScale := (tn - t0) / tDiff.			val := v0 + (vDiff * tScale).			eAss event perform: property with: val].		^self].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: array into: eList	"Parse and process the linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	| evts |	evts := eList events.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | v0 v1 vDiff t0 t1 tDiff |		v0 := array at: 2.		v1 := array last.		vDiff := v1 - v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			tScale := (tn - t0) / tDiff.			val := v0 + (vDiff * tScale).			eAss event perform: property with: val].		^self].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 10 100))"	| evts |	evts := eList events.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | v0 v1 vDiff t0 t1 tDiff |		v0 := array at: 2.		v1 := array last.		vDiff := v1 / v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			tScale := (tn - t0) / tDiff.			val := v0 + (vDiff * tScale).			eAss event perform: property with: val].		^self].self halt.</body></methods><do-it>'20 .1 .2 .3 .4' asWordArray</do-it><do-it> '20 .1 .2 .3 .4' piecesCutWhere:  [:each :next | each = $ ]</do-it><do-it>'20 .1 .2 .3 .4' piecesCutWhere:  [:each :next | next = $ ] </do-it><do-it>'brave new world' tokensBasedOn: Character space</do-it><do-it>'20 .1 .2 .3 .4' tokensBasedOn: Character space</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	| toks rnd |	toks := vString tokensBasedOn: Character space.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '8:11:31 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 8:11:31 PM on July 22, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))"	| evts |	evts := eList events.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | v0 v1 vDiff t0 t1 tDiff |		v0 := array at: 2.		v1 := array last.		vDiff := v1 / v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			tScale := (tn - t0) / tDiff.			val := v0 * (vDiff raisedTo: tScale).			eAss event perform: property with: val].		^self]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: array into: eList	"Parse and process the linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	| evts |	evts := eList events.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | v0 v1 vDiff t0 t1 tDiff |		v0 := array at: 2.		v1 := array last.		vDiff := v1 - v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			tScale := (tn - t0) / tDiff.			val := v0 + (vDiff * tScale).			eAss event perform: property with: val].		^self]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));		add: #p9 -&gt; (#mx -&gt; #(10 1 100))	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p5 -&gt; #(1.0 1.0 5.0);   "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));		add: #p9 -&gt; (#mx -&gt; #(10 1 100))	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect </do-it><do-it>'20 .1 .2 .3 .4' tokensBasedOn: Character space</do-it><do-it>('20 .1 .2 .3 .4' tokensBasedOn: Character space) removeFirst</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space) removeFirst.ar</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar atRandom:  Random new</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar atRandom:  Random new</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar atRandom:  Random new</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar atRandom:  Random new</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar atRandom:  Random new</do-it><do-it>| ar |ar := ('20 .1 .2 .3 .4' tokensBasedOn: Character space).ar removeFirst.ar atRandom:  Random new</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	| toks rnd tim |	toks := vString tokensBasedOn: $ .	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: toks into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; #(10 1 3 5 7 9)); "	| rnd tim |	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: arr into: eList	"Parse and process the random RH keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; #(10 1 3 5 7 9)); "	| toks rnd tim |	toks := arr asOrderedCollection.	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><do-it> -</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '8:50:46 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 8:50:46 PM on July 22, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	| toks rnd tim |	toks := vString tokensBasedOn: $ .	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="tempo:">tempo: arr	"Set the tempo curve of the receiver"	properties at: #tempo put: arr</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #());"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	data isNumber ifTrue:						"rh number"		[num := 1.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	tim := start.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [val isEmpty ifFalse: [num := 1.0 / val asNumber].			eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num.			strm atEnd ifTrue: [strm := ReadStream on: data]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #());"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	data respondsToArithmetic ifTrue:				"rh number"		[num := 1.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	tim := start.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [val isEmpty ifFalse: [num := 1.0 / val asNumber].			eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num.			strm atEnd ifTrue: [strm := ReadStream on: data]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #());"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:				"rh number"		[num := 1.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [val isEmpty ifFalse: [num := 1.0 / val asNumber].			eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num.			strm atEnd ifTrue: [strm := ReadStream on: data]]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(10 4 100))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #());"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:				"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.					"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].			eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num.			strm atEnd ifTrue: [strm := ReadStream on: data]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #());"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].			eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num.			strm atEnd ifTrue: [strm := ReadStream on: data]]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(10 4 100))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><do-it>Siren.Score11 organization addCategory: #private before: #'private-generators'</do-it><do-it>Siren.Score11 organization classify: #parseRanges: under: #private</do-it><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #assign:to: #instrument: #start: #stop: #tempo:)(''playing'' #eventList)(''private-generators'' #populate:required:as:into: #writeMove:from:into: #writeMoveX:from:into: #writeP3:into: #writeRH:into: #writeRand:from:into: #writeRandRH:into: #writeSequential:from:into: #writeSet:from:into:)(''private'' #parseRanges:)'</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move   "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= tOffset + segDur]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val].			tOffset := tOffset + segDur]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val].			tOffset := tOffset + segDur]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges']. self halt.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := evts first key asSec value.		t1 := evts last key asSec value.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val].			tOffset := tOffset + segDur]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges']. self halt.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val].			tOffset := tOffset + segDur]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges']. self halt.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val.Transcript show: val printString; cr].			tOffset := tOffset + segDur]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val.Transcript show: val printString; cr].			tOffset := tOffset + segDur]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val.Transcript show: val printString; cr]].			tOffset := tOffset + segDur]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale).				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mx -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: array into: eList	"Parse and process the linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	| evts tOffset |	evts := eList events.	tOffset := 0. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 - v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := (v0 + (vDiff * tScale)) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move   "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNumerical:from:into:">writeNumerical: property from: vString into: eList	"Parse and process the numerical keyword to generate events"	"aScore11 add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5' "	| strm ind evts |	strm := ReadStream on: vString.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | val cnt evt num | 		evt := (evts at: ind) event.		val := strm upTo: $/.					"read to next $/ "		(val includes: $*)					"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := (str2 upTo: $*).				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[evt perform: property with: num.					ind := ind + 1.					evt := (evts at: ind) event]]			ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNumerical:from:into:">writeNumerical: property from: vString into: eList	"Parse and process the numerical keyword to generate events"	"aScore11 add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5') "	| strm ind evts |	strm := ReadStream on: vString.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | val cnt evt num | 		evt := (evts at: ind) event.		val := strm upTo: $/.					"read to next $/ "		(val includes: $*)					"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := (str2 upTo: $*).				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[evt perform: property with: num.					ind := ind + 1.					evt := (evts at: ind) event]]			ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences   "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '10:31:29 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 10:31:29 PM on July 22, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences 	 "	| item key val |	item := generators at: param.	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3:into:">writeP3: param into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); "	| key val |	param isAssociation ifFalse:		"handle non-rh arrays - rand sequences"		[^self writeRandRH: param into: eList].	key := param key.	val := param value.	key == #rh ifTrue: [^self writeRH: val into: eList].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRand:from:into:">writeRand: property from: array into: eList	"Parse and process the random keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| rnd ranges | 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[eList eventsDo:			[ :evt | 			evt perform: property with: (rnd nextFrom: (array at: 2) to: (array last))].		^self].	ranges := self parseRanges: array.	eList eventsDo:		[ :evt | | val rng |		val := rnd next.				"get a rand 0-1 to select which range we'll use"		ranges do: [ :ass |			ass key &lt; val ifTrue: [rng := ass value]].		evt perform: property with: (rnd nextFrom: rng first to: rng stop)].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSequential:from:into:">writeSequential: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts |	strm := ReadStream on: vString.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | val cnt evt num | 		evt := (evts at: ind) event.		val := strm upTo: $/.					"read to next $/ "		(val includes: $*)					"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := (str2 upTo: $*).				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[evt perform: property with: num.					ind := ind + 1.					evt := (evts at: ind) event]]			ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString].		ind := ind + 1].	^self</body></methods><do-it>'4..' copyWithout: $.</do-it><do-it>'4..' copyWithout: $.</do-it><class><name>RestEvent</name><environment>Siren</environment><super>Siren.DurationEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-Events</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #RestEvent	superclass: #{Siren.DurationEvent}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'</do-it><comment><class-id>Siren.RestEvent</class-id><body>RestEvents are rarely used. They represent regular DurationEvents but never play themselves.</body></comment><do-it>Siren.RestEvent organization addCategory: #scheduling before: nil</do-it><methods><class-id>Siren.RestEvent</class-id> <category>scheduling</category><body package="(none)" selector="play">play	"Play the receiver by ignoring it."	^nil</body></methods><methods><class-id>Siren.RestEvent</class-id> <category>scheduling</category><body package="(none)" selector="playAt:">playAt: aTime	"Play the receiver on its voice then."		^nil</body></methods><methods><class-id>Siren.RestEvent</class-id> <category>scheduling</category><body package="(none)" selector="scheduleAt:">scheduleAt: aTime	"Play the receiver on its voice then."	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [ | | 						val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4 4. 4.. 8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD | self halt.					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD | self halt.					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD | self halt.					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/4./4../8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><do-it>| st |st := ReadStream on: '4/4./4../8'.5 timesRepeat: [Transcript show: (st upTo: $/); cr]</do-it><do-it>| st |st := ReadStream on: '4/4./4../8'.5 timesRepeat: [Transcript show: (st upTo: $/); cr]</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/4./4../8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><do-it>Siren.RestEvent class organization addCategory: #'instance creation' before: nil</do-it><methods><class-id>Siren.RestEvent class</class-id> <category>instance creation</category><body package="(none)" selector="dur:">dur: aD	"Answer a RestEvent instance initialized with the arguments."	^self new duration: aD</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRH:into:">writeRH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/-4/8/-8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '11:18:36 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 11:18:36 PM on July 22, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 22, 2020' '11:32:29 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 11:32:29 PM on July 22, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 23, 2020' '12:38:10 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 12:38:10 AM on July 23, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: data into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	| toks rnd tim |	data isString		ifTrue:  [toks := data tokensBasedOn: $ ]				"rh string"		ifFalse: [toks := data].	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: data into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	| toks rnd tim |	data isString		ifTrue:  [toks := data tokensBasedOn: $ ]				"rh string"		ifFalse: [toks := data asOrderedCollection].	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));		add: #p9 -&gt; (#mx -&gt; #(10 1 100))	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect </do-it><methods><class-id>Siren.MusicMagnitude</class-id> <category>printing</category><body package="Siren" selector="printString">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream parens: true.	^aStream contents</body></methods><methods><class-id>Siren.MusicMagnitude</class-id> <category>printing</category><body package="Siren" selector="printOn:parens:">printOn: aStream parens: useParens	"Print the receiver on the argument as a MM declaration."self halt.	useParens		ifTrue: [self isImmediate			ifFalse: [aStream nextPutAll: '(', self species name, ': ', 				self printValue, ')']			ifTrue: [aStream nextPutAll: '(', self printValue, self units, ')']]		ifFalse: [self isImmediate			ifFalse: [aStream nextPutAll: self species name, ': ', self printValue]			ifTrue: [aStream nextPutAll: self printValue, self units]]</body></methods><methods><class-id>Siren.MusicMagnitude</class-id> <category>printing</category><body package="Siren" selector="printOn:parens:">printOn: aStream parens: useParens	"Print the receiver on the argument as a MM declaration."self safeHalt.	useParens		ifTrue: [self isImmediate			ifFalse: [aStream nextPutAll: '(', self species name, ': ', 				self printValue, ')']			ifTrue: [aStream nextPutAll: '(', self printValue, self units, ')']]		ifFalse: [self isImmediate			ifFalse: [aStream nextPutAll: self species name, ': ', self printValue]			ifTrue: [aStream nextPutAll: self printValue, self units]]</body></methods><methods><class-id>Siren.MusicMagnitude</class-id> <category>printing</category><body package="Siren" selector="printOn:parens:">printOn: aStream parens: useParens	"Print the receiver on the argument as a MM declaration."	useParens		ifTrue: [self isImmediate			ifFalse: [aStream nextPutAll: '(', self species name, ': ', 				self printValue, ')']			ifTrue: [aStream nextPutAll: '(', self printValue, self units, ')']]		ifFalse: [self isImmediate			ifFalse: [aStream nextPutAll: self species name, ': ', self printValue]			ifTrue: [aStream nextPutAll: self printValue, self units]]</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' ', pitch printString].	loudness == nil"		ifFalse: [aStream nextPutAll: ' (l: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: ' (v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value respondsToArithmetic					ifTrue: [aStream nextPutAll: ' (', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>testing</category><body package="Magnitude-Numbers" selector="isReal">isReal	"Answer whether the receiver is a limited-precision real number"	^true</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>testing</category><body package="Magnitude-Numbers" selector="isLPReal">isLPReal	"Answer whether the receiver is a limited-precision real number"	^true</body></methods><remove-selector><class-id>Core.LimitedPrecisionReal</class-id> <selector>isReal</selector></remove-selector><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Siren" selector="isLPReal">isLPReal	"Answer whether the receiver is a limited-precision real number"	^false</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' ', pitch printString].	loudness == nil"		ifFalse: [aStream nextPutAll: ' (l: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: ' (v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: ' (', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' ', pitch printString].	loudness == nil"		ifFalse: [aStream nextPutAll: ' (l: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: ' (v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: ' (', ass key, ': '. self safeHalt.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' ', pitch printString].	loudness == nil"		ifFalse: [aStream nextPutAll: ' (l: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: ' (v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: ' (', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>private - printing</category><body package="Magnitude-Numbers" selector="printExponentCharacterIfNeededOn:">printExponentCharacterIfNeededOn: aStream	"Floating point numbers other than floats should print their type indicator"	^self"	aStream nextPut: self class exponentCharacter"</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: '	', pitch printString].	loudness == nil"		ifFalse: [aStream nextPutAll: '	(l: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: '	(v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: '	(', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: '	(', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 23, 2020' '5:15:19 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 5:15:19 PM on July 23, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: data into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); ""		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));"	| toks rnd tim |	data isString		ifTrue:  [toks := data tokensBasedOn: $ ]				"rh string"		ifFalse: [toks := data asOrderedCollection].	tim := toks removeFirst.	rnd := Random new.	eList eventsDo: 		[ :evt |		evt perform: property with: (toks atRandom: rnd)]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: array into: eList	"Parse and process the linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	| evts tOffset |	evts := eList events.	tOffset := start. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 - v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := (v0 + (vDiff * tScale)) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) "	| evts tOffset |	evts := eList events.	tOffset := start.  	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSequential:from:into:">writeSequential: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts |	strm := ReadStream on: vString.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					cnt timesRepeat: 						[evt perform: property with: num.						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: data into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); ""		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));"	| toks rnd tim |	data isString		ifTrue:  [toks := data tokensBasedOn: $ ]				"rh string"		ifFalse: [toks := data asOrderedCollection].	tim := toks removeFirst.	rnd := Random new.	eList do: 		[ :eAss | | evt tn |		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[evt perform: property with: (toks atRandom: rnd)]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: data into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); ""		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));"	| toks rnd tim |	data isString		ifTrue:  [toks := data tokensBasedOn: $ ]				"rh string"		ifFalse: [toks := data asOrderedCollection].	tim := toks removeFirst.	rnd := Random new.	eList do: 		[ :eAss | | evt tn |		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (start + tim)]) ifTrue:			[evt perform: property with: (toks atRandom: rnd)]]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 23, 2020' '5:25:53 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 5:25:53 PM on July 23, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 23, 2020' '7:49:39 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 7:49:39 PM on July 23, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5)) 		add: #p5 -&gt; (#mx -&gt; '5 110 100 , 120 140' ) "	| evts tOffset |	(array isString and: [(array detect: [ :ch | ((ch == $,) or: [ch == $/])] ifNone: [nil]) notNil])		ifTrue: [^self writeMoveX2: property from: array into: eList].	evts := eList events.	tOffset := start.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: array into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| evts tOffset |	evts := eList events.	tOffset := start.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100   5 100 5))  ) "	| evts tOffset |	(array isString and: [(array detect: [ :ch | ((ch == $,) or: [ch == $/])] ifNone: [nil]) notNil])		ifTrue: [^self writeMoveX2: property from: array into: eList].	evts := eList events.	tOffset := start.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 23, 2020' '8:19:03 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 8:19:03 PM on July 23, 2020."</do-it><do-it>$,</do-it><do-it>'/,' detect: [ :c | c == $,] ifNone: [nil]</do-it><do-it>(ReadStream on: '100 1 1 , 1 1 / 20 1 1 , .9 1.1') next</do-it><do-it>(ReadStream on: ('100 1 1 , 1 1 / 20 1 1 , .9 1.1' tokensBasedOn: $ )) next</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNumerical:from:into:">writeNumerical: property from: vString into: eList	"Parse and process the numerical keyword to generate events"	"aScore11 add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5') "	| strm ind evts |	strm := ReadStream on: vString.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | val cnt evt num | 		evt := (evts at: ind) event.		val := strm upTo: $/.					"read to next $/ "		(val includes: $*)					"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := (str2 upTo: $*).				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[evt perform: property with: num.					ind := ind + 1.					evt := (evts at: ind) event]]			ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString].		ind := ind + 1].	^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '1:41:01 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 1:41:01 PM on July 24, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff1 vDiff2 |	strm := ReadStream on: (vString tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next.					"read first 3 vals: dur a0 b0"		a0 := strm next.		b0 := strm next.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next.					b1 := strm next].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				(sep = '/') ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff1 := a1 / a0.		vDiff2 := b1 / b0.		evts do:								"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						val := a0 * (vDiff1 raisedTo: tScale) asFloat].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 |	strm := ReadStream on: (vString tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next.					"read first 3 vals: dur a0 b0"		a0 := strm next.		b0 := strm next.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next.					b1 := strm next].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				(sep = '/') ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '2:00:25 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 2:00:25 PM on July 24, 2020."</do-it><do-it>'5' asNumber</do-it><do-it>'/,' includes: sep</do-it><do-it>'/,' includes: sep first</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 |	strm := ReadStream on: (vString tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next.					"read first 3 vals: dur a0 b0"		a0 := strm next.		b0 := strm next.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next.					b1 := strm next].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				(sep = '/') ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '2:06:18 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 2:06:18 PM on July 24, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 |	strm := ReadStream on: (vString tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next.					"read first 3 vals: dur a0 b0"		a0 := strm next.		b0 := strm next.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next.				b1 := strm next.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>vString copyWithout: Character cr.</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	tStr := tStr copyReplaceAll: '  ' with: ' '.	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next.					"read first 3 vals: dur a0 b0"		a0 := strm next.		b0 := strm next.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next.				b1 := strm next.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>'/' = '/' </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	tStr := tStr copyReplaceAll: '  ' with: ' '.	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next.				b1 := strm next.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	tStr := tStr copyReplaceAll: '  ' with: ' '.	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep == $,)						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep == $/)				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next asNumber.				b1 := strm next asNumber.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	tStr := tStr copyReplaceAll: '  ' with: ' '.	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next asNumber.				b1 := strm next asNumber.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>tStr includes: '  '</do-it><do-it>tStr includes: '  '</do-it><do-it>(tStr findString: '  ' startingAt: 1) &gt; 0</do-it><do-it>[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| evts strm rnd t0 t1 tDiff vDiff0 vDiff1 tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next asNumber.				b1 := strm next asNumber.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [a1 := strm next asNumber.				b1 := strm next asNumber.				sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp					ifTrue: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifFalse: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := a1 / a0.		vDiff1 := b1 / b0.self halt.		evts do:								"event loop"			[ :eAss | | tn tScale val v0 v1 |			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tn - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '6:40:04 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 6:40:04 PM on July 24, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript show: t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] -[ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript show: t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] -[ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		(strm atEnd)							"read trailing slash"			ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']].		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] -[ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"										"read trailing slash""		(strm atEnd)									ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]."		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	[strm atEnd] whileFalse:					"loop through the segments"		[Transcript show:  strm next, '  '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"										"read trailing slash""		(strm atEnd)									ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]."		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	[strm atEnd] whileFalse:					"loop through the segments"		[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')						"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"										"read trailing slash""		(strm atEnd)									ifFalse: [sep := strm next.				((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]."		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '8:19:50 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 8:19:50 PM on July 24, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	[strm atEnd] whileFalse:					"loop through the segments"		[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:					"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.		"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.				"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')					"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)			"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].		"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: b0) / (a0 min: b0).		vDiff1 := (a1 max: b1) / (a1 min: b1).		Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := a1 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences 	 "	| item key val |	item := generators at: param ifAbsent: [nil].	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences 	 "	| item key val |	item := generators at: param ifAbsent: [nil].	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	(isReq not and: [item isNil])		ifTrue: [^self].	item isAssociation ifFalse:		"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '4/8/'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100 , 2000 2100 /						4 2050 2050 /						6 2000 2000 , 2200 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	[strm atEnd] whileFalse:						"loop through the segments"		[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b1 min: b1).		Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr.		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '4/8/'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	[strm atEnd] whileFalse:						"loop through the segments"		[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b1 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	[strm atEnd] whileFalse:						"loop through the segments"		[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b1 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 '  "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear.	[strm atEnd] whileFalse:						"loop through the segments"		[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b1 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b1 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, ']'; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '8:39:33 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 8:39:33 PM on July 24, 2020."</do-it><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep =  ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep =  '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b0 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 200 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber. self halt.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]].			(sep = '/')				ifTrue: [interp := false]].			"no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b0 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber. self halt.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)				"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b0 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:								"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp						"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber. self halt.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b0 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := (a0 max: a1) / (a0 min: a1).		"compute start/end ratios for expon moving range"		vDiff1 := (b0 max: b1) / (b0 min: b1).		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 200 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		"compute start/end ratios for expon moving range"		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat.		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		"compute start/end ratios for expon moving range"		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat.		vDiff0 := (a0  / a1) asFloat.				"compute start/end ratios for expon moving range"		vDiff1 := (b0  / b1) asFloat.		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 200 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 tDiff vDiff0 vDiff1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		"compute start/end ratios for expon moving range"		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat."		vDiff0 := (a0 / a1) asFloat.			vDiff1 := (b0 / b1) asFloat."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 * (vDiff1 raisedTo: tScale) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 200 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 vDir0 vDir1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		"compute start/end ratios for expon moving range"		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat.		vDir0 := a1 &gt; a0.		vDir1 := b1 &gt; b0.		"		vDiff0 := (a0 / a1) asFloat.			vDiff1 := (b0 / b1) asFloat."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						vDir0							ifTrue: [v0 := a0 * (vDiff0 raisedTo: tScale) asFloat]							ifFalse: [v0 := a0 * (1.0 - (vDiff0 raisedTo: tScale)) asFloat].						vDir1							ifTrue: [v1 := b0 * (vDiff1 raisedTo: tScale) asFloat]							ifFalse: [v1 := b0 * (1.0 - (vDiff1 raisedTo: tScale)) asFloat].						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 vDir0 vDir1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		"compute start/end ratios for expon moving range"		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat.		vDir0 := a1 &gt; a0.		vDir1 := b1 &gt; b0.		"		vDiff0 := (a0 / a1) asFloat.			vDiff1 := (b0 / b1) asFloat."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						vDir0							ifTrue: [v0 := a0 * (vDiff0 raisedTo: tScale) asFloat]							ifFalse: [v0 := a0 * (1.0 - (vDiff0 raisedTo: tScale)) asFloat].						vDir1							ifTrue: [v1 := b0 * (vDiff1 raisedTo: tScale) asFloat]							ifFalse: [v1 := b0 * (1.0 - (vDiff1 raisedTo: tScale)) asFloat].						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 200 , 2000 2100 /						4 2050 2060 /						6 2000 2100 , 1100 1600' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 vDir0 vDir1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		tDiff := t1 - t0.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		"compute start/end ratios for expon moving range"		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat.		vDir0 := a1 &gt; a0.		vDir1 := b1 &gt; b0.				vDiff0 := (a0 / a1) asFloat.			vDiff1 := (b0 / b1) asFloat.		vDir0 := true.		vDir1 := true.		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						vDir0							ifTrue: [v0 := a0 * (vDiff0 raisedTo: tScale) asFloat]							ifFalse: [v0 := a0 - (1.0 - (vDiff0 raisedTo: tScale)) asFloat].						vDir1							ifTrue: [v1 := b0 * (vDiff1 raisedTo: tScale) asFloat]							ifFalse: [v1 := b0 - (1.0 - (vDiff1 raisedTo: tScale)) asFloat].						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 vDir0 vDir1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0."		vDiff1 := ((b0 max: b1) / (b0 min: b1)) asFloat.		vDiff0 := ((a0 max: a1) / (a0 min: a1)) asFloat.		vDir0 := a1 &gt; a0.		vDir1 := b1 &gt; b0."				vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		vDir0 := true.		vDir1 := true.		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						vDir0							ifTrue: [v0 := a0 * (vDiff0 raisedTo: tScale) asFloat]							ifFalse: [v0 := a0 - (1.0 - (vDiff0 raisedTo: tScale)) asFloat].						vDir1							ifTrue: [v1 := b0 * (vDiff1 raisedTo: tScale) asFloat]							ifFalse: [v1 := b0 - (1.0 - (vDiff1 raisedTo: tScale)) asFloat].						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 * (vDiff0 raisedTo: tScale) asFloat.						v1 := b0 - (1.0 - (vDiff1 raisedTo: tScale)) asFloat.						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	Transcript clear."	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr].		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 asFloat * (vDiff0 raisedTo: tScale).						v1 := b0 asFloat * (vDiff1 raisedTo: tScale).						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1).						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList inspect </do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '9:17:42 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 9:17:42 PM on July 24, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '9:20:48 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 9:20:48 PM on July 24, 2020."</do-it><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList inspect </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces""	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 asFloat * (vDiff0 raisedTo: tScale).						v1 := b0 asFloat * (vDiff1 raisedTo: tScale).						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr"].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"test complex movex"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList open </do-it><do-it> | s11 |			"test complex movex 2"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; (#mx -&gt; '5 140 160 , 400 440 /						4 450 460 /						6 400 400 , 200 300' )).	s11 eventList inspect </do-it><do-it> | s11 |			"test complex movex 2"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; (#mx -&gt; '5 140 160 , 400 440 /						4 450 460 /						6 400 400 , 200 300' )).	s11 eventList open </do-it><do-it> | s11 |			"test complex movex 2"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 8) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; (#mx -&gt; '3 140 160 , 400 440 /						2 440 460 /						3 400 400 , 200 300' )).	s11 eventList open </do-it><do-it> | s11 |			"test complex movex 2"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 8) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; (#mx -&gt; '3 140 190 , 400 440 /						2 440 460 /						3 400 400 , 150 250' )).	s11 eventList open </do-it><do-it> | s11 |			"test complex movex 2"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 8) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; (#mx -&gt; '3 140 190 , 400 440 /						2 440 460 /						3 400 400 , 150 250' )).	s11 eventList open </do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '9:30:14 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 9:30:14 PM on July 24, 2020."</do-it><do-it>item isImmediate </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences 	 "	| item key val |	item := generators at: param ifAbsent: [nil].	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	(isReq not and: [item isNil])		ifTrue: [^self].	item isImmediate ifTrue:			"handle consts"		[^self writeConst: property from: item into: eList].	item isAssociation ifFalse:			"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><do-it>5 isImmediate</do-it><do-it>(1 -&gt; 7) isImmediate</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeConstant:from:into:">writeConstant: property from: val into: eList	"Parse and process the numerical keyword to generate events"	"aScore11 add: (#p5 -&gt; 70); "	| ind evts |	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | evt | 		evt := (evts at: ind) event.		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeConstant:from:into:">writeConstant: property from: val into: eList	"Parse and process the numerical keyword to generate events"	"aScore11 add: (#p5 -&gt; 70); "	| evts |	evts := eList events.	evts do:									"event loop"		[ :eAss | | tN |		tN := eAss time asSec value.		(tN &gt;= start and: [tN &lt;= stop]) ifTrue:			[eAss event perform: property with: val]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeConst:from:into:">writeConst: property from: val into: eList	"Parse and process the numerical keyword to generate events"	"aScore11 add: (#p5 -&gt; 70); "	| evts |	evts := eList events.	evts do:									"event loop"		[ :eAss | | tN |		tN := eAss time asSec value.		(tN &gt;= start and: [tN &lt;= stop]) ifTrue:			[eAss event perform: property with: val]]</body></methods><remove-selector><class-id>Siren.Score11</class-id> <selector>writeConstant:from:into:</selector></remove-selector><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList open </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3:into:">writeP3: param into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); "	| key val |	param isAssociation ifFalse:		"handle non-rh arrays - rand sequences"		[^self writeRandRH: param into: eList].	key := param key.	val := param value.	key == #rh ifTrue: [^self writeP3RH: val into: eList].	key == #mx ifTrue: [^self writeP3MX: val into: eList].	self error: 'Unknown Score11 term'</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><remove-selector><class-id>Siren.Score11</class-id> <selector>writeRH:into:</selector></remove-selector><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		[t0 &lt; t1] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val voice: instrument).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList open </do-it><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.self halt.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		[t0 &lt; t1] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val voice: instrument).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><do-it>(t0 &gt; stop) or: [strm atEnd]</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.self halt.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur tN sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		tN := t0 + segDur.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		[tN &lt; t1] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val voice: instrument).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur tN sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		tN := t0 + segDur.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.self halt.		[tN &lt; t1] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val voice: instrument).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur tN sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		tN := t0 + segDur.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		[t1 &lt; tN] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val voice: instrument).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 24, 2020' '10:02:05 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 10:02:05 PM on July 24, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 26, 2020' '12:03:52 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 12:03:52 PM on July 26, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90o.im' 'July 26, 2020' '12:03:57 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90o.im was created at 12:03:57 PM on July 26, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '7:34:22 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 7:34:22 PM on July 26, 2020."</do-it><do-it>Siren.Score11 class organization addCategory: #examples before: nil</do-it><do-it>| s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList</do-it><do-it>| s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	| s11 score |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	score voice: (OSCVoice map: #pMapForCSLFMBell).	score play</body></methods><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p5 to: #gliss:.	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: dur, ampl, frq, m_fr, ind, pos""		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6"	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 6.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	TypedOSCMessage for: inst with: arr]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Scopre11 booh1"	| s11 score |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	score voice: (OSCVoice map: #pMapForCSLFMBell).	score play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	score voice: (OSCVoice map: #pMapForCSLFMBell).	score play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: dur, ampl, frq, m_fr, ind, pos""		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6"	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	TypedOSCMessage for: inst with: arr]</body></methods><do-it>Score11 booh1</do-it><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p5 to: #gliss:.	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	vox := OSCVoice default.	vox parameterMap: self pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	score play</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '7:53:20 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 7:53:20 PM on July 26, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: self pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	score play</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLSimpleFM">pMapForCSLSimpleFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos"	^[ :e | | arr |	arr := Array new: 6.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl asRatio value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pitch asHz value * e ratio.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos.	Transcript show: arr printString; cr.	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: self pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	score play</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLSimpleFM">pMapForCSLSimpleFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos"	^[ :e | | arr |	arr := Array new: 6.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl asRatio value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pitch asHz value * e ratio.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos.	Transcript show: arr printString; cr.	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: OSCVoice pMapForCSLFMBell.	"plug in the parameter map"	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLSimpleFM">pMapForCSLSimpleFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, c_fr, , ind, pos"	^[ :e | | arr |	arr := Array new: 6.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl asRatio value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pitch asHz value * e ratio.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: dur, ampl, frq, m_fr, ind, pos""		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6"	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	Transcript show: arr printString; cr.	TypedOSCMessage for: inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6"	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	Transcript show: arr printString; cr.	TypedOSCMessage for: inst with: arr]</body></methods><do-it>Score11 booh1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '7:58:32 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 7:58:32 PM on July 26, 2020."</do-it><methods><class-id>Siren.TypedOSCMessage</class-id> <category>osc</category><body package="Siren" selector="typesToOSC:">typesToOSC: converter 	"Convert the arguments to an OSC type string."	| t2 t3 |	arguments isEmpty ifTrue: [^self].	arguments do: [ :t4 | t4 toOSCTypeOn: converter].	t2 := 1.	t3 := 4 - (converter position \\ 4).	[t2 &lt;= t3]		whileTrue: 			[converter nextPut: 0.			t2 := t2 + 1].	^self</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: OSCVoice pMapForCSLFMBell.	"plug in the parameter map"	score voice: vox.self halt.	score play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: OSCVoice pMapForCSLFMBell.	"plug in the parameter map"	score voice: vox.self halt.	(score excerptFrom: 0 to: 1) play</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '8:04:11 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 8:04:11 PM on July 26, 2020."</do-it><do-it>score excerptFrom: 0 to: 1</do-it><do-it>Score11 booh1</do-it><do-it>5 sec</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: OSCVoice pMapForCSLFMBell.	"plug in the parameter map"	score voice: vox.self halt.	(score excerptFrom: 0 to: 1) play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice map: #pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.self halt.	(score excerptFrom: 0 to: 1) play</body></methods><do-it>OSCVoice fmExample1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6"	| cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	Transcript show: arr printString; cr.	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice map: #pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	score := (score excerptFrom: 0 to: 1).self halt.	score play</body></methods><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="playEvent:at:">playEvent: event at: start 	"Expand the list and play it at the given time."self halt.	start ifNotNil:		[self waitTill: start].	event hasItems ifTrue: [^self play: event at: start].	port send: (self oscMessageFrom: event)</body></methods><do-it>Score11 booh1</do-it><do-it> | s11 |			"BOOH part 1"	s11 := ((Siren.Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p5 to: #gliss:.	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 eventList  </do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample6">fmExample6	"Play a few random notes on the CSL FM bell instrument"	"OSCVoice fmExample5"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos,"	| events voice  |	events := (EventList randomExample: 4	 					"create the event list"		from: ((#duration: -&gt; (1.0 to: 1.0)), 			(#pitch: -&gt; (120.1 to: 170.1)), 			(#ratio: -&gt; (1.0to: 2.0)),			(#ampl: -&gt; (0.4 to: 0.8)), 			(#gliss -&gt; (0.5 to: 2.0)), 			(#position: -&gt; (-0.7 to: 0.7)))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFMBell.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><do-it>OSCVoice fmExample5</do-it><do-it>OSCVoice fmExample5</do-it><do-it>OSCVoice fmExample5</do-it><do-it>OSCVoice fmExample5</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	Transcript show: arr printString; cr.	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e pos.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	Transcript show: arr printString; cr.	inst := '/i', cnt printString, '/pn'.	TypedOSCMessage for: inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample6">fmExample6	"Play a few random notes on the CSL FM bell instrument"	"OSCVoice fmExample6"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos,"	| events voice  |	events := (EventList randomExample: 4	 					"create the event list"		from: ((#duration: -&gt; (1.0 to: 1.0)), 			(#pitch: -&gt; (120.1 to: 170.1)), 			(#ratio: -&gt; (1.0to: 2.0)),			(#ampl: -&gt; (0.4 to: 0.8)), 			(#gliss -&gt; (0.5 to: 2.0)), 			(#position: -&gt; (-0.7 to: 0.7)))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFMBell.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample6">fmExample6	"Play a few random notes on the CSL FM bell instrument"	"OSCVoice fmExample6"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos,"	| events voice  |	events := (EventList randomExample: 4	 					"create the event list"		from: ((#duration: -&gt; (1.0 to: 1.0)), 			(#pitch: -&gt; (120.1 to: 170.1)), 			(#ratio: -&gt; (1.0to: 2.0)),			(#ampl: -&gt; (0.4 to: 0.8)), 			(#gliss: -&gt; (0.5 to: 2.0)), 			(#position: -&gt; (-0.7 to: 0.7)))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFMBell.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><do-it>OSCVoice fmExample6</do-it><do-it>OSCVoice fmExample6</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e position.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	Transcript show: arr printString; cr.	inst := '/i', cnt printString, '/pn'.	TypedOSCMessage for: inst with: arr]</body></methods><do-it>OSCVoice fmExample6</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="fmExample6">fmExample6	"Play a few random notes on the CSL FM bell instrument"	"OSCVoice fmExample6"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos,"	| events voice  |	events := (EventList randomExample: 4	 					"create the event list"		from: ((#duration: -&gt; (1.0 to: 2.0)), 			(#pitch: -&gt; (120.1 to: 170.1)), 			(#ratio: -&gt; (1.0 to: 2.0)),			(#ampl: -&gt; (0.4 to: 0.8)), 			(#gliss: -&gt; (0.5 to: 2.0)), 			(#position: -&gt; (-1.0 to: 1.0)))).	voice := self default.	voice  instrument: '/i1/pn'.									"default instrument"	voice parameterMap: self pMapForCSLFMBell.					"plug in the parameter map"	events voice: voice.	events play.</body></methods><do-it>OSCVoice fmExample6</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '8:31:29 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 8:31:29 PM on July 26, 2020."</do-it><do-it>OSCVoice fmExample6</do-it><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="playEvent:at:">playEvent: event at: start 	"Expand the list and play it at the given time."	start ifNotNil:		[self waitTill: start].	event hasItems ifTrue: [^self play: event at: start].	port send: (self oscMessageFrom: event)</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '8:34:47 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 8:34:47 PM on July 26, 2020."</do-it><do-it>OSCVoice fmExample6</do-it><do-it>OSCVoice fmExample6</do-it><do-it>OSCVoice fmExample6</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 							"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec."		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')"].	vox := OSCVoice map: #pMapForCSLFMBell.		"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 						"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec."		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')"].	vox := OSCVoice default.	vox  instrument: '/i1/pn'.			 	vox map: #pMapForCSLFMBell.					"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 						"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec."		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')"].	vox := OSCVoice default.	vox  instrument: '/i1/pn'.			 	vox parameterMap: #pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec."		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')"].	vox := OSCVoice default.	vox  instrument: '/i1/pn'.			 	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	| inst cnt |	cnt := 1.	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e position.	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt &gt; 32 ifTrue: [cnt := 1].	Transcript show: arr printString; cr.	TypedOSCMessage for: inst with: arr]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox  instrument: '/i1/pn'.			 	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox  instrument: '/i1/pn'.			 	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	v loudness isNil		ifTrue: [arr at: 2 put: e ampl value]		ifFalse: [arr at: 2 put: e ampl value * v loudness value].	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e position.	Transcript show: arr printString; cr.	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play"	^Array with: events duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play""	^Array with: events duration with: voice"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1: 1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 41) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play""	^Array with: events duration with: voice"</body></methods><do-it>OSCVoice vxFadeExample1: 1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '8:51:38 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 8:51:38 PM on July 26, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Play for first section of 'Bat out of Hell' "	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."	vox := OSCVoice default."	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 6 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score voice: vox.	(score excerptFrom: 0 to: 3) play</body></methods><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="playEvent:at:">playEvent: event at: start 	"Expand the list and play it at the given time."self halt.	start ifNotNil:		[self waitTill: start].	event hasItems ifTrue: [^self play: event at: start].	port send: (self oscMessageFrom: event)</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score := score excerptFrom: 0 to: 3.	score voice: vox.	score play</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '8:57:05 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 8:57:05 PM on July 26, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 70);		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score := score excerptFrom: 0 to: 3.	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur tN sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		tN := t0 + segDur.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		[t1 &lt; tN] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '9:00:23 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 9:00:23 PM on July 26, 2020."</do-it><methods><class-id>Siren.DurationEvent class</class-id> <category>instance creation</category><body package="Siren" selector="dur:">dur: aD	"Answer a DurationEvent instance initialized with the arguments."	^self new duration: aD</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice</class-id> <category>events</category><body package="Siren" selector="playEvent:at:">playEvent: event at: start 	"Expand the list and play it at the given time."	start ifNotNil:		[self waitTill: start].	event hasItems ifTrue: [^self play: event at: start].	port send: (self oscMessageFrom: event)</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '9:02:30 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 9:02:30 PM on July 26, 2020."</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 8.0.		"index"	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) "dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.2);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score := score excerptFrom: 0 to: 3.	score voice: vox.	score play</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences 	 "	| item key val |	item := generators at: param ifAbsent: [nil].	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	(isReq not and: [item isNil])		ifTrue: [^self].	(item isImmediate or: [item respondsToArithmetic]) ifTrue:			"handle consts"		[^self writeConst: property from: item into: eList].	item isAssociation ifFalse:			"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeSequential: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><do-it>item isImmediate or: [item respondsToArithmetic]</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) "dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.2);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."												"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.	1 to: score events size do: 									"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"plug in the parameter map"	score := score excerptFrom: 0 to: 30.	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.2);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt"	score := score excerptFrom: 0 to: 30.	score voice: vox.	score play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.2);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt"	score := score excerptFrom: 0 to: 60.	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '9:46:16 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 9:46:16 PM on July 26, 2020."</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt"	score := score excerptFrom: 0 to: 60.	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 4.0.		"index"	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 4.0.		"index"	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 2.0.		"index"	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	arr at: 5 put: 1.412.		"ratio"	arr at: 6 put: 1.0.			"index"	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '9:54:34 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 9:54:34 PM on July 26, 2020."</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '9:56:17 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 9:56:17 PM on July 26, 2020."</do-it><do-it>Score11 booh1</do-it><do-it>	Schedule == nil		ifFalse: [self release].	Schedule := EventScheduler new initialize.</do-it><do-it>EventScheduler instanceCount </do-it><do-it>Schedule</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt""	score := score excerptFrom: 0 to: 60."	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.ev loudness ifNil: [self halt].		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt""	score := score excerptFrom: 0 to: 60."	score voice: vox.	score play</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.ev loudness ifNil: [self halt].		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt""	score := score excerptFrom: 0 to: 60."	score voice: vox."	score play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.ev loudness ifNil: [self halt].		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt"	score := score excerptFrom: 0 to: 120.	score voice: vox."	score play"</body></methods><do-it>score events last</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."plug in dur &amp; instruments 1-32"	score := s11 eventList.	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.ev loudness ifNil: [self halt].		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play an excerpt"	score voice: vox."	score play"</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList."take an excerpt"	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 											[ :ind | | ev |			"plug in dur &amp; instruments 1-32"		ev := (score events at: ind) event.		ev dur: 3 sec.ev loudness ifNil: [self halt].		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play"	score voice: vox."	score play"</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 						"Score11 instrument block""dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); "pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); "ampl ratio"		add: (#p5 -&gt; 0.1);"gliss"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');"position"		add: #p7 -&gt; #(1.0 -1.0 1.0) )."	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:."generate the score and take an excerpt"	score := s11 eventList.	score := score excerptFrom: 0 to: 120."plug in dur &amp; instruments 1-32"	1 to: score events size do: 											[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."plug in the voice and parameter map"	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).	vox parameterMap: OSCVoice pMapForCSLFMBell.			"play"	score voice: vox.	score play</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '10:15:51 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 10:15:51 PM on July 26, 2020."</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /			"dur in sec"						15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /"pitch in Hz"						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"position""	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321)." "plug in the voice and parameter map"	vox := OSCVoice default.							"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play										"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"position""	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."	vox := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321)." "plug in the voice and parameter map"	vox := OSCVoice default.							"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play										"play"</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position""	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play											"play"</body></methods><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Tools.UIPainter new openOnClass: self andSelector: #utilWindowSpec</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position""	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play											"play"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '11:22:20 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 11:22:20 PM on July 26, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 26, 2020' '11:34:11 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 11:34:11 PM on July 26, 2020."</do-it><methods><class-id>Tools.Workbook</class-id> <category>actions</category><body package="Siren" selector="saveAll">saveAll	"Create a directory and save all the receiver's pages there."	| sel nam folder toc |	sel := (Menu labelArray: #('save as BOSS file' 'save as HTML pages' 'save as text files')) startUp.	(sel = 0) ifTrue: [^self].	(sel = 1) ifTrue: [^self bossOutAll].	(sel = 2) ifTrue: [^self htmlOutAll].	nam := Dialog 		requestNewFileName: 'Save the workbook to directory' 		default: 'Workbook'.	nam isEmpty ifTrue: [^self].	folder := Filename named: nam.	folder exists		ifTrue: [folder isDirectory			ifFalse: [Dialog warn: 'File exists and is not a directory.'.				^self]]		ifFalse: [folder makeDirectory].	toc := (folder asString, Filename separator asString, 'TableOfContents.txt') 			asFilename writeStream.	self pages do:		[ :pa | | fn |"		Transcript show: 'Save: ', pa label; cr."		(pa respondsTo: #setFilename:)			ifTrue: [ fn := pa label copyReplaceAll: ' ' with: '_'.				pa setFilename: (folder asString, Filename separator asString, 							fn, '.ws') asFilename.			self selectPage: pa.			pa acceptDocument.			toc nextPutAll: (fn, '.ws'); cr]].	toc close.</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /.						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position""	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play											"play"</body></methods><do-it>Siren.Score11 class organization addCategory: #tests before: #examples</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90p.im' 'July 27, 2020' '1:10:16 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90p.im was created at 1:10:16 PM on July 27, 2020."</do-it><do-it>Workspace someInstance</do-it><do-it>Workbook someInstance</do-it><do-it>Workbook someInstance</do-it><do-it>ListWorkBook someInstance</do-it><do-it>self remove: self last</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '1:17:28 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 1:17:28 PM on July 27, 2020."</do-it><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8////4//'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8//16////'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><do-it>	TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8//16////32//////'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test1">test1	"Open a TSV on a simple Score11 event list"	"Score11 test1"	TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8//16////32//////'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; #(5 1000 2000))) 	eventList</body></methods><do-it>	TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/12*6/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)) 	eventList</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test2">test2	"Open a TSV on a simple Score11 event list"	"Score11 test2"	TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/12*6/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0)) 	eventList</body></methods><do-it> | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));		add: #p9 -&gt; (#mx -&gt; #(10 1 100))	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect </do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test3">test3	"Inspect a simple Score11 event list"	"Score11 test3"	 | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(10 10 100));		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));		add: #p9 -&gt; (#mx -&gt; #(10 1 100))	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test4">test4	"Inspect a simple Score11 event list - test multi-segment moves"	"Score11 test4"	 | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test5">test5	"Inspect a simple Score11 event list - test dotted values"	"Score11 test5"	  | s11 |		s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/4./4../8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect </body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test6">test6	"Inspect a simple Score11 event list - test rests"	"Score11 test6"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/-4/8/-8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; #(7 5 100  3 100 5))	).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7">test7	"Inspect a simple Score11 event list - test complex movex"	"Score11 test7"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 /						6 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test8">test8	"Inspect a simple Score11 event list - test complex movex"	"Score11 test8"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 8) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; (#mx -&gt; '3 140 190 , 400 440 /						2 440 460 /						3 400 400 , 150 250' )).	s11 eventList inspect</body></methods><do-it>Siren.Score11 class reorganizeFromString: '(''instance creation'' #instr:from:to:)(''examples'' #booh1)(''tests'' #test1 #test2 #test3 #test4 #test5 #test6 #test7 #test8)'</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3MX:into:">writeP3MX: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p3 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| tStr strm rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces"	rnd := Random new.	t0 := start.	[(t0 &gt; stop) or: [strm atEnd]] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur tN sep interp vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0.									"compute start/end ratios for expon moving range"		tN := t0 + segDur.		vDiff0 := (a1 / a0) asFloat.			vDiff1 := (b1 / b0) asFloat.		[t1 &lt; tN] whileTrue:						"event loop"			[ | val v0 v1 tScale |			interp							"false means single rand range for segment"				ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]				ifTrue: [tScale := (t1 - t0) / segDur.					v0 := a0 asFloat * (vDiff0 raisedTo: tScale).					v1 := b0 asFloat * (vDiff1 raisedTo: tScale).					val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)].			eList add: (MusicEvent dur: val voice: instrument).			t1 := t1 + val].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	strm := ReadStream on: data.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="flushInstruments">flushInstruments	"Set all the events voices to nil"	self eventsDo: [ :ev | ev voice: nil]</body></methods><methods><class-id>Siren.EventList</class-id> <category>accessing</category><body package="Siren" selector="flushInstruments">flushInstruments	"Set all the events voices to nil"	self eventsDo: [ :ev | ev voice: nil]</body></methods><remove-selector><class-id>Siren.Score11</class-id> <selector>flushInstruments</selector></remove-selector><methods><class-id>Siren.EventList</class-id> <category>accessing</category><body package="Siren" selector="flushVoices">flushVoices	"Set all the events voices to nil"	self eventsDo: [ :ev | ev voice: nil]</body></methods><remove-selector><class-id>Siren.EventList</class-id> <selector>flushInstruments</selector></remove-selector><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /.						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position""	s11 du: 303."										"ToDo: Score11 duty cycle"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play											"play"</body></methods><class><name>Score11</name><environment>Siren</environment><super>Siren.EventGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generators paramMap instrument start stop duty </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-EventGenerators</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: 'generators paramMap instrument start stop duty'	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '1:41:10 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 1:41:10 PM on July 27, 2020."</do-it><class><name>Score11</name><environment>Siren</environment><super>Siren.EventGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop instrument generators postProcessors paramMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-EventGenerators</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #Score11	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: 'start stop instrument generators postProcessors paramMap  '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'</do-it><methods><class-id>Siren.Score11</class-id> <category>initialize-release</category><body package="(none)" selector="initialize">initialize	"Initialize an instance with default state."	generators := Dictionary new.	paramMap := Dictionary new.	postProcessors := Dictionary new</body></methods><methods><class-id>Siren.Score11</class-id> <category>initialize-release</category><body package="(none)" selector="initialize">initialize	"Initialize an instance with default state."	generators := Dictionary new.	paramMap := Dictionary new.	postProcessors := Dictionary new</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="du:">du: dutyCycle	"Add a duty cycle post-processor to the receiver"	postProcessors at: #du put: dutyCycle</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	postProcessors do:		[ :key :val |		self perform: key with: val].	^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="du:">du: dutyCycle	"Add a duty cycle post-processor to the receiver"	postProcessors at: #duty: put: dutyCycle</body></methods><do-it>Siren.Score11 organization addCategory: #'private-post-processors' before: #'private-generators'</do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	postProcessors do:		[ :key :val |		self perform: key with: val with: eList].	^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="duty:list:">duty: dutyCycle list: eList	"Post-process the event list's durations."</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="du:">du: dutyCycle	"Add a duty cycle post-processor to the receiver"	postProcessors at: #duty:list: put: dutyCycle</body></methods><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #assign:to: #du: #instrument: #start: #stop: #tempo:)(''playing'' #eventList)(''private-post-processors'' #duty:list:)(''private-generators'' #populate:required:as:into: #writeConst:from:into: #writeMove:from:into: #writeMoveX2:from:into: #writeMoveX:from:into: #writeNumerical:from:into: #writeP3:into: #writeP3MX:into: #writeP3RH:into: #writeRand:from:into: #writeRandRH:into: #writeSequential:from:into: #writeSet:from:into:)(''private'' #parseRanges:)'</do-it><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #assign:to: #du: #instrument: #start: #stop: #tempo:)(''playing'' #eventList)(''private-generators'' #populate:required:as:into: #writeConst:from:into: #writeMove:from:into: #writeMoveX2:from:into: #writeMoveX:from:into: #writeNumerical:from:into: #writeP3:into: #writeP3MX:into: #writeP3RH:into: #writeRand:from:into: #writeRandRH:into: #writeSequential:from:into: #writeSet:from:into:)(''private'' #parseRanges:)(''private-post-processors'' #duty:list:)'</do-it><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #assign:to: #du: #instrument: #start: #stop: #tempo:)(''playing'' #eventList)(''private-generators'' #populate:required:as:into: #writeConst:from:into: #writeMove:from:into: #writeMoveX2:from:into: #writeMoveX:from:into: #writeNumerical:from:into: #writeP3:into: #writeP3MX:into: #writeP3RH:into: #writeRand:from:into: #writeRandRH:into: #writeSequential:from:into: #writeSet:from:into:)(''private'' #parseRanges:)(''private-post-processors'' #duty:list:)'</do-it><do-it>Siren.Score11 reorganizeFromString: '(''initialize-release'' #initialize)(''accessing'' #add: #assign:to: #du: #instrument: #start: #stop: #tempo:)(''playing'' #eventList)(''private-generators'' #populate:required:as:into: #writeConst:from:into: #writeMove:from:into: #writeMoveX2:from:into: #writeMoveX:from:into: #writeNumerical:from:into: #writeP3:into: #writeP3MX:into: #writeP3RH:into: #writeRand:from:into: #writeRandRH:into: #writeSequential:from:into: #writeSet:from:into:)(''private-post-processors'' #duty:list:)(''private'' #parseRanges:)'</do-it><do-it>420 \\ 100</do-it><do-it>420 / 100</do-it><do-it>420 / 100 truncated</do-it><do-it>420 / 100 asInteger</do-it><do-it>(420 / 100) truncated</do-it><do-it>(480 / 100) truncated</do-it><do-it>(399 / 100) truncated</do-it><do-it>399  \\100</do-it><do-it>26  \\ 100</do-it><do-it>303  \\ 100</do-it><do-it>135  \\ 100</do-it><do-it>35  \\ 100</do-it><do-it>(7 / 100) truncated.</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="duty:list:">duty: dutyCycle list: eList	"Post-process the event list's durations."	"000 - 099		multiply dur by dutyCycle	  100 - 199		add dutyCycle - 100 to dur	 200 - 299		subtract dutyCycle - 200 from dur	 300 - 399		set dur to dutyCycle - 300	 400 - 399		set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"	| dec val |	dec := (dutyCycle / 100) truncated.	val := dutyCycle \\ 100.	(dec == 0) ifTrue: 			"000 - 099	multiply dur by dutyCycle"		[eList scaleDurationsBy: val.		^self].	(dec == 1) ifTrue: 			"100 - 199	add dutyCycle - 100 to dur"		[eList eventsDo: [ :ev | ev duration: (ev duration + (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 2) ifTrue: 			"200 - 299	subtract dutyCycle - 200 from dur"		[eList eventsDo: [ :ev | ev duration: (ev duration - (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 4) ifTrue: 			"300 - 399	set dur to dutyCycle - 300"		[eList eventsDo: [ :ev | ev duration: (val perform: ev duration class ddMsgName)].		eList recomputeDuration.		^self].	(dec &gt;= 4) ifTrue: 			"400 - 399	set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"		[eList eventsDo: 			[ :ev |  | frq |			frq := ev pitch asHz.			ev duration: ((1.0 / frq) * (dutyCycle - 400) sec)].		eList recomputeDuration].	</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /.						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."														"plug in dur &amp; instruments 1-32""	1 to: score events size do: 		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /.						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."														"plug in dur &amp; instruments 1-32""	1 to: score events size do: 		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."														"plug in dur &amp; instruments 1-32""	1 to: score events size do: 		[ :ind | | ev |					ev := (score events at: ind) event.		ev dur: 3 sec.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')]."	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	postProcessors do:		[ :key :val | self halt.		self perform: key with: val with: eList].	^eList</body></methods><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	postProcessors keysAndValuesDo:		[ :key :val |		self perform: key with: val with: eList].	^eList</body></methods><do-it>Score11 booh1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '4:29:06 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:29:06 PM on July 27, 2020."</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="duty:list:">duty: dutyCycle list: eList	"Post-process the event list's durations."	"000 - 099		multiply dur by dutyCycle	  100 - 199		add dutyCycle - 100 to dur	 200 - 299		subtract dutyCycle - 200 from dur	 300 - 399		set dur to dutyCycle - 300	 400 - 399		set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"	| dec val | self halt.	dec := (dutyCycle / 100) truncated.	val := dutyCycle \\ 100.	(dec == 0) ifTrue: 			"000 - 099	multiply dur by dutyCycle"		[eList scaleDurationsBy: val.		^self].	(dec == 1) ifTrue: 			"100 - 199	add dutyCycle - 100 to dur"		[eList eventsDo: [ :ev | ev duration: (ev duration + (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 2) ifTrue: 			"200 - 299	subtract dutyCycle - 200 from dur"		[eList eventsDo: [ :ev | ev duration: (ev duration - (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 4) ifTrue: 			"300 - 399	set dur to dutyCycle - 300"		[eList eventsDo: [ :ev | ev duration: (val perform: ev duration class ddMsgName)].		eList recomputeDuration.		^self].	(dec &gt;= 4) ifTrue: 			"400 - 399	set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"		[eList eventsDo: 			[ :ev |  | frq |			frq := ev pitch asHz.			ev duration: ((1.0 / frq) * (dutyCycle - 400) sec)].		eList recomputeDuration].</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="duty:list:">duty: dutyCycle list: eList	"Post-process the event list's durations."	"000 - 099		multiply dur by dutyCycle	  100 - 199		add dutyCycle - 100 to dur	 200 - 299		subtract dutyCycle - 200 from dur	 300 - 399		set dur to dutyCycle - 300	 400 - 399		set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"	| dec val | self halt.	dec := (dutyCycle / 100) truncated.	val := dutyCycle \\ 100.	(dec == 0) ifTrue: 			"000 - 099	multiply dur by dutyCycle"		[eList scaleDurationsBy: val.		^self].	(dec == 1) ifTrue: 			"100 - 199	add dutyCycle - 100 to dur"		[eList eventsDo: [ :ev | ev duration: (ev duration + (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 2) ifTrue: 			"200 - 299	subtract dutyCycle - 200 from dur"		[eList eventsDo: [ :ev | ev duration: (ev duration - (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 3) ifTrue: 			"300 - 399	set dur to dutyCycle - 300"		[eList eventsDo: [ :ev | ev duration: (val perform: ev duration class ddMsgName)].		eList recomputeDuration.		^self].	(dec &gt;= 4) ifTrue: 			"400 - 399	set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"		[eList eventsDo: 			[ :ev |  | frq |			frq := ev pitch asHz.			ev duration: ((1.0 / frq) * (dutyCycle - 400) sec)].		eList recomputeDuration].</body></methods><do-it>ev duration class ddMsgName</do-it><methods><class-id>Siren.Duration class</class-id> <category>instance creation</category><body package="Siren" selector="value:">value: aValue	"Answer a new instance of a member of my species."	| number |	aValue species == Duration ifTrue: [^aValue].	(aValue isMemberOf: SmallInteger)		ifTrue: [aValue &lt; 100			ifTrue: [^SecondDuration new value: aValue]			ifFalse: [^MSecondDuration new value: aValue]].	(aValue isKindOf: LimitedPrecisionReal)		ifTrue: [^SecondDuration new value: aValue].	(aValue isMemberOf: Fraction)		ifTrue: [^RatioDuration new value: aValue].	(aValue isKindOf: String)		ifTrue: [number := Number readFrom: (ReadStream on: aValue).			number = 0 ifTrue: [^self error: 'Unknown duration value.'].			^Duration value: number].	(aValue isMemberOf: BlockContext)		ifTrue: [^ConditionalDuration new value: aValue]."	^self error: 'Unknown duration type.'"	^aValue</body></methods><do-it>ev duration species value: val</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="duty:list:">duty: dutyCycle list: eList	"Post-process the event list's durations."	"000 - 099		multiply dur by dutyCycle	  100 - 199		add dutyCycle - 100 to dur	 200 - 299		subtract dutyCycle - 200 from dur	 300 - 399		set dur to dutyCycle - 300	 400 - 399		set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"	| dec val |	dec := (dutyCycle / 100) truncated.	val := dutyCycle \\ 100.	(dec == 0) ifTrue: 			"000 - 099	multiply dur by dutyCycle"		[eList scaleDurationsBy: val.		^self].	(dec == 1) ifTrue: 			"100 - 199	add dutyCycle - 100 to dur"		[eList eventsDo: [ :ev | ev duration: (ev duration + (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 2) ifTrue: 			"200 - 299	subtract dutyCycle - 200 from dur"		[eList eventsDo: [ :ev | ev duration: (ev duration - (val perform: ev duration class ddMsgName))].		eList recomputeDuration.		^self].	(dec == 3) ifTrue: 			"300 - 399	set dur to dutyCycle - 300"		[eList eventsDo: [ :ev | ev duration: (ev duration species value: val)].		eList recomputeDuration.		^self].	(dec &gt;= 4) ifTrue: 			"400 - 399	set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"		[eList eventsDo: 			[ :ev |  | frq |			frq := ev pitch asHz.			ev duration: ((1.0 / frq) * (dutyCycle - 400) sec)].		eList recomputeDuration].</body></methods><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="tempo:">tempo: arr	"Set the tempo curve of the receiver"	postProcessors at: #tempo:list: put: arr</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test post-processors"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '32/'); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := tData at: 2.			tN := tData at: 3.			tDiff := tN - t0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec.				val := tX + ( tDiff * tX / dur).				evAss key: val asSec].			eList recomputeDuration]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := tData at: 2.			tN := tData at: 3.			tDiff := tN - t0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				evAss key: val asSec].			eList recomputeDuration]].self halt.</body></methods><do-it>val sec</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := tData at: 2.			tN := tData at: 3.			tDiff := tN - t0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				evAss key: val sec].			eList recomputeDuration]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := tData at: 2.			tN := tData at: 3.			tDiff := tN - t0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := (tData at: 2) / 60.0.			tN := (tData at: 3) / 60.0.			tDiff := tN - t0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '50/'); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '10/'); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN prev |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				Transcript show: (prev - val) printString; cr.				prev := val.				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN prev |	tData isString ifFalse:		[ | tDiff |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss |  | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				Transcript show: (val - prev) printString; cr.				prev := val.				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				Transcript show: tX printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX * ( tDiff * tX / dur).				Transcript show: tX printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss key: val sec.self halt].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				Transcript show: tX printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss key: val sec.self halt].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it> tX / dur</do-it><do-it> tDiff * tX / dur</do-it><do-it> tDiff * 10 / dur</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				Transcript show: tX printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss key: val sec].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX + ( tDiff * tX / dur).				Transcript show: tX printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '15/'); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; 0.1; 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.1  0.1); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>self size</do-it><do-it>rng size == 0</do-it><do-it>			rng size = 0</do-it><do-it>rng size = 0				ifTrue: [dur := rng first]				ifFalse: [dur := rng atRandom: rnd].</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeRandRH:into:">writeRandRH: array into: eList		"Parse and process the random RH keyword to generate events"	"aScore11 add: #p3 -&gt; #(1.0 1.0 5.0);"	"aScore11 add: #p3 -&gt; #(0.5 1.0 2.0  0.5 0.25 0.5);"	| tim rnd |	tim := start. 	rnd := Random new.	array size == 3 ifTrue:			"use a single range, ignoring the percentage value"		[ | rng |		rng := (array at: 2) to: (array last).		[tim &lt;= stop] whileTrue:			[ | dur |			rng size = 0				ifTrue: [dur := rng first]				ifFalse: [dur := rng atRandom: rnd].			eList add: (MusicEvent dur: dur voice: instrument).			tim := tim + dur].		^self].</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX + (tDiff * tX / dur).				Transcript show: tX printString, ' - ', (tDiff * tX / dur) printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| typ dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := 0 - tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX * (1.0 - (tDiff * tX / dur)).				Transcript show: tX printString, ' - ', (tDiff * tX / dur) printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := 0 - (tN - t0).			prev := 0.			eList do: 				[ :evAss | | tX val |				tX := evAss key asSec value.				val := tX * (1.0 - (tDiff * tX / dur)).				Transcript show: tX printString, ' - ', (tDiff * tX / dur) printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '6:01:53 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:01:53 PM on July 27, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := 0 - (tN - t0).			prev := 0.			eList do: 				[ :evAss | | tX val sca |				tX := evAss key asSec value.				sca := tDiff * tX / dur.				val := tX * (1.0 - sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val sca |				tX := evAss key asSec value.				sca := t0 + (tDiff * tX / dur).				val := tX * (1.0 - sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prev.				sca := t0 + (tDiff * tX / dur).				val := prev + (ioi * sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', (val - prev) printString; cr.				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prev.				sca := t0 + (tDiff * tX / dur).				val := prev + (ioi * sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', (val - prev) printString; cr.				prev := val.(tX &gt; 5) ifTrue: [self halt].				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.1  0.1); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5)."	s11 tempo: #(10 60 120)."	s11 eventList inspect</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prev.				sca := t0 + (tDiff * tX / dur).				val := prev + (ioi * sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', (val - prev) printString; cr.(tX &gt; 7) ifTrue: [self halt].				prev := val.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prev |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prev := 0.			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prev.				sca := t0 + (tDiff * tX / dur).				val := prev + (ioi * sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', (val - prev) printString; cr.(tX &gt; 7) ifTrue: [self halt].				prev := val.				evAss start: (Duration value: tX / 2)].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.1  0.1); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prevS prevA |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prevS := 0.					"scaled start of previous note"			prevA := 0.					"actual start of previous note"			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prevA.				sca := t0 + (tDiff * tX / dur).				val := prevS + (ioi * sca).				Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.(tX &gt; 7) ifTrue: [self halt].				prevS := val.				prevA := tX.				evAss start: (Duration value: tX / 2)].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prevS prevA |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prevS := 0.					"scaled start of previous note"			prevA := 0.					"actual start of previous note"			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prevA.				sca := t0 + (tDiff * tX / dur).				val := prevS + (ioi * sca)."				Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."				prevS := val.				prevA := tX.				evAss start: (Duration value: tX / 2)].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prevS prevA |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prevS := 0.					"scaled start of previous note"			prevA := 0.					"actual start of previous note"			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prevA.				sca := t0 + (tDiff * tX / dur).				val := prevS + (ioi * sca)."				Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."				prevS := val.				prevA := tX.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.1  0.1); 		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.1  0.1); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 120).	s11 eventList open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 180).	s11 eventList open</body></methods><do-it>Score11 test9</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '6:48:26 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:48:26 PM on July 27, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca)."			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."			prevS := val.			prevA := tX.			evAss start: val].	eList recomputeDuration.	^self]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo0:list:">tempo0: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | tDiff prevS prevA |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			tDiff := tN - t0.			prevS := 0.					"scaled start of previous note"			prevA := 0.					"actual start of previous note"			eList do: 				[ :evAss | | tX val sca ioi |				tX := evAss key asSec value.				ioi := tX - prevA.				sca := t0 + (tDiff * tX / dur).				val := prevS + (ioi * sca)."				Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."				prevS := val.				prevA := tX.				evAss start: val].			eList recomputeDuration.			^self]].self halt.</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[ | |		tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			self tempoFrom: t0 to: tN in: dur list: eList startingAt: 0.			eList recomputeDuration.			^self]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[tData size == 3 ifTrue:			[dur := tData at: 1.			t0 := 60.0 / (tData at: 2).			tN := 60.0 / (tData at: 3).			self tempoFrom: t0 to: tN in: dur list: eList startingAt: 0.			eList recomputeDuration.			^self]]</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val].	eList recomputeDuration.	^self]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val].	eList recomputeDuration.	^self]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 180).	s11 eventList open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 180).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 180).	sco := s11 eventList.	sco scaleDurationsBy: 0.5.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="scaleDurationsBy:">scaleDurationsBy: theValue	"Multiply the start times all events by theValue."	self events do: [ :assoc | assoc event scaleDurationBy: theValue]	self recomputeDuration</body></methods><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="scaleStartTimesBy:">scaleStartTimesBy: theValue	"Multiply the start times all events by theValue."	self events do: [ :assoc | assoc key: (assoc key * theValue)]</body></methods><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="scaleDurationsBy:">scaleDurationsBy: theValue	"Multiply the start times all events by theValue."	self events do: [ :assoc | assoc event scaleDurationBy: theValue].	self recomputeDuration</body></methods><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="scaleStartTimesBy:">scaleStartTimesBy: theValue	"Multiply the start times all events by theValue."	self events do: [ :assoc | assoc key: (assoc key * theValue)].	self recomputeDuration</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.5).	s11 tempo: #(10 60 180).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN off |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[off := 0.			1 to: tData size by: 3 do:				[ :ind |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind).					tN := 60.0 / (tData at: ind).				self tempoFrom: t0 to: tN in: dur list: eList startingAt: off.				off := off + dur.				eList recomputeDuration].			^self]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN off |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[off := 0.			1 to: tData size by: 3 do:				[ :ind |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind).				tN := 60.0 / (tData at: ind).				self tempoFrom: t0 to: tN in: dur list: eList startingAt: off.				off := off + dur.				eList recomputeDuration].			^self]]</body></methods><do-it>Score11 test9</do-it><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr. self halt.			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN off |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[off := 0.			1 to: tData size by: 3 do:				[ :ind |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind + 1).				tN := 60.0 / (tData at: ind + 2).				self tempoFrom: t0 to: tN in: dur list: eList startingAt: off.				off := off + dur.				eList recomputeDuration].			^self]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		tX &gt;= eStart ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca)."			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><do-it>Score11 test9</do-it><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 tempo: #(10 60 180).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)(''private'' #scrollableExtent #setModel: #visibleExtent)(''controller access'' #defaultControllerClass #transformPoint:)(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)'</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''private'' #scrollableExtent #setModel: #visibleExtent)(''controller access'' #defaultControllerClass #transformPoint:)(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)'</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)(''private'' #scrollableExtent #setModel: #visibleExtent)(''controller access'' #defaultControllerClass #transformPoint:)(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)'</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)(''controller access'' #defaultControllerClass #transformPoint:)(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)(''private'' #scrollableExtent #setModel: #visibleExtent)'</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)(''controller access'' #defaultControllerClass #transformPoint:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)(''private'' #scrollableExtent #setModel: #visibleExtent)'</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)(''controller access'' #defaultControllerClass #transformPoint:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)(''private'' #scrollableExtent #setModel: #visibleExtent)'</do-it><do-it>Siren.DisplayListView reorganizeFromString: '(''initialize-release'' #component #initialize #initializeCache #initializeWithGrid:color: #release)(''accessing'' #background: #backgroundColor #bounds: #cache: #displayList #displayList: #foregroundColor #inset: #list #pageOffset #pageOffset: #pixmap: #preferredBounds #zoom:)(''controller access'' #defaultControllerClass #transformPoint:)(''displaying'' #displayOn: #displaySelectionOn: #invalidate)(''private'' #scrollableExtent #setModel: #visibleExtent)'</do-it><methods><class-id>Siren.DisplayListView</class-id> <category>accessing</category><body package="Siren" selector="preferredBounds">preferredBounds	"Answer the displayList's bounds."	| rect | self halt.	displayList == nil		ifTrue: [^super preferredBounds].	rect := displayList computePreferredBounds.	^zoom == nil		ifTrue: [(rect origin) extent: (rect extent + (inset * 2))]		ifFalse: [((rect origin) extent: (rect extent + (inset * 2))) scaledBy: zoom]</body></methods><methods><class-id>Siren.DisplayListView</class-id> <category>accessing</category><body package="Siren" selector="preferredBounds">preferredBounds	"Answer the displayList's bounds."	| rect |	displayList == nil		ifTrue: [^super preferredBounds].	rect := displayList computePreferredBounds.	^zoom == nil		ifTrue: [(rect origin) extent: (rect extent + (inset * 2))]		ifFalse: [((rect origin) extent: (rect extent + (inset * 2))) scaledBy: zoom]</body></methods><do-it>Score11 test9</do-it><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 tempo: #(5 60 180  5 180 60).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 tempo: #(10 60 180)."	s11 tempo: #(10 180 60)."	s11 tempo: #(5 60 180  5 180 60)."	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA eEnd |	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca)."			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, ' startingAt: ', eStart printString; cr.	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := eStart.					"actual start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 tempo: #(10 60 180).	s11 tempo: #(10 180 60)."	s11 tempo: #(5 60 180  5 180 60).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN off |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[off := 0.			1 to: tData size by: 3 do:				[ :ind |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind + 1).				tN := 60.0 / (tData at: ind + 2).				self tempoFrom: t0 to: tN in: dur list: eList startingAt: off.				off := off + dur].			eList recomputeDuration.			^self]]</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN last |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[ | rOff mOff |			rOff := 0.			"real offset"			mOff := 0.			"mapped offset"			1 to: tData size by: 3 do:				[ :ind |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind + 1).				tN := 60.0 / (tData at: ind + 2).				last := self tempoFrom: t0 to: tN in: dur list: eList startingAt: rOff mappedTo: mOff.				rOff := rOff + dur.				mOff := mOff + last].			eList recomputeDuration.			^self]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[ | rOff mOff |			rOff := 0.			"real offset"			mOff := 0.			"mapped offset"			1 to: tData size by: 3 do:				[ :ind | | last |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind + 1).				tN := 60.0 / (tData at: ind + 2).				last := self tempoFrom: t0 to: tN in: dur list: eList startingAt: rOff mappedTo: mOff.				rOff := rOff + dur.				mOff := mOff + last].			eList recomputeDuration.			^self]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, ' startingAt: ', eStart printString; cr.	tDiff := tN - t0.	prevS := eStart.					"scaled start of previous note"	prevA := mOff.					"actual start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevA eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, ' startingAt: ', eStart printString; cr.	tDiff := tN - t0.	prevS := eStart.				"scaled start of previous note"	prevA := mOff.					"actual start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevA.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevA := tX.			evAss start: val]].	^prevA</body></methods><do-it>Score11 test9</do-it><remove-selector><class-id>Siren.Score11</class-id> <selector>tempoFrom:to:in:list:startingAt:</selector></remove-selector><remove-selector><class-id>Siren.Score11</class-id> <selector>tempo0:list:</selector></remove-selector><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevO eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, 			' startingAt ', eStart printString, ' mappedTo ', mOff printString; cr.	tDiff := tN - t0.	prevO := eStart.				"original start of previous note"	prevS := mOff.				"scaled start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevO.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			evAss start: val.			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevO := tX.			evAss start: val]].	^prevS</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 tempo: #(10 60 180)."	s11 tempo: #(10 180 60).	s11 tempo: #(5 60 180  5 180 60)."	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 tempo: #(10 60 180)."	s11 tempo: #(10 180 60)."	s11 tempo: #(5 60 180  5 180 60)."	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 tempo: #(10 60 180).	s11 tempo: #(10 180 60)."	s11 tempo: #(5 60 180  5 180 60).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 tempo: #(10 60 180)."	s11 tempo: #(10 180 60)."	s11 tempo: #(5 60 180  5 180 60)."	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 tempo: #(10 60 180).	s11 tempo: #(10 180 60)."	s11 tempo: #(5 60 180  5 180 60).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9:">test9: which	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9: #accel"	"Score11 test9: #decel"	"Score11 test9: #both"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #accel ifTrue: [s11 tempo: #(10 60 180)].	which == #decel ifTrue: [s11 tempo: #(10 180 60)].	which == #both ifTrue: [s11 tempo: #(5 60 180  5 180 60)].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 tempo: #(10 60 180).	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9: #accel</do-it><do-it>Score11 test9: #decel</do-it><do-it>Score11 test9: #both</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevO eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, 			' startingAt ', eStart printString, ' mappedTo ', mOff printString; cr.	tDiff := tN - t0.	prevO := eStart.				"original start of previous note"	prevS := mOff.				"scaled start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevO.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			evAss start: val. self halt.			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevO := tX.			evAss start: val]].	^prevS</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevO eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, 			' startingAt ', eStart printString, ' mappedTo ', mOff printString; cr.	tDiff := tN - t0.	prevO := eStart.				"original start of previous note"	prevS := mOff.				"scaled start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevO.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			evAss start: val. t0 &lt; tN ifTrue: [self halt].			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevO := tX.			evAss start: val]].	^prevS</body></methods><do-it>sca := t0 + (tDiff * (tX - eStart) / dur).</do-it><do-it>sca := t0 + (tDiff * (tX - eStart) / dur).			val := prevS + (ioi * sca).</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevO eEnd |	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, 			' startingAt ', eStart printString, ' mappedTo ', mOff printString; cr.	tDiff := tN - t0.	prevO := eStart.				"original start of previous note"	prevS := mOff.				"scaled start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevO.			sca := t0 + (tDiff * (tX - eStart) / dur).			val := prevS + (ioi * sca).			evAss start: val. t0 &lt; tN ifTrue: [self safeHalt].			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr.			prevS := val.			prevO := tX.			evAss start: val]].	^prevS</body></methods><do-it>Score11 test9: #both</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9:">test9: which	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9: #accel"	"Score11 test9: #decel"	"Score11 test9: #both"	"Score11 test9: #complex"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #accel ifTrue: [s11 tempo: #(10 60 180)].	which == #decel ifTrue: [s11 tempo: #(10 180 60)].	which == #both ifTrue: [s11 tempo: #(2 60 180  3 180 60  5 60 300)].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9:">test9: which	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9: #accel"	"Score11 test9: #decel"	"Score11 test9: #both"	"Score11 test9: #complex"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #accel ifTrue: [s11 tempo: #(10 60 180)].	which == #decel ifTrue: [s11 tempo: #(10 180 60)].	which == #both ifTrue: [s11 tempo: #(5 60 180  5 180 60)].	which == #complex ifTrue: [s11 tempo: #(3 60 180  2 180 60  5 90 240)].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9:">test9: which	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9: #accel"	"Score11 test9: #decel"	"Score11 test9: #both"	"Score11 test9: #complex"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #accel ifTrue: [s11 tempo: #(10 60 180)].	which == #decel ifTrue: [s11 tempo: #(10 180 60)].	which == #both ifTrue: [s11 tempo: #(5 60 180  5 180 60)].	which == #complex ifTrue: [s11 tempo: #(3 60 180  2 180 60  5 90 240)].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9: #complex</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9:">test9: which	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9: #accel"	"Score11 test9: #decel"	"Score11 test9: #both"	"Score11 test9: #complex"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #accel ifTrue: [s11 tempo: #(10 60 180)].	which == #decel ifTrue: [s11 tempo: #(10 180 60)].	which == #both ifTrue: [s11 tempo: #(5 60 180  5 180 60)].	which == #complex ifTrue: [s11 tempo: #(3 60 180  2 180 60  5 120 24)].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9: #complex</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| dur t0 tN |	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[ | rOff mOff |			rOff := 0.			"real offset"			mOff := 0.			"mapped offset"			1 to: tData size by: 3 do:				[ :ind | | last |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind + 1).				tN := 60.0 / (tData at: ind + 2).				last := self tempoFrom: t0 to: tN in: dur list: eList startingAt: rOff mappedTo: mOff.				rOff := rOff + dur.				mOff := last].			eList recomputeDuration.			^self]]</body></methods><do-it>Score11 test9: #complex</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9:">test9: which	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test9: #accel"	"Score11 test9: #decel"	"Score11 test9: #both"	"Score11 test9: #complex"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.15  0.15); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #accel ifTrue: [s11 tempo: #(10 60 180)].	which == #decel ifTrue: [s11 tempo: #(10 180 60)].	which == #both ifTrue: [s11 tempo: #(5 60 180  5 180 60)].	which == #complex ifTrue: [s11 tempo: #(3 60 180  2 180 60  5 120 40)].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test9: #complex</do-it><do-it>Score11 test9: #accel</do-it><do-it>Score11 test9: #both</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempoFrom:to:in:list:startingAt:mappedTo:">tempoFrom: t0 to: tN in: dur list: eList startingAt: eStart mappedTo: mOff	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	| tDiff prevS prevO eEnd |"	Transcript cr; show: t0 printString, ' to ', tN printString, ' in ', dur printString, 			' startingAt ', eStart printString, ' mappedTo ', mOff printString; cr."	tDiff := tN - t0.	prevO := eStart.				"original start of previous note"	prevS := mOff.				"scaled start of previous note"	eEnd := eStart + dur.	eList do: 		[ :evAss | | tX val sca ioi |		tX := evAss key asSec value.		(tX &gt;= eStart and: [tX &lt;= eEnd]) ifTrue:			[ioi := tX - prevO.			sca := t0 + (tDiff * tX / dur).			val := prevS + (ioi * sca).			evAss start: val. "			Transcript show: tX printString, ' - ', sca printString, ' - ', val printString; cr."			prevS := val.			prevO := tX.			evAss start: val]].	^prevS</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="rdev:">rdev: skew	"Set the start-time skew of the receiver"	postProcessors at: #rdev:list: put: skew</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="rdev:list:">rdev: rData list: eList	"Post-process the event list's start-times with the random skew."	"s11 rdev: 0.02."	"s11 rdev: #(10 0.0 0.1)."	| rand | 	rand := Random new.	rData respondsToArithmetic ifTrue:		[eList do: 			[ :evAss | | tX |			tX := evAss key asSec value.			tX := tX + (rand next * 2 - 1.0) * rData.			evAss start: tX].		eList recomputeDuration.		^self].	rData size \\ 3 = 0 ifTrue:		[ | dur rn0 rnN vDiff |		dur := rData at: 1.		rn0 := rData at: 2.		rnN := rData at: 3.		vDiff := rnN - rn0.		eList events do:			[ :evAss | | tX tScale val |			tX := evAss key asSec value.			tScale := tX / dur.			val := (rn0 + (vDiff * tScale)) asFloat.			tX := tX + (rand next * 2 - 1.0) * val.			evAss start: tX].		eList recomputeDuration.		^self]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test9">test9	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.05.	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test tempo maps"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.05.	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><remove-selector><class-id>Siren.Score11 class</class-id> <selector>test9</selector></remove-selector><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.05.	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test10</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="rdev:list:">rdev: rData list: eList	"Post-process the event list's start-times with the random skew."	"s11 rdev: 0.02."	"s11 rdev: #(10 0.0 0.1)."	| rand | 	rand := Random new.	rData respondsToArithmetic ifTrue:		[eList do: 			[ :evAss | | tX |			tX := evAss key asSec value.			tX := tX + ((rand next * 2 - 1.0) * rData).			evAss start: tX].		eList recomputeDuration.		^self].	rData size \\ 3 = 0 ifTrue:		[ | dur rn0 rnN vDiff |		dur := rData at: 1.		rn0 := rData at: 2.		rnN := rData at: 3.		vDiff := rnN - rn0.		eList events do:			[ :evAss | | tX tScale val |			tX := evAss key asSec value.			tScale := tX / dur.			val := (rn0 + (vDiff * tScale)) asFloat.			tX := tX + (rand next * 2 - 1.0) * val.			evAss start: tX].		eList recomputeDuration.		^self]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.25  0.25); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.05.	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test10</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.05.	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.02.	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test10</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.03.	sco := s11 eventList.	sco open</body></methods><do-it>Score11 test10</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	s11 rdev: 0.03.	sco := s11 eventList.	sco scaleDurationsBy: 0.4.	sco open</body></methods><do-it>Score11 test10</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test10">test10	"Inspect a simple Score11 event list - test rand dev"	"Score11 test10"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.2  0.2); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01)."	s11 rdev: 0.03."	s11 rdev: #(10 0.0 0.1).	sco := s11 eventList.	sco scaleDurationsBy: 0.4.	sco open</body></methods><do-it>Score11 test10</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="rdev:list:">rdev: rData list: eList	"Post-process the event list's start-times with the random skew."	"s11 rdev: 0.02."	"s11 rdev: #(10 0.0 0.1)."	| rand | 	rand := Random new.	rData respondsToArithmetic ifTrue:		[eList do: 			[ :evAss | | tX |			tX := evAss key asSec value.			tX := tX + ((rand next * 2 - 1.0) * rData).			evAss start: tX].		eList recomputeDuration.		^self].	rData size \\ 3 = 0 ifTrue:		[ | dur rn0 rnN vDiff |		dur := rData at: 1.		rn0 := rData at: 2.		rnN := rData at: 3.		vDiff := rnN - rn0.		eList events do:			[ :evAss | | tX tScale val |			tX := evAss key asSec value.			tScale := tX / dur.			val := (rn0 + (vDiff * tScale)) asFloat.			tX := tX + ((rand next * 2 - 1.0) * val).			evAss start: tX].		eList recomputeDuration.		^self]</body></methods><do-it>Score11 test10</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '10:20:09 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 10:20:09 PM on July 27, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 20) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2///'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; ''); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(5 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '10:23:58 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 10:23:58 PM on July 27, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 20) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(5 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 20) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(5 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 20) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(5 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score := score excerptFrom: 0 to: 20.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 20) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(5 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '10:46:28 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 10:46:28 PM on July 27, 2020."</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="tempo:list:">tempo: tData list: eList	"Post-process the event list's start-times with the tempo curve."	"s11 tempo: #(10 60 120)."	"s11 tempo: 120."	| dur t0 tN |	tData respondsToArithmetic		ifTrue: [ | val |			val := 60.0 / tData.			eList scaleStartTimesBy: val.			eList scaleDurationsBy: val.			eList recomputeDuration.			^self].	tData isString ifFalse:		[tData size  \\ 3 = 0 ifTrue:			[ | rOff mOff |			rOff := 0.			"real offset"			mOff := 0.			"mapped offset"			1 to: tData size by: 3 do:				[ :ind | | last |				dur := tData at: ind.				t0 := 60.0 / (tData at: ind + 1).				tN := 60.0 / (tData at: ind + 2).				last := self tempoFrom: t0 to: tN in: dur list: eList startingAt: rOff mappedTo: mOff.				rOff := rOff + dur.				mOff := last].			eList recomputeDuration.			^self]]</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 180.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 180.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0))).				"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 180.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 180.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 180.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val tStr |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	tStr := data copyWithout: Character cr.	tStr := data copyWithout: $ .	strm := ReadStream on: tStr.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSequential:from:into:">writeSequential: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					cnt timesRepeat: 						[evt perform: property with: num.						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val tStr |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	tStr := data copyWithout: Character cr.	tStr := tStr copyWithout: $ .	strm := ReadStream on: tStr.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 180.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeP3RH:into:">writeP3RH: data into: eList		"Parse and process the RH keyword to generate events"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8//4//');"	"aScore11 add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/');"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 8 4. 8));"	"aScore11 add: #p3 -&gt; (#rh -&gt; #(4 8 -8 4 -4));"	"aScore11 add: #p3 -&gt; (#rh -&gt; 16);"	| strm num cnt tim val tStr |	tim := start.	data respondsToArithmetic ifTrue:			"rh number"		[num := 4.0 / data.		[tim &gt; stop] whileFalse:			[eList add: (MusicEvent dur: num voice: instrument).			tim := tim + num].		^self].	data isString ifFalse:							"rh string"		[self error: 'Mal-formed duration data?'].	tStr := data copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	cnt := 0.	[tim &gt; stop] whileFalse:		[val := strm upTo: $/.						"read to next $/ "		(val includes: $*)						"handle * expressions"			ifTrue: [ | str2 | 				str2 := ReadStream on: val.				num := 1.0 / (str2 upTo: $*) asNumber.				cnt := str2 upToEnd asNumber.				cnt timesRepeat: 					[eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num]]				ifFalse: [(val includes: $.)				"handle dotted rhythmic values"				ifTrue: [ | va2 nDots delD |					va2 := val copyWithout: $. .					nDots := val size - va2 size.					num := 4.0 / val asNumber.					delD := num / 2.0.					nDots timesRepeat:						[num := num + delD.						delD := delD + (delD / 2.0)].					eList add: (MusicEvent dur: num voice: instrument).					tim := tim + num.					strm atEnd ifTrue: [strm := ReadStream on: data]]				ifFalse: [(val includes: $-)		"handle rests"					ifTrue: [val isEmpty ifFalse: [num := -4.0 / val asNumber].						eList add: (RestEvent dur: num).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]					ifFalse: [val isEmpty ifFalse: [num := 4.0 / val asNumber].						eList add: (MusicEvent dur: num voice: instrument).						tim := tim + num.						strm atEnd ifTrue: [strm := ReadStream on: data]]]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSequential:from:into:">writeSequential: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					cnt timesRepeat: 						[evt perform: property with: num.						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [evt perform: property with: val].		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'd/e/fs/e/fs/g/fs/e/d/fs/g/a/						d/e/fs/e/fs/g/fs/e/d/fs/e/d/'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 240.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 240.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 240.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 27, 2020' '11:06:40 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 11:06:40 PM on July 27, 2020."</do-it><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	score scaleDurationsBy: 3.0.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>43 \\ 100 / 100</do-it><do-it>43 \\ 100 / 10.0</do-it><do-it>100.5 \\ 100</do-it><do-it>210.5 \\ 100</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test11:val:">test11: which val: val	"Inspect a simple Score11 event list - test duty cycle settings"	"Score11 test11: #scale val: 0.5"	"Score11 test11: #add val: 0.5"	"Score11 test11: #sub val: 0.1"	"Score11 test11: #set val: 1.0"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.5  0.5); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #scale ifTrue: [s11 du: val].	which == #add ifTrue: [s11 du: val + 100].	which == #sub ifTrue: [s11 du: val + 200].	which == #set ifTrue: [s11 du: val + 300].	sco := s11 eventList.	sco scaleDurationsBy: 0.1.	sco open</body></methods><do-it>Score11 test11: #scale val: 0.5</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test11:val:">test11: which val: val	"Inspect a simple Score11 event list - test duty cycle settings"	"Score11 test11: #scale val: 0.5"	"Score11 test11: #add val: 0.5"	"Score11 test11: #sub val: 0.1"	"Score11 test11: #set val: 1.0"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.5  0.5); 		add: #p4 -&gt; 440.0;		add: #p5 -&gt; 0.01).	which == #scale ifTrue: [s11 du: val].	which == #add ifTrue: [s11 du: val + 100].	which == #sub ifTrue: [s11 du: val + 200].	which == #set ifTrue: [s11 du: val + 300].	sco := s11 eventList.	sco open</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test11:val:">test11: which val: val	"Inspect a simple Score11 event list - test duty cycle settings"	"Score11 test11: #scale val: 0.5"	"Score11 test11: #add val: 0.5"	"Score11 test11: #sub val: 0.1"	"Score11 test11: #set val: 1.0"	| s11 sco |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; #(1.0  0.5  0.5); 		add: #p4 -&gt; #(1.0  220  440);		add: #p5 -&gt; 0.01).	which == #scale ifTrue: [s11 du: val].	which == #add ifTrue: [s11 du: val + 100].	which == #sub ifTrue: [s11 du: val + 200].	which == #set ifTrue: [s11 du: val + 300].	sco := s11 eventList.	sco open</body></methods><do-it>Score11 test11: #scale val: 0.5</do-it><methods><class-id>Siren.Score11</class-id> <category>private-post-processors</category><body package="(none)" selector="duty:list:">duty: dutyCycle list: eList	"Post-process the event list's durations."	"000 - 099		multiply dur by dutyCycle	  100 - 199		add dutyCycle - 100 to dur	 200 - 299		subtract dutyCycle - 200 from dur	 300 - 399		set dur to dutyCycle - 300	 400 - 399		set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"	| dec val |	dec := (dutyCycle / 100) truncated.	val := dutyCycle \\ 100.	(dec == 0) ifTrue: 			"000 - 099	multiply dur by dutyCycle"		[eList scaleDurationsBy: val.		^self].	(dec == 1) ifTrue: 			"100 - 199	add dutyCycle - 100 to dur"		[eList eventsDo: [ :ev | ev duration: (ev duration + (ev duration species value: val))].		eList recomputeDuration.		^self].	(dec == 2) ifTrue: 			"200 - 299	subtract dutyCycle - 200 from dur"		[eList eventsDo: [ :ev | ev duration: (ev duration - (ev duration species value: val))].		eList recomputeDuration.		^self].	(dec == 3) ifTrue: 			"300 - 399	set dur to dutyCycle - 300"		[eList eventsDo: [ :ev | ev duration: (ev duration species value: val)].		eList recomputeDuration.		^self].	(dec &gt;= 4) ifTrue: 			"400 - 399	set dur to dutyCycle - 400 cycles (dur = (1/Hz) * (dutycycle - 400)"		[eList eventsDo: 			[ :ev |  | frq |			frq := ev pitch asHz.			ev duration: ((1.0 / frq) * (dutyCycle - 400) sec)].		eList recomputeDuration].</body></methods><do-it>Score11 test11: #add val: 0.5</do-it><do-it>Score11 test11: #sub val: 0.1</do-it><do-it>Score11 test11: #set val: 1.0</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 3.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 6.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 20.					"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody from Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 2.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 3.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 1.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><do-it>Score11 melody1b</do-it><do-it>'c' pitch</do-it><do-it>self asMIDI</do-it><do-it>'c4' pitch</do-it><do-it>self asMIDI</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c4/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 1.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 1.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c6/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 1.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c6/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 1.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><do-it>'c4' last isDigit</do-it><do-it>'c' last isDigit</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr oct |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := 3.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit ifTrue: [oct := num last.						num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]												"else just assign property"				ifFalse: [evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; #(10 10 100));			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));			-- set		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p5 -&gt; (#mx -&gt; #(5 4 100  5 100 5))		-- multi-stage exponential move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5')		-- numerical sequences 	 "	| item key val |	item := generators at: param ifAbsent: [nil].	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	(isReq not and: [item isNil])		ifTrue: [^self].	(item isImmediate or: [item respondsToArithmetic]) ifTrue:			"handle consts"		[^self writeConst: property from: item into: eList].	item isAssociation ifFalse:			"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeNotes: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr oct |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit ifTrue: [oct := num last.						num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]												"else just assign property"				ifFalse: [evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr oct |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit ifTrue: [oct := num last.						num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]												"else just assign property"				ifFalse: [val last isDigit					ifTrue: [oct := val last.						val := val allButLast: 1].					evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr oct |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit ifTrue: [oct := String with: num last.						num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]												"else just assign property"				ifFalse: [val last isDigit					ifTrue: [oct := String with: val last.						val := val allButLast: 1].					evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]].		ind := ind + 1].	^self</body></methods><do-it>Score11 melody1b</do-it><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 2.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 3.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice"	vox channel: 3.	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><do-it>Score11 melody1b</do-it><do-it>Score11 melody1b</do-it><do-it>Score11 melody1b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf  p. 99"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c6/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)).						"L/R position"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 tempo: 280.	s11 du: 0.8.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice""	vox channel: 3."	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1b</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 28, 2020' '11:17:21 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 11:17:21 AM on July 28, 2020."</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.AbstractEvent</class-id> <category>properties</category><body package="Siren" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	"Handle doesNotUnderstand: to try to access the property dictionary.	If this is unsuccessful, announce that the receiver does not understand the argument."	"N.B.: One may want to turn this off for debugging."	| sel |	sel := aMessage selector.	(sel includes: $:)									"access property"		ifFalse: [(properties ~~ nil and: [properties includesKey: sel])			ifTrue: [^properties at: sel]]		ifTrue: [((sel occurrencesOf: $:) = 1)			"set property"			ifTrue: [^self at: (sel copyUpTo: $:) asSymbol					put: (aMessage arguments at: 1)]].	^super doesNotUnderstand: aMessage			"otherwise"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 1.0 4.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #index:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 1.0 8.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #index:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 4.0 12.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #index:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #index)			"index"		ifTrue: [arr at: 6 put: (e at: #index)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 4.0 40.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #index:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 4.0 400.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #index:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #index)			"index"		ifTrue: [arr at: 6 put: (e at: #index)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position. self halt."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].self halt.	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	postProcessors keysAndValuesDo:		[ :key :val |		self perform: key with: val with: eList].	^eList</body></methods><do-it>rnd nextFrom: (array at: 2) to: (array last)</do-it><do-it>rnd nextFrom: (array at: 2) to: (array last) </do-it><do-it>rnd nextFrom: (array at: 2) to: (array last)  </do-it><do-it>rnd nextFrom: (array at: 2) to: (array last)   </do-it><methods><class-id>Siren.Score11</class-id> <category>playing</category><body package="(none)" selector="eventList">eventList	"Answer an eventList for the receiver."	| eList param keys |	eList := EventList newNamed: 'Score11-I', instrument printString.	"create new event list"	keys := generators keys copy.	param := generators at: #p3.					"P3 is required"	param ifNil: [self error: 'No duration data?'].	self writeP3: param into: eList.	keys remove: #p3.												"Process optional parameters"	self populate: #p4 required: false as: #pitch: into: eList.	keys remove: #p4 ifAbsent: [nil].	self populate: #p5 required: false as: #loudness: into: eList.	keys remove: #p5 ifAbsent: [nil].	keys do: [ :aK |		(paramMap includesKey: aK)			ifTrue: [self populate: aK required: false as: (paramMap at: aK) into: eList]			ifFalse: [self populate: aK required: false as: (aK, ':') asSymbol into: eList]].	postProcessors keysAndValuesDo:		[ :key :val |		self perform: key with: val with: eList].	^eList</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 4.0 400.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #modInd:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd:)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd:)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position. self halt."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><do-it>arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)			"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd:)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position.</do-it><do-it>e hasProperty: #modInd</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)			"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position. self halt."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)			"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e position."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 2.0 8.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #modInd:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0;									"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0);						"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0)).						"index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #modInd:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 28, 2020' '5:03:02 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 5:03:02 PM on July 28, 2020."</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0 mappedTo: #gliss:;				"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mappedTo: #gliss:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mappedTo: #gliss:).	"modulation index"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	s11 assign: #p8 to: #modInd:.	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="add:mappedTo:">add: instAssoc mappedTo: prop	"Add a generator clause to the receiver"	generators at: instAssoc key put: instAssoc value.	self assign: instAssoc key to: prop</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0 mappedTo: #gliss:;				"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mappedTo: #position:;	"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mappedTo: #modInd:).	"modulation index"	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0 mappedTo: #gliss:;				"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mappedTo: #position:;	"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mappedTo: #modInd:).	"modulation index"	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 														"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: (#p5 -&gt; 0.25);								"ampl ratio"		add: #p6 -&gt; 1.0 mappedTo: #gliss:;				"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0)) mappedTo: #position:;	"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mappedTo: #modInd:).	"modulation index"	s11 tempo: 280.	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mappedTo: #gliss:;					"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 -1.0 1.0)) mappedTo: #pos:;	"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mappedTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11</class-id> <category>accessing</category><body package="(none)" selector="add:mapTo:">add: instAssoc mapTo: prop	"Add a generator clause to the receiver"	generators at: instAssoc key put: instAssoc value.	self assign: instAssoc key to: prop</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note (broken)"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><remove-selector><class-id>Siren.Score11</class-id> <selector>add:mappedTo:</selector></remove-selector><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 28, 2020' '6:46:59 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:46:59 PM on July 28, 2020."</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore)"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Score for a simple melody by Praetorius (Volta 201 from Terpsichore); play it on the CSL FM bell"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf  p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf" "p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1b">melody1b	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) via MIDI chan 1"	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf  p. 99"	"Score11 melody1b"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 0.9.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score events removeLast.							"remove last note (broken)"	vox := MIDIVoice default.								"plug in the voice""	vox channel: 3."	score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 28, 2020' '6:50:47 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:50:47 PM on July 28, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #position:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 booh3</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 32 + 1) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 booh3</do-it><do-it>Score11 melody1</do-it><do-it>Score11 booh1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 3162 + 32) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 32) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 32) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf" "p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 32) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><do-it>7 - 1 \\ 16 + 32</do-it><do-it>1 - 1 \\ 16 + 32</do-it><do-it>17 - 1 \\ 16 + 32</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf" "p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 32) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf" "p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 32) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos.	Transcript show: arr printString; cr.	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0		//				 0    1       2        3      4         5     6  "	^[ :e :v | | arr |	arr := Array new: 7.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos.				"L/R position""	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf" "p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><do-it>Score11 melody1</do-it><do-it>1 - 1 \\ 16 + 40</do-it><do-it>Score11 melody1</do-it><do-it>1 - 1 \\ 16 + 40</do-it><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="melody1">melody1	"Play the score for a simple melody by Praetorius (Volta 201 from Terpsichore) on the CSL FM bell."	"http://conquest.imslp.info/files/imglnks/usimg/f/f1/IMSLP464311-PMLP176492-PraetoriusTerpsichoreCantus.pdf" "p. 99"	"Score11 melody1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 32) 				"Score11 instrument block"															"dur in sec"		add: #p3 -&gt; (#rh -&gt; '4///8//4////2//1/						4///8//4////2//1/'); 															"pitch in Hz"		add: #p4 -&gt; (#no -&gt; 'c/d/e/d/e/f/e/d/c/e/f/g/						c/d/e/d/e/f/e/d/c/e/d/c'); 		add: #p5 -&gt; #(1.0 0.25 0.35);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(32 1.0 -1.0)) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 10.0) mapTo: #modInd:).		"modulation index"	s11 tempo: 280.										"speed it up"	s11 du: 5.0.											"duty cycle &lt; 100 scales evt dur by value"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh1">booh1	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh1"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 2000 3000 , 2000 2100 /						20 2050 2050 /						30 2000 2100 , 2200 1600 /						20 2400 2500 , 2800 2000 /						30 2400 2400 , 2200 2100'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2');	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 to: #gliss:.	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"														"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 														"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);								"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2')to: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0)to: #pos: ).						"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:).							"L/R position"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 4.0 16.0) mapTo: #modInd:).		"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 4.0 16.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 40) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 booh3</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 4.0 16.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 melody1</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="stringExample:to:">stringExample: oct1 to: oct2	"Play a long merged list of random notes on the CSL plucked string instrument"	"OSCVoice stringExample2"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL StringInstrument has args: ampl, c_fr, pos"	"CSL SynthServer		0 - 15 = plucked string		16 - 23 = snd-file sampler		24 - 39 = FM voices		40 - 55 =  FM bells		56 - 63 = SOS x-fade voices"	| num scale evList voice  pitches |	num := 10.	scale := OrderedCollection new.						"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N re) notes) collect: [ : ea | ea name asLowercase].	oct1 to: oct2 do: [ :oct |		1 to: pitches size do: [ :ind |			scale add: (Pitch value: (pitches at: ind), oct printString) asHertz]].	evList := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: num 		"add in the 2nd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	evList addAll: (EventList randomExample: num 		"add in the 3rd event list"		from: ((#duration: -&gt; (1.0 to: 2.5)), 			(#ampl: -&gt; (0.1 to: 0.5)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: evList events size do: 							"plug in instruments 1-16"		[ :ind | | ev |					ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	evList computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLString.			"plug in the parameter map"	evList voice: voice.	evList play.											"play"	^Array with: evList duration with: voice</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1: 1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	"CSL SynthServer		0 - 15 = plucked string		16 - 23 = snd-file sampler		24 - 39 = FM voices		40 - 55 =  FM bells		56 - 63 = SOS x-fade voices"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 57) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play""	^Array with: events duration with: voice"</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>examples</category><body package="Siren" selector="vxFadeExample1:">vxFadeExample1: num	"Play a long merged list of random notes on the CSL vector SOS instrument"	"OSCVoice vxFadeExample1: 1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL VSOS Instrument has args: dur, ampl, frq, pos"	"CSL SynthServer		0 - 15 = plucked string		16 - 23 = snd-file sampler		24 - 39 = FM voices		40 - 55 =  FM bells		56 - 63 = SOS x-fade voices"	| scale events voice  pitches |	scale := OrderedCollection new.							"create a list of freqs of a 3-octave pentatonic scale on D"	pitches := ((PentatonicScale root: N do) notes) collect: [ : ea | ea name asLowercase].	1 to: pitches size do: [ :ind |		scale add: (Pitch value: (pitches at: ind), '0') asHertz]. 	events := (EventList randomExample: num 				"create the event list"		from: ((#duration: -&gt; (4.0 to: 8.5)), 			(#ampl: -&gt; (0.06 to: 0.2)), 			(#pitch: -&gt; scale), 			(#pos: -&gt; (-1.0 to: 1.0)))).	1 to: events events size do: 								"plug in instruments 40-48"		[ :ind | | ev |					ev := (events events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 8 + 57) printString, '/pn')].	events computeDuration.	voice := self default.	voice parameterMap: self pMapForCSLVSOS.				"plug in the parameter map"	events voice: voice.	events play.												"play"	^Array with: events duration with: voice</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 29, 2020' '3:21:48 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 3:21:48 PM on July 29, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private</category><body package="(none)" selector="cleanStreamFrom:">cleanStreamFrom: vString	"Clean up the string and answer a stream on it."	| tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	^(ReadStream on: tStr)</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	| strm ind evts tStr oct newEvents |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	newEvents := EventList newAnonymous.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit						ifTrue: [oct := String with: num last.							num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [(val includes: $:)			"handle : chord expressions"					ifTrue: [ | str2 firstDone | 						str2 := ReadStream on: val.						firstDone := false.						[str2 atEnd] whileFalse:							[num := (str2 upTo: $*).							num last isDigit							ifTrue: [oct := String with: num last.								num := num allButLast: 1].							firstDone								ifFalse: [evt perform: property with: (num, oct).									firstDone := true.]								ifTrue: [ | newEv |									newEv := evt copy.									newEv perform: property with: (num, oct).									newEvents add: eAss start =&gt; newEv]]]												"else just assign property"						ifFalse: [val last isDigit							ifTrue: [oct := String with: val last.								val := val allButLast: 1].							evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]]].		ind := ind + 1].	newEvents isEmpty		ifFalse: [eList addAll: newEvents].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4*3/a*5/'); "	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4:e:g:/d:fs:a/ef:g:bf'); "	| strm ind evts tStr oct newEvents |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	newEvents := EventList newAnonymous.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit						ifTrue: [oct := String with: num last.							num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [(val includes: $:)			"handle : chord expressions"					ifTrue: [ | str2 firstDone | 						str2 := ReadStream on: val.						firstDone := false.						[str2 atEnd] whileFalse:							[num := (str2 upTo: $*).							num last isDigit							ifTrue: [oct := String with: num last.								num := num allButLast: 1].							firstDone								ifFalse: [evt perform: property with: (num, oct).									firstDone := true.]								ifTrue: [ | newEv |									newEv := evt copy.									newEv perform: property with: (num, oct).									newEvents add: eAss start =&gt; newEv]]]												"else just assign property"						ifFalse: [val last isDigit							ifTrue: [oct := String with: val last.								val := val allButLast: 1].							evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]]].		ind := ind + 1].	newEvents isEmpty		ifFalse: [eList addAll: newEvents].	^self</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test12">test12	"Inspect a simple Score11 event list - test chords"	"Score11 test12"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 5) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#no -&gt; 'c4:e:g:/d:fs:a/ef:g:bf')).	s11 eventList inspect</body></methods><do-it>Score11 test12</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4*3/a*5/'); "	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4:e:g:/d:fs:a/ef:g:bf'); "	| strm ind evts tStr oct newEvents |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	newEvents := EventList newAnonymous.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit						ifTrue: [oct := String with: num last.							num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [(val includes: $:)			"handle : chord expressions"					ifTrue: [ | str2 firstDone | 						str2 := ReadStream on: val.						firstDone := false.						[str2 atEnd] whileFalse:							[num := (str2 upTo: $:).							num last isDigit							ifTrue: [oct := String with: num last.								num := num allButLast: 1].							firstDone								ifFalse: [evt perform: property with: (num, oct).									firstDone := true.]								ifTrue: [ | newEv |									newEv := evt copy.									newEv perform: property with: (num, oct).									newEvents add: eAss start =&gt; newEv]]]												"else just assign property"						ifFalse: [val last isDigit							ifTrue: [oct := String with: val last.								val := val allButLast: 1].							evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]]].		ind := ind + 1].	newEvents isEmpty		ifFalse: [eList addAll: newEvents].	^self</body></methods><do-it>Score11 test12</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test12">test12	"Inspect a simple Score11 event list - test chords"	"Score11 test12"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 5) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#no -&gt; 'c4:e:g:/d:fs:a/ef:g:bf/')).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeNotes:from:into:">writeNotes: property from: vString into: eList	"Parse and process the sequential keywords to generate events"	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); "	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4*3/a*5/'); "	"aScore11 add: #p4 -&gt; (#no -&gt; 'c4:e:g:/d:fs:a/ef:g:bf'); "	| strm ind evts tStr oct newEvents |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	strm := ReadStream on: tStr.	ind := 1.	evts := eList events.	oct := '3'.	newEvents := EventList newAnonymous.	[ind &lt; eList events size] whileTrue:		[ | eAss tn val cnt evt num | 		eAss := evts at: ind.		evt := eAss event.		tn := eAss time asSec value.		(tn &gt;= start and: [tn &lt;= (stop)]) ifTrue:			[val := strm upTo: $/.					"read to next $/ "			(val includes: $*)					"handle * expressions"				ifTrue: [ | str2 | 					str2 := ReadStream on: val.					num := (str2 upTo: $*).					cnt := str2 upToEnd asNumber.					num last isDigit						ifTrue: [oct := String with: num last.							num := num allButLast: 1].					cnt timesRepeat: 						[evt perform: property with: (num, oct).						ind := ind + 1.						evt := (evts at: ind) event]]				ifFalse: [(val includes: $:)			"handle : chord expressions"					ifTrue: [ | str2 firstDone | 						str2 := ReadStream on: val.						firstDone := false.						[str2 atEnd] whileFalse:							[num := (str2 upTo: $:).							num last isDigit							ifTrue: [oct := String with: num last.								num := num allButLast: 1].							firstDone								ifFalse: [evt perform: property with: (num, oct).									firstDone := true.]								ifTrue: [ | newEv |									newEv := evt copy.									newEv perform: property with: (num, oct).									newEvents add: eAss start =&gt; newEv]]]												"else just assign property"						ifFalse: [val last isDigit							ifTrue: [oct := String with: val last.								val := val allButLast: 1].							evt perform: property with: (val, oct)].												"repeat as necessary"		strm atEnd ifTrue: [strm := ReadStream on: vString]]].		ind := ind + 1].	newEvents isEmpty		ifFalse: [eList addAll: newEvents].	^self</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item t0 strm segs tN |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[item := strm next.		segDur := strm next.		[item = '/'] whileFalse:			[toks add: item].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	self halt.	rnd := Random new.	1 to: segs size do:		[ :ind |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tn |			evt := eAss event.			tn := eAss time asSec value.			(tn &gt;= t0 and: [tn &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[item := strm next.		segDur := strm next.		[item = '/'] whileFalse:			[toks add: item].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	self halt.	rnd := Random new.	1 to: segs size do:		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[item := strm next.		segDur := strm next.		[item = '/'] whileFalse:			[toks add: item].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	self halt.	rnd := Random new.	1 to: segs size do:		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test13">test13	"Inspect a simple Score11 event list - multi-segment sets"	"Score11 test13"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4/')).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[item := strm next.		segDur := strm next.		[item = '/'] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	self halt.	rnd := Random new.	1 to: segs size do:		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 30, 2020' '1:53:34 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 1:53:34 PM on July 30, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private</category><body package="(none)" selector="compactStreamFrom:">compactStreamFrom: vString	"Clean up the string and answer a stream on it."	| tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyWithout: $ .	tStr := tStr copyWithout: $	.	^(ReadStream on: tStr)</body></methods><methods><class-id>Siren.Score11</class-id> <category>private</category><body package="(none)" selector="cleanStreamFrom:">cleanStreamFrom: vString	"Clean up the string and answer a stream on it - leave spaces."	| tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	^(ReadStream on: tStr)</body></methods><methods><class-id>Siren.Score11</class-id> <category>private</category><body package="(none)" selector="cleanStreamFrom:">cleanStreamFrom: vString	"Clean up the string and answer a stream on it - leave spaces."	| tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '/' with: ' / '.	tStr := tStr copyReplaceAll: '	' with: ' '.			"tab"	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	^(ReadStream on: (tStr tokensBasedOn: $ ))</body></methods><do-it>strm atEnd</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[item := strm next.		segDur := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	self halt.	rnd := Random new.	1 to: segs size do:		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><do-it>strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	</do-it><do-it> self cleanStreamFrom: vString.</do-it><do-it>self cleanStreamFrom: vString.</do-it><do-it>tStr copyFrom: 1 to: tStr size -1</do-it><do-it>tStr := tStr copyFrom: 1 to: tStr size - 1</do-it><do-it>tStr tokensBasedOn: $ </do-it><methods><class-id>Siren.Score11</class-id> <category>private</category><body package="(none)" selector="cleanStreamFrom:">cleanStreamFrom: vString	"Clean up the string and answer a stream on it - leave spaces."	| tStr |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '/' with: ' / '.	tStr := tStr copyReplaceAll: '	' with: ' '.			"tab"	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	(tStr last == $ )		ifTrue: [tStr := tStr copyFrom: 1 to: tStr size - 1].	^(ReadStream on: (tStr tokensBasedOn: $ ))</body></methods><do-it>	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:				"collect the segments"					[segDur := strm next.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].	</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:				"collect the segments"					[segDur := strm next.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].		rnd := Random new.	1 to: segs size do:		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := Set new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := Set new].		rnd := Random new.	1 to: segs size do:						"step through the segments"		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	1 to: segs size do:						"step through the segments"		[ :ind | | t0 tN |		t0 := (segs at: ind) key.		ind + 1 = segs size			ifFalse: [tN := (segs at: ind) key]			ifTrue: [tN := stop].		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)]]]</body></methods><do-it>Score11 test13</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[evt perform: property with: (toks atRandom: rnd)].		t0 := tN]]</body></methods><do-it>Score11 test13</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[ | val |				val := toks atRandom: rnd.				evt perform: property with: val.				Transcript show: tX printString, ' - ', val printString; cr].		t0 := tN]]</body></methods><do-it>Score11 test13</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX | self halt.			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[ | val |				val := toks atRandom: rnd.				evt perform: property with: val.				Transcript show: tX printString, ' - ', val printString; cr].		t0 := tN]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX | self halt.			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[ | val |				val := toks atRandom: rnd.				evt perform: property with: val.				Transcript show: tX printString, ' - ', val printString; cr]].		t0 := tN]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[ | val |				val := toks atRandom: rnd.				evt perform: property with: val.				Transcript show: tX printString, ' - ', val printString; cr]].		t0 := tN]</body></methods><do-it>Score11 test13</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 30, 2020' '2:35:24 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 2:35:24 PM on July 30, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX | self halt.			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[ | val |				val := toks atRandom: rnd.				evt perform: property with: val."				Transcript show: tX printString, ' - ', val printString; cr"].		t0 := tN]]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 12) 				"Score11 instrument block"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2///'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; (#mo -&gt; #(1.0 1.0 -1.0)) mapTo: #pos:;	"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 120.										"speed it up"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 30, 2020' '8:12:31 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 8:12:31 PM on July 30, 2020."</do-it><do-it>Score11 chorale1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 12) 				"Score11 instrument block"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2///'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:;				"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 120.										"speed it up"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><do-it>Siren.RatioLoudness reorganizeFromString: '(''printing'' #printOn0:)(''converting'' #asDB #asMIDI #asSymbol)(''private'' #species)'</do-it><do-it>Siren.RatioLoudness reorganizeFromString: '(''converting'' #asDB #asMIDI #asSymbol)(''private'' #species)(''printing'' #printOn0:)'</do-it><do-it>Siren.RatioLoudness reorganizeFromString: '(''converting'' #asDB #asMIDI #asSymbol)(''printing'' #printOn0:)(''private'' #species)'</do-it><methods><class-id>Siren.RatioLoudness</class-id> <category>printing</category><body package="Siren" selector="printOn:">printOn: aStream	"Print the receiver as a ratio."	aStream nextPutAll: "'a:'," value printString</body></methods><remove-selector><class-id>Siren.RatioLoudness</class-id> <selector>printOn0:</selector></remove-selector><methods><class-id>Siren.MusicMagnitude</class-id> <category>printing</category><body package="Siren" selector="printValue">printValue	value isString ifTrue: [^value].	value isLPReal ifTrue: [^value printPlaces: 4].	^value printString</body></methods><methods><class-id>Siren.MusicMagnitude</class-id> <category>printing</category><body package="Siren" selector="printValue">printValue	value isString ifTrue: [^value].	value isLPReal ifTrue: [^value printString: 4].	^value printString</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: '	', pitch printString].	loudness == nil		ifFalse: [aStream nextPutAll: '	(ampl: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString]."	voice == nil		ifFalse: [aStream nextPutAll: '	(v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: '	(', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: '	(', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: '	', pitch printString].	loudness == nil		ifFalse: [aStream nextPutAll: '	(ampl: ', loudness printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString]."	voice == nil		ifFalse: [aStream nextPutAll: '	(v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: '	(', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: '	(', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: '	', pitch printString].	loudness == nil		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: '	(v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: '	(', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: '	(', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Siren.RatioLoudness</class-id> <category>printing</category><body package="Siren" selector="units">units	"Answer the units string of the receiver."	^' V'</body></methods><methods><class-id>Siren.RatioLoudness</class-id> <category>printing</category><body package="Siren" selector="units">units	"Answer the units string of the receiver."	^' dB'</body></methods><do-it>Score11 chorale1</do-it><do-it>Score11 chorale1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 12) 				"Score11 instrument block"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2///'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:;				"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 120.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 				"Score11 instrument block"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2///'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:;				"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 120.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 				"Score11 instrument block"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:;				"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 120.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:;				"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 120.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale1">chorale1	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block for 9 beats"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; 1.0 mapTo: #gliss:;						"gliss ratio"		add: #p7 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:;				"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).			"modulation index"	s11 tempo: 100.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale2">chorale2	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block for 9 beats"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:).				"L/R position"	s11 tempo: 100.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLString.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale2">chorale2	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale2"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block for 9 beats"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.25 0.3);							"ampl ratio"		add: #p6 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:).				"L/R position"	s11 tempo: 100.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLString.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale2</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale2">chorale2	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale2"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block for 9 beats"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.75 0.9);							"ampl ratio"		add: #p6 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:).				"L/R position"	s11 tempo: 100.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLString.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale2</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale2">chorale2	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale2"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block for 9 beats"															"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 															"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.85 0.95);							"ampl ratio"		add: #p6 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:).				"L/R position"	s11 tempo: 100.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLString.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale2</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="chorale2">chorale2	"Play the score for a Bach chorale - http://scores.ccarh.org/bach/chorale/chorales.pdf #28"	"Score11 chorale2"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 9) 				"Score11 instrument block for 9 beats"														"dur in beats"		add: #p3 -&gt; (#rh -&gt; '4/////2//'); 														"pitch as chords"		add: #p4 -&gt; (#no -&gt; 'f3:a4:c:f/f4:c5:f:a6/e4:c5:g:g/eb4:c:f:a5/d4:d:f:bb5/c4:g:e5:c/f4:c:f5:a/'); 		add: #p5 -&gt; #(1.0 0.85 0.95);						"ampl ratio"		add: #p6 -&gt; #(1.0 1.0 -1.0) mapTo: #pos:).			"L/R position"	s11 tempo: 100.										"speed it up"	s11 du: 303.											"duty cycle sets evt dur to 3"	score := s11 eventList.								"generate the score"	score flushVoices.	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 1) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLString.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 chorale1</do-it><do-it>Score11 booh3</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 8.0 24.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 8.0 24.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 booh3</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 6.0 20.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="booh3">booh3	"Score for the first section of 'Bat out of Hell' (1980-82)"	"Score11 booh3"	"100 timesRepeat: [Score11 booh1. (Delay forSeconds: 130) wait ]"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 120) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '15 .4 .5 , .05 .14 /									15 .1 .15 , .5 .4 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '20 200 300 , 200 210 /						20 205 205 /						30 200 210 , 220 160 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; 0.1);												"ampl ratio"		add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .8 1.2') mapTo: #gliss:;	"gliss ratio"		add: #p7 -&gt; #(1.0 -1.0 1.0) mapTo: #pos:;							"L/R position"		add: #p8 -&gt; #(1.0 6.0 20.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in dur &amp; instruments 1-32"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 booh3</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 30, 2020' '8:42:07 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 8:42:07 PM on July 30, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 .05 .05 , .05 .06 /									5 .06 .06 , .06 .07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 100 1050 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: (#p5 -&gt; (#mx -&gt; '4 0.2 0.3 / 6 0.3 0.5') );						"ampl ratio"		add: #p6 -&gt; (#mx -&gt; ' 1.0 .8 1.2') mapTo: #gliss:;					"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.0 0.0 , 0.0 -0.5' ) mapTo: #pos:;			"L/R position"		add: #p8 -&gt; #(1.0 6.0 12.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 .05 .05 , .05 .06 /									5 .06 .06 , .06 .07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 100 1050 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.2 0.3  6 0.3 0.5));						"ampl ratio"		add: #p6 -&gt; (#mx -&gt; ' 1.0 .8 1.2') mapTo: #gliss:;					"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.0 0.0 , 0.0 -0.5' ) mapTo: #pos:;			"L/R position"		add: #p8 -&gt; #(1.0 6.0 12.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 .05 .05 , .05 .06 /									5 .06 .06 , .06 .07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 100 1050 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.2 0.3  6 0.3 0.5));						"ampl ratio"		add: #p6 -&gt; #(1.0 .8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.0 0.0 , 0.0 -0.5' ) mapTo: #pos:;			"L/R position"		add: #p8 -&gt; #(1.0 6.0 12.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 .05 .05 , .05 .06 /									5 .06 .06 , .06 .07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 100 1050 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.2 0.3  6 0.3 0.5));						"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.0 0.0 , 0.0 -0.5' ) mapTo: #pos:;			"L/R position"		add: #p8 -&gt; #(1.0 6.0 12.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 .05 .05 , .05 .06 /									5 .06 .06 , .06 .07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 100 1050 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.2 0.3  6 0.3 0.5));						"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 6.0 12.0) mapTo: #modInd:).					"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.02 0.1  6 0.3 0.5));						"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).						"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.05 0.1  6 0.1 0.3));						"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 4.0 8.0) mapTo: #modInd:).						"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 30, 2020' '9:01:56 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 9:01:56 PM on July 30, 2020."</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 2.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 303.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 2.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to 3"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 2.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 120.				"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 900 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 2.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						4 920 920 /						5 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 2.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 2.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 10) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						20 .5 .3 , .1 .13 /						25 .2 .1 , .6 .6 /						25 .5 .7 , .1 .06 /						20 .12 .08 , .5 .5'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						20 240 250 , 280 200 /						30 240 240 , 220 210'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1			4 0.04 0.08  6 0.1 0.1  4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1			4 0.04 0.08  6 0.1 0.1  4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1			4 0.04 0.08  6 0.1 0.1  4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 			10 0.01 -0.01 , 0.01 -0.5 / 10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 10.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 		add: #p5 -&gt; (#mo -&gt; #(4 0.04 0.08  6 0.1 0.1			4 0.04 0.08  6 0.1 0.1  4 0.04 0.08  6 0.1 0.1));					"ampl ratio"		add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 			10 0.01 -0.01 , 0.01 -0.5 / 10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						1.0 1.0 1.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.04 0.08 / 6 0.1 0.1 /					1 0.0001 0.0001 /				4 0.04 0.08  6 0.1 0.1  				1 0.0001 0.0001 /				4 0.04 0.08  6 0.1 0.1 / ');			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 30) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						1.0 1.0 1.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.04 0.08 / 6 0.1 0.1 /					1 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1  /				1 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1 /');			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>strm atEnd</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces""	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:						"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.			"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		(strm atEnd) ifFalse:			[sep := strm next.					"read comma or slash"			('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].			(sep = ',')							"comma means read 2 more tokens"				ifTrue: [interp := true.					a1 := strm next asNumber.					b1 := strm next asNumber.					(strm atEnd)					"read trailing slash"									ifFalse: [sep := strm next.							((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]				ifFalse: [interp := false]].			"3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		interp ifTrue:			[vDiff0 := (a1 / a0) asFloat.				vDiff1 := (b1 / b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[interp							"false means single rand range for segment"					ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]					ifTrue: [tScale := (tN - t0) / tDiff.						v0 := a0 asFloat * (vDiff0 raisedTo: tScale).						v1 := b0 asFloat * (vDiff1 raisedTo: tScale).						val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."						Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr"].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						2 1 1 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						2 1 1 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.04 0.08 / 6 0.1 0.1 /					1 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1  /				1 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1 /');			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						2 1 1 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						2 1 1 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.04 0.08 / 6 0.1 0.1 /					1 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1  /				1 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1 /');			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 /									5 0.1 0.1 , 0.12 0.07 /						2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 /						2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 /						5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						2 1 1 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 /						2 1 1 /						3 1000 1000 , 1000 960 /						3 920 920 /						4 920 910 , 880 860 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.04 0.08 / 6 0.1 0.1 /					2 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1  /				2 0.0001 0.0001 /				4 0.04 0.08 / 6 0.1 0.1 /');			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5 / 				10 0.01 -0.01 , 0.01 -0.5' ) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	s11 assign: #p6 .	s11 assign: #p7 to: #pos:.	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 30, 2020' '9:27:45 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 9:27:45 PM on July 30, 2020."</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 31, 2020' '4:39:16 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:39:16 PM on July 31, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 940 910 , 890 100 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 				12 -0.5 0.0' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 940 910 , 890 100 						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 				12 -0.5 0.0' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 940 910 , 890 100 /						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0 /' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 940 910 , 890 100 /						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0 /' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 940 910 , 890 900 /						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0 /' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 940 910 , 890 900 /						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0 /' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900 /						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15 /'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0 /' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>strm atEnd</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 				12 -1.0 -0.5 /				12 -0.5 0.0' 				) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first section of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>ClusterEditor allInstances</do-it><do-it>self terminate</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1"	| s11 score vox |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.											"duty cycle sets evt dur to X - 300"	score := s11 eventList.								"generate the score and take an excerpt"	score flushVoices.	score := score excerptFrom: 0 to: 30.					"trim to the time alloted..."	1 to: score events size do: 							"plug in instruments 41-56"		[ :ind | | ev |					ev := (score events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score events removeLast.							"remove last note"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score voice: vox.		InputState default shiftDown ifTrue: [^score inspect].	"inspect"	score play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>ClusterEditor allInstances</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 31, 2020' '4:56:15 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:56:15 PM on July 31, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 31, 2020' '4:56:25 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:56:25 PM on July 31, 2020."</do-it><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="assignInstruments:">assignInstruments: instBlock	"Assign the instruments based on the index using the given block"	1 to: events size do: 							"plug in instruments"		[ :ind | | ev |					ev := (events at: ind) event.		ev inst: (instBlock value: ind)].</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						/ 10 0.06 0.06 / 2.0 2.0 2.0						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5						') mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0						') mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						/ 10 0.06 0.06 / 2.0 2.0 2.0						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5						') mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0						') mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>strm atEnd</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5						') mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0						') mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5						') mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0						') mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists"self halt."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.8 0.9 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.09 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.18  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.16  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 3.0 / 5 3.0 4.0 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.16  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 3.0 / 5 3.0 4.0 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove0:from:into:">writeMove0: property from: array into: eList	"Parse and process the linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	"aScore11 add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| evts tOffset |	evts := eList events.	tOffset := start. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 - v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := (v0 + (vDiff * tScale)) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: vString into: eList	"Parse and process the complex linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; '10 10 100')"	"	add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mo -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  / 3 2080 /						6 2000 2100  ,  1100 1600' ) "	| strm evts rnd t0 t1 |	strm := self cleanStreamFrom: vString."	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:							"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp const tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.				"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next asNumber.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]					"constant clause"			ifFalse: [(strm atEnd) ifFalse:				[sep := strm next.					"read comma or slash"				('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].				(sep = ',')							"comma means read 2 more tokens"					ifTrue: [interp := true.							a1 := strm next asNumber.						b1 := strm next asNumber.						(strm atEnd)					"read trailing slash"										ifFalse: [sep := strm next.								((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].													"else 3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (b0 - a0) asFloat.		interp ifTrue:			[vDiff0 := (a1 - a0) asFloat.				vDiff1 := (b1 - b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[const 					ifTrue: [val := a0]					ifFalse: [interp							"false means single range for segment"						ifFalse: [val := (v0 + (vDiff0 * tScale)) asFloat]						ifTrue: [tScale := (tN - t0) / tDiff.		"true means interpolating random ranges"							v0 := (a0 + (vDiff0 * tScale)) asFloat.							v1 := (b0 + (vDiff1 * tScale)) asFloat.							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						3 940 940 / 7 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.16  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 3.0 / 5 3.0 4.0 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7b">test7b	"Inspect a simple Score11 event list - test complex move"	"Score11 test7b"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mo -&gt; '5 100 120 , 2000 2400 /						4 2050 2060 / 3 2100 /						3 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: vString into: eList	"Parse and process the complex linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; '10 10 100')"	"	add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mo -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  / 3 2080 /						6 2000 2100  ,  1100 1600' ) "	| strm evts rnd t0 t1 |	strm := self cleanStreamFrom: vString."	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:							"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp const tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.				"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]					"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:					[sep := strm next.					"read comma or slash"					('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].					(sep = ',')							"comma means read 2 more tokens"						ifTrue: [interp := true.							a1 := strm next asNumber.							b1 := strm next asNumber.							(strm atEnd)					"read trailing slash"											ifFalse: [sep := strm next.									((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].													"else 3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (b0 - a0) asFloat.		interp ifTrue:			[vDiff0 := (a1 - a0) asFloat.				vDiff1 := (b1 - b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[const 					ifTrue: [val := a0]					ifFalse: [interp							"false means single range for segment"						ifFalse: [val := (v0 + (vDiff0 * tScale)) asFloat]						ifTrue: [tScale := (tN - t0) / tDiff.		"true means interpolating random ranges"							v0 := (a0 + (vDiff0 * tScale)) asFloat.							v1 := (b0 + (vDiff1 * tScale)) asFloat.							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: vString into: eList	"Parse and process the complex linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; '10 10 100')"	"	add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mo -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  / 3 2080 /						6 2000 2100  ,  1100 1600' ) "	| strm evts rnd t0 t1 |	strm := self cleanStreamFrom: vString."	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:							"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp const tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.				"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]					"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:					[sep := strm next.					"read comma or slash"					('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].					(sep = ',')							"comma means read 2 more tokens"						ifTrue: [interp := true.							a1 := strm next asNumber.							b1 := strm next asNumber.							(strm atEnd)					"read trailing slash"											ifFalse: [sep := strm next.									((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].													"else 3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (b0 - a0) asFloat.		interp ifTrue:			[vDiff0 := (a1 - a0) asFloat.				vDiff1 := (b1 - b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp							"false means single range for segment"						ifFalse: [val := (v0 + (vDiff0 * tScale)) asFloat]						ifTrue: [		"true means interpolating random ranges"							v0 := (a0 + (vDiff0 * tScale)) asFloat.							v1 := (b0 + (vDiff1 * tScale)) asFloat.							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: vString into: eList	"Parse and process the complex linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; '10 10 100')"	"	add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mo -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  / 3 2080 /						6 2000 2100  ,  1100 1600' ) "	| strm evts rnd t0 t1 |	strm := self cleanStreamFrom: vString."	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:							"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp const tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.				"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]					"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:					[sep := strm next.					"read comma or slash"					('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].					(sep = ',')							"comma means read 2 more tokens"						ifTrue: [interp := true.							a1 := strm next asNumber.							b1 := strm next asNumber.							(strm atEnd)					"read trailing slash"											ifFalse: [sep := strm next.									((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].													"else 3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		vDiff0 := (b0 - a0) asFloat.		interp ifTrue:			[vDiff0 := (a1 - a0) asFloat.				vDiff1 := (b1 - b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp							"false means single range for segment"						ifFalse: [val := (a0 + (vDiff0 * tScale)) asFloat]						ifTrue: [		"true means interpolating random ranges"							v0 := (a0 + (vDiff0 * tScale)) asFloat.							v1 := (b0 + (vDiff1 * tScale)) asFloat.							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: vString into: eList	"Parse and process the complex linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; '10 10 100')"	"	add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mo -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  / 3 2080 /						6 2000 2100  ,  1100 1600' ) "	| strm evts rnd t0 t1 |	strm := self cleanStreamFrom: vString."	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:							"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp const tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.				"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]					"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:					[sep := strm next.					"read comma or slash"					('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].					(sep = ',')							"comma means read 2 more tokens"						ifTrue: [interp := true.							a1 := strm next asNumber.							b1 := strm next asNumber.							(strm atEnd)					"read trailing slash"											ifFalse: [sep := strm next.									((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].													"else 3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		const ifFalse:			[vDiff0 := (b0 - a0) asFloat].		interp ifTrue:			[vDiff0 := (a1 - a0) asFloat.				vDiff1 := (b1 - b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp							"false means single range for segment"						ifFalse: [val := (a0 + (vDiff0 * tScale)) asFloat]						ifTrue: [		"true means interpolating random ranges"							v0 := (a0 + (vDiff0 * tScale)) asFloat.							v1 := (b0 + (vDiff1 * tScale)) asFloat.							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>Score11 test7b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7b">test7b	"Inspect a simple Score11 event list - test complex move"	"Score11 test7b"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mo -&gt; '5 100 120 , 2000 2000 /						4 2050 2060 / 3 2100 /						3 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><do-it>Score11 test7b</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove:from:into:">writeMove: property from: vString into: eList	"Parse and process the complex linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; '10 10 100')"	"	add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mo -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  / 3 2080 /						6 2000 2100  ,  1100 1600' ) "	| strm evts rnd t0 t1 |	strm := self cleanStreamFrom: vString."	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:								"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp const tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.					"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]						"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:					[sep := strm next.					"read comma or slash"					('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].					(sep = ',')							"comma means read 2 more tokens"						ifTrue: [interp := true.							a1 := strm next asNumber.							b1 := strm next asNumber.							(strm atEnd)					"read trailing slash"											ifFalse: [sep := strm next.									((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].														"else 3 toks = no interpolation; const range"		t1 := t0 + segDur.		"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		const ifFalse:			[vDiff0 := (b0 - a0) asFloat].		interp ifTrue:			[vDiff0 := (a1 - a0) asFloat.				vDiff1 := (b1 - b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:									"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp							"false means single range for segment"						ifFalse: [val := (a0 + (vDiff0 * tScale)) asFloat]						ifTrue: [		"true means interpolating random ranges"							v0 := (a0 + (vDiff0 * tScale)) asFloat.							v1 := (b0 + (vDiff1 * tScale)) asFloat.							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>Score11 test7b</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 const |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces""	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:								"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.					"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]						"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:				[sep := strm next.						"read comma or slash"				('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].				(sep = ',')								"comma means read 2 more tokens"					ifTrue: [interp := true.						a1 := strm next asNumber.						b1 := strm next asNumber.						(strm atEnd)						"read trailing slash"										ifFalse: [sep := strm next.								((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].														"3 toks = no interpolation; const range"		t1 := t0 + segDur.								"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		const ifFalse:			[vDiff0 := (b0 / a0) asFloat].		interp ifTrue:			[vDiff0 := (a1 / a0) asFloat.				vDiff1 := (b1 / b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:											"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp						"false means single range for segment"						ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]						ifTrue: [							"true means interpolating random ranges"							v0 := a0 asFloat * (vDiff0 raisedTo: tScale).							v1 := b0 asFloat * (vDiff1 raisedTo: tScale).							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ].				eAss event perform: property with: val]].		t0 := t0 + segDur]]</body></methods><do-it>Score11 test7b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7c">test7c	"Inspect a simple Score11 event list - test complex movex"	"Score11 test7c"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2000 /						4 2050 2060 / 3 2100 /						3 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><do-it>Score11 test7c</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 const |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces""	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:								"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.					"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]						"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:				[sep := strm next.						"read comma or slash"				('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].				(sep = ',')								"comma means read 2 more tokens"					ifTrue: [interp := true.						a1 := strm next asNumber.						b1 := strm next asNumber.						(strm atEnd)						"read trailing slash"										ifFalse: [sep := strm next.								((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].														"3 toks = no interpolation; const range"		t1 := t0 + segDur.								"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		const ifFalse:			[vDiff0 := (b0 / a0) asFloat].		interp ifTrue:			[vDiff0 := (a1 / a0) asFloat.				vDiff1 := (b1 / b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]." self halt.		evts do:											"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp						"false means single range for segment"						ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]						ifTrue: [							"true means interpolating random ranges"							v0 := a0 asFloat * (vDiff0 raisedTo: tScale).							v1 := b0 asFloat * (vDiff1 raisedTo: tScale).							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)."							Transcript show: tN printString, ' -  [', v0 printString, ' - ', v1 printString, '] - ', val printString, ']'; cr" ].				eAss event perform: property with: val]].		t0 := t0 + segDur]]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 const |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).		"split on spaces""	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:								"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.					"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]						"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:				[sep := strm next.						"read comma or slash"				('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].				(sep = ',')								"comma means read 2 more tokens"					ifTrue: [interp := true.						a1 := strm next asNumber.						b1 := strm next asNumber.						(strm atEnd)						"read trailing slash"										ifFalse: [sep := strm next.								((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].														"3 toks = no interpolation; const range"		t1 := t0 + segDur.								"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		const ifFalse:			[vDiff0 := (b0 / a0) asFloat].		interp ifTrue:			[vDiff0 := (a1 / a0) asFloat.				vDiff1 := (b1 / b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]." self halt.		evts do:											"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp						"false means single range for segment"						ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]						ifTrue: [							"true means interpolating random ranges"							v0 := a0 asFloat * (vDiff0 raisedTo: tScale).							v1 := b0 asFloat * (vDiff1 raisedTo: tScale).							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX2:from:into:">writeMoveX2: property from: vString into: eList	"Parse and process the complex exponential move keyword to generate events"	"aScore11 add: #p6 -&gt; (#mx -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); 		add: #p4 -&gt; (#mx -&gt; '5 200 100  ,  2000 2100  /						4 2050 2060  /						6 2000 2100  ,  1100 1600' ) "	"Toks: _5_   _200_   _100_   _,_   _2000_   _2100_   _/_   _4_   _2050_   _2060_   _/_   _6_   _2000_   _2100_   _,_   _1100_   _1600_   "	| tStr strm evts rnd t0 t1 const |	tStr := vString copyWithout: Character cr.	tStr := tStr copyReplaceAll: '	' with: ' '.	[(tStr findString: '  ' startingAt: 1) &gt; 0] whileTrue:		[tStr := tStr copyReplaceAll: '  ' with: ' '].	strm := ReadStream on: (tStr tokensBasedOn: $ ).			"split on spaces""	Transcript clear.	[strm atEnd] whileFalse:								[Transcript show:  '_', strm next, '_   '].	strm := ReadStream on: (tStr tokensBasedOn: $ )."	evts := eList events.	rnd := Random new.	t0 := start.	[strm atEnd] whileFalse:								"loop through the segments"		[ | a0 b0 a1 b1 segDur sep interp tDiff vDiff0 vDiff1 |		segDur := strm next asNumber.					"read first 3 vals: dur a0 b0"		a0 := strm next asNumber.		b0 := strm next.		interp := false.		const := false.		('/,' includes: b0 first)			ifTrue: [const := true]						"constant clause"			ifFalse: [b0 := b0 asNumber.				(strm atEnd) ifFalse:				[sep := strm next.						"read comma or slash"				('/,' includes: sep first) ifFalse: [self error: 'Malformed movex expression'].				(sep = ',')								"comma means read 2 more tokens"					ifTrue: [interp := true.						a1 := strm next asNumber.						b1 := strm next asNumber.						(strm atEnd)					"read trailing slash"										ifFalse: [sep := strm next.								((sep = '/') or: [strm atEnd]) ifFalse: [self error: 'Malformed movex expression']]]]].													"3 toks = no interpolation; const range"		t1 := t0 + segDur.								"compute start/end ratios for expon moving range"		tDiff := t1 - t0.		const ifFalse:			[vDiff0 := (b0 / a0) asFloat].		interp ifTrue:			[vDiff0 := (a1 / a0) asFloat.				vDiff1 := (b1 / b0) asFloat]."		interp			ifTrue:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, '] - [ ', 						a1 printString, ' - ', b1 printString, '] - ', vDiff0 printString, ' : ', vDiff1 printString; cr]			ifFalse:[Transcript cr; show: 'Seg: ', t0 printString, ' - ', t1 printString, ' [', a0 printString, ' - ', b0 printString, ']'; cr]."		evts do:										"event loop"			[ :eAss | | tN tScale val v0 v1 |			tN := eAss time asSec value.			(tN &gt;= t0 and: [tN &lt;= t1]) ifTrue:				[tScale := (tN - t0) / tDiff.				const ifTrue: [val := a0]					ifFalse: [interp						"false means single range for segment"						ifFalse: [val := rnd nextFrom: (a0 min: b0) to: (a0 max: b0)]						ifTrue: [						"true means interpolating random ranges"							v0 := a0 asFloat * (vDiff0 raisedTo: tScale).							v1 := b0 asFloat * (vDiff1 raisedTo: tScale).							val := rnd nextFrom: (v0 min: v1) to: (v0 max: v1)]].				eAss event perform: property with: val]].		t0 := t0 + segDur]</body></methods><do-it>Score11 test7c</do-it><do-it>Score11 test7b</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test1">test1	"Open a TSV on a simple Score11 event list"	"Score11 test1"	TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4//8//16////32//////'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; #(1.0 1.0 5.0); 		add: #p6 -&gt; (#mo -&gt; '5 1000 2000' )) 	eventList</body></methods><do-it>Score11 test1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test2">test2	"Open a TSV on a simple Score11 event list"	"Score11 test2"	TimeSequenceView openOnEventList: ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/12*6/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; '10 10 100' );		add: #p6 -&gt; #(1.0 -1.0 1.0)) 	eventList</body></methods><do-it>Score11 test2</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test3">test3	"Inspect a simple Score11 event list"	"Score11 test3"	 | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; '10 10 100' );		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; #(10 1 3 5 7 9));		add: #p9 -&gt; (#mx -&gt; '10 1 100' )	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test3">test3	"Inspect a simple Score11 event list"	"Score11 test3"	 | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/8*4/6*3/4/'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; '10 10 100' );		add: #p6 -&gt; #(1.0 -1.0 1.0);		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);		add: #p8 -&gt; (#se -&gt; '10 1 3 5 7 9' );		add: #p9 -&gt; (#mx -&gt; '10 1 100' )	).	s11 assign: #p6 to: #position:.	s11 assign: #p7 to: #attack:.	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeSet:from:into:">writeSet: property from: vString into: eList	"Parse and process the 'set' keyword to generate events"	"aScore11 add: #p4 -&gt; (#se -&gt; '20 .1 .2 .3 .4'); "	"	add: #p8 -&gt; (#se -&gt; '5 c5 e g / 5 d5 fs a4'/);"	| toks rnd segDur item strm segs t0 |	strm := self cleanStreamFrom: vString.	segs := OrderedCollection new.	toks := OrderedCollection new.	[strm atEnd] whileFalse:					"collect the segments"					[segDur := strm next asNumber.		item := strm next.		[(item = '/') or: [strm atEnd]] whileFalse:			[toks add: item.			item := strm next].		segs addLast: segDur -&gt; toks.		"start-time -&gt; data-set"		toks := OrderedCollection new].		rnd := Random new.	t0 := 0.	1 to: segs size do:						"step through the segments"		[ :ind | | tN |		tN := t0 + (segs at: ind) key.		toks := (segs at: ind) value.		eList do: 			[ :eAss | | evt tX |			evt := eAss event.			tX := eAss time asSec value.			(tX &gt;= t0 and: [tX &lt;= tN]) ifTrue:				[ | val |				val := toks atRandom: rnd.				evt perform: property with: val."				Transcript show: tX printString, ' - ', val printString; cr"].		t0 := tN]]</body></methods><do-it>self writeMoveX2: property from: array into: eList</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100   5 100 5))  ) "	| evts tOffset |	array isString ifTrue: [^self writeMoveX2: property from: array into: eList].	"The rest of this is for backward comp0atibility"	evts := eList events.	tOffset := start.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><do-it>Score11 test3</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test4">test4	"Inspect a simple Score11 event list - test multi-segment moves"	"Score11 test4"	 | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5' ); 		add: #p5 -&gt; (#mo -&gt; '7 5 100  3 100 5' )	).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test4">test4	"Inspect a simple Score11 event list - test multi-segment moves"	"Score11 test4"	 | s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; 16); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5' ); 		add: #p5 -&gt; (#mo -&gt; '7 5 100 / 3 100 5' )	).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>Score11 test4</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test5">test5	"Inspect a simple Score11 event list - test dotted values"	"Score11 test5"	  | s11 |		s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/4./4../8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; '7 5 100 / 3 100 5' )	).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>Score11 test5</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test6">test6	"Inspect a simple Score11 event list - test rests"	"Score11 test6"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '4/-4/8/-8'); 		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		add: #p5 -&gt; (#mo -&gt; '7 5 100 / 3 100 5' )	).	s11 tempo: #(10 60 120).	s11 eventList inspect</body></methods><do-it>Score11 test6</do-it><do-it>Score11 test7</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7b">test7b	"Inspect a simple Score11 event list - test complex move with const clauses"	"Score11 test7b"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mo -&gt; '5 100 120 , 2000 2000 /						4 2050 2060 / 3 2100 /						3 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7b">test7b	"Inspect a simple Score11 event list - test complex linear move with const clauses"	"Score11 test7b"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mo -&gt; '5 100 120 , 2000 2000 /						4 2050 2060 / 3 2100 /						3 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test7c">test7c	"Inspect a simple Score11 event list - test complex movex with const clauses"	"Score11 test7c"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 15) 		add: #p3 -&gt; (#rh -&gt; '8/'); 		add: #p4 -&gt; (#mx -&gt; '5 100 120 , 2000 2000 /						4 2050 2060 / 3 2100 /						3 2000 2100 , 700 1100' )).	s11 eventList inspect</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 31, 2020' '6:36:28 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:36:28 PM on July 31, 2020."</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						10 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.16  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.07 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.16  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."	score1 addAll: score2 at: dur1.	"					"concatenate event lists"	score1 := score2."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1.						"concatenate event lists""	score1 := score2.""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 					"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].self halt.	score1 addAll: score2 at: dur1.						"concatenate event lists""	score1 := score2.""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>aTime </do-it><methods><class-id>Siren.EventList</class-id> <category>event accessing</category><body package="Siren" selector="addAll:at:">addAll: anEventList at: aTime	"Add the given event list's events to the receiver."	anEventList events do:		[ :assoc |			self events add: (assoc key + aTime =&gt; assoc value).		"need to make copies?"			assoc value duration == nil 				ifTrue: [duration := duration max: assoc key]				ifFalse: [duration := duration 							max: (assoc key + assoc value duration)]].	self changed: #added</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.08 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd:).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'July 31, 2020' '6:58:26 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:58:26 PM on July 31, 2020."</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMoveX:from:into:">writeMoveX: property from: array into: eList	"Parse and process the exponential move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mx -&gt; #(10 1 100))		add: #p5 -&gt; (#mx -&gt; #(5 4 100   5 100 5))  ) "	| evts tOffset |	array isString ifTrue: [^self writeMoveX2: property from: array into: eList].										"The rest of this is for backward compatibility; you shouldn't use arrays any more"	evts := eList events.	tOffset := start.	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 / v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := v0 * (vDiff raisedTo: tScale) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="populate:required:as:into:">populate: param required: isReq as: property into: eList	"Execute the generator for the given key and property"	"self populate: #p4 required: false as: #pitch into: eList.		add: #p4 -&gt; (#no -&gt; 'c4/d/e/f/g/a/b/c5'); 		-- sequential scale		add: #p5 -&gt; (#mo -&gt; '10 10 100' );			-- linear move		add: #p5 -&gt; #(1.0 1.0 5.0);					-- rand range		add: #p7 -&gt; #(0.5 1 2  0.5 100 200);			-- mix of ranges		add: #p8 -&gt; (#se -&gt; '10 1 3 5 7 9' );			-- set		add: #p5 -&gt; (#mx -&gt; '5 4 100 / 5 100 5' )		-- multi-stage exponential move		add: #p5 -&gt; (#mx -&gt; '3 100 100 , 100 96' )		-- multi-stage exponential tendancy mask move		add: #p4 -&gt; (#nu -&gt; '1./.5*3/.25//-.5/1.5' )		-- numerical sequences 	 "	| item key val |	item := generators at: param ifAbsent: [nil].	(isReq and: [item isNil])		ifTrue: [self error: 'No data for ', property, '?'].	(isReq not and: [item isNil])		ifTrue: [^self].	(item isImmediate or: [item respondsToArithmetic]) ifTrue:		"handle consts"		[^self writeConst: property from: item into: eList].	item isAssociation ifFalse:			"handle range arrays"		[^self writeRand: property from: item into: eList].	key := item key.	val := item value.	key == #no ifTrue: [^self writeNotes: property from: val into: eList].	key == #nu ifTrue: [^self writeNumerical: property from: val into: eList].	key == #se ifTrue: [^self writeSet: property from: val into: eList].	key == #mo ifTrue: [^self writeMove: property from: val into: eList].	key == #mx ifTrue: [^self writeMoveX: property from: val into: eList].	self error: 'Unknown Score11 term'</body></methods><class><name>BohlenPierceScale</name><environment>Siren</environment><super>Siren.Scale</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Music-PitchScales</category><attributes><package>(none)</package></attributes></class><do-it>Smalltalk.Siren defineClass: #BohlenPierceScale	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closts to the given pitch in Hz."	| pit |	</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="computeNotes">computeNotes	"intervalList depends on the type of the scale. It is redefined in each subclass of Scale"	notes := self class intervalList collect: [:s | root perform: s]</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closts to the given pitch in Hz."	| notz pit |	notz := self computeNotes.	notz do: 	[ :nt |	pit := nt].	^pit</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closts to the given pitch in Hz."	| notz pit |	notz := self computeNotes.self halt.	notz do: 	[ :nt |	pit := nt].	^pit</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closts to the given pitch in Hz."	"PentatonicScale nearestNoteTo: 450"	| notz pit |	notz := self computeNotes.self halt.	notz do: 	[ :nt |	pit := nt].	^pit</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closts to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| notz pit |	notz := self computeNotes.self halt.	notz do: 	[ :nt |	pit := nt].	^pit</body></methods><do-it>((450 / 8.17579891564371) log: 2) * 12.</do-it><do-it>((450 / 8.17579891564371) log: 2) * 12.</do-it><do-it> ((440 / 8.17579891564371) log: 2) * 12.</do-it><do-it> ((440 / 8.17579891564371) log: 2) * 12.</do-it><do-it>	60 / 12</do-it><do-it>69 \\ 12.</do-it><do-it>70 \\ 12.</do-it><do-it> 70 / 12.</do-it><do-it> (70 / 12) truncated.</do-it><do-it> (69 / 12) truncated.</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| noteNum oct pit nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.self halt.	notes do: 		[ :nt | | p0 p1 tmp |		tmp := bNote + nt semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  |				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				(a &gt;= b)					ifTrue:  [^a]					ifFalse: [b]]].</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.self halt.	notes do: 		[ :nt | | p0 p1 tmp |		tmp := bNote + nt semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  |				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				(a &gt;= b)					ifTrue:  [^a]					ifFalse: [b]]].</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.self halt.	notes do: 		[ :nt | | p0 p1 tmp |		tmp := bNote + nt semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: (((tmp + 1) asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  |				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				(a &gt;= b)					ifTrue:  [^a]					ifFalse: [b]]].</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	notes do: 		[ :nt | | p0 p1 tmp |		tmp := bNote + nt semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: (((tmp + 1) asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | self halt.				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				(a &gt;= b)					ifTrue:  [^a]					ifFalse: [b]]].</body></methods><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	notes do: 		[ :nt | | p0 p1 tmp |		tmp := bNote + nt semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: (((tmp + 1) asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | self halt.				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [a]					ifFalse: [b]]].</body></methods><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	notes do: 		[ :nt | | p0 p1 tmp |		tmp := bNote + nt semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((tmp asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: (((tmp + 1) asFloat) / 12.0)).self halt.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  |				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [a]					ifFalse: [b]]].self halt</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	2 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind - 1.		nt1 := notes at: ind.		t0 := bNote + nt0 semiToneCount.		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).self halt.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  |				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [a]					ifFalse: [b]]].self halt</body></methods><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	2 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind - 1.		nt1 := notes at: ind.		t0 := bNote + nt0 semiToneCount.		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | self halt.				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [a]					ifFalse: [b]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	2 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind - 1.		nt1 := notes at: ind.		t0 := bNote + nt0 semiToneCount.		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [a]					ifFalse: [b]]].	self error: 'Pitch class member not found'</body></methods><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	2 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind - 1.		nt1 := notes at: ind.		t0 := bNote + nt0 semiToneCount.		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><do-it>(PentatonicScale root: N re) nearestNoteTo: 450</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	2 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind - 1.		nt1 := notes at: ind.		t0 := bNote + nt0 semiToneCount.		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>Siren.Scale class organization renameCategory: #creation to: #'instance creation'</do-it><do-it>Siren.Scale class reorganizeFromString: '(''examples'' #example)(''Paleo class initialize'' #initialize)(''interval list'' #intervalList)(''instance creation'' #askScale #root: #standardScales #warn:)'</do-it><do-it>Siren.Scale class reorganizeFromString: '(''Paleo class initialize'' #initialize)(''interval list'' #intervalList)(''instance creation'' #askScale #root: #standardScales #warn:)(''examples'' #example)'</do-it><do-it>Siren.Scale class reorganizeFromString: '(''instance creation'' #askScale #root: #standardScales #warn:)(''Paleo class initialize'' #initialize)(''interval list'' #intervalList)(''examples'' #example)'</do-it><do-it>Siren.Scale class organization renameCategory: #'Paleo class initialize' to: #'class initialize'</do-it><do-it>Siren.Scale class reorganizeFromString: '(''class initialize'' #initialize)(''instance creation'' #askScale #root: #standardScales #warn:)(''interval list'' #intervalList)(''examples'' #example)'</do-it><do-it>Siren.BohlenPierceScale class organization addCategory: #'instance creation' before: nil</do-it><methods><class-id>Siren.BohlenPierceScale class</class-id> <category>instance creation</category><body package="(none)" selector="root:">root: aNote 	| g |	g := self new.	g root: aNote; computeNotes.	^g</body></methods><do-it>Siren.BohlenPierceScale organization addCategory: #'computing notes' before: nil</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	2 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind - 1.					"get the note degrees"		nt1 := notes at: ind.		t0 := bNote + nt0 semiToneCount.		"adjust to oct base"		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		"lower/higher pitch of interval"		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>PentatonicScale root: N re</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale on: mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: ((root asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * 3.0 raisedTo: (ind / 13) asFloat]</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale on: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: ((root asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * 3.0 raisedTo: (ind / 13) asFloat]</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale root: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: ((root asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * 3.0 raisedTo: (ind / 13) asFloat]</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale root: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: ((root semiToneCount asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * 3.0 raisedTo: (ind / 13) asFloat]</body></methods><do-it>BohlenPierceScale root: N mi</do-it><do-it> 8.17579891564371 * (2.0 raisedTo: ((3 asFloat) / 12.0)).</do-it><do-it> 8.17579891564371 * (2.0 raisedTo: ((24 asFloat) / 12.0)).</do-it><do-it> 8.17579891564371 * (2.0 raisedTo: ((48 asFloat) / 12.0)).</do-it><do-it> 8.17579891564371 * (2.0 raisedTo: ((60 asFloat) / 12.0)).</do-it><do-it> 8.17579891564371 * (2.0 raisedTo: ((69 asFloat) / 12.0)).</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale root: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: (((root semiToneCount + 60) asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * 3.0 raisedTo: (ind / 13) asFloat]</body></methods><do-it>BohlenPierceScale root: N mi</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale root: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: (((root semiToneCount + 60) asFloat) / 12.0)).self halt.	notes := (0 to: 12) collect:		[ :ind |		bas * 3.0 raisedTo: (ind / 13) asFloat]</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale root: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: (((root semiToneCount + 60) asFloat) / 12.0)).self halt.	notes := (0 to: 12) collect:		[ :ind |		bas * (3.0 raisedTo: (ind / 13) asFloat)]</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"BohlenPierceScale root: N mi"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: (((root semiToneCount + 60) asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * (3.0 raisedTo: (ind / 13) asFloat)]</body></methods><do-it>BohlenPierceScale root: N mi</do-it><do-it>349.228 * 3</do-it><do-it>Siren.BohlenPierceScale organization addCategory: #testing before: nil</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>testing</category><body package="(none)" selector="isMajor">isMajor	^false</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>testing</category><body package="(none)" selector="isMinor">isMinor	^false</body></methods><do-it>BohlenPierceScale root: N mi</do-it><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="applyBlock:toProp:from:to:">applyBlock: theBlock toProp: theSelector from: t0 to: tN	"Apply the given block to the aspect refered to by theSelector of all events."	"someEList applyBlock: [ :d | (MSecondDuration value: (d asMS value * 10))] 			toProp: #duration"	| anEvent val |	self events do: 		[ :anAssociation |		anEvent := anAssociation value.		anEvent isEventList			ifTrue: [anEvent applyBlock: theBlock toProp: theSelector]			ifFalse: [val := anEvent perform: theSelector.				anEvent perform: ((theSelector, ':') asSymbol)						with: (theBlock value: val)]]</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="computeNotes">computeNotes	"Make the note list for the 13th root of 3."	"(BohlenPierceScale root: N mi) inspect"	| bas |	bas := 8.17579891564371 * (2.0 raisedTo: (((root semiToneCount + 60) asFloat) / 12.0)).	notes := (0 to: 12) collect:		[ :ind |		bas * (3.0 raisedTo: (ind / 13) asFloat)]</body></methods><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="applyBlock:toProp:from:to:">applyBlock: theBlock toProp: theSelector from: t0 to: tN	"Apply the given block to the aspect refered to by theSelector of all events."	"someEList applyBlock: [ :d | (MSecondDuration value: (d asMS value * 10))] 			toProp: #duration"	self events do: 		[ :anAssociation | | stTime anEvent val |		stTime := anAssociation key value asSec.		anEvent := anAssociation value.		anEvent isEventList			ifTrue: [anEvent applyBlock: theBlock toProp: theSelector from: t0 + stTime to: tN + stTime]			ifFalse: [(stTime &gt;= t0 and: [stTime &lt;= tN])				ifTrue:[val := anEvent perform: theSelector.					anEvent perform: ((theSelector, ':') asSymbol)						with: (theBlock value: val)]]]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 1, 2020' '3:53:15 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 3:53:15 PM on August 1, 2020."</do-it><methods><class-id>Siren.EventList</class-id> <category>processing</category><body package="Siren" selector="applyBlock:toProp:from:to:">applyBlock: theBlock toProp: theSelector from: t0 to: tN	"Apply the given block to the aspect refered to by theSelector of all events."	"someEList applyBlock: [ :d | (MSecondDuration value: (d asMS value * 10))] 			toProp: #duration"	self events do: 		[ :anAssociation | | stTime anEvent val |		stTime := anAssociation key value.		anEvent := anAssociation value.		anEvent isEventList			ifTrue: [anEvent applyBlock: theBlock toProp: theSelector from: t0 + stTime to: tN + stTime]			ifFalse: [(stTime &gt;= t0 and: [stTime &lt;= tN])				ifTrue:[val := anEvent perform: theSelector.					anEvent perform: ((theSelector, ':') asSymbol)						with: (theBlock value: val)]]]</body></methods><do-it> p asHz value</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1050 1040 / 3 930 930 / 4 930 910 , 880 890 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.5 / 						12 -1.0 -0.2 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Scale</class-id> <category>transpose</category><body package="Siren" selector="octaveScale">octaveScale	"Most scales repeate in octaves of 2.0"	^2.0</body></methods><do-it>Siren.BohlenPierceScale organization addCategory: #transpose before: nil</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>transpose</category><body package="(none)" selector="octaveScale">octaveScale	"Most scales repeate in octaves of 2.0, but not BP"	^3.0</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	1 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind.						"get the note degrees"		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1]			ifFalse: [nt1 := (notes at: 1) * self octaveScale].		t0 := bNote + nt0 semiToneCount.			"adjust to oct base"		t1 := bNote + nt1 semiToneCount.		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		"lower/higher pitch of interval"		p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)).		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])		"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	1 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind.							"get the note degrees"		t0 := bNote + nt0 semiToneCount.				"adjust to oct base"		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		"lower/higher pitch of interval"		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1.				t1 := bNote + nt1 semiToneCount.				p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0))]			ifFalse: [nt1 := (notes at: 1).				t1 := bNote + nt1 semiToneCount.								p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)) * self octaveScale].		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr.	1 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		nt0 := notes at: ind.							"get the note degrees"		t0 := bNote + nt0 semiToneCount.				"adjust to oct base"		p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)).		"lower/higher pitch of interval"		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1.				t1 := bNote + nt1 semiToneCount.				p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0))]			ifFalse: [nt1 := (notes at: 1).				t1 := bNote + nt1 semiToneCount.								p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)) * self octaveScale].		Transcript tab; show: 'Between: ', p0 printString, 'and: ', p1 printString; cr.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>notes last.	</do-it><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr.	0 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		(ind = 0)			ifFalse: [nt0 := notes at: ind.						"get the note degrees"				t0 := bNote + nt0 semiToneCount.				"adjust to oct base"				p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0))]		"lower/higher pitch of interval"			ifTrue:  [nt0 := notes last.									t0 := bNote + nt0 semiToneCount.								p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)) / self octaveScale].		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1.				t1 := bNote + nt1 semiToneCount.				p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0))]			ifFalse: [nt1 := (notes at: 1).				t1 := bNote + nt1 semiToneCount.								p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)) * self octaveScale].		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12.	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr.	0 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		(ind = 0)			ifFalse: [nt0 := notes at: ind.						"get the note degrees"				t0 := bNote + nt0.							"adjust to oct base"				p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0))]		"lower/higher pitch of interval"			ifTrue:  [nt0 := notes last.									t0 := bNote + nt0.								p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)) / self octaveScale].		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1.				t1 := bNote + nt1.				p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0))]			ifFalse: [nt1 := (notes at: 1).				t1 := bNote + nt1.								p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)) * self octaveScale].		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>notes first.</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| f0 fN oct |	oct := 0.0.	f0 := notes first.	fN := notes last.	[f0 &gt; aHzPitch] whileTrue:		[oct := oct - 1.0.		f0 := f0 / 3.0. 		fN := fN / 3.0.].	[fN &lt; aHzPitch] whileTrue: 		[oct := oct + 1.0.		f0 := f0 * 3.0.		fN := fN * 3.0].	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr.	0 to: notes size do: 		[ :ind | | p0 p1 |		(ind = 0)			ifFalse: [p0 := notes at: ind * (3.0 raisedTo: oct)]		"get the note degrees"			ifTrue: [p0 := notes last * (3.0 raisedTo: oct - 1)].		(ind &lt; notes size)			ifTrue: [p1 := notes at: ind + 1* (3.0 raisedTo: oct)]			ifFalse: [p1 := notes first * (3.0 raisedTo: oct + 1)].		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| f0 fN oct |	oct := 0.0.	f0 := notes first.	fN := notes last.	[f0 &gt; aHzPitch] whileTrue:		[oct := oct - 1.0.		f0 := f0 / 3.0. 		fN := fN / 3.0.].	[fN &lt; aHzPitch] whileTrue: 		[oct := oct + 1.0.		f0 := f0 * 3.0.		fN := fN * 3.0].	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr.	0 to: notes size do: 		[ :ind | | p0 p1 |		(ind = 0)			ifFalse: [p0 := (notes at: ind) * (3.0 raisedTo: oct)]		"get the note degrees"			ifTrue: [p0 := notes last * (3.0 raisedTo: oct - 1)].		(ind &lt; notes size)			ifTrue: [p1 := (notes at: ind + 1)* (3.0 raisedTo: oct)]			ifFalse: [p1 := notes first * (3.0 raisedTo: oct + 1)].		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12."	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr."	0 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		(ind = 0)			ifFalse: [nt0 := notes at: ind.						"get the note degrees"				t0 := bNote + nt0.							"adjust to oct base"				p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0))]		"lower/higher pitch of interval"			ifTrue:  [nt0 := notes last.									t0 := bNote + nt0.								p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)) / self octaveScale].		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1.				t1 := bNote + nt1.				p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0))]			ifFalse: [nt1 := (notes at: 1).				t1 := bNote + nt1.								p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)) * self octaveScale]."		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr."		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.Scale</class-id> <category>computing notes</category><body package="Siren" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| oct nNum bNote |	nNum := (((aHzPitch / 8.17579891564371) log: 2) * 12) truncated.	oct:= (nNum / 12) truncated.	bNote := oct * 12."	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr."	0 to: notes size do: 		[ :ind | | nt0 nt1 t0 t1 p0 p1 |		(ind = 0)			ifFalse: [nt0 := notes at: ind.						"get the note degrees"				t0 := bNote + nt0 semiToneCount.				"adjust to oct base"				p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0))]		"lower/higher pitch of interval"			ifTrue:  [nt0 := notes last.									t0 := bNote + nt0 semiToneCount.								p0 := 8.17579891564371 * (2.0 raisedTo: ((t0 asFloat) / 12.0)) / self octaveScale].		(ind &lt; notes size)			ifTrue: [nt1 := notes at: ind + 1.				t1 := bNote + nt1 semiToneCount.				p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0))]			ifFalse: [nt1 := (notes at: 1).				t1 := bNote + nt1 semiToneCount.								p1 := 8.17579891564371 * (2.0 raisedTo: ((t1 asFloat) / 12.0)) * self octaveScale]."		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr."		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| f0 fN oct |	oct := 0.0.	f0 := notes first.	fN := notes last.	[f0 &gt; aHzPitch] whileTrue:		[oct := oct - 1.0.		f0 := f0 / 3.0. 		fN := fN / 3.0.].	[fN &lt; aHzPitch] whileTrue: 		[oct := oct + 1.0.		f0 := f0 * 3.0.		fN := fN * 3.0].	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr.	0 to: notes size do: 		[ :ind | | p0 p1 |		(ind = 0)			ifFalse: [p0 := (notes at: ind) * (3.0 raisedTo: oct)]		"get the note degrees"			ifTrue: [p0 := notes last * (3.0 raisedTo: oct - 1)].		(ind &lt; notes size)			ifTrue: [p1 := (notes at: ind + 1)* (3.0 raisedTo: oct)]			ifFalse: [p1 := notes first * (3.0 raisedTo: oct + 1)].		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr.		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><methods><class-id>Siren.BohlenPierceScale</class-id> <category>computing notes</category><body package="(none)" selector="nearestNoteTo:">nearestNoteTo: aHzPitch	"Answer the frequency of the scale degree closest to the given pitch in Hz."	"(PentatonicScale root: N re) nearestNoteTo: 450"	| f0 fN oct |	oct := 0.0.	f0 := notes first.	fN := notes last.	[f0 &gt; aHzPitch] whileTrue:		[oct := oct - 1.0.		f0 := f0 / 3.0. 		fN := fN / 3.0.].	[fN &lt; aHzPitch] whileTrue: 		[oct := oct + 1.0.		f0 := f0 * 3.0.		fN := fN * 3.0]."	Transcript show: 'nearestNoteTo: ', aHzPitch printString; cr."	0 to: notes size do: 		[ :ind | | p0 p1 |		(ind = 0)			ifFalse: [p0 := (notes at: ind) * (3.0 raisedTo: oct)]		"get the note degrees"			ifTrue: [p0 := notes last * (3.0 raisedTo: oct - 1)].		(ind &lt; notes size)			ifTrue: [p1 := (notes at: ind + 1)* (3.0 raisedTo: oct)]			ifFalse: [p1 := notes first * (3.0 raisedTo: oct + 1)]."		Transcript tab; show: 'Between: ', p0 printString, ' and: ', p1 printString; cr."		(p0 &lt;= aHzPitch and: [p1 &gt;= aHzPitch])			"loop over intervals looking for the one that includes the given freq"			ifTrue:  [ |  a b  | 				a := (aHzPitch - p0).				b := (p1 - aHzPitch).				^(a &gt;= b)					ifTrue:  [p1]					ifFalse: [p0]]].	self error: 'Pitch class member not found'</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 1, 2020' '4:30:15 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:30:15 PM on August 1, 2020."</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 1000 960 / 3 920 920 / 4 920 910 , 880 860 / 2 1 1 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1 1 /						3 1000 1000 , 1000 980 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1 1 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1 1 /						3 1000 1000 , 980 1000 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1 1 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1 1 /						3 1000 1000 , 980 1000 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.0001 0.0001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.0001 0.0001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1000 1000 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1000 1000 /						3 1000 1000 , 980 1000 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.00001 0.00001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.00001 0.00001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1 1 /						7 940 940 / 3 940 940 , 930 940 / 2 1 1'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1000 1000 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1000 1000 /						3 1000 1000 , 980 1000 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.00001 0.00001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.00001 0.00001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1000 1000 /						7 940 940 / 3 940 940 , 930 940 / 2 1000 1000'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2.""Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p]  toProp: #pitch from: 24 to: 34."Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1000 1000 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1000 1000 /						3 1000 1000 , 980 1000 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.00001 0.00001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.00001 0.00001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1000 1000 /						7 940 940 / 3 940 940 , 930 940 / 2 1000 1000'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2."									"for testing""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1000 1000 /						3 1100 1100 , 1030 1070 / 3 930 930 / 4 900 930 , 880 910 / 2 1000 1000 /						3 1000 1000 , 980 1000 / 3 940 940 / 4 910 940 , 890 900						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.00001 0.00001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.00001 0.00001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1000 1000 /						7 940 940 / 3 940 940 , 930 940 / 2 1000 1000'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2."									"for testing""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1000 1000 /						3 1100 1100 , 1000 1070 / 3 930 930 / 4 900 960 , 840 910 / 2 1000 1000 /						3 1000 1000 , 940 1000 / 3 940 940 / 4 900 940 , 890 960						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.00001 0.00001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.00001 0.00001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:).						"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1000 1000 /						7 940 940 / 3 940 940 , 930 940 / 2 1000 1000'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value]  toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value]  toProp: #pitch.	score1 addAll: score2 at: dur1 + 2.0.					"concatenate event lists""	score1 := score2."									"for testing""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 1, 2020' '4:42:15 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:42:15 PM on August 1, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 1, 2020' '4:58:24 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 4:58:24 PM on August 1, 2020."</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 			"start T"		add: #p4 -&gt; 440;					"frq"		add: #p5 -&gt; 0.25;					"ampl"		add: #p6 -&gt; 1.0;						"gliss"		add: #p7 -&gt; 0.0;						"L/R pos"		add: #p8 -&gt; (#mo -&gt; '10 0.0 1.0')).	"wet/dry ratio"	s11 eventList inspect</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11</class-id> <category>private-generators</category><body package="(none)" selector="writeMove0:from:into:">writeMove0: property from: array into: eList	"Parse and process the linear move keyword to generate events"	"aScore11 add: #p5 -&gt; (#mo -&gt; #(10 10 100))"	"aScore11 add: #p6 -&gt; (#mo -&gt; '100 1 1 , 1 1 / 20 1 1 , .9 1.1'); "	| evts tOffset |	evts := eList events.	tOffset := start. 	array size \\ 3 = 0 ifFalse:				"use a single range, ignoring the percentage value"		[self error: 'Wrong array size in parseRanges'].	1 to: array size by: 3 do:				"loop through the segments"		[ :ind | | v0 v1 vDiff t0 t1 tDiff segDur |		segDur := array at: ind.		v0 := array at: ind + 1.		v1 := array at: ind + 2.		vDiff := v1 - v0.		t0 := tOffset.		t1 := tOffset + segDur.		tDiff := t1 - t0.		evts do:							"event loop"			[ :eAss | | tn tScale val |			tn := eAss time asSec value.			(tn &gt;= tOffset and: [tn &lt;= (tOffset + segDur)]) ifTrue:				[tScale := (tn - t0) / tDiff.				val := (v0 + (vDiff * tScale)) asFloat.				eAss event perform: property with: val]].		tOffset := tOffset + segDur]</body></methods><methods><class-id>Siren.AbstractEvent</class-id> <category>printing</category><body package="Siren" selector="printOn:">printOn: aStream 	"Format and print the receiver on the argument."	aStream nextPut: $(.	super printOn: aStream.	aStream space.	properties == nil		ifFalse: [properties associations asSortedCollection do:				[ :ass |				aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']].	aStream nextPut: $); cr</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.MusicEvent</class-id> <category>printing</category><body package="Siren" selector="printTerseOn:">printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: '	', pitch printString].	loudness == nil		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: '	(v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associations asSortedCollection do:				[ :ass |				ass value isLPReal					ifTrue: [aStream nextPutAll: '	(', ass key, ': '.						ass value printOn: aStream digits: 4.						 aStream nextPutAll: ')']					ifFalse: [aStream nextPutAll: '	(', ass key, ': ', ass value printString, ')']]].	aStream "nextPutAll: ')';" cr</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 			"start T"		add: #p4 -&gt; 440;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss:;		add: #p7 -&gt; 0.0 mapTo: #pos:;		add: #p8 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet:).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos   wet/dry		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0  0.0		//				 0    1       2        3      4         5      6     7"	^[ :e :v | | arr |	arr := Array new: 8.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos.				"L/R position"	(e hasProperty: #wet)		"modulation index"		ifTrue: [arr at: 8 put: (e at: #wet)]		ifFalse:[arr at: 8 put: 0.0]."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 test14</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 2, 2020' '6:37:34 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 6:37:34 PM on August 2, 2020."</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos   wet/dry		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0  0.0		//				 0    1       2        3      4         5      6     7"	^[ :e :v | | arr |	arr := Array new: 8.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e gliss.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos.				"L/R position"	(e hasProperty: #wet)			"wet/dry ratio"		ifTrue: [arr at: 8 put: (e at: #wet)]		ifFalse:[arr at: 8 put: 0.0]."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 			"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 			"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><methods><class-id>Siren.OSCVoice class</class-id> <category>parameter maps</category><body package="Siren" selector="pMapForCSLFMBell">pMapForCSLFMBell	"Answer the default parameterMap for use with the CSL FM bell instrument."	"CSL bell instrument has args: 		// 				 dur, ampl, fr0,  gliss, rat,  ind,  pos   wet/dry		// OSC: /i37/pn  4.0  0.49  204.1 1.0    1.933 2.0   0.0  0.0		//				 0    1       2        3      4         5      6     7"	^[ :e :v | | arr |	arr := Array new: 8.				"set up the parameter map"	arr at: 1 put: e duration asSec value asFloat.	arr at: 2 put: e ampl value asFloat.	arr at: 3 put: e pitch asHz value asFloat.	arr at: 4 put: e gliss asFloat.	(e hasProperty: #ratio)			"ratio"		ifTrue: [arr at: 5 put: (e at: #ratio)]		ifFalse:[arr at: 5 put: 1.414].	(e hasProperty: #modInd)		"modulation index"		ifTrue: [arr at: 6 put: (e at: #modInd)]		ifFalse:[arr at: 6 put: 1.0].	arr at: 7 put: e pos.				"L/R position"	(e hasProperty: #wet)			"wet/dry ratio"		ifTrue: [arr at: 8 put: (e at: #wet)]		ifFalse:[arr at: 8 put: 0.0]."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]</body></methods><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 1.0 0.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 0.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 1.0 1.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.25;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 1.0 0.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '8/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.2;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 1.0 0.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '32/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.2;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '16/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.2;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '16/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.2;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	s11 du: 301.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '16/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.2;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 3.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	s11 du: 300.75.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><methods><class-id>Siren.Score11 class</class-id> <category>tests</category><body package="(none)" selector="test14">test14	"Inspect/play a simple Score11 event list - test fm bell direct/reflected control"	"Score11 test14"	| s11 score1 vox |	s11 := ((Siren.Score11 instr: 1 from: 0 to: 10) 		add: #p3 -&gt; (#rh -&gt; '16/'); 						"start T"		add: #p4 -&gt; 440 Hz;		add: #p5 -&gt; 0.15;		add: #p6 -&gt; 1.0 mapTo: #gliss: ;		add: #p7 -&gt; 0.0 mapTo: #pos: ;		add: #p8 -&gt; 2.0 mapTo: #modInd: ;		add: #p9 -&gt; (#mo -&gt; '10 0.0 1.0') mapTo: #wet: ).	s11 du: 300.75.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 10.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')].	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 test14</do-it><do-it>Score11 sleepingSword1</do-it><do-it>Score11 sleepingSword1</do-it><methods><class-id>Siren.Score11 class</class-id> <category>examples</category><body package="(none)" selector="sleepingSword1">sleepingSword1	"Score for the first gestures of 'SleepingSword' (WIP 2020)"	"Score11 sleepingSword1""Block 1: 3 clouds"	| s11 score1 score2 vox dur1 |	s11 := ((Score11 instr: 1 from: 0 to: 34) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.08 0.08 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 / 2.0 2.0 2.0 / 						5 0.077 0.077 , 0.1 0.12 / 5 0.1 0.1 , 0.12 0.07 						'); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 1000 1000 , 960 1000 / 3 920 920 / 4 910 920 , 860 880 / 2 1000 1000 /						3 1100 1100 , 1000 1070 / 3 930 930 / 4 900 960 , 840 910 / 2 1000 1000 /						3 1000 1000 , 940 1000 / 3 940 940 / 4 900 940 , 890 960						'); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '4 0.03 0.05 / 6 0.1 0.1 /	2 0.00001 0.00001 /						4 0.04 0.05 / 6 0.1 0.15  / 2 0.00001 0.00001 /						4 0.04 0.04 / 6 0.14 0.15'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mx -&gt; '12 -1.0 -0.3 / 						12 -1.0 -0.1 /						12 -0.4 0.2' 						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; #(1.0 3.0 4.0) mapTo: #modInd:;						"modulation index"		add: #p9 -&gt; 1.0 mapTo: #wet: ).									"wet/dry"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score1 := s11 eventList.								"generate the score and take an excerpt"	score1 := score1 excerptFrom: 0 to: 34.				"trim to the time alloted..."	score1 events removeLast.							"remove last note"	dur1 := score1 computeDuration.	score1 flushVoices.									"flush voices and assign sequential instruments 41-57"	score1 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Block 2: spinning cloud"	s11 := ((Score11 instr: 1 from: 0 to: 24) 				"Score11 instrument block"																		"dur in sec"		add: #p3 -&gt; (#mx -&gt; '5 0.08 0.08 , 0.08 0.09 / 5 0.08 0.08 , 0.06 0.06 / 2.0 2.0 2.0 / 						2 0.06 0.075 , 0.06 0.06 / 8 0.06 0.06 / 2.0 2.0 2.0'						); 																		"pitch in Hz"		add: #p4 -&gt; (#mx -&gt; '3 900 910 , 930 940 / 7 940 940 / 2 1000 1000 /						7 940 940 / 3 940 940 , 930 940 / 2 1000 1000'						); 																		"ampl ratio"		add: #p5 -&gt; (#mx -&gt; '6 0.1 0.15 / 4 0.15 0.15 /	2 0.0001 0.0001 /						10 0.15 0.15  / 2 0.0001 0.0001'						);			add: #p6 -&gt; #(1.0 0.8 1.2) mapTo: #gliss:;							"gliss ratio"		add: #p7 -&gt; (#mo -&gt; '7 -0.1 0.1 , -0.1 0.1 / 5 -0.1 0.1 , -0.5 0.5 / 						7 -0.5 0.5 , 0.2 0.2 / 5 0.2 0.2'						) mapTo: #pos:;									"L/R position"		add: #p8 -&gt; (#mx -&gt; '7 3.0 4.0 , 3.0 4.0 / 5 3.0 4.0 , 2.0 3.0 / 						7 2.0 3.0 , 2.0 2.2 / 5 2.0 2.2 , 2.0 2.0'						) mapTo: #modInd: ).								"modulation index"	s11 du: 300.5.										"duty cycle sets evt dur to X - 300"	score2 := s11 eventList.								"generate the score and take an excerpt"	score2 := score2 excerptFrom: 0 to: 24.				"trim to the time alloted..."	score2 events removeLast.							"remove last note"	score1 computeDuration.	score2 flushVoices.									"flush voices and assign sequential instruments 41-57"	score2 assignInstruments: [ :ind | ('/i', (ind - 1 \\ 16 + 41) printString, '/pn')]."Post-processing"	score1 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value] toProp: #pitch from: 12 to: 22.	score1 applyBlock: [ :p | (BohlenPierceScale root: N mi) nearestNoteTo: p asHz value] toProp: #pitch from: 24 to: 34.	score2 applyBlock: [ :p | (PentatonicScale root: N re) nearestNoteTo: p asHz value] toProp: #pitch.	score1 addAll: score2 at: dur1 + 3.0.					"concatenate event lists""	score1 := score2."									"for testing""Play or inspect"	vox := OSCVoice default.								"plug in the voice and parameter map"	vox parameterMap: OSCVoice pMapForCSLFMBell.				score1 voice: vox.		InputState default shiftDown ifTrue: [^score1 inspect].	"inspect"	score1 play											"play"</body></methods><do-it>Score11 sleepingSword1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 2, 2020' '7:11:52 PM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 7:11:52 PM on August 2, 2020."</do-it><do-it>Score11 sleepingSword1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 3, 2020' '11:11:08 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 11:11:08 AM on August 3, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 3, 2020' '11:16:29 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 11:16:29 AM on August 3, 2020."</do-it><comment><class-id>Siren.EventList</class-id><body>Instances of class EventList (subclass of DurationEvent), are used for holding onto multiple timed events. EventLists are events themselves and can have arbitrary properties as well as a collection of (relative start time -&gt; event) associations.Class EventList implements much collection-style protocol for event processing, as well as having special block application methods. All EventList algorithms are recursive in order to handle arbitrarily-deep hierarchical EventLists (possible because EventList is a subclass of DurationEvent). The class also has numerous powerful and flexible instance creation methods.Instance Variables:	events &lt;SortedCollection of EventAssociations (Duration =&gt; MEvent)&gt; 				the list's events, time/event associations sorted by relative start times	index &lt;Integer&gt; the current position (used in scheduling)	startedAt &lt;Integer&gt; the clock value when I startedStandard properties are #tempoScale for the tempo scaling factor (used by the CMN editors as the MS/whole note scale), and #code (#duration, #delta, or #startStop) to support different event coding schemes. The class also supports typed links to other event lists, e.g., "eList1 isTonicAnswerOf: eList2" or "eList1 hasPreviousVersion: eList2", which can be very useful properties in editors and browsers.The global dictionary EventLists holds onto instances that can be referenced with their name symbols; these can have gensym-like names such as #temp.23. Creating a named EventList automatically adds it to the global dictionary. There are tools for browsing and maintaining this dictionary.</body></comment><comment><class-id>Siren.Function</class-id><body>Instances of of Function and its subclasses represent abstractions of 1- or n-dimensional functions of 1 variable (e.g., time). Class Function is concrete and represents functions that are described by a array of data points assumed to lie equally-spaced in the unit interval.Functions are normally created from an array of values over the unit interval; x varies from 0.0 to 1.0 and y is free over that range.One can address them within the unit interval with atX: or one can address them with integer indices up to the data set's size with atIndex: (can be dangerous).Examples are a ramp from 0 to 1 such as:	[(LinearFunction from: #((0 0) (1 2))) at: 0.33]or a spline that traces a sine-like path centered around 1:	[(SplineFunction from: #((0 1) (0.33 2) (0.67 0) (1 1))) at: 0.35]InstanceVariables:	data &lt;Array of Numbers, OrderedCollection of (Z)Points, or UninterpretedBytes&gt;				the data values or breakpoints of the function	domain &lt;Interval&gt; the x-range	range &lt;Interval&gt; the y-range</body></comment><comment><class-id>Siren.MIDIPort</class-id><body>An instance of a subclass of MIDIPort is used for the interface between Siren and external MIDI drivers and devices. It implements both note-oriented (e.g., play: pitch at: aDelay dur: aDur amp: anAmp voice: voice), and data-oriented (e.g., put: data at: delay length: size) behaviors for MIDI I/O. There is an extensive test suite and demo in the class examples method and in the Siren outline view.There is typically only one instance of MIDIPort. The messages new, default, and instance all answer the sole instance. MIDIPorts use dependency to signal input data, objects wishing to receive input should register themselves as dependents of a port. In the default Siren implementation, the scheduler is all in Smalltalk, and only the simplest MIDI driver is assumed.Instance Variables:	readProcess &lt;Process&gt; The loop process to read input data.	inputData &lt;OrderedCollection of (Integer -&gt; ByteArray)&gt; The available data.	status &lt;Symbol&gt; #open or #closed	device &lt;Integer&gt; my IO device's indexClass Variables:	Instance &lt;MIDIPort|nil&gt; The sole instance, or nil.	Debug &lt;Boolean&gt; Debug mode prints all I/O to the Transcript.	UseSingleton &lt;Boolean&gt; whether to use a singleton instance (not necessary)	DefaultInputDevice &lt;Integer&gt; the index in the driver of the default input device	DefaultOutputDevice see aboveMIDI Commands Supported:	0x9x pp vv -- note-on (x=channel, pp=pitch, vv=velocity)	0x8x pp vv -- note-off (x=channel, pp=pitch, vv=velocity)	0xCx cc -- program-change (x=channel, pp=pitch)	0xEx ll hh -- program-change (x=channel, ll=low 7 bits, hh=high 7 bits)	0xBx cc dd -- control change (x=channel, cc=controller, dd=data)</body></comment><comment><class-id>Siren.EventAssociation</class-id><body>An EventAssociation is an Association with some special semantics for Siren. It can be created with the '=&gt;' message to a Number, meaning start-time associated with event.</body></comment><comment><class-id>Siren.DisplayListView</class-id><body>DisplayListViews can display and scroll structured graphics display lists generated by various models or layout managers.Using their page offset, they can scroll over very large display lists.They can have colored or gridded background pixmaps and can scroll/page on demand; they display their lists on their graphics contexts.Subclasses generally override the displayOn: or displayOnImage methods, and add initialization or transformation methods.Instance Variables	displayList	&lt;DisplayList&gt; the view's display list	pixmap	 &lt;Pixmap or nil&gt; the view's cached display pixel map (optional)	background &lt;Pixmap or nil&gt; the view's background form (e.g., gridding)	zoom &lt;Point or nil&gt; the display list's zoom-in factor or nil	pageOffset	 &lt;Point&gt; the offset in "pages" used for very large display lists	backgroundColor &lt;ColorValue&gt; graphics background color	foregroundColor &lt;ColorValue&gt; graphics display color	redrawn &lt;nil or not&gt; set to nil to re-draw cache	cache &lt;boolean&gt; should I cache a Pixmap of redisplay n the fly?See the class examples for numerous ways of using display list views.The subclasses add knowledge of smart display list generation, background pixmap generation (e.g., gridding), display of item or x/y-range selection, x- or y-scaling or step/grid, property-&gt;color mapping, "clef forms" or other special pixmaps, multiple-model viewing, etc.</body></comment><comment><class-id>Siren.Swell</class-id><body>A swell applies a function to the amplitudes of events in an event list.</body></comment><comment><class-id>Siren.EventModifier</class-id><body>EventModifier is the abstract superclass of the classes whose instances operate on event lists. There are operations that can be done eagerly (at definition time) or lazily (at run time)Instance Variables:	selector	&lt;Symbol&gt;  What aspect of the event list do I modify	function	&lt;Function&gt;  What function do I apply to the aspect	scale	&lt;Number&gt;  Do I apply a scalar scale?	start	&lt;Number&gt;  When do I start in the event list?	stop	&lt;Number&gt;  When do I stop in the event list?	index	&lt;Number&gt;  Used internally to count through events</body></comment><comment><class-id>Siren.MIDIDump</class-id><body>An instance of MIDIDump is used as a dependent of the MIDIPort to demonstrate the use of dependency for MIDI input. See the class example.Instance Variables:	verbose &lt;Boolean&gt; should I log events to the Transcript?	live &lt;Boolean&gt; should I match noteOn/Off commands on the fly?	eventList &lt;EventList&gt; the event list I'm capturing input to	notesOn &lt;OrderedCollection of MusicEvents&gt; the current playing notes	startedAt &lt;Integer&gt; the clock time I was started at</body></comment><comment><class-id>Siren.SoundEditor</class-id><body>A SoundEditor is the editor model for sound views.Instance Variables:	copyBuffer &lt;Sound&gt; the selected sound after a copy command	sound &lt;Sound&gt; the model sound	markers &lt;OrderedCollection of: Integer&gt; the sample indices of the selected points	selection1 &lt;Integer&gt; the sample index start of the current selection	selection2 &lt;Integer&gt; the stop of the selection	lastSelection &lt;Integer&gt; selection1 or 2, whichever was selected last	view &lt;Siren.SoundView&gt; my view	changed &lt;Boolean&gt; whether the sound has been changed</body></comment><comment><class-id>Siren.OSCMessage</class-id><body>OSCMessages are concrete old-format (untyped) OSC messagesInstance Variables:	address	&lt;String&gt;  my OSC command address	arguments	&lt;Collection&gt;  the arguments</body></comment><comment><class-id>Siren.Arpeggio</class-id><body>Arpeggii can be created on Chords or other event lists and can step through their events (assumed to be simultaneous at the start) with the given delay time.Instance variables:	delay &lt;Duration or Number&gt; the delay between the onsets of my events</body></comment><comment><class-id>Siren.DisplayRectangle</class-id><body>Instances of DisplayRectangle can be used to display bordered or filled rectangles in display lists. This is a subclass of DisplayLine for reasons of practicality. a "purist" (e.g., David Liebs), would create an intermediate abstract class (e.g., BoundedDisplayItem) for both DisplayLine and DisplayRectangle.Instance Variables:	fill		&lt;Boolean or nil&gt; whether or not to fill the receiver on display (no by default)</body></comment><comment><class-id>Siren.DisplayListSubcanvas</class-id><body>A DisplayListSubcanvas is used to plug a display list view into an application.Instance Variables:	displayList	&lt;?type?&gt;  comment	componentPart	&lt;CompositePart&gt;  my app. pane	displayListView &lt;Siren.DisplayListView&gt;  my view (does all the work)	scroller	&lt;?type?&gt;  my scroller (container)	vZoom	&lt;Number&gt;  vertical zoom factor	hZoom	&lt;Number&gt;  horiz. zoom factor</body></comment><comment><class-id>Siren.SplineFunction</class-id><body>Instances of SplineSeg are cubic splines between their points.Instance Variable:	linSeg		&lt;LinearFunction&gt; my linear twin</body></comment><comment><class-id>Siren.FourierSummation</class-id><body>Instances of FourierSummation are functions that interpret their points as 3-element arrays (harmonic, amplitude, phase), and sum sine waves into their data array based on the Fourier summation of these components.Instance variables:	myForm		&lt;Form&gt; my function plot--default size = 1024@180	myArray		&lt;Array of Floats&gt; my value array--default length = 1024	lazy &lt;Boolean&gt; do I cache my values (eager) or compute them on the fly (lazy)?Example:	| fcn |	fcn := FourierSummation from: #((1 1 0) (3 0.3 0) (5 0.2 0) 							(7 0.15 0) (9 0.11 0) (11 0.09 0)).	Transcript show: (fcn at: 0.14) printString; cr.</body></comment><comment><class-id>Siren.FunctionView</class-id><body>Instances of class FunctionView are views on breakpoint or sampled data functions.They can display up to 4 model functions on a fixed-size non-scrolling field.Instance variables:	models	 &lt;Array of 1 to 4 Functions&gt; the function array	aScale &lt;Number&gt; the y-scale of the view	vRange &lt;Number&gt; the vertical range, normally = aScale	hRange &lt;Number&gt; the horizontal range	colors &lt;Array of 1 to 4 ColorValues&gt; the colors for the 4 functions	normalize &lt;&lt;Array of 1 to 4 Booleans&gt; whether to normalize (to +- 1) the functions</body></comment><comment><class-id>Siren.PitchClass</class-id><body>Instances of (subclasses of) this class represent pitch-classes.A pitch class is an octave-independent note. There are 35 (sub) instances of this class. Octave-dependent notes are represented by instances of class OctaveDependentNote.Ideally PitchClass should be a metaclass, so that its instances be classes, and octave-dependent notes could then be instances of pitchClassesUnfortunately this is not possible straightforwadly in Smalltalk, so we use aggregation instead to represent octave-dependent notes</body></comment><comment><class-id>Siren.PitchClass</class-id><body>Instances of (subclasses of) this class represent pitch-classes.A pitch class is an octave-independent note. There are 35 (sub) instances of this class. Octave-dependent notes are represented by instances of class OctaveDependentNote.Ideally PitchClass should be a metaclass, so that its instances be classes, and octave-dependent notes could then be instances of pitchClassesUnfortunately this is not possible straight-forwadly in Smalltalk, so we use aggregation instead to represent octave-dependent notes</body></comment><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 3, 2020' '11:26:19 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 11:26:19 AM on August 3, 2020."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Content/Code/Smalltalk/Siren9/Siren90q.im' 'August 3, 2020' '11:29:08 AM')""An image file /Content/Code/Smalltalk/Siren9/Siren90q.im was created at 11:29:08 AM on August 3, 2020."</do-it><do-it>ListWorkBook open</do-it><do-it>ListWorkBook open</do-it><do-it>ListWorkBook open</do-it><do-it>ListWorkBook open</do-it><do-it>SirenUtility fileoutCategories</do-it><do-it>ListWorkBook open</do-it>