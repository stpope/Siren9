"Name: SirenNotice: Copyright (C) Stephen Travis Pope et al. 1984-2020Comment: This is the Siren 9.0 Music/Sound Package for Visualworks SmalltalkThe Siren system is a general-purpose software framework for music and sound composition, processing, performance, and analysis; it is a collection of about 350 classes written in Smalltalk-80. This version of Siren (9.0) works on VisualWorks Smalltalk (available for free for non-commercial use, see http://www.cincom.com/smalltalk) and supports streaming I/O via OpenSoundControl (OSC), MIDI, and multi-channel audio ports. The Siren release (with supporting external code) is available via the web from the URL http://FASTLabInc.com/Siren.Siren is a programming framework and tool kit; the intended audience is Smalltalk developers, or users willing to learn Smalltalk in order to write their own applications. The built-in applications are meant as demonstrations of the use of the libraries, rather than as end-user applications. Siren is not a MIDI sequencer, nor a score notation editor, through both of these applications would be easy to implement with the Siren framework.There are several elements to Siren:	the Smoke music representation language		(music magnitudes, events, event lists, generators, functions, and sounds);	voices, schedulers and I/O drivers		(real-time and file-based voices, sound, score, and MIDI I/O);	user interface components for musical applications		(UI framework, tools, and widgets); and	several built-in applications 		(editors and browsers for Smoke objects).There are external packages for the external DLLCC C code for using LibSndFile, PortMIDI, FFTW, PortAudio and OSC, as well as SWIG-based I/O Interfaces to both CSL and LorisYou can down-load the full release from	http://FASTLabInc.com/Siren or github or the Cincom Smalltalk repositorySTP -- Munich, Oct, 1984 - Santa Barbara, May, 2020DevelopmentPrerequisites: #(#(#any 'BOSS' '') #(#any 'StoreBase' '') #(#any 'DLLCC' '') #(#any 'Tools-Workspace' '') #(#any 'Tools-Trippy' '') #(#any 'Tools-File Browser' ''))PackageName: SirenParcel: #('Siren9.0h')ParcelDirectory: Siren9.0hPrerequisiteDescriptions: #(#(#name 'BOSS' #componentType #package) #(#name 'StoreBase' #componentType #bundle) #(#name 'DLLCC' #componentType #package) #(#name 'Tools-Workspace' #componentType #package) #(#name 'Tools-Trippy' #componentType #package) #(#name 'Tools-File Browser' #componentType #package))PrerequisiteParcels: #(#('BOSS' '') #('StoreBase' '') #('DLLCC' '') #('Tools-Workspace' '') #('Tools-Trippy' '') #('Tools-File Browser' ''))Version: 9.0hDate: 1:50:48 PM May 13, 2020"!'From VisualWorksÂ® Personal Use Edition, 8.3 of July 28, 2017 on May 13, 2020 at 1:50:48 PM'!(Dialog confirm: 'You are filing-in a Parcel source file!!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']!Smalltalk defineNameSpace: #Siren	private: false	imports: '			private Smalltalk.*			'	category: 'Music-Support'!Smalltalk.Siren defineClass: #DisplayListView	superclass: #{UI.AutoScrollingView}	indexedType: #none	private: false	instanceVariableNames: 'displayList pixmap background page zoom grid extent inset backgroundColor foregroundColor redrawn cache '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayListViews'!Siren.DisplayListView comment:'DisplayListViews can display and scroll structured graphics display lists generated by various models or layout managers.Using their page offset, they can scroll over very large display lists.They can have colored or gridded background pixmaps and can scroll/page on demand; they display their lists on their graphics contexts.Subclasses generally override the displayOn: or displayOnImage methods, and add initialization or transformation methods.Instance Variables	displayList	<DisplayList> the view''s display list	pixmap	 <Pixmap or nil> the view''s cached display pixel map (optional)	background <Pixmap or nil> the view''s background form (e.g., gridding)	zoom <Point or nil> the display list''s zoom-in factor or nil	pageOffset	 <Point> the offset in "pages" used for very large display lists	backgroundColor <ColorValue> graphics background color	foregroundColor <ColorValue> graphics display color	redrawn <nil or not> set to nil to re-draw cache	cache <boolean> should I cache a Pixmap of redisply n the fly?See the class examples for numerous ways of using display list views.The subclasses add knowledge of smart display list generation, background pixmap generation (e.g., gridding), display of item or x/y-range selection, x- or y-scaling or step/grid, property->color mapping, "clef forms" or other special pixmaps, multiple-model viewing, etc.'!Siren.DisplayListView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #TimeSequenceView	superclass: #{Siren.DisplayListView}	indexedType: #none	private: false	instanceVariableNames: 'clefForm xScaleDefault xScale xColor yColor headColor clefColor itemAccessors '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.TimeSequenceView comment:'Instances of SequenceView (and its subclasses) are time-line oriented DisplayListViews.Time may run horizontally (default) or vertically, depending on the layout manager.Instance Variables:	clefForm	<Form> the view''s clef form or axes (optional), may be staff or scale/grid/ruler	xScale	<Number> the time-to-x-coordinate scale	xColor	<ColorValue> the color of the lines for note duration	yColor	<ColorValue> the color of the lines for note amplitude	headColor	<ColorValue> the note head color	clefColor	<ColorValue> the clef color	itemAccessors	<Symbol or Dictionary of (Voice -> Symbol)> the item accessor(s) to use to generate the display list items for the notesThis implementation is MODE 1.1, STEIM, Amsterdam, May/June 1990; updated at the Lagoon in Palo Alto, July, 1991-May, 1992.The entirety of this software is Copyright (c) 1990, Stephen Travis Pope, Nomad Object Design/Nomad Computer Music Research. All Rights Reserved.'!Siren.TimeSequenceView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassChord	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'root structure notes possibleTonalities '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassChord class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Triad	superclass: #{Siren.PitchClassChord}	indexedType: #none	private: false	instanceVariableNames: 'type '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.Triad class	instanceVariableNames: ''!Smalltalk.Tools defineClass: #ListWorkBook	superclass: #{Tools.Workbook}	indexedType: #none	private: false	instanceVariableNames: 'textView '	classInstanceVariableNames: ''	imports: ''	category: 'Tools-Workspace'!Tools.ListWorkBook class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PortModel	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'name status device in out '	classInstanceVariableNames: 'devices in out properties singleton useSingleton rate blockSize mutex '	imports: ''	category: 'Music-Support'!Siren.PortModel class	instanceVariableNames: 'devices in out properties singleton useSingleton rate blockSize mutex '!Smalltalk.Siren defineClass: #SoundPort	superclass: #{Siren.PortModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Sound'!Siren.SoundPort comment:'SoundPort instances are interfaces to real-time sound I/O streams.Concrete subclasses add primitive interfaces to special devices such as audio ports or coprocessors.'!Siren.SoundPort class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PortAudioPort	superclass: #{Siren.SoundPort}	indexedType: #none	private: false	instanceVariableNames: 'rate format outChannels interface isOpen isRunning bufferSize '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Sound'!Siren.PortAudioPort comment:'A PortAudioPort is an interface to the external PortAudio library. It is simple, supports playback only, and does not use callbacks from C into Smalltalk. For a fancier version that supports input as well , see SmartAudioPort.Instance Variables:	device <Integer> the PortAudio device flag for my device	rate <Integer>  the sample rate in Hz	format <Symbol>  sample format as in #lin16Bit	outChannels <Integer>  # of out channels	interface <Siren.PortAudioInterface>  my low-level interface	isOpen	<Boolean>  am I open?	isRunning <Boolean>  am I running?	bufferSize <Integer>  size of the preallocated IO buffersShared Variables:	Devices <Array of: Integer>  my total # of I/O channels and default I/O sample rates'!Siren.PortAudioPort class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClass	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClass comment:'Instances of (subclasses of) this class represent pitch-classes.A pitch class is an octave-independent note.There are 35 (sub) instances of this class.Octave-dependent notes are represented by instances of classOctaveDependentNote.Ideally PitchClass should be a metaclass, so that its instancesbe classes, and octave-dependent notes could then be instancesof pitchClasses !!!!Unfortunately this is not possible straightforwadly in Smaltalk, so weuse aggregation instead to represent octave-dependent notes'!Siren.PitchClass class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassAltered	superclass: #{Siren.PitchClass}	indexedType: #none	private: false	instanceVariableNames: 'natural '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassAltered class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #LayoutManager	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'view orientation itemAccessor '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.LayoutManager comment:'Instances of the LayoutManager classes are used to generate display lists given random data structures and possibly hints in terms of structure accessors.This is David''s miraculous idea and the heart of the Navigator architecture.Instance Variables:	view		<DisplayListView> the view--May provide the displayItems	orientation	<Symbol or nil> my ''base'' symbol (e.g., #top)	itemAccessor	<StructureAccessor> my referencing protocol translatorLook for class references to the LayoutManager classes (mostly from DisplayListView classes), for lots of examples of the use of LayoutManagers.This implementation is Topaz 0, STEIM, Amsterdam, May/June 1990.The entirety of this software is Copyright (c) 1990, Stephen Travis Pope, Nomad Object Design/Nomad Computer Music Research. All Rights Reserved.'!Siren.LayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #HierarchyLayoutManager	superclass: #{Siren.LayoutManager}	indexedType: #none	private: false	instanceVariableNames: 'length xStep yStep treeAccessor '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.HierarchyLayoutManager comment:'Instances of the HierarchyLayoutManager classes are used to generate display lists from tree-like data and tree accessors.Instance Variables:	length		<Integer or Point> temp. depth used in layout	xStep		<Integer> step size for x	yStep		<Integer> step size for x	treeAccessor	<TreeAccessor> the TreeAccessor used to access the model'!Siren.HierarchyLayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventModifier	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'selector function scale start stop index '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventModifiers'!Siren.EventModifier comment:'EventModifier is the abstract superclass of the classes whose instances operate on event lists. There are operations that can be done eagerly (at definition time) or lazily (at run time)Instance Variables:	selector	<Symbol>  What aspect of the event list do I modify	function	<Function>  What function do I aply to the aspect	scale	<Number>  Do I apply a scalar scale?	start	<Number>  When do I start in the event list?	stop	<Number>  When do I stop in the event list?	index	<Number>  Used internally to count through events'!Siren.EventModifier class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Rubato	superclass: #{Siren.EventModifier}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventModifiers'!Siren.Rubato comment:'Rubato allows you to apply a function of time to the start times of events.'!Siren.Rubato class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #StructureAccessor	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'subject itemGenerator '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.StructureAccessor comment:'Instances of StructureAccessor and its subclasses are ''protocol convertors'' which provide predictable interfaces (e.g., tree-speak), for diverse data structures.The basic display item generating protocol is: 	(aStructureAccessor itemFor: aModelNode).InstanceVariableNames:	subject			<Object> the model or victim	itemGenerator   	<Symbol or Block> the DisplayItem generator						Model items are passed to it (if it''s a Block),						or have to perform: it (if it''s a Symbol).'!Siren.StructureAccessor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #STreeAccessor	superclass: #{Siren.StructureAccessor}	indexedType: #none	private: false	instanceVariableNames: 'terminalQuery childAccessor '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.STreeAccessor comment:'Instances of STreeAccessor tree-navigation interfaces to diverse data structures.The basic display tree walking protocol is: 	(aSTreeAccessor childrenOf: aModelNode); and	(aSTreeAccessor isTerminal: aModelNode).InstanceVariableNames:	terminalQuery	<Symbol or Block> the isLeaf or hasChildrenNot query	childAccessor		<Symbol or Block> accessor to get a node''s children						Model items are passed to these (if they''re Blocks),						or have to perform: them (if they''re Symbols).'!Siren.STreeAccessor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MusicMagnitude	superclass: #{Core.Magnitude}	indexedType: #none	private: false	instanceVariableNames: 'value '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.MusicMagnitude comment:'Instances of the subclasses of MusicMagnitude are used to represent scalar magnitudes in musical objects. The class MusicMagnitude is a place for the music magnitudes to share their state and basic accessing behavior.MusicMagnitudes generally implement precise mixed-mode arithmetic and comparison methods using a per-species generality table and auto-coercion within a species.The "type abstraction" classes (Duration, Pitch, Amplitude, etc.) represent "what"; they are never instantiated; their class creation methods answer instances of their species, but they manage coercion within the classes of their species. The "representational abstraction" classes (NominalMagnitude, OrdinalMagnitude, NumericalMagnitude, RatioMagnitude, etc.) represent "how"; they share value model semantics and coercion techniques. Note that the concrete implementation classes therefore answer their species by property model rather than by implementation subclass (i.e., HertzPitch species --> Pitch rather than NumericalMagnitude).MusicMagnitudes can have dependents (observers), and send themselves the changed: message when their values are changed.There are many examples in the implementation classes and the Siren  outline.Instance variables:	value		<Number or Symbol> the magnitude''s value'!Siren.MusicMagnitude class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OrdinalMagnitude	superclass: #{Siren.MusicMagnitude}	indexedType: #none	private: false	instanceVariableNames: 'table '	classInstanceVariableNames: 'Table '	imports: ''	category: 'Music-Models-Implementation'!Siren.OrdinalMagnitude comment:'Instances of the OrdinalMagnitude classes are order-only magnitudes.They use the instance or class instance tables for holding comparative relationships among instances (e.g., mag1 might know that it''s > mag2).The relation-setting (i.e., order assignment) messages are: ==, >>, <<, =<, and =>.The query messages are: =?, > < <=, and >=.Each subclass may decide whether instances or the class will hold the table of relationships.The decision should be made on the basis of the expected number of magnitude instances and the sparseness of their relationships.See the subclass'' class examples.Instance Variable:	table <Dictionary of OrdinalMagnitude -> Symbol> instance rel. tableClass Instance Variable:	Table <Dictionary of OrdinalMagnitude -> Symbol> class rel. table of all instances'!Siren.OrdinalMagnitude class	instanceVariableNames: 'Table '!Smalltalk.Siren defineClass: #Sharpness	superclass: #{Siren.OrdinalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.Sharpness comment:'Instances of Sharpness represent subjective sharpness (~ pitch * loudness) values.The instance variable tables are used for the name -> relation symbol map.See the class examples.'!Siren.Sharpness class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventListTreeEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'scoreView listTree '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.EventListTreeEditor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #AbstractEvent	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'properties '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'!Siren.AbstractEvent comment:'AbstractEvent is the base class in the event/event-list hierarchy (although it can be instantiated). Instances of AbstractEvent are objects that can be used as dictionaries or property lists. Their properties can be accessed either with at: and at:put: or by using the new property names themselves as selectors (e.g., (anAEventInstance at: #color put: #green) or (anAEventInstance color: #green)).Instance variables:	properties	 <Dictionary or nil> property list dictionaryThe global dictionary called Events can be used for sharing event instances.'!Siren.AbstractEvent class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DurationEvent	superclass: #{Siren.AbstractEvent}	indexedType: #none	private: false	instanceVariableNames: 'duration index startedAt realTime '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'!Siren.DurationEvent comment:'Instances of DurationEvent are events that have special slots for their duration and voice properties.Instance variables:	duration <Duration species or nil> duration--a relative time'!Siren.DurationEvent class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MusicEvent	superclass: #{Siren.DurationEvent}	indexedType: #none	private: false	instanceVariableNames: 'pitch loudness voice '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'!Siren.MusicEvent comment:'Instances of class MusicEvent are concrete musical note event objects used for eventLists and eventGenerators.Instance variables:	pitch <Pitch-species MusicMagnitude> the pitch/frequency	loudness <Loudness-species MusicMagnitude> the loudness/amplitude	voice <Voice, Symbol or Number> voice--a voice or key'!Siren.MusicEvent class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventList	superclass: #{Siren.MusicEvent}	indexedType: #none	private: false	instanceVariableNames: 'events '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'!Siren.EventList comment:'Instances of class EventList (subclass of DurationEvent), are used for holding onto multiple timed events. EventLists are events themselves and can have arbitrary properties as well as a collection of (relative start time -> event) associations.Class EventList implements much collection-style protocol for event processing, as well as having special block application methods. All EventList algorithms are recurrsive in order to handle arbitrarily-deep hierarchical EventLists (possible because EventList is a subclass of DurationEvent). The class also has numerous powerful and flexible instance creation methods.Instance Variables:	events <SortedCollection of EventAssociations (Duration => MEvent)> 				the list''s events, time/event associations sorted by relative start times	index <Integer> the current position (used in scheduling)	startedAt <Integer> the clock value when I stertedStandard properties are #tempoScale for the tempo scaling factor (used by the CMN editors as the MS/whole note scale), and #code (#duration, #delta, or #startStop) to support different event coding schemes. The class also supports typed links to other event lists, e.g., "eList1 isTonicAnswerOf: eList2" or "eList1 hasPreviousVersion: eList2", which can be very useful properties in editors and browsers.The global dictionary EventLists holds onto instances that can be referenced with their name symbols; these can have gensym-like names such as #temp.23. Creating a named EventList automatically adds it to the global dictionary. There are tools for browsing and maintaining this dictionary.'!Siren.EventList class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventGenerator	superclass: #{Siren.EventList}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.EventGenerator comment:'This class is the parent of most of the simple music-structure classes in this category.An EventGenerator can create an EventList using its given parameters and a function (block) to use to create Event sequences.  See the subclasses for examples.'!Siren.EventGenerator class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Cluster	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Cluster comment:'Cluster is an abstraction of a set of simultaneous (or same-pitch) events.A cluster need only have a set of pitches, or a rhythm.'!Siren.Cluster class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Chord	superclass: #{Siren.Cluster}	indexedType: #none	private: false	instanceVariableNames: 'root inversion type arity '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Chord comment:'Instances of Chord are eventLists that can be created by giving them a root and inversion. They can return eventLists.Instance variables:	root <Pitch> the root of the chord	inversion <Integer> the inversion level (unused at present)	type <Symbol> #major, #minor, etc.	arity <Integer> number of notes of the chord'!Siren.Chord class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Scale	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'root notes '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.Scale class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MajorScale	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.MajorScale class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Voice	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'name instrument stream '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.Voice comment:'Subclasses of Voice implement the mappings between symbolic event parameters (like timbre descriptions and pitch names) and concrete output event data.They can be used for generating sound compiler notelists or (real-time output or file dumps of) MIDI data.The instance variables are:	instrument <Symbol, association or device> my instrument	name 		<String or Symbol> my handle or name	stream		<Stream> my (optional) I/O streamThe global object Voices is a dictionary that note events can refer to with integer or symbolic keys.'!Siren.Voice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #NotelistVoice	superclass: #{Siren.Voice}	indexedType: #none	private: false	instanceVariableNames: 'parameterMap lastTime header '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.NotelistVoice comment:'Instances of the subclasses of NotelistVoice can read or write note list file streams in various formats for software sound synthesis packages such as cmusic, csound, or cmix.Note that we are output-only at present.Instance Variables:	parameterMap		<OrderedCollection of Symbols, Blocks, or Associations> 			the object''s P:=map, used to print out or parse note commands.'!Siren.NotelistVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OSCVoice	superclass: #{Siren.NotelistVoice}	indexedType: #objects	private: false	instanceVariableNames: 'port '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.OSCVoice comment:'An OSCVoice can play events out to an OSC server using a predefined parameter mapping block to generate the OSC message.Instance Variables:	port	<Siren.OSCPort>  my output port'!Siren.OSCVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SirenExternalInterface	superclass: #{External.ExternalInterface}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'singleton instance '	imports: '			private Siren.SirenExternalInterfaceDictionary.*			'	category: 'MusicIO-External'	attributes: #(			#(#includeFiles #())			#(#includeDirectories #())			#(#libraryFiles #())			#(#libraryDirectories #())			#(#beVirtual false)			#(#optimizationLevel #full))!Siren.SirenExternalInterface class	instanceVariableNames: 'singleton instance '!Smalltalk.Siren defineClass: #LibSndFileInterface	superclass: #{Siren.SirenExternalInterface}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: '			private Siren.LibSndFileInterfaceDictionary.*			'	category: 'MusicIO-External'	attributes: #(			#(#includeFiles #('sndfile_lite.h'))			#(#includeDirectories #('Siren7.5/DLLCC'))			#(#libraryFiles #('libsndfile.dylib' 'sndfile_lite.dylib'))			#(#libraryDirectories #('/usr/local/lib'))			#(#beVirtual false)			#(#optimizationLevel #full))!Siren.LibSndFileInterface class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIPacket	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'length time flags duration data '	classInstanceVariableNames: ''	imports: '			private MIDICommands.*			'	category: 'MusicIO-MIDI'!Siren.MIDIPacket comment:'A MIDIPacket represents a simple MIDI datagram with a time-stamp and a data array.Instance Variables	data <ByteArray> The MIDI data bytes (may include a MIDI command and running status messages)	length <Integer> The number of meaningful bytes in the data	time <Integer> The msec timestamp when the packet was created or received.	flags <Integer> Any ''flags'' received from the MIDI driver.	duration <Integer> my event''s lengthPool dictionaries:	MIDICommands <Dictionary of (command symbol -> octet)> e.g., (#noteOn -> 16r90)		(It is initialized by class MIDIPort.)See the class comment in MIDIPort for details.'!Siren.MIDIPacket class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MusicModel	superclass: #{Siren.MusicMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'generalityTable '	imports: ''	category: 'Music-Models-Representation'!Siren.MusicModel comment:'MusicModel adds the class instance variable generalityTable that is used for "abstract" music magnitude models such as Pitch and Amplitude.See the class methods for generality.Class inst Vars:	generalityTable <Dictionary of (Class ->Integer)> The species generality table'!Siren.MusicModel class	instanceVariableNames: 'generalityTable '!Smalltalk.Siren defineClass: #Chroma	superclass: #{Siren.MusicModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Chroma comment:'Class Chroma is the abstract representational class for the pitch and mode-element species.Instances of its subclass species are used to model pitches, gamut members, and frequencies.'!Siren.Chroma class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Pitch	superclass: #{Siren.Chroma}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Pitch comment:'Instances of classes whose species is Pitch are used for the pitch or frequency parameters of musical events.Pitches come in several flavors, as in the classes HertzPitch, RatioPitch, MIDIPitch and SymbolicPitch.The class Pitch is abstract, its class creation method answers an instance of a concrete Pitch class.Examples:	Pitch value: 440.0 	"create an instance with units of Hertz"	Pitch value: 77		"create an instance with units of MIDI key numbers"	Pitch value: #e4		"create a symbolic instance"	Pitch value: ''e4''		"same as using a symbol"	Pitch value: 4/3		"create a ratio instance"Note that new pitch representations such as music11-like pch (4.11 = 11th note in oct 4) or oct (4.1100 = oct4 + 1100 cts) notations can be added by overriding the float-to-Hz or float-to-midi conversions.See also the class example.'!Siren.Pitch class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OctaveDependentNote	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'oct pc midiPitch natural '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.OctaveDependentNote comment:'Instances of this class represent octave dependent notes.	pc : the pitch class of the note (takes enharmonic spelling into account)	octave: integer from 0 to .., represent the octave. Middle C is therefore represented by 	pc : C	octave: 4Defines methods to compute intervals, midiPitches, and lotsof thing that PitchClass implements too.So why not make this class and PitchClass havea common superclass, to factor out common computations ?Ontological questions :	how to compute an interval between two octave-dependent notes,since their ambitus may be arbitrarily large (no question of computing 25th intervals).So intervals should be reduced to thirteenth, i.e. :	octaves should be taken into account only in a 0/1 manner'!Siren.OctaveDependentNote class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DoubleHarmonic	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.DoubleHarmonic class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassSharp	superclass: #{Siren.PitchClassAltered}	indexedType: #none	private: false	instanceVariableNames: 'sharp '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassSharp class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Function	superclass: #{Siren.DurationEvent}	indexedType: #objects	private: false	instanceVariableNames: 'data range domain scale offset '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.Function comment:'Instances of of Function and its subclasses represent abstractions of 1- or n-dimensional functions of 1 variable (e.g., time). Class Function is concrete and represents functions that are described by a array of data points assumed to lie equally-spaced in the unit interval.Functions are normally created from an array of values over the unit interval; x varies from 0.0 to 1.0 and y is free over that range.One can address them within the unit interval with atX: or one can address them with integer indeces up to the data set''s size with atIndex: (can be dangerous).Examples are a ramp from 0 to 1 such as:	[(LinearFunction from: #((0 0) (1 2))) at: 0.33]or a spline that traces a sine-like path centered around 1:	[(SplineFunction from: #((0 1) (0.33 2) (0.67 0) (1 1))) at: 0.35]InstanceVariables:	data <Array of Numbers, OrderedCollection of (Z)Points, or UninterpretedBytes>				the data values or breakpoints of the function	domain <Interval> the x-range	range <Interval> the y-range'!Siren.Function class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #LinearFunction	superclass: #{Siren.Function}	indexedType: #objects	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.LinearFunction comment:'Instances of LinearFunction are line-segment functions of one free variable.Example:	LinearFunction from: #((0 0) (0.1 1) (0.2 0.6) (0.9 0.4) (1 0))'!Siren.LinearFunction class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SplineFunction	superclass: #{Siren.LinearFunction}	indexedType: #objects	private: false	instanceVariableNames: 'linSeg '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.SplineFunction comment:'Instances of SplineSeg are cubic splines betwen their points.Instance Variable:	linSeg		<LinearFunction> my linear twin'!Siren.SplineFunction class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Arpeggio	superclass: #{Siren.Chord}	indexedType: #none	private: false	instanceVariableNames: 'delay '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Arpeggio comment:'Arpeggii can be created on Chords or other event lists and can step through their events (assumed to be simultaneous at the start) with the given delay time.Instance variables:	delay <Duration or Number> the delay betyween the onsets of my events'!Siren.Arpeggio class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Positus	superclass: #{Siren.MusicModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Positus comment:'Class Positus is the abstract representational class for the position, space, and direction species.Instances of its subclass species are used to model spatial and positional values.'!Siren.Positus class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Directionality	superclass: #{Siren.Positus}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Directionality comment:'Instances of the Directionality species model the radiation characteristics of sound sources in room simulations.This class can be used as a concrete one (adding a few methods to fill it out), or like the other representational classes (making concrete classes of this species).In the later case, the value instance variable would hold a 1- or 2-dimensional position as a number or point.'!Siren.Directionality class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DeviceModel	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'name port stream debug in out rate '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.DeviceModel class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIDevice	superclass: #{Siren.DeviceModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-MIDI'!Siren.MIDIDevice comment:'MIDIDevice is a subclass of Model whose instances are used to model MIDI input/output hardware devices.The abstract class MIDIDevice implements the generic MIDI note on/off type events.Subclasses of MIDIDevice exist for specific models of devices and  implement the device-specific (system exclusive) commands.MIDIDevice are passed Events and channel numbers by their voices and generate commands as ByteArrays that they pass to MIDIPorts.Several devices may share one port (if there are several MIDI-capable devices on one cable), and one voice may point to several device/channel pairs on one or more devices.Instance variables:	port <MidiPort> the MIDIPort I use	stream <WriteStream> logging stream	debug <Boolean> verbosity flag for Transcript dumpingClass variable:	MStream	<WriteStream> the stream I dump by bytes on if my port is nil (good for debugging new subclasses)Standard MIDI Commands:		Note On = 9n kk vv		Note Off = 8n kk vv		Key Pressure = An kk vv		Pitch Wheel = En ll ll		After Touch Channel Pressure = Dn vv		Control Change = Bn cc vv		Program change = Cn ppRelevant Constants for description of MIDI commands:		n = 4-bit channel number		kk = 7-bit key number		vv = 7-bit key velocity		ll = 7-bit low-order value		hh = 7-bit high-order value		cc = 7-bit control number		pp = 7-bit program number'!Siren.MIDIDevice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIFB01	superclass: #{Siren.MIDIDevice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-MIDI'!Siren.MIDIFB01 comment:'MidiFB01 is a type of MidiDevice for the system exclusive commands of the Yamaha FB-01 synthesiser.It implements the special commands available here (like note commands with fractional pitch and given duration).The standard FB01 note command is like:		2n k f v d1 d2 = cmd:channel, noteNum, frac, vel, durLow, durHigh'!Siren.MIDIFB01 class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIDump	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'eventList live notesOn startedAt '	classInstanceVariableNames: ''	imports: '			private MIDICommands.*			'	category: 'MusicIO-MIDI'!Siren.MIDIDump comment:'An instance of MIDIDump is used as a dependent of the MIDIPort to demonstrate the use of dependency for MIDI input. See the class example.Instance Variables:	verbose <Boolean> should I log events to the Transcript?	live <Boolean> should I match noteOn/Off commands on the fly?	eventList <EventList> the event list I''m capturing input to	notesOn <OrderedCollection of MusciEvents> the current playing notes	startedAt <Integer> the clock time I was started at'!Siren.MIDIDump class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Ergon	superclass: #{Siren.MusicModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Ergon comment:'Class Ergon is the abstract representational class for the amplitude/loudness/dynamic species.Instances of its subclass species are used to model loudness values.'!Siren.Ergon class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Amplitude	superclass: #{Siren.Ergon}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Amplitude comment:'Instances of classes whose species is Amplitude are used for the loudness parameters of musical events.Amplitudes come in several flavors, as in the classes RatioMagnitude, MIDIVelocity and SymbolicLoudness.The class Amplitude is abstract, its class creation method answers an instance of a concrete Amplitude/Loudness class.Examples:	Amplitude value: 0.77		"create a ratio instance - range 0.0 to 1.0 (cmusic)"	Amplitude value: 77		"create an MIDI instance - range 0 to 127"	Amplitude value: #mp		"create a symbolic instance - range #ppp to #fff"See also the class example.'!Siren.Amplitude class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Sound	superclass: #{Siren.Function}	indexedType: #objects	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: '			private SoundConstants.*			'	category: 'Music-Sound'!Siren.Sound comment:'Instances of the subclasses of Sound are used to represent sound objects.The abstract class Sound is vacuous.Sounds use their Function and DurationEvent behaviors actively.'!Siren.Sound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SampledSound	superclass: #{Siren.Sound}	indexedType: #objects	private: false	instanceVariableNames: 'name rate format channels samplesInMemory firstIndex '	classInstanceVariableNames: ''	imports: '			private SoundConstants.*			'	category: 'Music-Sound'!Siren.SampledSound comment:'Instances of SampledSound represent digitally-sampled sound objects.  Their "samples" are stored in the "data" instance variable inherited from Function. They can be read/written to/from files (using SoundFile objects), displayed (in SoundViews) and played (via SoundPorts).The class SampledSound is concrete and assumes 16-bit linear encoding of samples; there are subclasses for floating-point and 8-bit Mu-law sample types. There are useful class methods for creating a number of standard sounds such as silence, impulses, swept sine waves, etc. Note that SampledSound uses the ''range'' instance variable inherited from Function as its (integer) size.Instance variables:	name <String> the file name or object ID	rate <Number> the sample rate	format <Symbol> the sample format, e.g., #lin16Bit	channels <Integer> the # of channels	samplesInMemory	<Integer> The number of samples held in memory (may be smaller than 			size for very large sounds)	firstIndex	<Integer> The sample index of the start of the in-memory samples  (may be non-zero 			for very large "paged" sounds)Other properties, such as the sound''s (optional) file name, its sample rate, or the number of channels, are stored in the property list dictionary that is inherited by virtue of being an event subclass.KNOWN BUGS:Note that not all of this class is finished--there are methods that call non-existent user primitives and have no Smalltalk implementations (like the heavy DSP).'!Siren.SampledSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #VirtualSound	superclass: #{Siren.SampledSound}	indexedType: #objects	private: false	instanceVariableNames: 'source '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Sound'!Siren.VirtualSound comment:'An instance of VirtualSound is a "reference" to another sound, typically by a named cue list entry.Instance Variables:	source	<StoredSound> the sound to which the VirtualSound points'!Siren.VirtualSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIPort	superclass: #{Siren.PortModel}	indexedType: #none	private: false	instanceVariableNames: 'inputData readProcess '	classInstanceVariableNames: ''	imports: '			private MIDICommands.*			private MIDIioctls.*			private GeneralMIDIMap.*			private GeneralMIDIDrums.*			'	category: 'MusicIO-MIDI'!Siren.MIDIPort comment:'An instance of a subclass of MIDIPort is used for the interface betweeen Siren and external MIDI drivers and devices. It implements both note-oriented (e.g., play: pitch at: aDelay dur: aDur amp: anAmp voice: voice), and data-oriented (e.g., put: data at: delay length: size) behaviors for MIDI I/O. There is an extensive test suite and demo in the class examples method and in the Siren outline view.There is typically only one instance of MIDIPort. The messages new, default, and instance all answer the sole instance. MIDIPorts use dependency to signal input data, objects wishing to receive input should register themselves as dependents of a port. In the default Siren implementation, the scheduler is all in Smalltalk, and only the simplest MIDI driver is assumed.Instance Variables:	readProcess <Process> The loop process to read input data.	inputData <OrderedCollection of (Integer -> ByteArray)> The available data.	status <Symbol> #open or #closed	device <Integer> my IO device''s indexClass Variables:	Instance <MIDIPort|nil> The sole instance, or nil.	Debug <Boolean> Debug mode prints all I/O to the Transcript.	UseSingleton <Boolean> whether to use a singleton instance (not necessary)	DefaultInputDevice <Integer> the index in the driver of the default input device	DefaultOutputDevice see aboveMIDI Commands Supported:	0x9x pp vv -- note-on (x=channel, pp=pitch, vv=velocity)	0x8x pp vv -- note-off (x=channel, pp=pitch, vv=velocity)	0xCx cc -- program-change (x=channel, pp=pitch)	0xEx ll hh -- program-change (x=channel, ll=low 7 bits, hh=high 7 bits)	0xBx cc dd -- control change (x=channel, cc=controller, dd=data)'!Siren.MIDIPort class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #FourierSummation	superclass: #{Siren.Function}	indexedType: #objects	private: false	instanceVariableNames: 'myForm myArray lazy '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.FourierSummation comment:'Instances of FourierSummation are functions that interpret their points as 3-element arrays (harmonic, amplitude, phase), and sum sine waves into their data array based on the fourier summation of these components.Instance variables:	myForm		<Form> my function plot--default size = 1024@180	myArray		<Array of Floats> my value array--default length = 1024	lazy <Boolean> do I cache my values (eager) or cmopute them on the fly (lazy)?Example:	| fcn |	fcn := FourierSummation from: #((1 1 0) (3 0.3 0) (5 0.2 0) 							(7 0.15 0) (9 0.11 0) (11 0.09 0)).	Transcript show: (fcn at: 0.14) printString; cr.'!Siren.FourierSummation class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PhraseView	superclass: #{Siren.TimeSequenceView}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.PhraseView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ActionEvent	superclass: #{Siren.DurationEvent}	indexedType: #objects	private: false	instanceVariableNames: 'action '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Events'!Siren.ActionEvent comment:'An instance of ActionEvent evaluates a Smalltalk block when scheduled.Instance variables:	action  <Block or Value> Something to do'!Siren.ActionEvent class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundEvent	superclass: #{Siren.ActionEvent}	indexedType: #objects	private: false	instanceVariableNames: 'sound '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Sound'!Siren.SoundEvent class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayListController	superclass: #{UI.ControllerWithMenu}	indexedType: #none	private: false	instanceVariableNames: 'selOffset '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayListViews'!Siren.DisplayListController comment:'Instances of DisplayListController (or its subclasses) are used by DisplayListViews (or subclass instances) for menu management and selection.By default, a simple YellowButton menu allows for group/inspect/redraw/zoom.The RedButton is used for display item selection (by pointing or boxing-in).LeftShift extends the selection, and dragging a selection moves it.Instance Variables:	selection		<DisplayList> the object''s selected items'!Siren.DisplayListController class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #TimeSequenceController	superclass: #{Siren.DisplayListController}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.TimeSequenceController class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchTimeController	superclass: #{Siren.TimeSequenceController}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.PitchTimeController class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIFileVoice	superclass: #{Siren.Voice}	indexedType: #none	private: false	instanceVariableNames: 'fileType tracks ppq tempo '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.MIDIFileVoice comment:'A MIDIFileVoice can read version 2 MIDI files.'!Siren.MIDIFileVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #NumericalMagnitude	superclass: #{Siren.MusicMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.NumericalMagnitude comment:'Instances of the subclasses of NumericalMagnitude are music magnitudes with numerical values.When the values are floating-point numbers, the range is often 0.0 to 1.0.Integer ranges such as 0 to 127 can also be used in subclasses.One may want to add range-checking for these cases.Note that the class NumericalMagnitude is vacuous at present, and exists solely for representational modeling.'!Siren.NumericalMagnitude class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MeasureDuration	superclass: #{Siren.NumericalMagnitude}	indexedType: #none	private: false	instanceVariableNames: 'timeSignature '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.MeasureDuration comment:'A MeasureDuration reprsents time as beats and measures.It is partially implemented and unused.Instance Variables:	timeSignature	<Fraction>  my time signature'!Siren.MeasureDuration class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #HertzPitch	superclass: #{Siren.NumericalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.HertzPitch comment:'Instances of HertzPitch are frequency values in Hertz.This is the most general Pitch representation.The value is assumed to be a floating-point number.'!Siren.HertzPitch class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayListTracker	superclass: #{UI.SelectionTracker}	indexedType: #none	private: false	instanceVariableNames: 'inside '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayListViews'!Siren.DisplayListTracker comment:'A DisplayListTracker is a controller for mouse tracking in DLViewsInstance Variables:	inside	<Boolean>  is the mouse in my view?'!Siren.DisplayListTracker class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MusicalInterval	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'type semiTones '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.MusicalInterval comment:'MusicalInterval commentStamp: ''<historical>'' prior: 0!!Intervalle represente un intervalle entre deux notes.type represente l''ecart entre les deux notes extremites. Cet ecart ne tient compteque des notes naturelles. Par exemple, les tierces (majeures ou mineures) ont comme type 3,les quarte 4 etc.demisTons est le nombre de demis tons entre les deux notes. Par exemple une tiercemajeure a comme type 3 et demisTons = 4.'!Siren.MusicalInterval class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundFileViewer	superclass: #{Tools.FileTools.FileInformationViewer}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Sound'!Siren.SoundFileViewer comment:'this is a plug-in for the FileBrowser for handling sound files'!Siren.SoundFileViewer class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #NominalMagnitude	superclass: #{Siren.MusicMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'NameMap '	imports: ''	category: 'Music-Models-Implementation'!Siren.NominalMagnitude comment:'Instances of the NominalMagnitude classes are named (symbolic) properties where a symbol <--> value map is well-established for a given range and domain, e.g., 0.0 to 1.0 or 0 to 127.Examples are pitch (#d4) or dynamic (#mp) names.Class Instance Variable:	NameMap	<Dictionary or Array of (Symbol -> Number or Interval)> the class'' look-up table'!Siren.NominalMagnitude class	instanceVariableNames: 'NameMap '!Smalltalk.Siren defineClass: #SymbolicPitch	superclass: #{Siren.NominalMagnitude}	indexedType: #none	private: false	instanceVariableNames: 'fracPitch '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.SymbolicPitch comment:'Instances of SymbolicPitch represent well-tempered note names relative to a4=440Hz.The range is c0 to g#9 and the values are symbols.Note the confusion between the sharp sign (always placed after the note name) and Smalltalk''s symbol key #.One often writes (''c#3'' asSymbol) to be safe.Instance Variables:	fracPitch <Float> the remainder for microtonal tuningsThe class instance variable NameMap is used for the name <--> MIDI key number mapping array.'!Siren.SymbolicPitch class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Spatialization	superclass: #{Siren.Positus}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Spatialization comment:'Instances of the Spatialization species model the characteristics and configuration of room simulations in scores.This class can be used as a concrete one (adding a few methods to fill it out), or like the other representational classes (making concrete classes of this species).In the later case, the value instance variable would hold a record with the geometry or the room, the positions of default sources, and the listener''s position and features.'!Siren.Spatialization class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventScheduler	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'appointments timers threads running doWait startTime delay logTime '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.EventScheduler comment:'An instance of EventScheduler is a simple driver for real-time message-passing among any classes that can return timed event association values.  One uses Schedules by setting up clients which a master scheduler process continuously evaluates for their next timed activations. Clients can return appointments which are sorted into the scheduler''s list of (time -> event) associations that is evaluated continuously when running. Changed messages are sent from the accessor messages to simplify EventScheduler browsers and inspectors.Instance variables:	clients 		<Collection> client objects	appointments <SEventQueue> the schedule	running 		<Boolean> running schedule?	doWait		<Boolean> whether or not the scheduler should do real-time 					scheduling--set to false if there is a lower level of scheduling 					(e.g., primitive-level) or if output need not be real-time	startTime <Integer> the clock time I was started atClass variable:	Schedule 	<EventScheduler> shared instance accessed by the class message masterScheduleSee the class examples.'!Siren.EventScheduler class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PField	superclass: #{Siren.MusicMagnitude}	indexedType: #none	private: false	instanceVariableNames: 'name field '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.PField comment:'Instances of PField magnitudes are used for arbitrary parameters of musical events oriented towards formats with positional parameter declarations, e.g., Music-V-style notelist formats (see uses).Instance variables:	field <Integer> field in the score	name <String or Symbol> the parameter''s name (optional)Examples:	PField field: 5 value: 0.7 name: #position	PField field: 9 value: ''legato'' name: #expression'!Siren.PField class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchTimeView	superclass: #{Siren.TimeSequenceView}	indexedType: #none	private: false	instanceVariableNames: 'pitchOffset yScale yScaleDefault '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.PitchTimeView comment:'Instances of PitchTimeView (and its subclasses) are time-line oriented DisplayListViews which make the assumption that the y-coordinate is related to pitch.The relationship may be a function (as in piano-roll and Hauer-Steffens notation), or involve a look-up table (as in CMN).Instance Variables:	pitchOffset	<Number> the view''s lowest pitch (normally a key number)'!Siren.PitchTimeView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PositionTimeView	superclass: #{Siren.PitchTimeView}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.PositionTimeView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #HauerSteffensView	superclass: #{Siren.PitchTimeView}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.HauerSteffensView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #NeapolitanMajor	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.NeapolitanMajor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassFlat	superclass: #{Siren.PitchClassAltered}	indexedType: #none	private: false	instanceVariableNames: 'flat '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassFlat class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ChordNameEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'pitchClass pitchClassIndex structure seventh eleventh root ninth fifth third thirteenth noteNames '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.ChordNameEditor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #CompositeSound	superclass: #{Siren.VirtualSound}	indexedType: #objects	private: false	instanceVariableNames: 'components '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Sound'!Siren.CompositeSound comment:'An instance of CompositeSound can be used to represent a sound constructed by "splicing together" sections of other sounds.It uses its components collection to maintain sounds and sample ranges that have been pasted together.It responds to sampleAt: and sampleAt:put: just like other sounds, but stores only its components list on files unless explicitly told to store samples.Instance Variables:	components <SortedCollection of ComponentSounds> the "sub-sounds" of the CompositeSound'!Siren.CompositeSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Track	superclass: #{Siren.DurationEvent}	indexedType: #none	private: false	instanceVariableNames: 'id name filename title artist album year labels size path kind genre comment key track modDate addDate bRate sRate persID type hasTags folder playlists '	classInstanceVariableNames: ''	imports: ''	category: 'Music-DBase'!Siren.Track class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OctaveDependentChord	superclass: #{Siren.PitchClassChord}	indexedType: #none	private: false	instanceVariableNames: 'notesByInterval '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.OctaveDependentChord comment:'notesBytInterval provides a fast access to the chord notesby the names of their intervals with the root. The calculation is done once forever.  On the contrary,  for FPChord thecalculation is done all the times a note is required since its rarely required.Note that for all request (e.g. theFifth) the copy of the note is answer). it is necessary in order to avoid some confusions. For instance,the pitches (ODNotes) of  an simple arpeggio on a chord ch may be obtained by: 	o := OredredCollection new.	o add: ch theTonic; add: ch theThird; ch theFifth; theTonic.the first and last must be different objects in the case we will assign them todifferents PlayableNotes.'!Siren.OctaveDependentChord class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DataSet	superclass: #{Siren.AbstractEvent}	indexedType: #none	private: false	instanceVariableNames: 'tracks albums playlists root artists tree date majVersion minVersion appVersion folder persID features tags name '	classInstanceVariableNames: 'SongDataSet Tags '	imports: ''	category: 'Music-DBase'!Siren.DataSet comment:'DataSet is a holder of tracks, tags, and other metadataInstance Variables:	tracks		<OrderedCollection of Tracks>	the track list	albums		<ClassOfVariable>	description of variable''s function	playlists	<ClassOfVariable>	root		<>	artists		<>	tree		<>	date		<>	majVersion		<>	minVersion		<>	appVersion	<>	folder		<>	persID		<>	features	<>	tags		<OrderedCollection of Trags>	the tag list'!Siren.DataSet class	instanceVariableNames: 'SongDataSet Tags '!Smalltalk.Siren defineClass: #Cloud	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: 'density '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Cloud comment:'Clouds are eventLists that are describe in terms of their contours or selection criteria.This can be (e.g.,) POD-style specification of ranges for random selection, or selection from a given set of pitches.See the class examples of my subclasses for description examples.Instance variables:	density		<Number> number of notes per second'!Siren.Cloud class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #HarmonicMinorScale	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.HarmonicMinorScale class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #AbstractOSCPacket	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'oscBytes '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.AbstractOSCPacket comment:'AbstractOSCPacket is the parent of the concrete OSC packet classes.Subclasses must implement the following messages:	osc>>toOSCBytes:Instance Variables:	oscBytes	<ByteArray>  my packet contents'!Siren.AbstractOSCPacket class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OSCMessage	superclass: #{Siren.AbstractOSCPacket}	indexedType: #none	private: false	instanceVariableNames: 'address arguments '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.OSCMessage comment:'OSCMessages are concrete old-format (untyped) OSC messagesInstance Variables:	address	<String>  my OSC cmomand address	arguments	<Collection>  the arguments'!Siren.OSCMessage class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Ostinato	superclass: #{Siren.EventGenerator}	indexedType: #none	private: false	instanceVariableNames: 'list playing process '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Ostinato comment:'Ostinati can repeat their basic eventList without end, if necessary.Instance variables:	list <EventList> my riff	playing <Boolean> am i on?	process <Process> the process that''s playing me'!Siren.Ostinato class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Spectrum	superclass: #{Siren.Function}	indexedType: #objects	private: false	instanceVariableNames: 'sound window windowSize stepSize magReal '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.Spectrum comment:'Instances of Spectrum represent 3-D data functions derived from sound analysis.Instance Variables:	sound <StoredSound> the receiver''s sound	window <Symbol>the window type id	windowSize <Integer> the window size	stepSize <Integer> the step between windows	fft <FFT> the receiver''s FFT analyzer	magReal <Symbol> The spectrum type: mag, real, polar, or complex'!Siren.Spectrum class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ChromaticInterval	superclass: #{Siren.MusicalInterval}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.ChromaticInterval comment:'ChromaticInterval commentStamp: ''<historical>'' prior: 0!!used to produce intervals with no names, measured only in termsof a number of semie tones (for non-tonal music)'!Siren.ChromaticInterval class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassDoubleSharp	superclass: #{Siren.PitchClassAltered}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassDoubleSharp class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #AnalysisList	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.AnalysisList class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #FloatSound	superclass: #{Siren.SampledSound}	indexedType: #objects	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Sound'!Siren.FloatSound comment:'Instances of FloatSound are used for sounds with 32-bit floating-point numbers as samples.There are behaviors for mapping into other formats.'!Siren.FloatSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EditorModel	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'selections copyBuffer view '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.EditorModel class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayListEditor	superclass: #{Siren.EditorModel}	indexedType: #none	private: false	instanceVariableNames: 'list '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayListViews'!Siren.DisplayListEditor comment:'An instance of DisplayListEditor is used as the intermediary model for viewing lists.It handles selection and operation on the list.It adds itself as a dependent of the list and echoes its change messages (i.e., the update: message says self changed).Instance Variable:	list			<DisplayList> the ''subject'' list model	selection		<DisplayItem orDisplayLIst> the current selection or nil'!Siren.DisplayListEditor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventListEditor	superclass: #{Siren.DisplayListEditor}	indexedType: #none	private: false	instanceVariableNames: 'eventList ostinato defaultEvent '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.EventListEditor comment:'Instances of EventListEditor are used as the models of EventListViews.They hold onto EventLists and send messages to them.Instance variables:	list 			<EventList> my EventList (subject)	ostinato 	<Ostinato> my loop process (if i''m looping)	selection 	<EventList> The "selected" notes	ampl 		<Number or Amplitude> My default amplitude'!Siren.EventListEditor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayItem	superclass: #{Graphics.DependentPart}	indexedType: #none	private: false	instanceVariableNames: 'offset color '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayLists'!Siren.DisplayItem comment:'Instances of the subclasses of the abstract class DisplayItem are used as the items in display lists. They can generally display themselves on graphics contexts.These are done this way because I don''t think wrappers are right for use in display lists.Instance Variables:	offset		<Point> the object''s offset relative to its container (display list)	color		<ColorValue> the object''s display color (or nil)The subclasses add special display-related state and behavior such as an extent point and display method, or a visual item such as a string or image to display.They generally implement displayOn: aGraphicsContext and bounds accessing methods.This implementation is MODE 1.1, STEIM, Amsterdam, May/June 1990; updated at the Lagoon in Palo Alto, July, 1991-May, 1992.The entirety of this software is Copyright (c) 1990, Stephen Travis Pope, Nomad Object Design/Nomad Computer Music Research. All Rights Reserved.'!Siren.DisplayItem class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayLine	superclass: #{Siren.DisplayItem}	indexedType: #none	private: false	instanceVariableNames: 'width extent '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayLists'!Siren.DisplayLine comment:'Instances of DisplayLine are used for visual lines in display lists.Instance Variables:	width		<Number> the object''s line width	extent		<Point> the object''s visual extent'!Siren.DisplayLine class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Peal	superclass: #{Core.SequenceableCollection}	indexedType: #objects	private: false	instanceVariableNames: 'base directions position finished '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Peal comment:'Peals are repetitive note-generating sequences.  This implementation was written by Mark Lentczner in 1986.Instance variables:	base <Collection of Numbers> the pitches i use	directions <Array of +-1> the direction of the current sub-sequence	position <Number> the current index	finished <Boolean> an i done?'!Siren.Peal class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #FunctionEvent	superclass: #{Siren.MusicEvent}	indexedType: #objects	private: false	instanceVariableNames: 'function interval delta '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.FunctionEvent class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayRectangle	superclass: #{Siren.DisplayLine}	indexedType: #none	private: false	instanceVariableNames: 'fill stroke '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayLists'!Siren.DisplayRectangle comment:'Instances of DisplayRectangle can be used to display bordered or filled rectangles in display lists. This is a subclass of DisplayLine for reasons of practicality. a "purist" (e.g., David Liebs), would create an intermediate abstract class (e.g., BoundedDisplayItem) for both DisplayLine and DisplayRectangle.Instanve Variables:	fill		<Boolean or nil> whether or not to fill the receiver on display (no by default)'!Siren.DisplayRectangle class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayPolyline	superclass: #{Siren.DisplayRectangle}	indexedType: #none	private: false	instanceVariableNames: 'vertices '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayLists'!Siren.DisplayPolyline comment:'A DisplayPolyline is a poly-line-segment display objectInstance Variables:	vertices	<OrderedCollection of Point>  my point array'!Siren.DisplayPolyline class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventListPanel	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'editorView scoreView textView '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.EventListPanel class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassNatural	superclass: #{Siren.PitchClass}	indexedType: #none	private: false	instanceVariableNames: 'semiToneCount nom name following preceding sharp flat '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassNatural class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Lapse	superclass: #{Siren.MusicalInterval}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.Lapse class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundView	superclass: #{Siren.DisplayListView}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Sound'!Siren.SoundView comment:'Instances of SoundView are used for displaying samples sound objects in R4.They can do horizontal scrolling and scaling.Instance variables:	step <Number> the step size for displaying--show every n''th sample	scale <Number> the vertical scale for multiplying the sample''s value'!Siren.SoundView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ConditionalDuration	superclass: #{Siren.MusicMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.ConditionalDuration comment:'Instances of ConditionalDuration are duration times where the value is a block.The accessing protocol allows them to be spawned as co-processes in schedulers.The valueAt: and waitUntil: methods allow flexible conditional scheduling.ConditionalDurations can be made dependents of other objects using the until: instance creation message.See the class examples.'!Siren.ConditionalDuration class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Signature	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'sharps flats '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.Signature comment:'Notion of signature is related to the notion of "legal" scales, i.e.scales having only sharps OR flats in their signature.So method tonality here works only for legal scales.It should possible to compute the tonality for arbitrary scales though,but I am not sure how'!Siren.Signature class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #IntervalMagnitude	superclass: #{Siren.NumericalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'range '	imports: ''	category: 'Music-Models-Implementation'!Siren.IntervalMagnitude comment:'Instances of subclasses of the abstract class IntervalMagnitude are NumericalMagnitudes where a specific interval is defined within which values are possible. Examples are MIDI values in the range of 0 .. 127. the actual range is a class inst var.'!Siren.IntervalMagnitude class	instanceVariableNames: 'range '!Smalltalk.Siren defineClass: #EventListTreeItem	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'lists '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.EventListTreeItem class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SecondDuration	superclass: #{Siren.NumericalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.SecondDuration comment:'Instances of SecondDuration are duration times in floating-point seconds.This is among the most general duration time representations.'!Siren.SecondDuration class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SHARCSample	superclass: #{Siren.Function}	indexedType: #objects	private: false	instanceVariableNames: 'name pitch key nHarm ampl noPitch rePitch centroid '	classInstanceVariableNames: ''	imports: ''	category: 'MusicApps-SHARC'!Siren.SHARCSample class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PlayList	superclass: #{Siren.Track}	indexedType: #none	private: false	instanceVariableNames: 'tracks parent all '	classInstanceVariableNames: ''	imports: ''	category: 'Music-DBase'!Siren.PlayList comment:'A PlayList corresponds to an iTunes play listInstance Variables:	tracks	<ClassOfVariable>	description of variable''s function	parent	<ClassOfVariable>	description of variable''s function	all	<ClassOfVariable>	description of variable''s function'!Siren.PlayList class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #LPCFrame	superclass: #{Siren.MusicEvent}	indexedType: #none	private: false	instanceVariableNames: 'srate npoles rmsO rmsR err coefficients '	classInstanceVariableNames: ''	imports: ''	category: 'MusicApps-LPC'!Siren.LPCFrame comment:'An LPCFrame represents a single frame of an LPC file.Instance Variables:	srate	<Number>  the sound''s sample rate	npoles	<Number>  the number of poles	rmsO	<Number>  the original RMS	rmsR	<Number>  the residual RMS	err	<Number>  the error value	coefficients	 <Array of Number>  the raw reflection coefficients'!Siren.LPCFrame class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OSCPort	superclass: #{Siren.PortModel}	indexedType: #none	private: false	instanceVariableNames: 'socket address '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.OSCPort comment:'An OSCPort represents a connection to an OSC client.Instance Variables:	socket <SocketAccessor>  how am I connected?	address <IPSocketAddress>  where do I go?Shared Variables:	DefaultIP <ByteArray>  where''s my default server?	DefaultPort	 <Integer>  where''s my default server?'!Siren.OSCPort class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Swell	superclass: #{Siren.EventModifier}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventModifiers'!Siren.Swell comment:'A swell applies a fnuction to the amplitudes of events in an event list.'!Siren.Swell class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SHARCInstrument	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'name directory range samples '	classInstanceVariableNames: ''	imports: ''	category: 'MusicApps-SHARC'!Siren.SHARCInstrument class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayListSubcanvas	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'displayList componentPart displayListView scroller vZoom hZoom '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayListViews'!Siren.DisplayListSubcanvas comment:'A DisplayListSubcanvas is used to plug a display list view into an aplpication.Instance Variables:	displayList	<?type?>  comment	componentPart	<CompositePart>  my app. pane	displayListView <Siren.DisplayListView>  my view (does all the work)	scroller	<?type?>  my scroller (container)	vZoom	<Number>  vertical zoom factor	hZoom	<Number>  horiz. zoom factor'!Siren.DisplayListSubcanvas class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SymbolicLoudness	superclass: #{Siren.NominalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.SymbolicLoudness comment:'Instances of SymbolicLoudness are dynamic names in the range #ppp to #fff.The class instance variable NameMap is used for the name <--> MIDI velocity range (0 to 127) mapping dictionary.'!Siren.SymbolicLoudness class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OSCByteConvertor	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'packetData '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.OSCByteConvertor comment:'Instances of OSCByteConvertor translate between different OSC formats.Instance Variables:	packetData	<PositionableStream>  my contents'!Siren.OSCByteConvertor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundVoice	superclass: #{Siren.Voice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.SoundVoice comment:'SoundVoice is unfinished; it is intended for putting sound objects in scores.'!Siren.SoundVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #USecondDuration	superclass: #{Siren.SecondDuration}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.USecondDuration comment:'Instances of USecondDuration are duration times in micro-seconds.This is the default time representation (most general duration) and is usually used for keys in event lists.'!Siren.USecondDuration class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #CmixVoice	superclass: #{Siren.NotelistVoice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.CmixVoice comment:'A CmixVoice can write an event list to a MINC format file for use by cmix.'!Siren.CmixVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SelectionCloud	superclass: #{Siren.Cloud}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.SelectionCloud comment:'Selection clouds are created with a set of pitch and amplitude values and return eventLists selected from these values.'!Siren.SelectionCloud class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DynamicSelectionCloud	superclass: #{Siren.SelectionCloud}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.DynamicSelectionCloud comment:'Dynamic selection clouds are described by their beginning and ending pitch and amplitude sets and interpolate between them.'!Siren.DynamicSelectionCloud class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ChromaticScale	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.ChromaticScale class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #TimeSequenceLayoutManager	superclass: #{Siren.LayoutManager}	indexedType: #none	private: false	instanceVariableNames: 'timeScale timeOffset '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.TimeSequenceLayoutManager comment:'Instances of the SequenceLayoutManager classes are used to generate display lists with "x = time" from event lists.Instance Variables:	timeScale		<Integer> the msec./pixel scale	timeOffset		<Integer> the start of the layout in msec.'!Siren.TimeSequenceLayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchTimeLayoutManager	superclass: #{Siren.TimeSequenceLayoutManager}	indexedType: #none	private: false	instanceVariableNames: 'pitchScale pitchOffset '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.PitchTimeLayoutManager comment:'Instances of the PitchTimeLayoutManager classes are used to generate display lists with "x = time" and "y = pitch" from event lists.The default layout is linear pitch-to-y, like piano-roll or Hauer-Steffens notation.Instance Variables:	pitchScale		<Integer> the key#/pixel scale	pitchOffset		<Integer> the bottom of the layout as a key#'!Siren.PitchTimeLayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PositionTimeLayoutManager	superclass: #{Siren.PitchTimeLayoutManager}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.PositionTimeLayoutManager comment:'Instances of PositionTimeLayoutManager are used to generate display lists with "x = time" and "y = position" from event lists.'!Siren.PositionTimeLayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #LPCSound	superclass: #{Siren.MusicEvent}	indexedType: #none	private: false	instanceVariableNames: 'filename filesize srate frate npoles nframes frames pchMax pchMin pitchRange rmsRange residRange '	classInstanceVariableNames: ''	imports: ''	category: 'MusicApps-LPC'!Siren.LPCSound comment:'An LPCSound represents LPC data read in from a Csound LPC file.Instance Variables:	filename	<String>  my source file name	filesize	<Number>  the raw file size	srate	<Number>  the sound''s sample rate	frate	<Number>  the frame rate	npoles	<Number>  the # of poles	nframes	<Number>  the # of frames	frames	<OrderedCollection of LPCFrame>  the frame data	pchMax	<Number>  max est. pitch	pchMin	<Number>  min est. pitch	pitchRange	<Interval>  est. pitch range	rmsRange	<Number>  RMS amplitude range	residRange	<Number>  error residual range'!Siren.LPCSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Position	superclass: #{Siren.Positus}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Position comment:'Instances of the Position species model the position of sound sources in room simulations or scores.This class can be used as a concrete one (adding a few methods to fill it out), or like the other representational classes (making concrete classes of this species).In the later case, the value instance variable could hold a number or point.'!Siren.Position class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #RatioMagnitude	superclass: #{Siren.NumericalMagnitude}	indexedType: #none	private: false	instanceVariableNames: 'relative '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.RatioMagnitude comment:'Instances of the RatioMagnitude subclasses are fractional values relative to some context-defined reference value--their relative. The relative may be provided, or it may be assumed if uninitialized (e.g., for a default whole note''s duration or default reference pitch).Instance Variable:	relative		<MusicMagnitude> the reference value'!Siren.RatioMagnitude class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #RatioLoudness	superclass: #{Siren.RatioMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.RatioLoudness comment:'Instances of RatioLoudness are fractional amplitude values normally relative to the range 0 to 1.'!Siren.RatioLoudness class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DBLoudness	superclass: #{Siren.RatioLoudness}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.DBLoudness comment:'Instances of DBLoudness represent deciBel loudness values.'!Siren.DBLoudness class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundEditor	superclass: #{Siren.EditorModel}	indexedType: #none	private: false	instanceVariableNames: 'sound undoSound markers lastSelection changed '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Sound'!Siren.SoundEditor comment:'A SoundEditor is the editor model for sound views.Instance Variables:	copyBuffer <Sound> the selected sound after a copy cmomand	sound <Sound> the model sound	markers <OrderedCollection of: Integer> the sample indices of the selected points	selection1 <Integer> the sample index start of the current selection	selection2 <Integer> the stop of the selection	lastSelection <Integer> selection1 or 2, whichever was selected last	view <Siren.SoundView> my view	changed <Boolean> whether the sound has been changed'!Siren.SoundEditor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundController	superclass: #{UI.ControllerWithMenu}	indexedType: #none	private: false	instanceVariableNames: 'selection tracking '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Sound'!Siren.SoundController comment:'Instances of SoundController are used with SoundViews and perform horizontal scrolling and menu operations'!Siren.SoundController class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Chronos	superclass: #{Siren.MusicModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Chronos comment:'Class Chronos is the abstract representational class for the duration and meter species.Instances of its subclass species are used to model times, durations and metronomes.'!Siren.Chronos class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Duration	superclass: #{Siren.Chronos}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Duration comment:'Instances of classes whose species is Duration are used for the duration parameters of musical events.Durations come in several flavors, as in the classes RatioDuration, MSecondDuration and ConditionalDuration.The class Duration is abstract, its class creation method answers an instance of a concrete Duration class.Examples:	Duration value: 0.77		"create an instance with seconds as the unit"	Duration value: 770		"create an instance with milliseconds as the unit"	Duration value: 1/4		"create an instance with beats as the unit"	Duration value: [ :x | x > 4]	"create an instance for: ''until x > 4''"See also the class example.'!Siren.Duration class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventAssociation	superclass: #{Core.Association}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.EventAssociation comment:'An EventAssociation is an Association with some special semantics for Siren. It can be created with the ''=>'' message to a Number, meaning start-time assicoated with event.'!Siren.EventAssociation class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundCanvas	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'vZoom hZoom soundView scroller componentPart '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Sound'!Siren.SoundCanvas comment:'A SoundCanvas is used for plugging SoundViews into applicationsInstance Variables:	vZoom	<Integer>  the vertical zoom	hZoom	<Integer>  horizontal	soundView	<SoundView>  the sound view	scroller	<Scroller>  the scroller	componentPart	<ComponentPart>  my component'!Siren.SoundCanvas class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SirenUtility	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'list '	imports: ''	category: 'Music-Support'!Siren.SirenUtility comment:'The class SirenUtility represents the package-level state of the Siren Framework. Its class methods answer a variety of Siren system variables such as default file directories.Class Variables:	DataDir <String> the default sound/score directory.	ScoreDir <String> the score directory.	SoundDir <String> the sound directory.'!Siren.SirenUtility class	instanceVariableNames: 'list '!Smalltalk.Siren defineClass: #FunctionView	superclass: #{Siren.DisplayListView}	indexedType: #none	private: false	instanceVariableNames: 'models aScale vRange hRange colors normalize lineWidth '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Functions'!Siren.FunctionView comment:'Instances of class FunctionView are views on breakpoint or sampled data functions.They can display up to 4 model functions on a fixed-size non-scrolling field.Instance variables:	models	 <Array of 1 to 4 Functions> the function array	aScale <Number> the y-scale of the view	vRange <Number> the vertical range, normally = aScale	hRange <Number> the horizontal range	colors <Array of 1 to 4 ColorValues> the colors for the 4 functions	normalize <<Array of 1 to 4 Booleans> whether to normalize (to +- 1) the fnuctions'!Siren.FunctionView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SuperColliderVoice	superclass: #{Siren.NotelistVoice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.SuperColliderVoice comment:'A SuperColliderVoice can write an event list to a sc format file for use by SuperCollider.'!Siren.SuperColliderVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PortAudioInterface	superclass: #{Siren.SirenExternalInterface}	indexedType: #none	private: false	instanceVariableNames: 'cbProcess ioSemaphore '	classInstanceVariableNames: ''	imports: '			private Siren.PortAudioInterfaceDictionary.*			'	category: 'MusicIO-External'	attributes: #(			#(#includeFiles #('portaudio_lite.h'))			#(#includeDirectories #('Siren7.5/DLLCC'))			#(#libraryFiles #('portaudio_lite.dylib' 'libportaudio.dylib'))			#(#libraryDirectories #('/usr/local/lib'))			#(#beVirtual false)			#(#optimizationLevel #full))!Siren.PortAudioInterface class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #RatioDuration	superclass: #{Siren.RatioMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.RatioDuration comment:'Instances of RatioDuration are ''beat'' fractions.They can be expanded into msec. relative to some given event (a whole note), or use the default tempo of 1 sec.'!Siren.RatioDuration class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Meter	superclass: #{Siren.Chronos}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.Meter comment:'Instances of the Meter species model the tempo or metronome used to map durations.This class can be used as a concrete one (adding a few methods to fill it out), or like the other representational classes (making concrete classes of this species).In the later case, the value instance variable could hold a number, process or block.'!Siren.Meter class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #NeapolitanMinor	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.NeapolitanMinor comment:'<historical>'!Siren.NeapolitanMinor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ModeMember	superclass: #{Siren.Chroma}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Representation'!Siren.ModeMember comment:'Instances of the ModeMember species model pitches as elements of a mode (e.g., minor) or gamut (e.g., pentatonic on F).This class can be used as a concrete one (adding a few methods to fill it out), or like the other representational classes (making concrete classes of this species).In the later case, the value instance variable could hold a number or pitch, and the mode or gamut could be shared.'!Siren.ModeMember class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ExtDynamicSelectionCloud	superclass: #{Siren.DynamicSelectionCloud}	indexedType: #none	private: false	instanceVariableNames: 'list '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.ExtDynamicSelectionCloud class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SoundFile	superclass: #{Siren.AbstractEvent}	indexedType: #objects	private: false	instanceVariableNames: 'name mode fileFormat sampleFormat rate channels size index position sound '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Sound'!Siren.SoundFile comment:'Instances of SoundFile are used for reading and writing sound objects to/from files using the libSndFile API.They handle formatting, headers and I/O.Instance variables:	sound		<SampledSound> the sound''s samples	rate		<Number> the sound''s sampling rate	channels	<Number> the number of channels	fileName	<String> the file''s name	file		<ExternalStream> the file''s stream	position	<Number> the current position	headerSize	<Number> the size of the soundfile header	properties	<Dictionary> the property list dictionary of the receiver	format		<Symbol> the format--currently only #linear16Bit is handled	size		<Number> the size in samples'!Siren.SoundFile class	instanceVariableNames: ''!Smalltalk defineClass: #ZPoint	superclass: #{Core.Point}	indexedType: #none	private: false	instanceVariableNames: 'z '	classInstanceVariableNames: ''	imports: ''	category: 'Graphics-Geometry'!ZPoint comment:'ZPoints define a third instance variable (z) in addition to Point''s x and y to hold 3-dimensional point values.'!Smalltalk.ZPoint class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PortMidiInterface	superclass: #{Siren.SirenExternalInterface}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: '			private Siren.PortMidiInterfaceDictionary.*			'	category: 'MusicIO-External'	attributes: #(			#(#includeFiles #('portmidi_lite.h'))			#(#includeDirectories #('Siren7.5/DLLCC'))			#(#libraryFiles #('portmidi_lite.dylib' 'portmidi.dylib' 'CoreMIDI'))			#(#libraryDirectories #('/usr/local/lib' '/System/Library/Frameworks/CoreMIDI.framework/Versions/Current'))			#(#beVirtual false)			#(#optimizationLevel #full))!Siren.PortMidiInterface class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ScoreView	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.ScoreView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Roll	superclass: #{Siren.Cluster}	indexedType: #none	private: false	instanceVariableNames: 'number delta noteDuration '	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Roll comment:'Rolls repeat their single events.It will eventually be possible to apply pitch, amplitude or duration envelopes to them as well.Instance variables:	number <Integer> how many notes to play	delta <Number> delta time between events	noteDuration <Number> duration of events'!Siren.Roll class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ExponentialFunction	superclass: #{Siren.LinearFunction}	indexedType: #objects	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.ExponentialFunction comment:'Instances of ExponentialFunction are exponential-segment functions of one free variable.They use ZPoints for x/y/exponent. The exponent determines the speed of the exponential/logarithmic transition between breakpoint values. A value of 0 leads to linear interpolation.Example:	ExponentialFunction from: #((0 0 -5) (0.2 1 -3) (0.8 0.5 -2) (1 0))'!Siren.ExponentialFunction class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayString	superclass: #{Siren.DisplayItem}	indexedType: #none	private: false	instanceVariableNames: 'string font '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayLists'!Siren.DisplayString comment:'Instances of DisplayString are used for visual text items in display lists.Instance Variables:	string		<String or Text> the object''s string/text	font		<ImplementationFont> the object''s display font'!Siren.DisplayString class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventListText	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.EventListText class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #HungarianMinor	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.HungarianMinor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Trill	superclass: #{Siren.Roll}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.Trill comment:'A trill is like a roll, except that it can be given an eventList for repetition.'!Siren.Trill class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #FFTWInterface	superclass: #{Siren.SirenExternalInterface}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: '			private Siren.FFTWInterfaceDictionary.*			'	category: 'MusicIO-External'	attributes: #(			#(#includeFiles #('fftw_lite.h'))			#(#includeDirectories #('Siren7.5/DLLCC'))			#(#libraryFiles #('fftw_lite.dylib' 'libfftw3f.a'))			#(#libraryDirectories #('/usr/local/lib'))			#(#beVirtual false)			#(#optimizationLevel #full))!Siren.FFTWInterface class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #IndentedListLayoutManager	superclass: #{Siren.HierarchyLayoutManager}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.IndentedListLayoutManager comment:'Instances of IndentedListLayoutManager are used to generate display lists which mirror the hierarchy of their models (accessed using a TreeAccessor) in the indentation of a list-like outline.'!Siren.IndentedListLayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SEventQueue	superclass: #{Core.SequenceableCollection}	indexedType: #objects	private: false	instanceVariableNames: 'first last '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.SEventQueue comment:'An SEventQueue is a doubly-linked list that has methods for inserting elements in time-sorted order.These are used for real-time schedules because they can have faster search methods than using SortedCollections of OrderedCollections for the EventScheduler.The current implementation uses a simple linear search. For really big schedules, this could be made faster with a binary search or tree-based schedule.Instance Variables:	first <ScheduleRecord> The first event in the Q	last <ScheduleRecord> The last event in the Q'!Siren.SEventQueue class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #LPCEditor	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'sound showSmoothed2 showResid showRMS showSmoothed showRunning showPitch '	classInstanceVariableNames: ''	imports: ''	category: 'MusicApps-LPC'!Siren.LPCEditor comment:'LPCEditor is the app model for the simple LPC data editor.Instance Variables:	sound	<LPCSound>  the model	showSmoothed2	<Boolean>  whether to display the smoothed-twice pitch data	showResid	<Boolean>  whether to display the residual data	showRMS	<Boolean>  whether to display the RMS data	showSmoothed	<Boolean>  whether to display the smoothed pitch data	showRunning	<Boolean>  whether to display the running-average pitch data	showPitch	<Boolean>  whether to display the raw pitch data'!Siren.LPCEditor class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ListOfNotes	superclass: #{Core.OrderedCollection}	indexedType: #objects	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.ListOfNotes class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DiatonicInterval	superclass: #{Siren.MusicalInterval}	indexedType: #none	private: false	instanceVariableNames: 'ascending '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.DiatonicInterval class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PitchClassDoubleFlat	superclass: #{Siren.PitchClassAltered}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.PitchClassDoubleFlat class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Tag	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'name tracks parents children siblings '	classInstanceVariableNames: ''	imports: ''	category: 'Music-DBase'!Siren.Tag comment:'A Tag represents a metadata label used in a song data set. It has its name and references to the songs that use it.Instance Variables:	name		<Symbol>	my name	parent		<Tag>	my parent tag	children	<OrderedCollection of Tags>	child tags	tracks		<OrderedCollection of Tracks>	the songs that use this tag'!Siren.Tag class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayList	superclass: #{Graphics.DependentComposite}	indexedType: #none	private: false	instanceVariableNames: 'offset '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-DisplayLists'!Siren.DisplayList comment:'Instances of DisplayList are used for representing composed structured graphics. They can be nested (see the class examples) and can display themselves and their components.Instance Variables:	offset		<Point> the object''s offset distance relative to its container'!Siren.DisplayList class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #CsoundVoice	superclass: #{Siren.NotelistVoice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.CsoundVoice comment:'A CsoundVoice can write an event list to a sco format file for use by Csound.'!Siren.CsoundVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #PseudoMinorScale	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.PseudoMinorScale class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DynamicCloud	superclass: #{Siren.Cloud}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-EventGenerators'!Siren.DynamicCloud comment:'Dynamic clouds are clouds that have starting and ending conditions (ranges or selection sets) and interpolate between them over their duration.'!Siren.DynamicCloud class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MelodicMinorScale	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.MelodicMinorScale class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #IndentedTreeLayoutManager	superclass: #{Siren.IndentedListLayoutManager}	indexedType: #none	private: false	instanceVariableNames: 'list '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Layout'!Siren.IndentedTreeLayoutManager comment:'Instances of IndentedTreeLayoutManager are used to generate display lists which mirror the hierarchy of their models (accessed using a TreeAccessor) in the indentation of a list-like tree.'!Siren.IndentedTreeLayoutManager class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MusicalDescendingInterval	superclass: #{Siren.MusicalInterval}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.MusicalDescendingInterval comment:'La theorie des intervalles "descendants" n''est pas tres claire:Que voudrait dire DescendingInterval topIfBottomIs: N C ?(quelle difference avec ascending ?).Introduit juste pour les besoins de la cause, mais un peu incoherent.Herite tout de MusicalInterval, et donc se comporte presque pareil.Utilisee uniquement en creation dans la methode intervalBetween: de OctaveDependentNote.Il faudrait d''ailleurs modifier aussi la methode similaire de PitchClass'!Siren.MusicalDescendingInterval class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIVoice	superclass: #{Siren.Voice}	indexedType: #none	private: false	instanceVariableNames: 'currentTime '	classInstanceVariableNames: 'useSingleton singleton default '	imports: ''	category: 'MusicIO-MIDI'!Siren.MIDIVoice comment:'A MidiVoice is used to play note events onto one or more output devices.I store a MidiDevice (with a MIDIPort) in my instrument variable and play events onto it when asked to.Instance variables:	instrument	<MIDIDevice> my instrument, a MidiDevice'!Siren.MIDIVoice class	instanceVariableNames: 'useSingleton singleton default '!Smalltalk.Siren defineClass: #MIDIPF70	superclass: #{Siren.MIDIDevice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-MIDI'!Siren.MIDIPF70 comment:'MidiPF70 is a type of MidiDevice for the system exclusive commands of the Yamaha PF-70 electric piano.It implements the special commands available here (like note commands with fractional pitch and given duration).The standard PF70 note command is like:		2n k f v d1 d2 = cmd:channel, noteNum, frac, vel, durLow, durHigh'!Siren.MIDIPF70 class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #EventListFileViewer	superclass: #{Siren.SoundFileViewer}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Editors'!Siren.EventListFileViewer class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DisplayVisual	superclass: #{Siren.DisplayItem}	indexedType: #none	private: false	instanceVariableNames: 'visual '	classInstanceVariableNames: ''	imports: '			MusicConstants			'	category: 'MusicUI-DisplayLists'!Siren.DisplayVisual comment:'Instances of DisplayVisual are used for displaying arbitrary visual objects (e.g., cached images) in display lists.Instance Variables:	visual		<VisualComponent> the object''s visual object, typically an image'!Siren.DisplayVisual class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #GapSound	superclass: #{Siren.VirtualSound}	indexedType: #objects	private: false	instanceVariableNames: 'cutList '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Sound'!Siren.GapSound comment:'An instance of GapSound can be used to represent a sound with samples deleted from it (i.e., a gap).It uses its cut list instance variable to maintain sample ranges that have been deleted from the sound that comprises it (the source).It responds to sampleAt: and sampleAt:put: just like other sounds, but stores only its cut list on files unless explicitly told to store samples.Instance Variables:	cutList		<SortedCollection of Integers> the list of deleted sections by sample index i.e., pointers denoting sections that have been deleted. For example, having a cutList of (1000 2000) means that samples (1000, 2000] have been virtually cut.'!Siren.GapSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #RatioPitch	superclass: #{Siren.RatioMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.RatioPitch comment:'Instances of RatioPitch are fractional pitch values normally relative to c=261.623Hz.They can be transformed into other values (e.g., note names or key numbers), but often at a loss of accuracy if they are not well-tempered.'!Siren.RatioPitch class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #DataSetTool	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'tree '	classInstanceVariableNames: ''	imports: ''	category: 'Music-DBase'!Siren.DataSetTool comment:'DataSetTool is the GUI for looking into DataSetsInstance Variables:	tree	<DataSet>	the root'!Siren.DataSetTool class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #TagSetTool	superclass: #{Siren.DataSetTool}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-DBase'!Siren.TagSetTool class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #OSCBundle	superclass: #{Siren.AbstractOSCPacket}	indexedType: #none	private: false	instanceVariableNames: 'messages time '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.OSCBundle comment:'OSCBundle represents a bundle of OSC messagesInstance Variables:	messages	<OrderedCollection of OSCMessage>  my contents	time	<Integer>  my action timeShared Variables:	MillisecScale	<Integer>  msec/year (?)	MillisecToNTP	<Fraction>  msec scale for NTP	SecsInAYear	<Integer>  sec/year'!Siren.OSCBundle class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SirenSession	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'scheduleList scheduleListText verbosity clock startedAt inChannels blockSize sampleRate outChannels interfaceParams transport eventList sound voice timer soundPort midiPort loadedSounds loadedLists oscAddress defaultVoiceClass '	classInstanceVariableNames: 'useSingleton singleton '	imports: ''	category: 'Music-Support'!Siren.SirenSession comment:'The class SirenSession represents the user session state of the Siren Framework. The class is also the implementor of the Siren configuration panel, see the interface window spec, and the instance methods.Instance Variables (used by the pop-up utility window)	sampleRate - the sample rate	inChannels outChannels - # of snd I/O channels	oscIP oscPort - OSC IP & port	defaultVoiceClass - voice class to use	blockSize - snd IO block size	interfaceParams - snd IO properties	transport - value used by GUI	eventList - value used by GUI	sound - value used by GUI	voice - value used by GUI	timer - value used by GUI	scheduleList - value used by GUI	soundPort - value used by GUI	midiPort - value used by GUIClass Variables:	EventLists <Dictionary> Event lists	Sounds <Dictionary> Sounds	Voices <Dictionary> Voices'!Siren.SirenSession class	instanceVariableNames: 'useSingleton singleton '!Smalltalk.Siren defineClass: #PortMIDIPort	superclass: #{Siren.MIDIPort}	indexedType: #none	private: false	instanceVariableNames: 'driver '	classInstanceVariableNames: ''	imports: '			private MIDICommands.*			private MIDIioctls.*			private GeneralMIDIMap.*			private GeneralMIDIDrums.*			'	category: 'MusicIO-MIDI'!Siren.PortMIDIPort comment:'An instance of PortMIDIPort is the interface to the external driver that talks to the PortMIDI interface.Instance Variables:	driver	<PortMidiInterface>  my I/O interface driverShared Variables:	Devices	<Dictionary>  unised	Streams	<IdentityDictionary key: Integer value: Integer>  the map between Siren devices and interface ports'!Siren.PortMIDIPort class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #FunctionController	superclass: #{Siren.DisplayListController}	indexedType: #none	private: false	instanceVariableNames: 'modelIndex '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Functions'!Siren.FunctionController comment:'Missing comment'!Siren.FunctionController class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #TypedOSCMessage	superclass: #{Siren.OSCMessage}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-OSC'!Siren.TypedOSCMessage comment:'A TypedOSCMessage represents the new form of (typed) OSC messages'!Siren.TypedOSCMessage class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ScheduleRecord	superclass: #{Core.Association}	indexedType: #none	private: false	instanceVariableNames: 'next previous loop '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.ScheduleRecord comment:'A ScheduleRecord is used as an entry in the SEventQueue. It''s a doubly-linked record with a key (the start time) and value (the scheduled event).Instance Variables	next <ScheduleRecord | nil> the next record in the Q (nil for the last)	previous <ScheduleRecord | nil> the previous record in the Q (nil for the first)	key <Integer> (inherited from LookupKey) the record''s start time in msec	value <Event> (inherited from Association) the record''s event.'!Siren.ScheduleRecord class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Analysis	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'scale degree '	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchClasses'!Siren.Analysis class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #ComponentSound	superclass: #{Siren.Sound}	indexedType: #objects	private: false	instanceVariableNames: 'start stop sound '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Sound'!Siren.ComponentSound comment:'A ComponentSound is used as a component (a "splice" element, if you will).It represents another sound that "composes" the composite.Instance Variables:	sound <StoredSound> the "subject" sound 	start <Integer> the starting sample in the composite	stop <Integer> the ending sample in the composite	offset <Number> the offset into the selection'!Siren.ComponentSound class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #CmusicVoice	superclass: #{Siren.NotelistVoice}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Voices'!Siren.CmusicVoice comment:'A CmusicVoice can write an event list to a sc format file for use by Cmusic.'!Siren.CmusicVoice class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIVelocity	superclass: #{Siren.IntervalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.MIDIVelocity comment:'Instances of MIDIVelocity are key velocities (approximately proportional to loudness) in the range 0 to 127.The SymbolicLoudness class maps symbolic dynamic names onto this range on an approximately logarithmic scale.'!Siren.MIDIVelocity class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Timer	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'startTime accumulator lastUpdate interval running name '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Support'!Siren.Timer class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #LPCView	superclass: #{Siren.DisplayListView}	indexedType: #none	private: false	instanceVariableNames: 'winSize editor '	classInstanceVariableNames: ''	imports: ''	category: 'MusicApps-LPC'!Siren.LPCView comment:'An LPCView displays the pitch estimates of LPC sound analysis files.Instance Variables:	winSize <Point>  the window extent	editor <Siren.LPCEditor>  my editor (host)'!Siren.LPCView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #FunctionGraph	superclass: #{Siren.Function}	indexedType: #objects	private: false	instanceVariableNames: 'operandL operandR operation '	classInstanceVariableNames: ''	imports: ''	category: 'Music-Functions'!Siren.FunctionGraph class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SmartAudioPort	superclass: #{Siren.PortAudioPort}	indexedType: #none	private: false	instanceVariableNames: 'inChannels callbackBlock useProcess ioProcess ioSemaphore inClient outClients inBuffer outBuffer counter '	classInstanceVariableNames: ''	imports: ''	category: 'MusicIO-Sound'!Siren.SmartAudioPort comment:'SmartPortAudioPort is a more advanced IO port for PortAudio; it uses a Smalltalk process that sleeps on a semaphore that is signalled by the PortAudio callback. this allows one to synthesize sound interactively or to record into Siren sounds. The methods nextInBuffer and nextInBuffer are used to copy buffers or call synthesis clients.Instance Variables:	inChannels	 <Integer>  # of input channels	ioSemaphore <Semaphore>  semaphore sent from the low-level driver	inClient	 <Sound -> sample index>  the sound being recorded into	outClients <OrderedCollection of (aSound -> Integer)>  my playing sounds and their sample indices	ioProcess <Process>  my IO thread	inBuffer <WordArray>  sample buffer handed to PortAudio	outBuffer <WordArray>  sample buffer handed to PortAudio'!Siren.SmartAudioPort class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Length	superclass: #{Siren.OrdinalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.Length comment:'Instances of Length represent subjective length (~ duration * loudness) values.The instance variable tables are used for the name -> relation symbol map.See the class examples.'!Siren.Length class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SpeciesTrainingTool	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-DBase'!Siren.SpeciesTrainingTool class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #Oriental	superclass: #{Siren.Scale}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-PitchScales'!Siren.Oriental class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #SpectrumView	superclass: #{Siren.SoundView}	indexedType: #none	private: false	instanceVariableNames: 'isColor '	classInstanceVariableNames: ''	imports: ''	category: 'MusicUI-Sound'!Siren.SpectrumView class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MIDIPitch	superclass: #{Siren.IntervalMagnitude}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.MIDIPitch comment:'Instances of MIDIPitch are well-tempered piano key numbers where 60 is middle-c (c3) according to the MIDI standard.The translation key <--> Hz. is done with the logarithm or 27.5 Hz. (very low A = 440/16).Note that AdC''s additions make fractional MIDI pitches possible, whereby the first 2 digits to the right of the decimal point signify pitch cents. There are coercion methods such as asFracMIDI for handling microtonal MIDI pitches.'!Siren.MIDIPitch class	instanceVariableNames: ''!Smalltalk.Siren defineClass: #MSecondDuration	superclass: #{Siren.SecondDuration}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Music-Models-Implementation'!Siren.MSecondDuration comment:'Instances of MSecondDuration are duration times in milli-seconds.'!Siren.MSecondDuration class	instanceVariableNames: ''!Siren.SirenSession defineSharedVariable: #EventLists	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenSession defineSharedVariable: #Voices	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenSession defineSharedVariable: #Sounds	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.OSCBundle defineSharedVariable: #MillisecScale	private: false	constant: false	category: 'Time constants'	initializer: '4295000'!Siren.OSCBundle defineSharedVariable: #MillisecToNTP	private: false	constant: false	category: 'Time constants'	initializer: '((2 raisedTo: 32) / 1000)'!Siren.OSCBundle defineSharedVariable: #SecsInAYear	private: false	constant: false	category: 'Time constants'	initializer: '(60 * 60 * 24 * 365)'!Siren.SEventQueue defineSharedVariable: #CurrentRecord	private: false	constant: false	category: 'record pool'	initializer: '1'!Siren.SEventQueue defineSharedVariable: #RecordPool	private: false	constant: false	category: 'record pool'	initializer: 'Array new: 32'!Siren.PitchClass defineSharedVariable: #AllNotes	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #B	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #C	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #D	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #A	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #E	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #AllNatural	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #English	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #F	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PitchClass defineSharedVariable: #G	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SampledSound defineSharedVariable: #MinIntSample	private: false	constant: false	category: 'class constants'	initializer: nil!Siren.SampledSound defineSharedVariable: #MaxIntSample	private: false	constant: false	category: 'class constants'	initializer: nil!Siren.SampledSound defineSharedVariable: #MagicNumbers	private: false	constant: false	category: 'class constants'	initializer: nil!Siren.MIDIDevice defineSharedVariable: #MStream	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.PortAudioInterface defineSharedVariable: #PA_Constants	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.MIDIPort defineSharedVariable: #Streams	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.DisplayListView defineSharedVariable: #MusicConstants	private: false	constant: false	category: 'class var accessing'	initializer: 'IdentityDictionary new'!Siren.LibSndFileInterface defineSharedVariable: #SF_Constants	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #DefaultOSCPort	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #DefaultMIDIIn	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #Verbosity	private: false	constant: false	category: 'As yet unclassified'	initializer: '0'!Siren.SirenUtility defineSharedVariable: #LoggingStream	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #DefaultMIDIOut	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #ScoreDir	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #DefaultOSCHost	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #DataDir	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SirenUtility defineSharedVariable: #SoundDir	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #FFTWInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #MIDICommands	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #GeneralMIDIMap	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #GeneralMIDIDrums	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #LibSndFileInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #ExampleVariablesNIExternalInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #ExampleClassNIExternalInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #GeneralMIDIFamilies	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #PortAudioInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #Streams	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #ExampleConstantsNIExternalInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #PortMidiInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Smalltalk.Siren defineSharedVariable: #SirenExternalInterfaceDictionary	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SoundFile defineSharedVariable: #FileFormats	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SoundFile defineSharedVariable: #SampleFormats	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SoundFile defineSharedVariable: #Interface	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.SHARCInstrument defineSharedVariable: #SHARCOrchestra	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.EventScheduler defineSharedVariable: #Schedule	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.FunctionView defineSharedVariable: #LineWidth	private: false	constant: false	category: 'constants'	initializer: '1'!Siren.Scale defineSharedVariable: #AllNotes	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!Siren.Voice defineSharedVariable: #DefaultVoiceClass	private: false	constant: false	category: 'As yet unclassified'	initializer: nil!!Siren.DisplayListView methodsFor: 'private'!scrollableExtent	"Answer the extent of the receiver's display object bounding box."	^zoom == nil		ifTrue: [super scrollableExtent]		ifFalse: [super scrollableExtent * zoom]!setModel: aModel	super setModel: aModel.	container ifNotNil: [self invalidate]!visibleExtent	"Answer the extent of the receiver's clipping box."	^zoom == nil		ifTrue: [super visibleExtent]		ifFalse: [super visibleExtent * zoom]! !!Siren.DisplayListView methodsFor: 'controller access'!defaultControllerClass	^DisplayListController!transformPoint: aPoint	"zoom, scroll, and page the given point, used for hit-detection."	^zoom == nil		ifTrue: [aPoint "- scrollOffset value - (16@16)"]		ifFalse: [aPoint "- scrollOffset value" / zoom]! !!Siren.DisplayListView methodsFor: 'accessing'!background: anObject	"Set the receiver's 'background' to be anObject."	background := anObject!backgroundColor	"Answer the receiver's backgroundColor or the default."	^backgroundColor == nil		ifTrue: [self class backgroundColor]		ifFalse: [backgroundColor]!bounds: aRectangle	"Set the receiver's bounds (and page offset)."	super bounds: aRectangle.	page := 0@0.	extent := aRectangle extent!cache: aBoolean	"Set the receiver's 'cache' to be aBoolean."self halt.	cache := aBoolean!displayList	"Answer the receiver's display list."	^displayList!displayList: anObject	"Set the receiver's 'displayList' to be anObject."	displayList := anObject.	cache ifTrue: [self initializeCache]		ifFalse: [pixmap := nil]!foregroundColor	"Answer the receiver's foregroundColor or the default."	^foregroundColor == nil		ifTrue: [self class foregroundColor]		ifFalse: [foregroundColor]!inset: aPoint	"Set the receiver's inset to aPoint (pixels)."	inset := aPoint!list	"Answer the receiver's display list."	^displayList!pageOffset	"Answer the receiver's 'pageOffset'."	^page!pageOffset: anObject	"Set the receiver's 'pageOffset' to be anObject."	page := anObject!pixmap: aPMorNil	"Set (or destroy) the receiver's cached pixmap."	pixmap := aPMorNil!preferredBounds	"Answer the displayList's bounds."	| rect |	displayList == nil		ifTrue: [^super preferredBounds].	rect := displayList computePreferredBounds.	^zoom == nil		ifTrue: [(rect origin) extent: (rect extent + (inset * 2))]		ifFalse: [((rect origin) extent: (rect extent + (inset * 2))) scaledBy: zoom]!zoom: aPoint	"Set the receiver's 'zoom' to be aPoint."	zoom := aPoint.	(zoom == (1@1))		ifTrue: [zoom := nil].	self invalidate! !!Siren.DisplayListView methodsFor: 'displaying'!displayOn: aGraphicsContext	"Display the receiver on the given GC, translating it as appropriate."	cache ifFalse: [aGraphicsContext paint: backgroundColor.				aGraphicsContext displayRectangle: aGraphicsContext clippingBounds].	aGraphicsContext translateBy: inset.	pixmap == nil		ifTrue: [zoom == nil			ifTrue: [self displayList displayOn: aGraphicsContext]			ifFalse: [(displayList scaledBy: zoom) displayOn: aGraphicsContext]]		ifFalse: [redrawn == nil ifTrue: [self displayOnImage].				pixmap displayOn: aGraphicsContext].	((model notNil) and: [model selection notNil])		ifTrue: [self displaySelectionOn: aGraphicsContext].	aGraphicsContext translateBy: inset negated!displaySelectionOn: aGC	"Display the model's selection using some form of highlighting."	| sel bound bRect wRect |	sel := model selection.	sel == nil ifTrue: [^self].	bRect := (-3@ -3) extent: (6@6).	wRect := (-2@ -2) extent: (4@4).	bound := sel bounds.	#(topLeft topRight bottomRight bottomLeft) do:		[ :cor | | pt |		pt := bound perform: cor.		aGC paint: ColorValue black.		aGC displayRectangle: bRect at: pt.		aGC paint: ColorValue white.		aGC displayRectangle: wRect at: pt]!invalidate	redrawn := nil.	super invalidate! !!Siren.DisplayListView methodsFor: 'initialize-release'!component	"Answer a DLView for use as a component."	"IndentedListLayoutManager listExample display"	| part wrapper |	part := CompositePart new.	wrapper := LookPreferences edgeDecorator on: self.	wrapper useHorizontalScrollBar; noMenuBar.	part add: wrapper in: (0@0 extent: 1.0@1.0).	^part!initialize	"Initialize the receiver's instance variables--the default is not to cache."	super initialize."	page := 0@0. -- unused"	zoom := 1@1.	backgroundColor := self class backgroundColor.	redrawn := false.	inset := self class inset.	extent := 1@1."	InputState default shiftDown		ifFalse: [cache := true]		ifTrue: [cache := false]"	cache := false!initializeCache	"Initialize the receiver's instance variables for cacheing the pixmap during display."	| ext |	cache := true.	ext := displayList extent truncated.	ext x: (ext x min: 2048).	ext y: (ext y min: 2048).	pixmap := Pixmap extent: ext	 "self class defaultCacheExtent".	pixmap background: self backgroundColor.	page := 0@0!initializeWithGrid: gPoint color: gColor	"Initialize the receiver's instance variables--the default is to cache."	| cacheE bGC |	self initialize.	self initializeCache.	cacheE := self class defaultCacheExtent.	background := Pixmap extent: cacheE.	bGC := background graphicsContext.	bGC paint: DisplayListView backgroundColor.	bGC displayRectangle: background bounds.	bGC paint: gColor.	0 to: cacheE x by: gPoint x do:		[ :x |		bGC displayLineFrom: (x@0) to: (x @ cacheE y)].	0 to: cacheE y by: gPoint y do:		[ :y |		bGC displayLineFrom: (0@y) to: (cacheE x @ y)].!release	"Remove the receiver as a dependent of its model."	model release.	model removeDependent: self.	model := nil.	super release! !!Siren.DisplayListView class methodsFor: 'examples'!classListExample	"DisplayListView classListExample"	IndentedListLayoutManager listExample display!classTreeExample	"DisplayListView classTreeExample"	(IndentedTreeLayoutManager listExample) display!colorClassListExample	"DisplayListView colorClassListExample"	IndentedListLayoutManager colorListExample!exampleHierarchical	"DisplayListView exampleHierarchical"	DisplayList exampleHierarchical display! !!Siren.DisplayListView class methodsFor: 'constant access'!backgroundColor	"Answer the default background color for display list views."	"ColorValue constantNames #(#black #blue #brown #chartreuse #cyan #darkCyan #darkGray #darkGreen #darkMagenta #darkRed #olive #gray #green #lightYellow #lightGray #magenta #navy #orange #orchid #paleGreen #pink #purple #red #royalBlue #salmon #lightCyan #springGreen #veryDarkGray #veryLightGray #white #yellow )""	^LookPreferences defaultForWindows backgroundColor"	^ColorValue lightYellow blendWith: ColorValue white!constants	^MusicConstants!constants: aDictionary	MusicConstants := aDictionary!defaultCacheExtent	"Answer the default extent of the receiver's instances' cache."	^600@600!foregroundColor	"Answer the default foreground color for display list views."	^LookPreferences defaultForWindows foregroundColor!inset	"Answer the default display inset."	^8@8! !!Siren.DisplayListView class methodsFor: 'class initialization'!initialize	"Init the class"	"DisplayListView initialize"	MusicConstants := IdentityDictionary new! !!Siren.DisplayListView class methodsFor: 'instance creation'!componentOnList: dlist	"Answer a DLView for use as a component."	"IndentedListLayoutManager listExample display"	| container me wrapper dled |	container := CompositePart new.	dled := DisplayListEditor on: dlist.	me := self on: dled.	wrapper := LookPreferences edgeDecorator on: me.	wrapper useHorizontalScrollBar; noMenuBar.	container add: wrapper in: (0@0 extent: 1.0@1.0).	^container!componentOnList: dlist withGrid: gPoint inColor: gColor	"Answer a DLView for use as a component."	| container me wrapper dled |	container := CompositePart new.	dled := DisplayListEditor on: dlist.	gPoint == nil		ifFalse: [me := self new initialize: dlist withGrid: gPoint color: gColor]		ifTrue: [me := self new initialize].	me displayList: dled list.	me model: dled.	wrapper := LookPreferences edgeDecorator on: me.	wrapper useHorizontalScrollBar; noMenuBar.	container add: wrapper			borderedIn: (0@0.1 extent: 1.0@0.9).	^container!on: anEditor	| me |	me := self new.	me displayList: anEditor list.	me model: anEditor.	anEditor view: me.	^me!open4SquareOn: aDisplayList	"Open the receiver on the given display list."	"DisplayListView open4SquareOn: (DisplayList rectanglesX: 2000 byY: 2000)"	| dls |	dls := DisplayListSubcanvas new.	dls setDisplayList: aDisplayList.	dls setComponent: (self componentOnList: aDisplayList).	DisplayListSubcanvas openOn: dls withSpec: #windowSpec4Square!openOn: aDisplayList	"Open the receiver on the given display list."	"DisplayListView openOn: (DisplayList rectanglesX: 2000 byY: 2000)"	| dls |	dls := DisplayListSubcanvas new.	dls setDisplayList: aDisplayList.	dls setComponent: (self componentOnList: aDisplayList).	DisplayListSubcanvas openOn: dls! !!Siren.TimeSequenceView methodsFor: 'transforming'!formXFromTime: aTime	"take a note's time and return a display point x coordinate relative to the form."	^((aTime - (page x) / xScale) asInteger)!timeFromX: aNumber	"Answer an event list time from the argument."	^(aNumber x - inset x - self bounds width * xScale + page x) max: 0! !!Siren.TimeSequenceView methodsFor: 'accessing'!cachedPixmap	"Answer the receiver's cached pixmap."	^pixmap!clefColor	"Answer the receiver's 'clefColor'."	^clefColor!clefColor: anObject	"Set the receiver's 'clefColor' to be anObject."	clefColor := anObject!clefForm	"Answer the receiver's clef form."	^clefForm!clefWidth	"Answer the receiver's clef form width."	^clefForm width!headColor	"Answer the receiver's 'headColor'."	^headColor!headColor: anObject	"Set the receiver's 'headColor' to be anObject."	headColor := anObject!xColor	"Answer the receiver's 'xColor'."	^xColor!xColor: anObject	"Set the receiver's 'xColor' to be anObject."	xColor := anObject!xScale	"Answer the receiver's 'xScale'."	^xScale!xScale: anObject	"Set the receiver's 'xScale' to be anObject."	xScale := anObject!yColor	"Answer the receiver's 'yColor'."	^yColor!yColor: anObject	"Set the receiver's 'yColor' to be anObject."	yColor := anObject! !!Siren.TimeSequenceView methodsFor: 'controller access'!defaultControllerClass	"Answer the class of the default controller for the receiver."	^TimeSequenceController! !!Siren.TimeSequenceView methodsFor: 'layout manager access'!generateItemFor: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	| dItem vox arr |	arr := MusicConstants at: #NoteIcons.	vox := anAss value voice.	vox == nil 		ifTrue: [vox := 1] 		ifFalse: [vox isInteger			ifTrue: [vox := (vox max: 1) min: arr size]			ifFalse: [vox := vox first asInteger \\ arr size]].	"hack -- take the first letter as the key for note heads"	dItem := (arr at: (vox )) copy.	dItem color: (headColor == nil				ifTrue: [ColorValue white]				ifFalse: [headColor]).	dItem model: anAss.	^dItem!itemFor: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	itemAccessors == nil		ifTrue: [^self generateItemFor: anAss].	itemAccessors isSymbol		ifTrue: [^self perform: itemAccessors with: anAss].	(itemAccessors isMemberOf: BlockClosure)		ifTrue: [^itemAccessors value: anAss].	(itemAccessors isMemberOf: Dictionary)		ifTrue: [^self perform: (itemAccessors at: anAss value voice ifAbsent: [0]) 						with: anAss].!layoutManager	"Answer a default layout manager for the receiver."	^(TimeSequenceLayoutManager new)			timeScale: xScale;			timeOffset: 0! !!Siren.TimeSequenceView methodsFor: 'displaying'!displayOn: aGC	"Display the receiver on the argument."	aGC paint: self backgroundColor.	aGC displayRectangle: aGC clippingBounds.	pixmap == nil		ifFalse: [(redrawn == true)			ifFalse: [ | pGC |				redrawn := true.				pGC := pixmap graphicsContext.				self reallyDisplayOn: pGC].			pixmap displayOn: aGC]		ifTrue: [self reallyDisplayOn: aGC]!displayOnImage	"Display the receiver on its cached form."	| pGC |	redrawn := true.	pGC := pixmap graphicsContext.	pGC paint: self backgroundColor.	pGC displayRectangle: pixmap bounds.	pGC paint: self foregroundColor.	pGC clippingRectangle: pixmap bounds.	pGC translateBy: inset."	clefForm == nil 		ifFalse: [clefForm displayOn: pGC.				pGC translateBy: clefForm width@0]."	background == nil ifFalse: [background displayOn: pGC].	displayList displayOn: pGC.	model selection == nil		ifFalse: 			[controller sensor shiftDown ifTrue: [self halt].			pGC displayRectangularBorder: controller selection bounds].	pGC translateBy: inset negated!highlightFrom: pt1 to: pt2	"Show selection of the range pt1--pt2."	| gc |	gc := self graphicsContext.	gc paint: DisplayList foregroundColor.	gc displayRectangularBorder: (pt1 corner: pt2)!highlightTime: value	"Show selection of the time value value.""	| x |	x := (value / xScale - page x - cachedForm offset x 				+ insetDisplayBox left + self class inset x) min: (insetDisplayBox right).	(x > (insetDisplayBox right - 64))		ifTrue: [self scroll: ((insetDisplayBox width - 128) negated@0).			x := x - (insetDisplayBox width - 128)].	Display fill: ((x @ insetDisplayBox top)			extent: (2 @insetDisplayBox height))		rule: Form reverse		mask: Form black."!reallyDisplayOn: gc	"Display the receiver on its cached form."	gc paint: self backgroundColor.	gc displayRectangle: gc clippingBounds.	gc paint: self foregroundColor.	gc translateBy: inset.	clefForm == nil 		ifFalse: [clefForm displayOn: gc.				gc translateBy: clefForm width@0].	background == nil ifFalse: [background displayOn: gc].	displayList displayOn: gc.	model selection == nil		ifFalse: 			[controller sensor shiftDown ifTrue: [self halt].			gc displayRectangularBorder: controller selection bounds].	gc translateBy: inset negated!zoom: aPoint	"Set the receiver's 'zoom' to be aPoint."	xScale := xScaleDefault * aPoint x.	Cursor wait showWhile:		[self displayList: (self layoutManager displayListFor: self).		super zoom: aPoint]! !!Siren.TimeSequenceView methodsFor: 'initialize-release'!initialize	"Initialize the instance variables of the receiver."	super initialize.	xScaleDefault := 15.	xScale := 15.	page := 0@0! !!Siren.TimeSequenceView methodsFor: 'updating'!update: ignored	"Redraw the display"	self displayList: (self layoutManager displayListFor: self).	self topComponent raise.	self invalidate"	self displayOn: self graphicsContext"! !!Siren.TimeSequenceView class methodsFor: 'examples'!randomExample	"Open a sequence view on a random event list."	"TimeSequenceView randomExample"	TimeSequenceView openOnEventList: EventList randomExample! !!Siren.TimeSequenceView class methodsFor: 'constant access'!defaultCacheExtent	"Answer the default extent of the receiver's instances' cache."	^600@200!inset	"Answer the default display inset."	^16@16! !!Siren.TimeSequenceView class methodsFor: 'instance creation'!openOnEventList: anEventList	"Open the receiver on the given event list."	"TimeSequenceView openOnEventList: EventList randomExample"	| me dls |	me := self new initialize model: (EventListEditor new eventList: anEventList).	me displayList: (me layoutManager displayListFor: me).	me initializeCache.	dls := DisplayListSubcanvas new.	dls setDisplayList: me displayList.	dls setComponent: me component.	DisplayListSubcanvas openOn: dls! !!Siren.PitchClassChord methodsFor: 'automatic access'!root   ^root!root: aValue  	 root := aValue.	self resetNotes!rootPitchClass	^root pitchClass!structure   ^structure!structure: aValue	structure := aValue.	self resetNotes! !!Siren.PitchClassChord methodsFor: 'mutations'!@ o 	o isInteger ifFalse: [^super @ o].	^self octave: o!asPlayableObject	^(self octave: self defaultOctave) asPlayableObject!defaultOctave	^2!fondamental	| t n |	t := self root octave: 3.	n := self notes collect: [:nn | nn octave: 4].	n addFirst: t.	^(OctaveDependentChord root: t notes: n)!inTessitura: qt	^ OctaveDependentChord root: (root inTessitura: qt)!lapse: l	^(self octave: self defaultOctave) lapse: l!octave: n 	^(OctaveDependentChord new) structure: structure copy; root: (root octave: n)!startBeat: s duration: d	"a default octave is used"	^(self octave: self defaultOctave) startBeat: s duration: d!startTime: s duration: d	^(self octave: self defaultOctave) startBeat: s duration: d! !!Siren.PitchClassChord methodsFor: 'printing'!name	"produces a printable name (without the sharps before symbols)"	| s |	s := WriteStream on: ''.	root printOn: s.	s nextPutAll: ' '.	structure		do: 			[:x | 			(x isKindOf: Integer)				ifTrue: [s nextPutAll: x printString]				ifFalse: [s nextPutAll: x].			s nextPutAll: ' '].	^s contents!notesString	| s |	s := ''.	self notes do: [:n | s := s , n printString , ' '].	^s!printOn: s  	s nextPutAll: '['.	(root isKindOf: PitchClass)		ifTrue: [root printOn: s]		ifFalse: [root pitchClass printOn: s].	s nextPutAll: ' '.	structure  do: 	[:x | 		(x isKindOf: SmallInteger)			ifTrue: [x  printOn: s]			ifFalse: [s nextPutAll: x asString].		s nextPutAll: ' '].	s nextPutAll: ']'.!quotedPrintOn: s	"as printOn but without the brackets [] and with quotes"	s nextPut: $'.	(root isKindOf: PitchClass) 		ifTrue: [root printOn: s]		ifFalse: [root pitchClass printOn: s].	s nextPutAll: ' '.	structure  do: 	[:x | 		(x isKindOf: SmallInteger)			ifTrue: [x  printOn: s]			ifFalse: [s nextPutAll: x asString].		s nextPutAll: ' '].	s nextPut: $'.!storeOn: s	"returns a String representation of the receiver from which the receiver	can be reconstructed"	s nextPut: $(.	self quotedPrintOn: s.	s nextPutAll: ' asChord)'.!structureString	| s |	s := WriteStream on: ''.	structure  do: 	[:x | 		(x isKindOf: SmallInteger)			ifTrue: [x  printOn: s]			ifFalse: [s nextPutAll: x asString].		s nextPutAll: ' '].	^s contents! !!Siren.PitchClassChord methodsFor: 'accessing by  intervals'!theFifth	self  hasNoFifth		ifTrue: [^nil].	self hasADiminishedFifth		ifTrue: [^root diminishedFifth].	self hasAnAugmentedFifth		ifTrue: [^root augmentedFifth].	^root fifth.!theFourth		^ root fourth.!theOctave		^ root octave.!theSeventh	self hasNoSeventh ifTrue: [^nil].	self hasAMajorSeventh ifTrue: [^root majorSeventh].	self hasADiminishedSeventh ifTrue: [^root diminishedSeventh].	self hasAMinorSeventh ifTrue: [^root minorSeventh].	^nil!theThird		self isSuspended		ifTrue: [^nil].	self isMinor		ifTrue: [^root  minorThird].	^ root majorThird.!theTonic	^root unison! !!Siren.PitchClassChord methodsFor: 'creation'!format	"format the structure. Assumes root is not nil"	structure := self structureFromNotes: self notes root: root!fromNotes: l 	"assumes the first note is the root"	^self fromNotes: l root: l first!fromNotes: aList root: r	"l isa list of pitch-classes.	This method computes the correct (and canonical) name for the chord"	| l |	root := r. 	l := aList  asOrderedCollection.	notes := l copy.	structure := OrderedCollection new.		(l includes: r) ifTrue: [l remove: r] ifFalse: [structure add: #noRoot].	(self notes: l contains: #(majorThird minorThird fourth)) ifFalse: [structure add: #no3].	(((self notes: l contains: #(majorThird minorThird)) not) and: [l includes: r fourth]) ifTrue: [structure add: #sus4. l remove: r fourth].	(l includes: root majorThird) ifTrue: [l remove: root majorThird].	(l includes: root minorThird) ifTrue: [structure add: #min. l remove: root minorThird].	(self notes: l contains: #(fifth augmentedFifth diminishedFifth)) ifFalse: [structure add: #no5].			(l includes: root diminishedFifth) ifTrue: [structure add: #dim5. l remove: root diminishedFifth].	(l includes: root augmentedFifth) ifTrue: [structure add: #aug5. l remove: root augmentedFifth].	(l includes: root perfectFifth) ifTrue: [ l remove: root perfectFifth].	((l includes: root minorSeventh) and: [(structure includes: #dim5) and: [structure includes: #min]])			ifTrue: [structure add: #halfDim7; remove: #dim5; remove: #min. l remove: root minorSeventh].	(l includes: root minorSeventh) ifTrue: [structure add: 7. l remove: root minorSeventh].	(l includes: root majorSeventh) ifTrue: [structure add: #maj7. l remove: root majorSeventh].	((l includes: root diminishedSeventh) and: [(structure includes: #dim5) and: [structure includes: #min]])			ifTrue: [structure add: #dim7; remove: #dim5; remove: #min. l remove: root diminishedSeventh].	((structure includes: #no7) not and: [((self notes: l contains: #(ninth augmentedNinth diminishedNinth)) and: [(self notes: notes contains: #(minorSeventh majorSeventh diminishedSeventh)) not])]) ifTrue: [structure add: #no7].	(l includes: root ninth) ifTrue: [structure add: 9. l remove: root ninth].	(l includes: root diminishedNinth) ifTrue: [structure add: #dim9. l remove: root diminishedNinth].	(l includes: root augmentedNinth) ifTrue: [structure add: #aug9. l remove: root augmentedNinth].	((structure includes: #no9) not and:		[((self notes: l contains: #(eleventh augmentedEleventh)) and:			[(self notes: notes contains: #(ninth augmentedNinth diminishedNinth)) not])])	ifTrue: [structure add: #no9].	((structure includes: #no7) not and: [((self notes: l contains: #(eleventh augmentedEleventh)) and: [(self notes: notes contains: #(minorSeventh majorSeventh diminishedSeventh)) not])]) ifTrue: [structure add: #no7].	(l includes: root eleventh) ifTrue: [structure add: 11. l remove: root eleventh]. 	(l includes: root augmentedEleventh) ifTrue: [structure add: #aug11. l remove: root augmentedEleventh]. 	((self notes: l contains: #(thirteenth)) and:		[(self notes: notes contains: #(minorSeventh majorSeventh)) not]) ifTrue: [structure add: #sixth. l remove: r thirteenth].	((structure includes: #no11) not and:		[((self notes: l contains: #(thirteenth diminishedThirteenth)) and:			[(self notes: notes contains: #(eleventh augmentedEleventh)) not])]) ifTrue: [structure add: #no11].	((structure includes: #no9) not and: [((self notes: l contains: #(thirteenth diminishedThirteenth)) and: [(self notes: notes contains: #(ninth augmentedNinth diminishedNinth)) not])]) ifTrue: [structure add: #no9].	((structure includes: #no7) not and: [((self notes: l contains: #(thirteenth  diminishedThirteenth)) and: [(self notes: notes contains: #(minorSeventh majorSeventh diminishedSeventh)) not])]) ifTrue: [structure add: #no7].	(l includes: root thirteenth) ifTrue: [structure add: 13. l remove: root thirteenth].	(l includes: root diminishedThirteenth) ifTrue: [structure add: #dim13. l remove: root diminishedThirteenth].!fromString: l	"l is a list whose first element is a note and the rest a structure, in our	standardized chord syntax"		| secondElement |	structure := (Scanner new scanTokens: l) asOrderedCollection.	root := PitchClass noteNamed: structure first.	structure removeFirst."the following is done twice to take double sharp and double flats into acountalthough those should not be allowed to form chords"	2 timesRepeat: [	structure isEmpty ifFalse:		[secondElement:= structure first.		(secondElement = '#' asSymbol)			ifTrue: [root := root sharp. structure removeFirst].		(secondElement = #b) ifTrue: [root:= root flat. structure removeFirst]]].	self format!structureFromNotes: aList root: r	"l isa list of pitch-classes.	This method computes the correct (and canonical) name for the chord"	| l struct |	l := aList  asOrderedCollection.	struct := OrderedCollection new. 	(l includes: r) ifTrue: [l remove: r] ifFalse: [struct add: #noRoot].	(self notes: l contains: #(majorThird minorThird fourth)) ifFalse: [struct add: #no3].	(((self notes: l contains: #(majorThird minorThird)) not) and: [l includes: r fourth]) ifTrue: [struct add: #sus4. l remove: r fourth].	(l includes: root majorThird) ifTrue: [l remove: root majorThird].	(l includes: root minorThird) ifTrue: [struct add: #min. l remove: root minorThird].	(self notes: l contains: #(fifth augmentedFifth diminishedFifth)) ifFalse: [struct add: #no5].			(l includes: root diminishedFifth) ifTrue: [struct add: #dim5. l remove: root diminishedFifth].	(l includes: root augmentedFifth) ifTrue: [struct add: #aug5. l remove: root augmentedFifth].	(l includes: root perfectFifth) ifTrue: [ l remove: root perfectFifth].	((l includes: root minorSeventh) and: [(struct includes: #dim5) and: [struct includes: #min]])			ifTrue: [struct add: #halfDim7; remove: #dim5; remove: #min. l remove: root minorSeventh].	(l includes: root minorSeventh) ifTrue: [struct add: 7. l remove: root minorSeventh].	(l includes: root majorSeventh) ifTrue: [struct add: #maj7. l remove: root majorSeventh].	((l includes: root diminishedSeventh) and: [(struct includes: #dim5) and: [struct includes: #min]])			ifTrue: [struct add: #dim7; remove: #dim5; remove: #min. l remove: root diminishedSeventh].	(l includes: root diminishedSeventh)			ifTrue: [struct add: #dim7. l remove: root diminishedSeventh].	((struct includes: #no7) not and: [((self notes: l contains: #(ninth augmentedNinth diminishedNinth)) and: [(self notes: notes contains: #(minorSeventh majorSeventh diminishedSeventh)) not])]) ifTrue: [struct add: #no7].	(l includes: root ninth) ifTrue: [struct add: 9. l remove: root ninth].	(l includes: root diminishedNinth) ifTrue: [struct add: #dim9. l remove: root diminishedNinth].	(l includes: root augmentedNinth) ifTrue: [struct add: #aug9. l remove: root augmentedNinth].	((struct includes: #no9) not and:		[((self notes: l contains: #(eleventh augmentedEleventh)) and:			[(self notes: notes contains: #(ninth augmentedNinth diminishedNinth)) not])])	ifTrue: [struct add: #no9].	((struct includes: #no7) not and: [((self notes: l contains: #(eleventh augmentedEleventh)) and: [(self notes: notes contains: #(minorSeventh majorSeventh diminishedSeventh)) not])]) ifTrue: [struct add: #no7].	(l includes: root eleventh) ifTrue: [struct add: 11. l remove: root eleventh]. 	(l includes: root augmentedEleventh) ifTrue: [struct add: #aug11. l remove: root augmentedEleventh]. 	((self notes: l contains: #(thirteenth)) and:		[(self notes: notes contains: #(minorSeventh majorSeventh)) not]) ifTrue: [struct add: #sixth. l remove: r thirteenth].	((struct includes: #no11) not and:		[((self notes: l contains: #(thirteenth diminishedThirteenth)) and:			[(self notes: notes contains: #(eleventh augmentedEleventh)) not])]) ifTrue: [struct add: #no11].	((struct includes: #no9) not and: [((self notes: l contains: #(thirteenth diminishedThirteenth)) and: [(self notes: notes contains: #(ninth augmentedNinth diminishedNinth)) not])]) ifTrue: [struct add: #no9].	((struct includes: #no7) not and: [((self notes: l contains: #(thirteenth  diminishedThirteenth)) and: [(self notes: notes contains: #(minorSeventh majorSeventh diminishedSeventh)) not])]) ifTrue: [struct add: #no7].	(l includes: root thirteenth) ifTrue: [struct add: 13. l remove: root thirteenth].	(l includes: root diminishedThirteenth) ifTrue: [struct add: #dim13. l remove: root diminishedThirteenth].	^struct! !!Siren.PitchClassChord methodsFor: 'FP'!natural	^root natural! !!Siren.PitchClassChord methodsFor: 'initializations'!initAnalyse 	possibleTonalities:= OrderedCollection new.	notes := OrderedCollection new.	self changed: #analyse; changed: #analysesPossibles!initialize	notes := OrderedCollection new.	structure := ''.	possibleTonalities := AnalysisList new.!resetNotes	"reset notes to an empty collection when an important change occurred"	(notes isEmpty  or: [notes == nil])		ifFalse: [notes := OrderedCollection new].	(possibleTonalities isEmpty  or: [possibleTonalities == nil])		ifFalse: [possibleTonalities := AnalysisList new]! !!Siren.PitchClassChord methodsFor: 'accessing'!possibleScales	^self possibleTonalities collect: [:a | a scale]!possibleTonalities 	possibleTonalities isEmpty ifTrue: [self computePossibleTonalities].	^possibleTonalities! !!Siren.PitchClassChord methodsFor: 'compute possible tonalities'!= c 	^root = c root and: [structure = c structure]!analyseIn: aScale	"en majeure, mineure harm et min mel"	| analysis |	analysis := Siren.Analysis new degree: (aScale degreDeAccord: self ).	analysis scale: aScale.	^analysis!computePossibleTonalities	"self allInstancesDo: [:x| x computePossibleTonalities]"	possibleTonalities := AnalysisList new.	"Scale allSubclasses do:"	Scale standardScales do:		[:aScaleClass | possibleTonalities addAll: (self possibleTonalitiesInScaleClass: aScaleClass)].	self changed: #analysesPossibles!matchWith: c 	"((Chord new fromString: 'D  min 7') computeAllNotes) format 	matchAvec: ((N re majorScale genereAccordsPoly: 4) at: 3)."	^structure = c structure!possibleTonalitiesInScaleClass: s 	"possible tonalities in scale class s. 	(PitchClassChord newFromString: 'C  ') possibleTonalitiesInScaleClass:  MajorScale  AnalysisList ({I de C MajorScale} {IV de G MajorScale} {V de F MajorScale} )		There is a problem here, related to invalid scales. If you ask for 	instance the possible  tonalities of 'C# min', it will try to say that V of G# major is a 	possible tonality. But the creation of G# major raises an error since it 	is an invalid scale. For the moment I leave it as is because	I would 	like to have a model of reasoning in an object-oriented setting first"	| scale ana res c |	"self format."	res := Siren.AnalysisList new.	scale := s root: PitchClass do.	scale notes do: 			[:n | 			c := PitchClassChord root: n structure: structure copy.			(c allNotesInScale: scale) ifTrue: 					[ana := Siren.Analysis new degree: (scale degreeOfNote: n).					ana scale: (s root: (self root pitchClass transposeOf: (n intervalBetween: PitchClass do))).					res add: ana]].	^res!standardPossibleTonalities	"possible tonalities in scale class major, minorMel and minorHarm 	(Chord new fromString: 'C min') standardPossibleTonalities 	ListeDAnalyses ({II de Sib MajorScale} {III de Lab MajorScale} {VI de 	Mib MajorScale} {I de Do HarmonicMinorScale} {IV de Sol 	HarmonicMinorScale} {I de Do MelodicMinorScale} {II de Sib 	MelodicMinorScale} )"	| res |	res := OrderedCollection new.	Scale standardScales do: [:s | res addAll: (self possibleTonalitiesInScaleClass: s)].	^res!tonalitesCommunesAvec: unAccord 	"(FPChord newFromString: 'C min') tonalitesCommunesAvec: (FPChord 	newFromString: 'D b ') "	^self possibleTonalities tonalitesCommunesAvec: unAccord possibleTonalities!tonalitesCommunesAvec: unAccord et: autreAccord	"(FPChord newFromString: 'C min') tonalitesCommunesAvec: (FPChord 	newFromString: 'D b ') "	^self possibleTonalities tonalitesCommunesAvec: unAccord possibleTonalities 						   et: autreAccord possibleTonalities! !!Siren.PitchClassChord methodsFor: 'notes computation'!computeAllNotes	"computes the list of notes from the structure. The job is the opposite 	of what is written is method fromListOfNotes. 	Assumes root is not nil. 	| c | 	c := FPChord newFromString: 'A halfDim7'. 	c computeAllNotes. 	c notes"	| structCopy |	notes := OrderedCollection new.	structCopy := structure copy.	self computeRoot; computeThird; computeFifth; computeSixth; computeSeventh; computeNinth; computeEleventh; computeThirteenth	"; computeDiminished".	structure isEmpty ifFalse: [^self error: 'bad structure : ', structure printString].	structure := structCopy!computeDiminished	(structure includes: #dim7)		ifTrue: 			[notes := OrderedCollection						with: root						with: root minorThird						with: root diminishedFifth						with: root diminishedSeventh.			structure remove: #dim7].	(structure includes: #halfDim7)		ifTrue: 			[notes := OrderedCollection						with: root						with: root minorThird						with: root diminishedFifth						with: root minorSeventh.			structure remove: #halfDim7]!computeEleventh	(structure includes: #no11)		ifTrue: 			[structure remove: #no11.			^nil].	(structure includes: 11)		ifTrue: 			[structure remove: 11.			^notes add: root eleventh].	(structure includes: #aug11)		ifTrue: 			[structure remove: #aug11.			^notes add: root augmentedEleventh].	(self structureHasEitherOf: #(13 #dim13 ))		ifTrue: [^notes add: root eleventh]!computeFifth	((structure includes: #dim7)		or: [structure includes: #halfDim7]) ifTrue: [^notes add: root diminishedFifth].	(structure includes: #no5) ifTrue: [structure remove: #no5. ^nil].	(structure includes: #dim5) ifTrue: [structure remove: #dim5. ^notes add: root diminishedFifth].	(structure includes: #b5) ifTrue: [structure remove: #b5. ^notes add: root diminishedFifth].	(structure includes: #aug5) ifTrue: [structure remove: #aug5. ^notes add: root augmentedFifth].	notes add: root perfectFifth!computeNinth	(structure includes: #no9) ifTrue: [structure remove: #no9. ^nil].	(structure includes: 9) ifTrue: [structure remove: 9. ^notes add: root ninth].	(structure includes: #aug9) ifTrue: [structure remove: #aug9. ^notes add: root augmentedNinth].	(structure includes: #dim9) ifTrue: [structure remove: #dim9. ^notes add: root diminishedNinth].	(structure includes: #b9) ifTrue: [structure remove: #b9. ^notes add: root diminishedNinth].	(self structureHasEitherOf: #(11 aug11 13 dim13))		ifTrue: [notes add: root majorNinth]!computeRoot	(structure includes: #noRoot)		ifTrue: [structure remove: #noRoot]		ifFalse: [notes add: root]!computeSeventh	(structure includes: #dim7) ifTrue: [structure remove: #dim7. ^notes add: root diminishedSeventh].	(structure includes: #halfDim7) ifTrue: [structure remove: #halfDim7. ^notes add: root minorSeventh].	(structure includes: #no7) ifTrue: [structure remove: #no7. ^nil].	(structure includes: 7) ifTrue: [structure remove: 7. ^notes add: root minorSeventh].	(structure includes: #maj7) ifTrue: [structure remove: #maj7. ^notes add: root majorSeventh].		(self structureHasEitherOf: #(9 dim9 aug9 11 aug11 13 dim13))		ifTrue: [notes add: root minorSeventh]!computeSixth	(structure includes: 6)		ifTrue: [structure remove: 6. ^notes add: root sixth].	(structure includes: #sixth)		ifTrue: [structure remove: #sixth. ^notes add: root sixth]!computeThird	((structure includes: #dim7)		or: [structure includes: #halfDim7]) ifTrue: [^notes add: root minorThird].	(structure includes: #no3) ifTrue: [structure remove: #no3. ^nil].	(structure includes: #sus4) ifTrue: [structure remove: #sus4. ^notes add: root fourth].	(structure includes: #min) ifTrue: [structure remove: #min. ^notes add: root minorThird].	(structure includes: #m) ifTrue: [structure remove: #m. ^notes add: root minorThird].	notes add: root majorThird!computeThirteenth	(structure includes: 13) ifTrue: [structure remove: 13. ^notes add: root thirteenth].	(structure includes: #dim13) ifTrue: [structure remove: #dim13. ^notes add: root diminishedThirteenth].	(structure includes: #b13) ifTrue: [structure remove: #b13. ^notes add: root diminishedThirteenth].	(structure includes: #no13)		ifTrue: 	[structure remove: #no13.	^nil].!notes	notes isEmpty ifTrue: [self computeAllNotes].	^notes!notesWithinOctave	"accordingly, return the notes as in the case of a four note chord	with no higher dissonances"	| col |	col := OrderedCollection  with: self theTonic							with: self theThird							with: self theFifth							with: self theSeventh.	^col select: [:each | (each == nil) not].! !!Siren.PitchClassChord methodsFor: 'note testing'!allNotesInScale: aScale  	"The previous version couldnt deal with situations like	  (FPChord newFromString: 'C  7 aug9')  possibleTonalitiesInScaleClass:  MajorScale"	self notesWithinOctave do: [:n | (aScale notes includes: n)			ifFalse: [^false]].	^true!chordNotesAmong: list	"select among given notes those that are chord notes"	^list select: [:each |		self containsNote: each]!containsNote: n	^(self notes detect: [:each | each pitchClass pitchEqual: n pitchClass]			ifNone: [nil]) notNil!nextIn: aCS	^aCS chordAfter: self!nonChordNotesAmong: list	"select among given notes those that are chord notes"	^list select: [:each |		(self containsNote: each) not]!notes: aListOfNotes contains: anArrayOfIntervals 	anArrayOfIntervals do: [:i | (aListOfNotes includes: (root perform: i))			ifTrue: [^true]].	^false! !!Siren.PitchClassChord methodsFor: 'private-pact'!bestTonalityInIsolatedCase	"answer the most plausible tonality when the chor is isolated.	Later, I will rewrite it to bypass possibleTonalities for sake of efficience"	| list  candidate |	list := self possibleTonalities.	candidate := list first.	self isDominant		ifTrue: [^list detect: [:each | each degree = 5] ifNone: [candidate]].	"the minor scale whose first degree is equal to root is preferred"	self isMinor		ifTrue: [^list detect: [:each | each scale isMinor and: [each degree = 1]] 				     ifNone: [list detect: [:each | each scale isMinor]						    ifNone: [candidate]]].	"root is the first degree"	^list detect: [:each | each degree = 1] ifNone: [candidate].! !!Siren.PitchClassChord methodsFor: 'testing ok'!commonTonalitiesWith: aChord	^self possibleTonalities tonalitesCommunesAvec: aChord possibleTonalities!hasA: anInterval 	"(FPChord newFromString: 'C min 7') hasA: #majorThird"	^self notes includes: (self root perform: anInterval)!hasADiminishedFifth	^(((structure includes: #halfDim7) 		or: [structure includes: #dim7])		or: [structure includes: #dim5])!hasADiminishedSeventh	^structure includes: #dim7!hasAMajorSeventh	^(structure includes: #maj7)!hasAMinorSeventh	^self structureHasEitherOf: #(7 #halfDim7 )!hasAnAugmentedFifth	^structure includes: #aug5!hasNoFifth	^structure includes: #no5!hasNoSeventh	^(structure includes: #no7)!isAlterate	^(self isDominant 		and: [self hasNoFifth])		and: [self structureHasEitherOf: #(dim9 13)].!isDiminished	^(structure includes: #dim7)!isDominant	^self isMajor		and: [self hasAMinorSeventh].!isHalfDiminished	^structure includes: #halfDim7!isMajor	^self isMinor not!isMinor	^self structureHasEitherOf: #( min  halfDim7 dim7)!isSuspended	^(structure includes: #sus4)!structureHasEitherOf: aList 	^(aList detect: [:x | structure includes: x]		ifNone: [ nil]) notNil!structureHasNeitherOf: aList 	^(aList detect: [:x | structure includes: x]		ifNone: [^true]) notNil! !!Siren.PitchClassChord methodsFor: 'transposing'!beTransposedBy: int 	| no |	no := self notes.	root := root transposeOf: int.	notes := no collect: [:n | n transposeOf: int]!transposeOf: interval 	^self class root: (root transposeOf: interval)		structure: structure! !!Siren.PitchClassChord methodsFor: 'other computations'!intervalBetweenRoots: aChord	"remark: not that this method answers the interval between 	the root *pitch classes*!!!!"	"('G min 7' asChordOct: 2) intervalBetweenRoots:  ('F maj7' asChordOct: 2)"	^self root pitchClass intervalBetween: aChord root pitchClass! !!Siren.PitchClassChord methodsFor: 'tessitura'!rootInTessitura: qt	^root inTessitura: qt! !!Siren.PitchClassChord class methodsFor: 'examples'!allChordsFromListOfNotes: aList 	"self allChordsFromListOfNotes: (Array with: N do with: N mi with: N sol) #(Do  Mi #min #no5 #no11 #no9 #no7 #dim13  Sol #sus4 #no5 #sixth  )	self allChordsFromListOfNotes: (Array with: N do with: N mi with: N sol with: N si)"	"tries in all possible inversion, assuming that the root is actually present"	^aList collect: [:n | self new fromNotes: aList root: n]!commonTonalities"(PitchClassChord new fromString: 'C maj7') 	possibleTonalities AnalysisList ({I of C MajorScale} {IV of G MajorScale} {VI of E HarmonicMinorScale} )(PitchClassChord new fromString: 'F maj7')	possibleTonalities AnalysisList ({I of F MajorScale} {IV of C MajorScale} {VI of A HarmonicMinorScale} )(PitchClassChord new fromString: 'E min 7')	possibleTonalities  AnalysisList ({II of D MajorScale} {III of C MajorScale} {VI of G MajorScale} {IV of B HarmonicMinorScale} {II of D MelodicMinorScale} )----(PitchClassChord new fromString: 'C maj7') 	tonalitesCommunesAvec: (PitchClassChord new fromString: 'F maj7')	et: (PitchClassChord new fromString: 'E min 7') Set (C MajorScale )"!exampleShort	"'C min 7 dim5' asChord. 	('C min 7 dim5 9' asChordOct: 4) notes		OrderedCollection (C4 Eb4 Gb4 Bb4 D5 )"!examples"(PitchClassChord new fromString: 'Re maj7') notes OrderedCollection (Re Fa# La Do# )(PitchClassChord new fromString: 'Re# maj7') notes  OrderedCollection (Re# Fa## La# Do## )(PitchClassChord new fromString: 'C') notes    OrderedCollection (Do Mi Sol )(PitchClassChord new fromString: 'D min 7 dim5') notes OrderedCollection (Re Fa Lab Do )(PitchClassChord new fromString: 'C aug9') notes   OrderedCollection (Do Mi Sol Sib Re# )(PitchClassChord new fromString: 'C aug9 dim5') notes OrderedCollection (Do Mi Solb Sib Re# )   (PitchClassChord new fromString: 'C 13') notes OrderedCollection (Do Mi Sol Sib Re Fa La )(PitchClassChord new fromString: 'C 13 aug9') notes OrderedCollection (Do Mi Sol Sib Re# Fa La )(PitchClassChord new fromString: 'C 13 aug9 no7') notes OrderedCollection (Do Mi Sol Re# Fa La )(PitchClassChord new fromString: 'C halfDim7') notes  OrderedCollection (Do Mib Solb Sib )'F min 7' asChord notes > OrderedCollection (F Ab C Eb ) 	'F min7' asChord notes  > OrderedCollection (F A C )		'F m 7' asChord notes  > OrderedCollection (F A C Eb )		'Fm 7' asChord notes > error	'F maj 7' asChord notes > error	'F m7' asChord notes  > OrderedCollection (F A C )		'F maj 7' asChord notes > OrderedCollection (F A C Eb )		'F maj7' asChord notes > OrderedCollection (F A C E )		'F halfDim7' asChord notes  > OrderedCollection (F Ab Cb Eb ) 	'F min dim5 7' asChord notes  OrderedCollection (F Ab Cb Eb )'F min b5 7' asChord notes OrderedCollection (F Ab Cb Eb )'F dim7' asChord notes OrderedCollection (F A C Ebb )PitchClassChord new fromNotes: (Array with: N do with: N mi with: N sol)  DoPitchClassChord new fromNotes: (Array with: N do with: N mi with: N sol sharp) Do #aug5 PitchClassChord new fromNotes: (Array with: N do with: N fa with: N sol )   	 Do #sus4PitchClassChord new fromNotes: (Array with: N do with: N mi with: N sol with: N la)  Do #sixth  PitchClassChord new fromNotes: (Array with: N do with: N mi with: N la)  Do #no5 #sixth PitchClassChord new fromNotes: (Array with: N do with: N la)  Do #no3 #no5 #sixth PitchClassChord new fromNotes: (Array with: N do with: N mi with: N sol sharp with: N si)  Do #aug5 #maj7 PitchClassChord new fromNotes: (Array with: N do with: N mi with: N sol flat with: N si flat) Do #dim5 7PitchClassChord new fromNotes: (Array with: N do with: N mi flat with: N sol flat with: N si flat)   Do #halfDim7PitchClassChord new fromNotes: (Array with: N do with: N mi flat with: N sol flat with: N si flat flat)  Do #dim7 PitchClassChord new fromNotes: (Array with: N do with: N mi flat) Do #min #no5 PitchClassChord new fromNotes: (Array with: N do with: N mi with: N fa  with: N fa sharp )  Do #no5 #no9 #no7 11 #aug11 PitchClassChord new fromNotes: (Array with: N do with: N sol flat with: N sol sharp) Do #no3 #dim5 #aug5A chord of A. holdsworthPitchClassChord new fromNotes: (Array with: N re sharp with: N fa sharp sharp  with: N la with: N do sharp sharp)   Re# #dim5 #maj7 (PitchClassChord new fromString: 'C min') standardPossibleTonalities OrderedCollection ({II de Sib MajorScale} {III de Lab MajorScale} {VI de Mib MajorScale} {I de Do HarmonicMinorScale} {IV de Sol HarmonicMinorScale} {I de Do MelodicMinorScale} {II de Sib MelodicMinorScale} )(PitchClassChord new fromString: 'Do') possibleTonalities ListeDAnalyses ({V de Fa HungarianMinor} {VI de Mi HungarianMinor} {I de Do MajorScale} {IV de Sol MajorScale} {V de Fa MajorScale} {I de Do DoubleHarmonic} {II de Si DoubleHarmonic} {IV de Sol MelodicMinorScale} {V de Fa MelodicMinorScale} {IV de Sol Oriental} {IV de Sol NeapolitanMajor} {V de Fa HarmonicMinorScale} {VI de Mi HarmonicMinorScale} {II de Si NeapolitanMinor} {VI de Mi NeapolitanMinor} )(PitchClassChord new fromString: 'D min ') possibleTonalitiesListeDAnalyses ({I de Re HungarianMinor} {VII de Mib HungarianMinor} {II de Do MajorScale} {III de Sib MajorScale} {VI de Fa MajorScale} {III de Sib DoubleHarmonic} {IV de La DoubleHarmonic} {I de Re MelodicMinorScale} {II de Do MelodicMinorScale} {I de Re NeapolitanMajor} {I de Re HarmonicMinorScale} {IV de La HarmonicMinorScale} {I de Re NeapolitanMinor} {IV de La NeapolitanMinor} )"!holdsworth	^PitchClassChord new fromNotes: (Array			with: N re sharp			with: N fa sharp sharp			with: N la			with: N do sharp sharp)!reallyAllChordsFromListOfNotes: aList 	"self reallyAllChordsFromListOfNotes: (Array with: N do with: N mi with: N sol) OrderedCollection ([La #noRoot #min 7 ] [Si #noRoot #sus4 #no5 #no7 #dim9 #dim13 ] [Do ] [Re #noRoot #sus4 #no5 7 9 ] [Mi #min #no5 #no11 #no9 #no7 #dim13 ] [Fa #noRoot #no3 #maj7 9 ] [Sol #sus4 #no5 #sixth ] [La# #noRoot #no3 #dim5 ] [Do# #noRoot #min #dim5 ] [Re# #noRoot #no3 #no5 #dim9 ] [Fa# #noRoot #no3 #dim5 7 #dim9 ] [Sol# #noRoot #no3 #no5 #no11 #no9 #no7 #dim13 ] [Lab #noRoot #aug5 #maj7 ] [Sib #noRoot #no3 #no5 #no7 9 #aug11 #sixth ] [Reb #noRoot #no3 #no5 #maj7 #aug9 #aug11 ] [Mib #noRoot #no5 #sixth ] [Solb #noRoot #no3 #no5 #no9 #no7 #aug11 ] )"	"tries in all possible inversion, assuming that the root is actually present"	^PitchClass allPlausibleRootNotes collect: [:n | self new fromNotes: aList root: n]! !!Siren.PitchClassChord class methodsFor: 'creation'!new	^super new initialize!newFromNotes: l 	"computes the name from the list of notes, according to our syntax"	^self new fromNotes: l!newFromNotesNames: aStringOfNoteNames 	"computes the name from the list of notes, according to our syntax	PitchClassChord newFromNotesNames: 'A C# E G'  [La 7 ] "	| l notes lastNote aNote |	l := Scanner new scanTokens: aStringOfNoteNames.	notes := OrderedCollection new.	l do: [:x | x = '#' asSymbol			ifTrue: 				[lastNote := notes last.				notes removeLast; addLast: lastNote sharp]			ifFalse: [x = 'b' asSymbol					ifTrue: 						[lastNote := notes last.						notes removeLast; addLast: lastNote flat]					ifFalse: 						[aNote := PitchClass noteNamed: x.						notes addLast: aNote]]].	^self new fromNotes: notes!newFromString: l 	"computes the list of notes fom the name acording to our syntax"	^self new fromString: l!root: r structure: s	^self new root: r; structure: s! !!Siren.PitchClassChord class methodsFor: 'editing'!openEditor	ChordNameEditor open! !!Siren.Triad methodsFor: 'type'!type	^type!type: t 	type := t! !!Siren.Triad methodsFor: 'notes'!notes: x 	notes := x! !!Tools.ListWorkBook methodsFor: 'aspects'!pageChanged	| selection |	selection := self pageHolder selection.	lastInstalledPage notNil ifTrue:		[lastInstalledPage deactivate.		lastInstalledPage := nil].	selection isNil ifTrue: [textView value: String new. ^self].	self installPage: selection!pageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^self pageHolder!tabControl	^(builder componentAt: #textView) widget!textView	^textView isNil		ifTrue:			[textView := String new asValue]		ifFalse:			[textView]! !!Tools.ListWorkBook methodsFor: 'interface closing'!requestForWindowClose	"The ApplicationWindow's controller is checking to see if the 	application is in a state such that it can be closed."	(Dialog confirm: 'Are you certain you want to close this workbook?')		ifFalse: [self open].	^super requestForWindowClose! !!Tools.ListWorkBook methodsFor: 'initialize-release'!postBuildWith: aBuilder	self pageHolder selectionIndexHolder		onChangeSend: #pageChanged to: self! !!Tools.ListWorkBook class methodsFor: 'utilities'!catAllToWebPage	"Take the directory of single web pages produced by the HTML output and concatenate them all onto 1 large web page (for printing)."	"ListWorkBook catAllToWebPage"	| dir in out toc hr string stream |	dir := './Siren7.5/Workbook/'.	toc := (dir, 'contents.txt') asFilename readStream.	out := (dir, 'Siren7.5_Workbook.html') asFilename writeStream.	in := (dir, 'index.html') asFilename.	hr := '<br><HR><br><br>'.	string := in contentsOfEntireFile.	string := string copyReplaceAll: '"./' with: '"#'.	string := string copyReplaceAll: '.html"'with: '"'.	out nextPutAll: string.	[toc atEnd] whileFalse:		[ | fil |		fil := toc upTo: Character cr.		stream := (dir, fil, '.html') asFilename readStream.		Transcript show: 'Processing ', (dir, fil, '.html'); cr.		stream upToAll: '<!!-- START -->'.		out nextPutAll: hr.		out nextPutAll: '<A NAME="', fil, '">'; cr.		out nextPutAll: (stream upToAll: '<!!-- END -->').		stream close.		].	out nextPutAll: hr.	out nextPutAll: '</BODY></HTML>'.	toc close.	out close.! !!Siren.PortModel methodsFor: 'mutex support'!critical: aBlock	"Execute the given block as a critical section"	self class mutex critical: aBlock! !!Siren.PortModel methodsFor: 'accessing'!device	^device!device: aValue	device := aValue!in	^in!in: aValue	in := aValue!name	^name!name: aValue	name := aValue!out	^out!out: aValue	out := aValue!status	^status!status: aValue	status := aValue! !!Siren.PortModel methodsFor: 'initialize-release'!initialize	"no-op"	^self! !!Siren.PortModel class methodsFor: 'class initialization'!initialize	"Set up the defaults for the class constants."	"PortModel initialize"	self initializeData.	PortModel allSubclassesDo: [ :cl | cl initializeData]!initializeData	"Set up the defaults for the class constants."	"PortModel initialize"	singleton := nil.	devices := OrderedCollection new.	properties := Array new.	useSingleton := true.	mutex := Semaphore forMutualExclusion.	out := 0.	in := 0.	rate := 0.	blockSize := 0! !!Siren.PortModel class methodsFor: 'class var accessing'!blockSize	^blockSize!blockSize: value	blockSize := value!devices	^devices!devices: anArr	devices := anArr!in	^in!in: value	in := value!instance: value	singleton := value!mutex	^mutex!out	^out!out: value	out := value!properties	^properties!properties: anArr	properties := anArr!rate	^rate!rate: value	rate := value!resetDevices	"Flush the device list"	devices := OrderedCollection new!sampleRate	^rate!sampleRate: value	rate := value! !!Siren.PortModel class methodsFor: 'instance creation'!concreteClass	"Answer the class to use for ports"	^self!default	"Answer a new instance, or the singleton"	"MIDIPort default"	"PortMIDIPort instanceCount"	^useSingleton		ifTrue:  [singleton ifNil: [singleton := self concreteClass basicNew initialize]. singleton]		ifFalse: [self new]!instance	"Answer a new instance, or the singleton"	"MIDIPort default"	"MIDIPort instanceCount"	^useSingleton		ifTrue:  [self default]		ifFalse: [self new]!new	"Answer a new instance, or the singleton"	"MIDIPort new"	"MIDIPort instanceCount"	useSingleton		ifTrue:  [singleton ifNil: [singleton := self concreteClass basicNew initialize]. ^singleton]		ifFalse: [ | inst |			[inst := self concreteClass basicNew initialize]				on: Error				do: [ :ex | Transcript show: 'MIDI driver not installed'.					^nil].			^inst]!release	"Release the unique instance"	"MIDIPort release"	singleton := nil! !!Siren.SoundPort methodsFor: 'initialize/release'!initialize	"Answer an initialized version of the receiver."	^self!release	"Terminate and release the receiver."	^self! !!Siren.SoundPort methodsFor: 'play/record'!play: aSound	"Play the argument on the receiver over the DACs."	self subclassResponsibility!play: aSound from: start to: stop	"Play the argument on the receiver over the DACs."	self subclassResponsibility!record: aSound	"Record into the argument via the receiver."	self subclassResponsibility! !!Siren.SoundPort methodsFor: 'open/close'!close	"Close the receiver sound port"	^self!open	"Open the receiver sound port"	^self!start	"Start the receiver sound port"	^self!stop	"Stop the receiver sound port"	^self! !!Siren.SoundPort class methodsFor: 'class initialization'!initializeData	"Set up the defaults for the class constants."	"PortModel initialize"	super initializeData.	useSingleton := true.	mutex := Semaphore forMutualExclusion."defaults: stereo out, no in"	out := 2.	in := 0.	rate := 44100.	blockSize := 1024.! !!Siren.SoundPort class methodsFor: 'instance creation'!concreteClass	"Answer the appropriate subclass."	^PortAudioPort!default	"Answer a default instance of the appropriate subclass."	"SoundPort concreteClass instanceCount"	"SoundPort default"	| count |	count := self concreteClass instanceCount.	(count > 0)		ifTrue: [^self concreteClass someInstance].	^self concreteClass basicNew initialize!defaultOrNil	"Answer the default instance of the appropriate subclass if it's set up."	"SoundPort defaultOrNil"	SoundPort concreteClass instanceCount = 0		ifTrue: [^nil].	^SoundPort concreteClass someInstance! !!Siren.PortAudioPort methodsFor: 'play/record'!play: aSound	"Play the argument on the receiver over the DACs."	"PortAudioPort playSweep"	self play: aSound from: 1 to: aSound size!play: aSound from: start to: stop	"Play the argument on the receiver over the DACs."	"SoundPort default play: (SampledSound sweepDur: 30.0 rate: 44100 from: 20 to: 500 chans: 1)			from: 300000 to: 400000"	| samps doGC swap |	self open.	self start.	UninterpretedBytes isBigEndian		ifTrue: [swap := 1]		ifFalse: [swap := 0]."make the pointer shareable"	samps := aSound data.	samps isCPointer ifFalse: 		[doGC := true. 		samps := samps copyToHeap.		swap := 1].	self critical: [interface pa_play: samps + (start * aSound channels) 					with: aSound channels 					with: (stop - start) 					with: swap]."fork a process to mark the shared buffer as garbage after we're done."	doGC ifNotNil: [[(aSound duration value + 0.5) wait.		samps beGarbageCollectable] fork]! !!Siren.PortAudioPort methodsFor: 'accessing'!format	^format!format: aValue	format := aValue!outChannels	^outChannels!outChannels: aValue	outChannels := aValue!rate	^rate!rate: aValue	rate := aValue! !!Siren.PortAudioPort methodsFor: 'initialize/release'!initialize	"Answer an initialized version of the receiver."	"PortAudioPort playSweep"	"SoundPort initialize"	"PortAudioInterface unloadLibraries"	"PortAudioPort devices" "PortAudioPort properties"	| val |	isOpen := false.	isRunning := false."Set the default settings"	rate := SoundPort sampleRate.	format := #lin16Bit.	outChannels := 2.				"default = stereo"	bufferSize := self class blockSize."Create the external interface"	interface := PortAudioInterface new."Initialize PA"	val := interface pa_initialize.	(val = 0)		ifFalse: [self error: 'PortAudio init returned: ', val printString]."Get IO data - should I create device objects and load the port names?"	device := interface pa_out_device.		"output by default"	self class resetDevices.	1 to: interface pa_num_devices do:		[ :cnt | | nam |"		nam := (String new: 32) gcCopyToHeap."		nam := interface pa_get_name: cnt.		self class devices add: (DeviceModel new name: nam copyCStringFromHeap asSymbol; 						port: cnt; rate: (interface pa_dev_rate: cnt);						in: (interface pa_dev_in: cnt); out: (interface pa_dev_out: cnt))].	self class properties:  (Array with: interface pa_num_in with: interface pa_num_out 					with: interface pa_in_rate with: interface pa_out_rate).	(SirenUtility verbosity > 1)		ifTrue: [Transcript cr; show: 'Sound Device Table'; crtab.			self class devices do: [ :aDev | Transcript show: aDev port printString, ': ', aDev name, ' ',					aDev in printString, ' in ', aDev out printString, ' out ', aDev rate printString, ' Hz']				separatedBy: [Transcript crtab].			Transcript cr.]! !!Siren.PortAudioPort methodsFor: 'open/close'!close	"Close the receiver sound port"	| val |	isOpen ifFalse: [^self].	self stop.	val := interface pa_close.	self critical: [interface pa_terminate].	SirenUtility log: 'PortAudio close returned: ', val printString level: 1.	isOpen := false.	self class instance: nil!open	"Open the receiver sound port"	| val |	isOpen ifTrue: [^self].	interface ifNil: [self initialize]."Open the PortAudio interface."	self critical: [val := interface pa_open_p: device with: outChannels 				with: (PortAudioInterface const: format) 				with: rate with: bufferSize]."Report, set my status, and plug me in as the singleton"	SirenUtility log: 'PortAudio open returned: ', val printString level: 1.	isOpen := true.	self class instance: self!start	"Start the receiver sound port"	isRunning ifTrue: [^self].	SirenUtility log: 'PortAudio running...' level: 1.	self critical: [interface pa_start].	isRunning := true.!stop	"Stop the receiver sound port"	isRunning ifFalse: [^self].	self critical: [interface pa_stop].	SirenUtility log: 'PortAudio stopped...' level: 1.	isRunning := false!terminate	"Shut down the receiver."	isRunning ifTrue: [self stop].	isOpen ifTrue: [self close]."Terminate the external interface"	self critical: [interface pa_terminate].	interface := nil.	SirenUtility log: 'PortAudio terminated...' level: 1.! !!Siren.PortAudioPort class methodsFor: 'initialize/release'!stop	"Stop and close the running instance"	"PortAudioPort stop"	"PortAudioPort instanceCount"	"PortAudioPort someInstance"	| inst |	(self instanceCount > 0)		ifTrue: [inst := self someInstance]		ifFalse: [^self].	inst stop.	inst close.	inst terminate.	inst release.	ObjectMemory garbageCollect! !!Siren.PortAudioPort class methodsFor: 'examples'!playSweep	"Play a swept sine wave using the simple output-only port audio port."	"PortAudioPort playSweep"	"SoundPort initialize"	| port snd |	port := self new.	port open.	1 wait.	snd := SampledSound sweepDur: 2.0 rate: 44100 from: 60 to: 800 chans: 2.	snd := snd scaleBy: 0.1.	port play: snd.	(snd duration value + 1) wait.	port close.	port terminate.!playSweepLong	"Play a *long* swept sine wave using the simple output-only port audio port."	"PortAudioPort playSweepLong"	"SoundPort initialize"	| port snd |	port := self new initialize.	port open.	1 wait.	snd := SampledSound sweepDur: 20.0 rate: 44100 from: 50 to: 500 chans: 2.	snd := snd scaleBy: 0.1.	port play: snd.	(snd duration value + 1) wait.	port close.	port terminate.! !!Siren.PitchClass methodsFor: 'public intervals'!alterate: note toReach: i 	self subclassResponsibility!alterateBelow: note toReach: i 	self subclassResponsibility!augmentedEleventh	^MusicalInterval augmentedEleventh topIfBottomIs: self!augmentedFifth	^MusicalInterval augmentedFifth topIfBottomIs: self!augmentedFourth	^MusicalInterval augmentedFourth topIfBottomIs: self!augmentedNinth	^MusicalInterval augmentedNinth topIfBottomIs: self!augmentedSecond	^MusicalInterval augmentedSecond topIfBottomIs: self!augmentedUnison	^MusicalInterval augmentedUnison topIfBottomIs: self!diminishedFifth	^MusicalInterval diminishedFifth topIfBottomIs: self!diminishedNinth	^MusicalInterval diminishedNinth topIfBottomIs: self!diminishedSecond	^MusicalInterval minorSecond topIfBottomIs: self!diminishedSeventh	^MusicalInterval diminishedSeventh topIfBottomIs: self!diminishedThirteenth	^MusicalInterval diminishedThirteenth topIfBottomIs: self!eleventh	^MusicalInterval eleventh topIfBottomIs: self!fifth	^MusicalInterval fifth topIfBottomIs: self!flatFifth	^MusicalInterval flatFifth topIfBottomIs: self!flatNinth	^MusicalInterval flatNinth topIfBottomIs: self!flatThirteenth	^MusicalInterval flatThirteenth topIfBottomIs: self!fourth	^MusicalInterval fourth topIfBottomIs: self!majorNinth	^MusicalInterval majorNinth topIfBottomIs: self!majorSecond	^MusicalInterval majorSecond topIfBottomIs: self!majorSeventh	^MusicalInterval majorSeventh topIfBottomIs: self!majorSixth	^MusicalInterval majorSixth topIfBottomIs: self!majorThird	^MusicalInterval majorThird topIfBottomIs: self!majorThirteenth	^MusicalInterval majorThirteenth topIfBottomIs: self!minorNinth	^MusicalInterval minorNinth topIfBottomIs: self!minorSecond	^MusicalInterval minorSecond topIfBottomIs: self!minorSeventh	^MusicalInterval minorSeventh topIfBottomIs: self!minorSixth	^MusicalInterval minorSixth topIfBottomIs: self!minorThird	^MusicalInterval minorThird topIfBottomIs: self!minorThirteenth	^MusicalInterval minorThirteenth topIfBottomIs: self!ninth	^MusicalInterval ninth topIfBottomIs: self!octave	^self!perfectEleventh	^MusicalInterval perfectEleventh topIfBottomIs: self!perfectFifth	^MusicalInterval perfectFifth topIfBottomIs: self!perfectFourth	^MusicalInterval perfectFourth topIfBottomIs: self!second	^MusicalInterval second topIfBottomIs: self!seventh	^MusicalInterval seventh topIfBottomIs: self!sixth	^MusicalInterval sixth topIfBottomIs: self!thirteenth	^MusicalInterval thirteenth topIfBottomIs: self!unison	^self! !!Siren.PitchClass methodsFor: 'private intervals'!descendingNumberOfSemiTonesBetween: aNote 	"Important method in the theory. It is a 3-stage computation of the interval between 2 notes"	^self semiTonesToNatural + 	(self natural semiTonesWithNaturalNoteBelow:  aNote natural) - 	aNote semiTonesToNatural!descendingSemiTonesToNatural	^self semiTonesToNatural negated!intervalBetween: aNote 	"returns the interval between the two notes"	|  b b2 type |	type := 1.	b := self natural.	b2 := aNote natural.	[b2 = b] whileFalse: 			[b := b following.			type := type + 1].	^MusicalInterval type: type semiTones: (self numberOfSemiTonesBetween: aNote)!intervalTypeBetween: aNote 	"returns the interval between the two notes"	| b b2 type |	type := 1.	b := self natural.	b2 := aNote natural.	[b2 = b]		whileFalse: 			[b := b following.			type := type + 1].	^ type!nthFollowing: i	"returns the i th natural note following self"	| nth |	nth := self.	i timesRepeat: [nth := nth following].	^nth!nthPreceding: i	"returns the i th natural note preceding self"	| nth |	nth := self.	i timesRepeat: [nth := nth preceding].	^nth!numberOfSemiTonesBetween: aNote 	"Important method in the theory. It is a 3-stage computation of the interval between 2 notes"	^self semiTonesToNatural + 	(self natural semiTonesWithNaturalNote:  aNote natural) - 	aNote semiTonesToNatural!semiToneCount	^self subclassResponsibility!smallestIntervalBetween: aNote 	"returns the descending interval between the two notes"	self semiToneCount <= aNote semiToneCount		ifTrue: [^self intervalBetween: aNote]		ifFalse: [^self descendingIntervalBetween: aNote]! !!Siren.PitchClass methodsFor: 'scales'!chromaticScale	^ChromaticScale root: self!harmonicMinorScale	^HarmonicMinorScale root: self!majorScale	^MajorScale root: self!melodicMinorScale	^MelodicMinorScale root: self!minorScale	^self harmonicMinorScale!pseudoMinorScale	^PseudoMinorScale root: self! !!Siren.PitchClass methodsFor: 'saving'!representBinaryOn: s 	"to ensure uniqueness, pitch classes save themselves as messages sent 	to the appropriate class, so that no duplicate are created"	^self subclassResponsibility! !!Siren.PitchClass methodsFor: 'mutations'!@ o 	(o isKindOf: Integer)		ifFalse: [^super @ o].	^self octave: o!chordFromString: st 	^self chordFromTokens: (Scanner new scanTokens: st)!inTessitura: qualTessitura	"N C pitchInTessitura: QTessitura high"	| tv octs |	tv := qualTessitura typicalValue.	octs := self downAndUpOctaves: tv.	(tv isNearerTo: (octs at: 1) than: (octs at: 2))		ifTrue: [^octs at: 1]		ifFalse: [^octs at: 2].!octave: o	^OctaveDependentNote octave: o pc: self! !!Siren.PitchClass methodsFor: 'printing'!printOn: s 	self subclassResponsibility!storeOn: s 	"N C storeString"	s nextPutAll: 'N ' , self name! !!Siren.PitchClass methodsFor: 'chord creation'!chordFromTokens: st 	^(PitchClassChord new) root: self; structure: st!majorTriad	^PitchClassChord root: self structure: ''!minorTriad	^PitchClassChord root: self structure: #(#min )! !!Siren.PitchClass methodsFor: 'making octave-dep notes'!downAndUpOctaves: odNote	"returns two octave dependent notes of self who are repectively	lower and higher than the given odNote"	| col n |	col := OrderedCollection new.	n := self octave: odNote oct.	(n > odNote)		ifTrue: [col add: (self octave: odNote oct - 1).			     col add: n]		ifFalse:  [ col add: n.			        col add:  (self octave: odNote oct + 1) ].	^col!pitchBetween: n1 and: n2	"return, if it exists, a pitch (octave dependent note) between the two given notes"	| candidate |	candidate := (self downAndUpOctaves: n1) at: 2.	candidate <= n2		ifTrue: [^candidate]		ifFalse: [^nil].!the: nb octavesBeginningFrom: initialOctave 	"N D the: 3 octavesBeginningFrom: 0"	| col |	col := OrderedCollection new.	initialOctave to: initialOctave + nb - 1 do: [:o | col add: (self octave: o)].	^col! !!Siren.PitchClass methodsFor: 'testing'!isDoubleFlat	^false!isDoubleSharp	^false!isFlat	^false!isNatural	^true!isSharp	^false!pitchEqual: aNote 	^(self semiToneCount - aNote semiToneCount) \\ 12 = 0! !!Siren.PitchClass methodsFor: 'access'!doubleFlat	^self flat flat!doubleSharp	^self sharp sharp!natural	self subclassResponsibility!pitchClass	^self! !!Siren.PitchClass methodsFor: 'constraining'!intervalTypeModuloOctaveBetween: n 	^(self intervalTypeBetween: n) - 1 \\ 7+ 1! !!Siren.PitchClass methodsFor: 'Paleo'!copy	self shouldNotImplement!nameInScale: aScale	^ aScale allNotes detect: [:n | self pitchEqual: n] ifNone: [self error: 'Should not reach here. Unknown note ' , self printString]! !!Siren.PitchClass methodsFor: 'transpose'!transposeOf: anInterval 	"three cases: integer (+/-), method name (= ascending interval), or interval 	object"	anInterval isInteger ifTrue: [^(ChromaticInterval semiTones: anInterval)			from: self].	anInterval isSymbol ifTrue: [^self perform: anInterval].	(anInterval isKindOf: MusicalInterval) ifTrue: [^anInterval topIfBottomIs: self].	^self error: 'type d''intervalle indefini'! !!Siren.PitchClass class methodsFor: 'ordering'!flatOrdering	^#(#B #E #A #D #G #C #F ) collect: [:n | self perform: n]!nFirstFlats: n 	"PitchClass nFirstFlats: 3"	^(1 to: n)		collect: [:i | (self flatOrdering at: i) flat]!nFirstSharps: n 	"PitchClass nFirstSharps: 3"	^(1 to: n)		collect: [:i | (self sharpOrdering at: i) sharp]!sharpOrdering	^#(#F #C #G #D #A #E #B ) collect: [:n | self perform: n]! !!Siren.PitchClass class methodsFor: 'vocal ranges'!altoRange	"retourne la collection des notes de l'alto"	^self from: (N sol octave: 3)		to: (N re octave: 5)!altoRangeInScale: aScale	"PitchClass sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N sol octave: 3)		to: (N re octave: 5)!baseRange	"retourne la collection des notes de la basse"	^self from: (N sol octave: 2)		to: (N re octave: 4)!baseRangeInScale: aScale	"PitchClass sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N sol octave: 2)		to: (N re octave: 4)!sopranoRange	"retourne la collection des notes du soprano"	^self from: (N re octave: 4)		to: (N do octave: 6)!sopranoRangeInScale: aScale	"PitchClass sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N re octave: 4)		to: (N do octave: 6)!tenorRange	"retourne la collection des notes du tenor"	^self from: (N re octave: 3)		to: (N la octave: 4)!tenorRangeInScale: aScale	"PitchClass sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N re octave: 3)		to: (N la octave: 4)! !!Siren.PitchClass class methodsFor: 'initialization'!englishOrFrench	English := Dialog confirm: 'English (Yes) or French (No)'!initialize	"There are 35 pitch classes. That's too much for Squeak, so the method was split into two methods"	"PitchClass initialize"	| la si do re mi fa sol lad sid dod red mid fad sold lab sib dob reb mib fab solb ladd sidd dodd redd midd fadd soldd |	la := (PitchClassNatural new) semiToneCount: 10; name: #A.	si := (PitchClassNatural new) semiToneCount: 12; name: #B.	do := (PitchClassNatural new) semiToneCount: 1; name: #C.	re := (PitchClassNatural new) semiToneCount: 3; name: #D.	mi := (PitchClassNatural new) semiToneCount: 5; name: #E.	fa := (PitchClassNatural new) semiToneCount: 6; name: #F.	sol := (PitchClassNatural new) semiToneCount: 8; name: #G.	lad := PitchClassSharp new natural: la.	sid := PitchClassSharp new natural: si.	dod := PitchClassSharp new natural: do.	red := PitchClassSharp new natural: re.	mid := PitchClassSharp new natural: mi.	fad := PitchClassSharp new natural: fa.	sold := PitchClassSharp new natural: sol.	lab := PitchClassFlat new natural: la.	sib := PitchClassFlat new natural: si.	dob := PitchClassFlat new natural: do.	reb := PitchClassFlat new natural: re.	mib := PitchClassFlat new natural: mi.	fab := PitchClassFlat new natural: fa.	solb := PitchClassFlat new natural: sol.	ladd := PitchClassDoubleSharp new natural: la.	sidd := PitchClassDoubleSharp new natural: si.	dodd := PitchClassDoubleSharp new natural: do.	redd := PitchClassDoubleSharp new natural: re.	midd := PitchClassDoubleSharp new natural: mi.	fadd := PitchClassDoubleSharp new natural: fa.	soldd := PitchClassDoubleSharp new natural: sol.	la following: si; preceding: sol; sharp: lad; flat: lab.	si following: do; preceding: la; sharp: sid; flat: sib.	do following: re; preceding: si; sharp: dod; flat: dob.	re following: mi; preceding: do; sharp: red; flat: reb.	mi following: fa; preceding: re; sharp: mid; flat: mib.	fa following: sol; preceding: mi; sharp: fad; flat: fab.	sol following: la; preceding: fa; sharp: sold; flat: solb.	lad sharp: ladd.	sid sharp: sidd.	dod sharp: dodd.	red sharp: redd.	mid sharp: midd.	fad sharp: fadd.	sold sharp: soldd.	A := la. B := si. C := do. D := re. E := mi. F := fa. G := sol.	self initializeDoubleFlat.	AllNotes := OrderedCollection new.	AllNotes add: do; add: re; add: mi; add: fa; add: sol; add: la; add: si; add: dod; add: red; add: mid; add: fad; add: sold; add: lad; add: sid; add: dob; add: reb; add: mib; add: fab; add: solb; add: lab; add: sib; add: dodd; add: redd; add: midd; add: fadd; add: soldd; add: ladd; add: sidd.	self initializeFrenchNames.	English := true.	self initializeAllNaturalNotes;  initializeGlobals!initializeAllNaturalNotes	AllNatural := #(#C #D #E #F #G #A #B ) collect: [:n | self perform: n]!initializeClass	"There are 35 pitch classes. That's too much for Squeak, so the method was split into two methods"	"PitchClass initializeClass"	| la si do re mi fa sol lad sid dod red mid fad sold lab sib dob reb mib fab solb ladd sidd dodd redd midd fadd soldd |	la := (PitchClassNatural new) semiToneCount: 10; name: #A.	si := (PitchClassNatural new) semiToneCount: 12; name: #B.	do := (PitchClassNatural new) semiToneCount: 1; name: #C.	re := (PitchClassNatural new) semiToneCount: 3; name: #D.	mi := (PitchClassNatural new) semiToneCount: 5; name: #E.	fa := (PitchClassNatural new) semiToneCount: 6; name: #F.	sol := (PitchClassNatural new) semiToneCount: 8; name: #G.	lad := PitchClassSharp new natural: la.	sid := PitchClassSharp new natural: si.	dod := PitchClassSharp new natural: do.	red := PitchClassSharp new natural: re.	mid := PitchClassSharp new natural: mi.	fad := PitchClassSharp new natural: fa.	sold := PitchClassSharp new natural: sol.	lab := PitchClassFlat new natural: la.	sib := PitchClassFlat new natural: si.	dob := PitchClassFlat new natural: do.	reb := PitchClassFlat new natural: re.	mib := PitchClassFlat new natural: mi.	fab := PitchClassFlat new natural: fa.	solb := PitchClassFlat new natural: sol.	ladd := PitchClassDoubleSharp new natural: la.	sidd := PitchClassDoubleSharp new natural: si.	dodd := PitchClassDoubleSharp new natural: do.	redd := PitchClassDoubleSharp new natural: re.	midd := PitchClassDoubleSharp new natural: mi.	fadd := PitchClassDoubleSharp new natural: fa.	soldd := PitchClassDoubleSharp new natural: sol.	la following: si; preceding: sol; sharp: lad; flat: lab.	si following: do; preceding: la; sharp: sid; flat: sib.	do following: re; preceding: si; sharp: dod; flat: dob.	re following: mi; preceding: do; sharp: red; flat: reb.	mi following: fa; preceding: re; sharp: mid; flat: mib.	fa following: sol; preceding: mi; sharp: fad; flat: fab.	sol following: la; preceding: fa; sharp: sold; flat: solb.	lad sharp: ladd.	sid sharp: sidd.	dod sharp: dodd.	red sharp: redd.	mid sharp: midd.	fad sharp: fadd.	sold sharp: soldd.	A := la. B := si. C := do. D := re. E := mi. F := fa. G := sol.	self initializeDoubleFlat.	AllNotes := OrderedCollection new.	AllNotes add: do; add: re; add: mi; add: fa; add: sol; add: la; add: si; add: dod; add: red; add: mid; add: fad; add: sold; add: lad; add: sid; add: dob; add: reb; add: mib; add: fab; add: solb; add: lab; add: sib; add: dodd; add: redd; add: midd; add: fadd; add: soldd; add: ladd; add: sidd.	self initializeFrenchNames.	English := true.	self initializeAllNaturalNotes;  initializeGlobals!initializeDoubleFlat	| labb sibb dobb rebb mibb fabb solbb |	labb := PitchClassDoubleFlat new natural: A.	sibb := PitchClassDoubleFlat new natural: B.	dobb := PitchClassDoubleFlat new natural: C.	rebb := PitchClassDoubleFlat new natural: D.	mibb := PitchClassDoubleFlat new natural: E.	fabb := PitchClassDoubleFlat new natural: F.	solbb := PitchClassDoubleFlat new natural: G.	A flat flat: labb.	B flat flat: sibb.	C flat flat: dobb.	D flat flat: rebb.	E flat flat: mibb.	F flat flat: fabb.	G flat flat: solbb!initializeFrenchNames	C nom: #Do.	D nom: #Re.	E nom: #Mi.	F nom: #Fa.	G nom: #Sol.	A nom: #La.	B nom: #Si!initializeGlobals	Smalltalk at: #N put: self. "for short-cuts"	Smalltalk at: #PitchClassDo put: C. "for short-cuts"! !!Siren.PitchClass class methodsFor: 'examples'!chordExamples"N C sharp chordFromString: '' ->  [C# ](N C sharp chordFromString: 'min 7 dim5') notes -> OrderedCollection (C# E G B )"!closestEnharmonic"N D sharp closestEnharmonic EbN E flat closestEnharmonic D#N B sharp closestEnharmonic C N C flat closestEnharmonic D#N D sharp sharp closestEnharmonic  EN E flat flat closestEnharmonic  D------(N D sharp @ 2)  closestEnharmonic Eb2 (N E flat @ 2) closestEnharmonic D#2(N B sharp @ 2) closestEnharmonic C3(N C flat @ 3) closestEnharmonic B2"!majorScaleExample"PitchClass B majorScale notes- >  #(B C# D# E F# G# A# )"!melodicMinorScaleExample	^PitchClass D flat melodicMinorScale!minorScaleExample	^PitchClass C sharp minorScale!pitchInTessituraExamples"	N C pitchInTessitura: QTessitura high ->  C5	N A pitchInTessitura: QTessitura high -> A4		N G pitchInTessitura: QTessitura high ->  G4	N F pitchInTessitura: QTessitura high ->  F5	N A pitchInTessitura: QTessitura low ->  A2	"!sharpflatAlgebraExample	"	sharp and flat's algebra	N C sharp ->Do# 	N C sharp sharp ->Do## 	N C sharp sharp sharp ->error 	N C flat sharp -> Do	N re sharp sharp natural -> re	Intervals computation :	N C diminishedFifth -> Solb	N C augmentedFourth -> Fa#	N C diminishedThirteenth -> Lab 	N C flat minorSeventh -> Sibb 	N C majorThird majorThird -> Sol#		Notes equivalence : pitchEgal methode	N C sharp pitchEqual: N re flat -> true	N C augmentedFourth pitchEqual: N C diminishedFifth -> true	N C diminishedFifth pitchEqual: N F minorSecond -> true	"! !!Siren.PitchClass class methodsFor: 'global access'!A	^A!B	^B!C	^C!D	^D!E	^E!F	^F!G	^G!allNotesButDoubles	^self naturalNotes, self sharpNotes, self flatNotes!allPlausibleRootNotes	^(self naturalNotes, self sharpNotes, self flatNotes) asOrderedCollection remove: (self B sharp); remove: (self E sharp); remove: (self C flat); remove: (self F flat); yourself!allPlausibleRootsForMajorScales	"self allPlausibleRootsForMajorScales"	| col |	col := OrderedCollection new.	col add: self C; 		add: self D flat; 		add: self D;		add: self E flat; 		add: self E; 		add: self F;		add: self F sharp; 		add: self G; 		add: self A flat;		add: self A; 		add: self B flat; 		add: self B.	^col!allPlausibleRootsForMinorScales	"self allPlausibleRootsForMinorScales"	| col |	col := OrderedCollection new.	col add: self C; 		add: self C sharp; 		add: self D;		add: self D sharp; 		add: self E; 		add: self F;		add: self F sharp; 		add: self G; 		add: self G sharp;		add: self A; 		add: self B flat; 		add: self B.	^col!do	^C!fa	^F!flatNotes	^self naturalNotes collect: [:n | n flat]!fromSemiTones: n 	"arbitrary method, used for transposing pitch classes (a strange notion...)"	| delta |	delta := n \\ 12.	delta = 1 ifTrue: [^N C].	delta = 2 ifTrue: [^N C sharp].	delta = 3 ifTrue: [^N D].	delta = 4 ifTrue: [^N D sharp].	delta = 5 ifTrue: [^N E].	delta = 6 ifTrue: [^N F].	delta = 7 ifTrue: [^N F sharp].	delta = 8 ifTrue: [^N G].	delta = 9 ifTrue: [^N G sharp].	delta = 10 ifTrue: [^N A].	delta = 11 ifTrue: [^N A sharp].	delta = 0 ifTrue: [^N B]!la	^A!mi	^E!naturalNotes	^AllNatural!noteNamed: c 	"takes the case of flat into account. Sharps are naturally parsed out 	from the note name by the smalltalk parser.	Since the algorithm proceeds from the left, it accepts any number of sharps and 	flats (using the common algebra) :	N noteNamed: 'C#b#b#b#' ->  C# "	|  note |	(c size > 1 and: [c last = $b])		ifTrue: 			[note := self noteNamed: (c copyFrom: 1 to: c size - 1).			^note flat].	(c size > 1 and: [c last = $#])		ifTrue: 			[note := self noteNamed: (c copyFrom: 1 to: c size - 1).			^note sharp].	^self naturalNotes detect: [:n | n nameIs: c asSymbol]		ifNone: [^self error: 'unknown note name : ', c]!re	^D!sharpNotes	^self naturalNotes collect: [:n | n sharp]!si	^B!sol	^G! !!Siren.PitchClassAltered methodsFor: 'accessing'!following	^natural following!name	"yields a symbol"	^self printString asSymbol!natural	^natural!natural: value	natural := value!nom	"yields a symbol"	^self printString asSymbol!preceding	^natural preceding! !!Siren.PitchClassAltered methodsFor: 'testing'!isNatural	^false! !!Siren.LayoutManager methodsFor: 'generating'!addItem: anAss atNode: aPath in: aDisplayList	"Add the given item to the display list."	^self subclassResponsibility!generateDisplayList	"Generate and answer the receiver's display list."	| list |	list := DisplayList new.	view model items do:		[ :e |		 self addItem: e atNode: (OrderedCollection new) in: list].	list computePreferredBounds.	^list! !!Siren.LayoutManager methodsFor: 'accessing'!displayList	"Answer the receiver's display list (generated)."	^self generateDisplayList!displayListFor: aView	"Answer the receiver's display list (generated)."	view := aView.	^self generateDisplayList!orientation: aSymbol	"Set the receiver's orientation."	orientation := aSymbol!view: aView	"Set the receiver's view."	view := aView! !!Siren.HierarchyLayoutManager methodsFor: 'generating'!addItem1: aModelNode atNode: aPath in: aDisplayList	"Add the given item to the display list."	| wrapper displayPoint item path2 displayList2 |	displayPoint := self displayPositionFor: aPath.	length := length + 1.	item := treeAccessor itemFor: aModelNode.	wrapper := TranslatingWrapper on: item at: displayPoint.	(treeAccessor isTerminal: aModelNode)		ifFalse: [displayList2 := DisplayList new.			displayList2 model: aModelNode.			(treeAccessor childrenOf: aModelNode) do: [ :i | 				path2 := aPath copy.				path2 addLast: aModelNode.				self addItem: i					atNode: path2					in: displayList2].			displayList2 add: wrapper.			aDisplayList add: displayList2 atPath: aPath]		ifTrue: [aDisplayList add: item atPath: aPath]!addItem: aModelNode atNode: aPath in: aDisplayList	"Add the given item to the display list."	| displayPoint item path2 displayList2 |	displayPoint := self displayPositionFor: aPath.	length := length + 1.	item := treeAccessor itemFor: aModelNode.	item offset: displayPoint.	(treeAccessor isTerminal: aModelNode)		ifFalse: [displayList2 := DisplayList new.			displayList2 model: aModelNode.			(treeAccessor childrenOf: aModelNode) do: 				[ :i | 				path2 := aPath copy.				path2 addLast: aModelNode.				self addItem: i					atNode: path2					in: displayList2].			displayList2 add: item"; offset: displayPoint".			aDisplayList add: displayList2 atPath: aPath]		ifTrue: [aDisplayList add: item atPath: aPath]!displayPositionFor: aPath	"Answer the display position of the element at the given path."	^self subclassResponsibility!generateDisplayList	"Generate and answer the receiver's display list."	| list |	list := DisplayList new.	self addItem: treeAccessor subject			atNode: (OrderedCollection new)			in: list.	list computePreferredBounds.	^list! !!Siren.HierarchyLayoutManager methodsFor: 'accessing'!accessor: aTA	"Set the receiver's tree accessor to the argument."	treeAccessor := aTA!xStep: aNumber	"Set the receiver's x step size to the argument."	xStep := aNumber!yStep: aNumber	"Set the receiver's y step size to the argument."	yStep := aNumber! !!Siren.EventModifier methodsFor: 'application'!applyTo: evtList	evtList applyFunction: function to: selector startingAt: 0!valueIn: evtList at: time	^function at: (time / evtList dur)! !!Siren.EventModifier methodsFor: 'accessing'!function	"Answer the receiver's 'function'."	^function!function: anObject	"Set the receiver's instance variable 'function' to be anObject."	function := anObject!index	"Answer the receiver's 'index'."	^index!index: anObject	"Set the receiver's instance variable 'index' to be anObject."	index := anObject!scale	"Answer the receiver's 'scale'."	^scale!scale: anObject	"Set the receiver's instance variable 'scale' to be anObject."	scale := anObject!selector	"Answer the receiver's 'selector'."	^selector!selector: anObject	"Set the receiver's instance variable 'selector' to be anObject."	selector := anObject!start	"Answer the receiver's 'start'."	^start!start: anObject	"Set the receiver's instance variable 'start' to be anObject."	start := anObject!stop	"Answer the receiver's 'stop'."	^stop!stop: anObject	"Set the receiver's instance variable 'stop' to be anObject."	stop := anObject! !!Siren.EventModifier class methodsFor: 'instance creation'!function: aFunction	"Create a new modifier and initialize it"	^self new function: aFunction!new	"Create a new modifier and initialize it"	^ super new initialize.! !!Siren.Rubato methodsFor: 'initialize-release'!initialize	selector := #tempo! !!Siren.Rubato class methodsFor: 'examples'!example	"Rubato example"	| roll rub |	roll := ((Roll length: 2 rhythm: 100 note: 60) ampl: 80) eventList.	"100 msec = 10/sec""	rub := Rubato new function: (LinearFunction from: #((0 1) (0.5 0.8) (1 1.2))); scale: 10. "	rub := Rubato new function: (LinearFunction from: #((0 1) (1 1.5))); scale: 10.	rub applyTo: roll.	roll play! !!Siren.StructureAccessor methodsFor: 'item accessing'!itemFor: aModel	"Answer a display item for the argument"	(itemGenerator isMemberOf: Symbol)		ifTrue: [^aModel perform: itemGenerator].	(itemGenerator isMemberOf: BlockClosure)		ifTrue: [^itemGenerator value: aModel].	self error: 'Unknown item generator type.'! !!Siren.StructureAccessor methodsFor: 'accessing'!itemGenerator	"Answer the iG of the receiver."	^itemGenerator!itemGenerator: anObject	"Set the iG of the receiver."	itemGenerator := anObject!subject	"Answer the subject of the receiver."	^subject!subject: anObject	"Set the subject of the receiver."	subject := anObject! !!Siren.STreeAccessor methodsFor: 'accessing'!childAccessor: anObject	"Set the cA of the receiver."	childAccessor := anObject!terminalQuery: anObject	"Set the tQ of the receiver."	terminalQuery := anObject!treeAccessor	"Answer the receiver."	^self! !!Siren.STreeAccessor methodsFor: 'tree accessing'!childrenOf: aNode	"Answer the children of the argument by using the child accessor."	(childAccessor isSymbol)		ifTrue: [^aNode perform: childAccessor].	(childAccessor isMemberOf: BlockClosure)		ifTrue: [^childAccessor value: aNode].	self error: 'Unknown child accessor type.'!isTerminal: aNode	"Answer whether the argument is terminal by using the terminal query."	(terminalQuery isSymbol)		ifTrue: [^aNode perform: terminalQuery].	(terminalQuery isMemberOf: BlockClosure)		ifTrue: [^terminalQuery value: aNode].	self error: 'Unknown terminal query type.'!leavesOf: aRoot	"Answer the leaves of the argument by using the child accessor."	| kids leaves |	leaves := OrderedCollection new.	(childAccessor isSymbol)		ifTrue: [kids := aRoot perform: childAccessor]		ifFalse: [(childAccessor isMemberOf: BlockClosure)			ifTrue: [kids := childAccessor value: aRoot]			ifFalse: [self error: 'Unknown child accessor type.']].	kids isEmpty		ifFalse: [kids do:			[ :aChild |			(self isTerminal: aChild)				ifTrue: [leaves add: aChild]				ifFalse: [leaves addAll: (self leavesOf: aChild)]]].	^leaves! !!Siren.STreeAccessor class methodsFor: 'instance creation'!subject: aS terminalQuery: aTQ childAccessor: aCA itemGenerator: anIG	"Answer an initialized instance."	^(self new) subject: aS;			terminalQuery: aTQ;			childAccessor: aCA;			itemGenerator: anIG! !!Siren.MusicMagnitude methodsFor: 'comparing'!< aValue	"Answer whether the receiver is less than the argument"	"100 msec < 0.2 sec"	| arr more |	^(aValue class == self class)		ifTrue: [self value < aValue value]		ifFalse: [(aValue species == self species)			ifTrue: [arr := self species generalize: self and: aValue.				more := arr first.				more == self 		"if I'm the more general"					ifTrue: [aValue value < ((self coerceTo: aValue class) value)]					ifFalse: [self value < ((aValue coerceTo: self class) value)]]			ifFalse: [value < aValue]]!= aValue	"Answer whether the receiver and the argument are equal."	| arr more less |	^(aValue class == self class)		ifTrue: [self value = aValue value]		ifFalse: [(aValue species == self species)			ifTrue: [arr := self species generalize: self and: aValue.				more := arr first.				less := arr last.				(more value = (less coerceTo: more class) value)]			ifFalse: [value = aValue]]!hash	"Answer a SmallInteger unique to the receiver."	^value hash! !!Siren.MusicMagnitude methodsFor: 'accessing'!, anArgument	"Answer en Event with the given magnitude as its first property."	"440 Hz, 250 msec"	| event |	event := MusicEvent new.	event perform: self species propertyName with: self.	anArgument isMusicMagnitude ifTrue:		[event perform: anArgument species propertyName with: anArgument].	^event!value	"Answer the instance variable 'value'."	^value!value: theValue	"Accept the argument, 'theValue', as the new instance variable 'value' 		and signal any dependents."	value := theValue.	self changed: #value with: value! !!Siren.MusicMagnitude methodsFor: 'testing'!isImmediate	"Answer whether the receiver has an immediate representation."	^self units ~~ nil!isMusicMagnitude	"Answer true for the receiver and all subsclasses."	^true! !!Siren.MusicMagnitude methodsFor: 'arithmetic'!* aValue	"Answer the product of the receiver and the argument"	| arr more less |	^(aValue class == self class)		ifTrue: [self class new value: (self value * aValue value)]		ifFalse: [(aValue species == self species)			ifTrue: [arr := self species generalize: self and: aValue.				more := arr first.				less := arr last.				more class new value: (more value * (less coerceTo: more class) value)]			ifFalse: [self class new value: (value * aValue)]]!+ aValue	"Answer the sum of the receiver and the argument, doing generality-based	class coercion within a species using auto-generated coercion messages."	"If the same class, add values directly."	"If the same species, add values coercing generality."	"1 sec + 10 msec"	| arr more less |	^(aValue class == self class)		ifTrue: [self class new value: (self value + aValue value)]		ifFalse: [(aValue species == self species)			ifTrue: [arr := self species generalize: self and: aValue.				more := arr first.				less := arr last.				more class new value: (more value + (less coerceTo: more class) value)]			ifFalse: [self class new value: (value + aValue)]]!- aValue	"Answer the difference of the receiver and the argument"	| arr more less |	^(aValue class == self class)		ifTrue: [self class new value: (self value - aValue value)]		ifFalse: [(aValue species == self species)			ifTrue: [arr := self species generalize: self and: aValue.				more := arr first.				less := (arr last coerceTo: more class) value.				more == self					ifTrue: [more class new value: (more value - less)]					ifFalse: [more class new value: (less - more value)]]			ifFalse: [self class new value: (value - aValue)]]!/ aValue	"Answer the quotient of the receiver and the argument"	| arr more less |	^(aValue class == self class)		ifTrue: [self class new value: (self value / aValue value)]		ifFalse: [(aValue species == self species)			ifTrue: [arr := self species generalize: self and: aValue.				more := arr first.				less := (arr last coerceTo: more class) value.				more == self					ifTrue: [more class new value: (more value / less)]					ifFalse: [more class new value: (less / more value)]]			ifFalse: [self class new value: (value / aValue)]]! !!Siren.MusicMagnitude methodsFor: 'private'!species	"Answer MusicMagnitude."	^MusicMagnitude! !!Siren.MusicMagnitude methodsFor: 'printing'!printOn: aStream	"Print the receiver on the argument as a MM declaration."	^self printOn: aStream parens: true!printOn: aStream parens: useParens	"Print the receiver on the argument as a MM declaration."	useParens		ifTrue: [self isImmediate			ifFalse: [aStream nextPutAll: '(', self species name, ': ', 				self printValue, ')']			ifTrue: [aStream nextPutAll: '(', self printValue, self units, ')']]		ifFalse: [self isImmediate			ifFalse: [aStream nextPutAll: self species name, ': ', self printValue]			ifTrue: [aStream nextPutAll: self printValue, self units]]!printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream  parens: true.	^aStream contents!printStringParens: bool	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream  parens: bool.	^aStream contents!printValue	value isString ifTrue: [^value]."	value isFloat ifTrue: [^value printPlaces: 4]."	^value printString!storeOn: aStream	"Store the receiver on the argument as a MM declaration."	aStream nextPutAll: '(', self class name, ' value: ', value printString, ')'!units	"Answer the units string of the receiver."	^nil! !!Siren.MusicMagnitude methodsFor: 'converting'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^self class value: (rcvr perform: selector with: self value)!coerceTo: type	"Coerce the receiver to the given class and answer a new object."	^self perform: type ddMsgName!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^self class ddMsgName!msec	"Answer a MSecondDuration."	^self asMsec!usec	"Answer a MSecondDuration."	^self asUsec! !!Siren.MusicMagnitude class methodsFor: 'class constants'!color	"Answer the default color to display instances with (hack for making pretty graphs)."	| spec |	spec := self new species.	^(spec == MusicMagnitude)		ifTrue: [ColorValue gray]		ifFalse: [spec color]!propertyName	"Answer the receiver class's default property name."	^self subclassResponsibility!relativeMember	"Answer the receiver class's species member used as a relative magnitude."	^self subclassResponsibility! !!Siren.MusicMagnitude class methodsFor: 'instance creation'!value: aValue	"Answer and instance with the argument as its value."	^self new value: aValue! !!Siren.OrdinalMagnitude methodsFor: 'ordering'!< anotherOMag	"Answer whether the receiver is less than the argument."	^(self table includesKey: anotherOMag)		ifTrue: [((self table at: anotherOMag) == #<)]		ifFalse: [((self table associations detect:					[ :z |					(z value == #<) and: [z key < anotherOMag]]			ifNone: [nil]) ~~ nil)]!<< anotherOMag	"Specify that the receiver is less than the argument."	(self table includesKey: anotherOMag)		ifTrue: [(self table at: anotherOMag) == #<			ifFalse: [^self error: 'relationship ',							(self table at: anotherOMag),							' already specified.']]		ifFalse: [self table at: anotherOMag put: #<.				anotherOMag >> self]!<= anotherOMag	"Answer whether the receiver is less than or equal to the argument."	^(self table includesKey: anotherOMag)		ifTrue: [(((self table at: anotherOMag) == #<)				or: [(self table at: anotherOMag) == #<=])				or: [(self table at: anotherOMag) == #=]]		ifFalse: [(self table associations detect:			[ :r |			(((r value == #<) or: [r value == #=])							or: [r value == #<=])					and: [r key <= anotherOMag]]			ifNone: [nil]) ~~ nil]!=< anotherOMag	"Specify that the receiver is less than or equal to the argument."	(self table includesKey: anotherOMag)		ifTrue: [(self table at: anotherOMag) == #<=			ifFalse: [^self error: 'relationship ',							(self table at: anotherOMag),							' already specified.']]		ifFalse: [self table at: anotherOMag put: #<=.				anotherOMag => self]!== anotherOMag	"Specify that the receiver is equal to the argument."	(self table includesKey: anotherOMag)		ifTrue: [(self table at: anotherOMag) == #=			ifFalse: [^self error: 'relationship ',							(self table at: anotherOMag),							' already specified.']]		ifFalse: [self table at: anotherOMag put: #=.				anotherOMag == self]!=> anotherOMag	"Specify that the receiver is greater than or equal to the argument."	(self table includesKey: anotherOMag)		ifTrue: [(self table at: anotherOMag) == #>=			ifFalse: [^self error: 'relationship ',							(self table at: anotherOMag),							' already specified.']]		ifFalse: [self table at: anotherOMag put: #>=.				anotherOMag =< self]!=? anotherOMag	"Answer whether the receiver is equal to the argument."	^self == anotherOMag		ifTrue: [true]		ifFalse: [(self table includesKey: anotherOMag)			ifTrue: [((self table at: anotherOMag) == #=)]			ifFalse: [((self table associations detect:					[ :z |					(z value == #=) and: [z key =? anotherOMag]]				ifNone: [nil]) ~~ nil)]]!> anotherOMag	"Answer whether the receiver is greater than the argument."	^(self table includesKey: anotherOMag)		ifTrue: [(self table at: anotherOMag) == #>]		ifFalse: [(self table associations detect:					[ :z |					(z value == #>) and: [z key > anotherOMag]]			ifNone: [nil]) ~~ nil]!>= anotherOMag	"Answer whether the receiver is greater than or equal to the argument."	^(self table includesKey: anotherOMag)		ifTrue: [(((self table at: anotherOMag) == #>)				or: [(self table at: anotherOMag) == #>=])				or: [(self table at: anotherOMag) == #=]]		ifFalse: [(self table associations detect:			[ :r |			(((r value == #>) or: [r value == #=])							or: [r value == #>=])					and: [r key >= anotherOMag]]			ifNone: [nil]) ~~ nil]!>> anotherOMag	"Specify that the receiver is greater than the argument."	(self table includesKey: anotherOMag)		ifTrue: [(self table at: anotherOMag) == #>			ifFalse: [^self error: 'relationship ',							(self table at: anotherOMag),							' already specified.']]		ifFalse: [self table at: anotherOMag put: #>.				anotherOMag << self]! !!Siren.OrdinalMagnitude methodsFor: 'accessing'!hash	"Answer a SmallInteger unique to the receiver.  Essential.  See  	Object documentation whatIsAPrimitive."	<primitive: 75>	^self!table	"Answer the receiver's loop-up table--its or the class'."	^table == nil		ifFalse: [table]		ifTrue: [self class table == nil			ifFalse: [self class table at: self]			ifTrue: [table := Dictionary new.					table]]!value	"Signal an error."	^self error: 'OrdinalMagnitudes don''t have values!!'!value: theValue	"Signal an error."	^super value: theValue"	^self error: 'OrdinalMagnitudes don''t have values!!'"! !!Siren.OrdinalMagnitude methodsFor: 'arithmetic'!* aValue	"Answer that it is an error to attempt arithmetic with ordinal magnitudes."	^self error: 'Arithmetic is undefined for this receiver.'!+ aValue	"Answer that it is an error to attempt arithmetic with ordinal magnitudes."	^self error: 'Arithmetic is undefined for this receiver.'!- aValue	"Answer that it is an error to attempt arithmetic with ordinal magnitudes."	^self error: 'Arithmetic is undefined for this receiver.'!/ aValue	"Answer that it is an error to attempt arithmetic with ordinal magnitudes."	^self error: 'Arithmetic is undefined for this receiver.'!= aValue	"Answer whether the receiver and the argument are equivalent."	^self == aValue! !!Siren.OrdinalMagnitude methodsFor: 'initialize-release'!release	"Release the receiver's table."	| relatives |	table == nil		ifFalse: [relatives := table keys.			table := nil.			relatives do: [ :m | m release]]! !!Siren.OrdinalMagnitude methodsFor: 'printing'!printOn: aStream	"Print the receiver as an ordinal magnitude."	value == nil		ifTrue: [aStream nextPutAll:						(self class name "copyFrom: 1 to: 3")]		ifFalse: [aStream nextPutAll: value printString].! !!Siren.OrdinalMagnitude methodsFor: 'converting'!mostGeneral	"Answer that it is an error to attempt coercion with ordinal magnitudes."	^self error: 'Coercion is undefined for this receiver.'! !!Siren.OrdinalMagnitude class methodsFor: 'class initialization'!flush	"Release the shared class table and all instances."	"OrdinalMagnitude allSubclassesDo: [ :t | t flush]"	Table == nil		ifFalse: [Table keysDo: [ :d | d release].				Table := nil]		ifTrue: [self allInstancesDo: [ :d | d release]]!useTable	"Set up a shared class table for all instances."	Table := Dictionary new.! !!Siren.OrdinalMagnitude class methodsFor: 'instance creation'!new	"Answer a new instance and, if it's in use, add it to the table."	| me |	me := super new.	Table == nil ifFalse: [Table at: me put: Dictionary new].	^me!value: aValue	"Answer an instance"	^self new value: aValue! !!Siren.OrdinalMagnitude class methodsFor: 'table access'!table	"Answer the class' instance look-up table."	^Table!values	"Answer the sorted values."		^Table == nil		ifTrue: [self allInstances asSortedCollection]		ifFalse: [Table keys asSortedCollection]! !!Siren.Sharpness methodsFor: 'private'!species	"Answer Pitch."	^Pitch! !!Siren.Sharpness class methodsFor: 'examples'!example	"Demonstrate the use of an OrdinalMagnitude with a scale of sharpness."	"Sharpness example"	| a b c d e f |		"define six values with names."	a := Sharpness value: #soft.	b := Sharpness value: #nasal.	c := Sharpness value: #round.	d := Sharpness value: #high.	e := Sharpness value: #loud.	f := Sharpness value: #shrill.					"put them in some order."	a << b.	b << c.	c << d.	d << e.	e << f.					"now ask some queries and let them extrapolate."	Transcript show: '(f > e) ', (f > e) printString; cr.	Transcript show: '(f > b) ', (f > b) printString; cr.	Transcript show: '(f =? f) ', (f =? f) printString; cr.	Transcript show: '(f =? a) ', (f =? a) printString; cr.	Transcript show: '(f >= a) ', (f >= a) printString; cr.	Transcript show: '(d >= b) ', (d >= b) printString; cr.	Transcript show: '(b >= d) ', (b >= d) printString; cr.	Transcript show: '(f < a) ', (f < a) printString; cr.	Transcript show: '(a < f) ', (a < f) printString; cr.	Sharpness values inspect! !!Siren.EventListTreeEditor methodsFor: 'aspects'!listTree	"Answer up the event list dictionary tree"	^listTree! !!Siren.EventListTreeEditor methodsFor: 'initialize/release'!initialize	"EventListTreeEditor open"	| model |	scoreView := Siren.DisplayListSubcanvas new.	listTree := SelectionInTree new.	model := TreeModel on: (EventListTreeItem new lists: SirenSession eventLists)					displayRoot: false					 childrenWith: [ :ea |  (ea isCollection)							ifTrue: [ea values] 							ifFalse: [ea children values]] .	listTree list: model! !!Siren.EventListTreeEditor methodsFor: 'accessing'!scoreView	"Answer up the score view"	^scoreView! !!Siren.EventListTreeEditor class methodsFor: 'resources'!treeMenu		^Menu labelArray: #(copy cut paste again undo)! !!Siren.AbstractEvent methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same values."	^anObject isEvent		ifFalse: [false]		ifTrue: [self properties = anObject properties]! !!Siren.AbstractEvent methodsFor: 'accessing'!, anArgument	"Add the argument as a property of the receiver."	"440 Hz, 250 msec, (#voice -> #flute)"	"(440 Hz, 250 msec, (#voice -> #flute)), 		((1/4) => (471 Hz, (1/4) beat, (#voice -> #flute)))"	anArgument isMusicMagnitude		ifTrue: [self perform: anArgument species propertyName with: anArgument]		ifFalse: [(anArgument isMemberOf: Association)			ifTrue: [self perform: (anArgument key, ':') asSymbol with: anArgument value]			ifFalse: [(anArgument isMemberOf: EventAssociation)				ifTrue: [^EventList new add: self; add: anArgument]				ifFalse: [self error: 'Unknown property type.']]]!date	"Answer the receiver's 'date'."	self propCheck.	^properties at: #date ifAbsent: [nil]!date: obj	"Set the receiver's 'date'."	self propCheck.	^properties at: #date put: obj!inspect	"Inspect the receiver--Use a special inspector for Event types"	"EventInspectorView open: (EventInspector inspect: MEvent someInstance)""	EventInspectorView open: (EventInspector inspect: self)"	^super inspect!name	"Answer the receiver's 'name'."	self propCheck.	^properties at: #name ifAbsent: ['']!open	"Edit, play (if <shift>) or inspect (if <ctrl>) the receiver, depending on the keyboard state"	^InputState default shiftDown		ifTrue: [self play]		ifFalse: [InputState default ctrlDown			ifTrue: [self inspect]			ifFalse: [self edit]]!species	"Answer AEvent--all subclasses look like me"	^AbstractEvent!version	"Answer the receiver's 'version'."	self propCheck.	^properties at: #version ifAbsent: [nil]!version: obj	"Set the receiver's 'version'."	self propCheck.	^properties at: #version put: obj! !!Siren.AbstractEvent methodsFor: 'testing'!isEvent	"Answer true."	^true!isSound	"Answer false."	^false! !!Siren.AbstractEvent methodsFor: 'private'!propCheck	"Make sure the receiver has a property list dictionary."	properties == nil		ifTrue: [properties := IdentityDictionary new].! !!Siren.AbstractEvent methodsFor: 'initialize-release'!initialize	"Set up the default state of the receiver--add props. dict."	properties := IdentityDictionary new.!release	"Flush the receiver."	properties == nil		ifFalse: [properties associationsDo: 			[ :a |			a key release.			a value release]].	properties  := nil! !!Siren.AbstractEvent methodsFor: 'scheduling'!scheduleOn: aChannel	"Perform or interpret the receiver on the argument; override in subclasses."	aChannel schedule: self at: 0! !!Siren.AbstractEvent methodsFor: 'printing'!display: showHide field: filter on: stream	| obj |	(showHide includes: filter)		ifTrue: [obj := self at: filter ifAbsent: [''].			obj isString ifFalse: [obj := obj printString].			obj isEmpty				ifFalse: [stream isEmpty 						ifFalse: [stream nextPutAll: ': '].					stream nextPutAll: obj]]!displayField: filter on: stream	| obj |	stream isEmpty ifFalse: [stream nextPutAll: ': '].	obj := self at: filter ifAbsent: [''].	obj isString ifFalse: [obj := obj printString].	stream nextPutAll: obj!printOn: aStream 	"Format and print the receiver on the argument."	aStream nextPut: $(.	super printOn: aStream.	aStream space.	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']].	aStream nextPut: $); cr!storeOn: aStream 	"Format and store the source the receiver on the argument."	aStream nextPutAll: (properties == nil			ifTrue: ['(', self class name, '']			ifFalse: ['((', self class name, '']).	properties == nil		ifFalse: [aStream nextPutAll: ')'.			properties associationsDo: [ :ass |					aStream nextPutAll: ' at: '.					ass key storeOn: aStream.					aStream nextPutAll: ' put: '.					ass value storeOn: aStream.					aStream nextPut: $;; cr.]].	aStream nextPutAll: ')'!templateFields	"Answer the field names for the instances of the receiver class."	| coll |	coll := self class templateFields asOrderedCollection.	coll remove: #properties.	properties ifNotNil:		[coll addAll: properties keys].	^coll! !!Siren.AbstractEvent methodsFor: 'properties'!at: aProp	"Answer a value from the property list dictionary (or an instVar)."	self propCheck.	^properties at: aProp ifAbsent: [nil]!at: aProp ifAbsent: otherCase	"Answer a value from the property list dictionary or the value of the given block.""	(self respondsTo: aProp)		ifTrue: [^self perform: aProp].	^properties == nil		ifTrue: [otherCase]		ifFalse: [properties at: aProp ifAbsent: otherCase value]"	properties ifNil: [^nil].	^properties at: aProp ifAbsent: 		["(self respondsTo: aProp)			ifTrue: [self perform: aProp]			ifFalse: ["otherCase value"]"]!at: aProp put: aVal	"Set a value in the receiver's property list dictionary (or instVar)."	self propCheck.	properties at: aProp put: aVal!doesNotUnderstand: aMessage 	"Handle doesNotUnderstand: to try to access the property dictionary.	If this is unsuccessful, announce that the receiver does not understand the argument."	"N.B.: One may want to turn this off for debugging."	| sel |	sel := aMessage selector.	(sel includes: $:)									"access property"		ifFalse: [(properties ~~ nil and: [properties includesKey: sel])			ifTrue: [^properties at: sel]]		ifTrue: [((sel occurrencesOf: $:) = 1)		"set property"			ifTrue: [^self at: (sel copyUpTo: $:) asSymbol					put: (aMessage arguments at: 1)]].	^super doesNotUnderstand: aMessage					"otherwise"!hasProperty: aSymbol	"Answer whether or not the receiver's property list dictionary includes the symbol as a key."	properties ifNil: [^false].	^properties includesKey: aSymbol!properties	"Answer the receiver's property list dictionary."	^properties!respondsTo: aSymbol	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector OR if the selector is unary and is a key 	in the receiver's property dictionary."	(super respondsTo: aSymbol) ifTrue: [^true]."	((properties ~~ nil) and: [properties includesKey: aSymbol])		ifTrue: [^true].	(aSymbol occurrencesOf: $:) = 1 ifTrue: [^true]."	^false! !!Siren.AbstractEvent class methodsFor: 'examples'!eventInspectExample	"Demonstrate the creation of an AEvent."	"AbstractEvent example"	((AbstractEvent new) color: #green; shape: #round) inspect!example	"Demonstrate the creation of an AEvent."	"AbstractEvent example inspect"	^(AbstractEvent new) color: #green; shape: #round! !!Siren.DurationEvent methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same values."	^anObject isEvent		ifFalse: [false]		ifTrue: [((self duration = anObject duration) and:				[super = anObject])]! !!Siren.DurationEvent methodsFor: 'accessing'!ampl	"Answer the receiver's ampl"	^nil!dur	"Answer the receiver's duration."	^self duration!dur: newValue	"Set the receiver's duration."	^self duration: newValue!duration	"Answer the receiver's duration."	^duration!duration: newValue	"Set the receiver's duration."	newValue species == Duration		ifTrue: [duration := newValue]		ifFalse: [duration := Duration value: newValue]!index: aNumber	"Set the receiver's event index."	index := aNumber!order	"Answer the receiver's order."	^self at: #order ifAbsent: [0].!order: anOrder	"Set the receiver's order."	^self at: #order put: anOrder!pitch	"Answer the receiver's pitch"	^nil!voice	"Answer the receiver's voice or some reasonable default."	self propCheck.	^properties at: #voice ifAbsent: [nil]!voice: aValue	"Set the receiver's voice to the argument."	properties at: #voice put: aValue! !!Siren.DurationEvent methodsFor: 'scheduling'!isActive	"Answer whether the receiver is in a schedule"	^nil ~= index!nextTime: ignored	"Answer whether to reschedule the receiver"	^nil!play	"Play the receiver by scheduling it."	^self playAt: nil!playAt: aTime	"Play the receiver on its voice then."		^self playOn: self voice at: aTime!playOn: aVoice at: aTime	"This is a no-op in the abstract class"	^self!reset	"Reset the receiver's index."	index := nil.	startedAt := Time microsecondClock!scheduleAt: aTime	"Play the receiver on its voice then."		self playAt: aTime.	^self nextTime: aTime! !!Siren.DurationEvent methodsFor: 'printing'!printOn: aStream 	"Format and print the receiver on the argument."	aStream nextPutAll: '(', self class name.	duration == nil		ifFalse: [aStream nextPutAll: ' ', duration printString]. 	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']].	aStream nextPutAll: ')'; cr!storeOn: aStream 	"Format and store the source the receiver on the argument."	aStream nextPutAll: (properties == nil			ifTrue: ['(', self class name, '']			ifFalse: ['((', self class name, '']).	duration == nil		ifFalse: [aStream nextPutAll: ' dur: ', duration value storeString]. 	properties == nil		ifFalse: [aStream nextPutAll: ')'.			properties associationsDo: [ :ass |					aStream nextPutAll: ' at: '.					ass key storeOn: aStream.					aStream nextPutAll: ' put: '.					ass value storeOn: aStream.					aStream nextPut: $;; cr.]].	aStream nextPutAll: ')'! !!Siren.DurationEvent methodsFor: 'initialize-release'!initialize	"Set up the default state of the receiver--add props. dict."	super initialize.	index := nil.	startedAt := nil.	realTime :=  true! !!Siren.DurationEvent class methodsFor: 'examples'!eventInspectExample	"Demonstrate the creation of a DEvent."	"DurationEvent example inspect"	(DurationEvent dur: 250 msec voice: #flute) inspect!example	"Demonstrate the creation of a DEvent."	"DurationEvent example"	^DurationEvent dur: 250 msec voice: #flute! !!Siren.DurationEvent class methodsFor: 'instance creation'!dur: aD voice: aVoice	"Answer a DurationEvent instance initialized with the arguments."	^self new duration: aD; voice: aVoice! !!Siren.MusicEvent methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same values."	^anObject isEvent		ifFalse: [false]		ifTrue: [(self pitch = anObject pitch) and: 			[(self loudness = anObject loudness) and: 				[super = anObject]]]! !!Siren.MusicEvent methodsFor: 'accessing'!ampl	"Answer the receiver's loudness"	^loudness!ampl: aValue	"Set the receiver's loudness to the argument."	^self loudness: aValue!amplitude	"Answer the receiver's loudness"	^loudness!amplitude: aValue	"Set the receiver's loudness to the argument."	(aValue species == Amplitude)		ifFalse: [loudness := Amplitude value: aValue]		ifTrue: [loudness := aValue]!loudness	"Answer the receiver's loudness"	^loudness!loudness: aValue	"Set the receiver's loudness to the argument."	(aValue species == Amplitude)		ifFalse: [loudness := Amplitude value: aValue]		ifTrue: [loudness := aValue]!pitch	"Answer the receiver's pitch"	^pitch!pitch: aValue	"Set the receiver's pitch to the argument."	(aValue species == Pitch)		ifFalse: [pitch := Pitch value: aValue]		ifTrue: [pitch := aValue]!voice	"Answer the receiver's voice"	^voice!voice: aValue	"Set the receiver's voice to the argument."	voice := aValue! !!Siren.MusicEvent methodsFor: 'scheduling'!playOn: aVoice at: aTime	"Play the receiver on the voice then."	aVoice == nil		ifTrue: [^Voice default playEvent: self at: aTime].	aVoice isVoice		ifTrue: [aVoice playEvent: self at: aTime].	(SirenSession voices includesKey: aVoice)			ifTrue: [^(SirenSession voices at: aVoice) playEvent: self at: aTime].	aVoice isInteger			ifTrue: [Voice default playEvent: self at: aTime]! !!Siren.MusicEvent methodsFor: 'printing'!printOn: aStream 	"Format and print the receiver on the argument.""	^self printVerboseOn: aStream"	^self printTerseOn: aStream!printTerseOn: aStream 	"Format and print the receiver on the argument as tersely as possible."	duration == nil		ifFalse: [aStream nextPutAll: duration printString]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' ', pitch printString].	loudness == nil"		ifFalse: [aStream nextPutAll: ' (l: ', loudness value printString,')']."		ifFalse: [aStream nextPutAll: ' ', loudness printString].	voice == nil		ifFalse: [aStream nextPutAll: ' (v: ', voice printString, ')'].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				aStream nextPutAll: ' (', ass key, ': ', ass value printString, ')']].	aStream "nextPutAll: ')';" cr!printVerboseOn: aStream 	"Format and print the receiver on the argument."	aStream nextPutAll: '(MEvent'; crtab.	duration == nil		ifFalse: [aStream nextPutAll: ' duration: ', duration printString; crtab]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' pitch: ', pitch printString; crtab].	voice == nil		ifFalse: [aStream nextPutAll: ' voice: ', voice printString; crtab].	loudness == nil		ifFalse: [aStream nextPutAll: ' loudness: ', loudness value printString].	properties == nil		ifFalse: [properties associationsDo:				[ :ass |				aStream crtab; nextPutAll: ' ', ass key, ': ', ass value printString]].	aStream nextPutAll: ')'; cr!readDataFrom: aDataStream size: size	"Read a new event from the given stream using the compact format."	| propSize |	duration := MusicMagnitude readDataFrom: aDataStream.	pitch := MusicMagnitude readDataFrom: aDataStream.	loudness := MusicMagnitude readDataFrom: aDataStream.	voice := aDataStream next.	propSize := size - self class instSize.	propSize > 0 ifTrue: [self propCheck].	propSize timesRepeat:		[properties at: (aDataStream next) put: (aDataStream next)]!storeDataOn: aDataStream	"Store myself on a DataStream. Answer self."	"Format: 4 normal IVs, properts as key/value (or nil)"	| cntInstVars cntProps |	cntInstVars := self class instSize.	properties isNil		ifFalse: [cntProps := properties size]		ifTrue: [cntProps := 0].	aDataStream		beginInstance: self class		size: cntInstVars + cntProps.	MusicMagnitude store: duration on: aDataStream.	MusicMagnitude store: pitch on: aDataStream.	MusicMagnitude store: loudness on: aDataStream.	aDataStream nextPut: voice.	properties isNil		ifFalse: [properties associationsDo: 				[ :ass |				aDataStream nextPut: ass key.				aDataStream nextPut: ass value]]!storeOn: aStream 	"Format and store the source the receiver on the argument."	aStream nextPutAll: (properties == nil			ifTrue: ['(', self class name, '']			ifFalse: ['((', self class name, '']).	duration == nil		ifFalse: [aStream nextPutAll: ' dur: ', duration value storeString]. 	pitch == nil		ifFalse: [aStream nextPutAll: ' pitch: ', pitch value storeString].	loudness == nil		ifFalse: [aStream nextPutAll: ' ampl: ', loudness value storeString].	voice == nil		ifFalse: [aStream nextPutAll: ' voice: ', voice storeString].	properties == nil		ifFalse: [aStream nextPutAll: ')'.			properties associationsDo: [ :ass |					aStream nextPutAll: ' at: '.					ass key storeOn: aStream.					aStream nextPutAll: ' put: '.					ass value storeOn: aStream.					aStream nextPut: $;; cr.]].	aStream nextPutAll: ')'! !!Siren.MusicEvent methodsFor: 'processing'!transposeBy: aStep	"Add the given step to the receiver's pitch."	self pitch: (self pitch + aStep)! !!Siren.MusicEvent class methodsFor: 'examples'!eventInspectExample	"Demonstrate the terse format of event description."	"MusicEvent eventInspectExample"	(440 Hz, 250 msec, (#voice -> #flute), 0.7071 ampl) inspect"	((880 Hz, 250 msec, (#voice -> #flute), 0.7071 ampl) accent: #sfz) inspect"!example	"Demonstrate the terse format of event description."	"MusicEvent example inspect"	^(440 Hz, 250 msec, (#voice -> #flute), 0.7071 ampl)"	((880 Hz, 250 msec, (#voice -> #flute), 0.7071 ampl) accent: #sfz) inspect"! !!Siren.MusicEvent class methodsFor: 'class initialization'!initialize	"Initialize the global dictionary of Events (optional)."	"MEvent initializeEventDictionary"	Smalltalk at: #Events put: Dictionary new!initializeEventDictionary	"Initialize the global dictionary of Events (optional)."	"MEvent initializeEventDictionary"	Smalltalk at: #Events put: Dictionary new! !!Siren.MusicEvent class methodsFor: 'instance creation'!ampl: anA voice: aVoice	"Answer a MusicEvent instance initialized with the arguments."	^self new loudness: anA; voice: aVoice!dur: aD ampl: anA voice: aVoice	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 ampl: 127 voice: 2"	"MusicEvent dur: 1/4 ampl: #mf voice: #flute"	^self new duration: aD;			loudness: anA;			voice: aVoice!dur: aD pitch: aP	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 pitch: 30"	"MusicEvent dur: 1/4 pitch: #c3"	^self new duration: aD; pitch: aP!dur: aD pitch: aP ampl: anA	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 pitch: 30 ampl: 127 "	"MusicEvent dur: 1/4 pitch: #c3 ampl: #mf "	^self new duration: aD;			pitch: aP; 			loudness: anA!dur: aD pitch: aP ampl: anA voice: aVoice	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 pitch: 30 ampl: 127 voice: 2"	"MusicEvent dur: 1/4 pitch: #c3 ampl: #mf voice: #flute"	^self new duration: aD;			pitch: aP; 			loudness: anA;			voice: aVoice!dur: aD pitch: aP voice: aVoice	"Answer a MusicEvent instance initialized with the arguments."	^self new duration: aD; pitch: aP; voice: aVoice!dur: aD voice: aVoice ampl: anA	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 pitch: 30 ampl: 127 voice: 2"	"MusicEvent dur: 1/4 pitch: #c3 ampl: #mf voice: #flute"	^self new duration: aD;			loudness: anA;			voice: aVoice!duration: aD pitch: aP	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 pitch: 30"	"MusicEvent dur: 1/4 pitch: #c3"	^self new duration: aD; pitch: aP!duration: aD pitch: aP ampl: anA	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent dur: 1000 pitch: 30 ampl: 127 "	"MusicEvent dur: 1/4 pitch: #c3 ampl: #mf "	^self new duration: aD;			pitch: aP; 			loudness: anA!pitch: aP	"Answer a MusicEvent instance initialized with the argument."	"MusicEvent pitch: 440.0"	"MusicEvent pitch: #c3"	^self new pitch: aP!pitch: aP ampl: anA voice: aVoice	"Answer a MusicEvent instance initialized with the arguments."	"MusicEvent pitch: 30 ampl: 127 voice: 2"	"MusicEvent pitch: #c3 ampl: #mf voice: #flute"	^self new pitch: aP; 			loudness: anA;			voice: aVoice! !!Siren.EventList methodsFor: 'processing'!addValue: theValue toProp: theSelector	"Add theValue to the aspect refered to by theSelector of all events."	"someEventList addValue: (MSecondDuration value: 10000) toProp: #duration"	"someEventList addValue: (MIDIPitch value: 100) toProp: #pitch"	self applyBlock: [ :v | (v class new value: (v value + theValue))] 			toProp: theSelector!applyBlock: theBlock toProp: theSelector	"Apply the given block to the aspect refered to by theSelector of all events."	"someEList applyBlock: [ :d | (MSecondDuration value: (d asMS value * 10))] 			toProp: #duration"	| anEvent val |	self events do: 		[ :anAssociation |		anEvent := anAssociation value.		anEvent isEventList			ifTrue: [anEvent applyBlock: theBlock toProp: theSelector]			ifFalse: [val := anEvent perform: theSelector.				anEvent perform: ((theSelector, ':') asSymbol)						with: (theBlock value: val)]]!applyFunction: aFunction to: aSelector	"Apply the given function to the range of the given selector"	^self applyFunction: aFunction to: aSelector startingAt: 0!applyFunction: aFunction to: aSelector startingAt: sTime	"Apply the given function to the range of the given selector starting at sTime."	| aTime anEvent tDur timeC |	tDur := self duration value.	self events do:		[ :anAssoc |		aTime := anAssoc key value.		timeC := anAssoc key class.		anEvent := anAssoc value.		aSelector == #tempo			ifTrue: [anAssoc key: (timeC value: (aTime * (aFunction at: (aTime / tDur))))]			ifFalse: [anEvent isEventList 				ifTrue: [anEvent apply: aFunction to: aSelector startingAt: aTime]				ifFalse: [ | oldVal |					oldVal := anEvent perform: aSelector.					anEvent perform: ((aSelector, ':') asSymbol) 							with: (oldVal class value: (oldVal value * (aFunction at: (aTime / tDur))))]]]!chooseRange: theRange toProp: theSelector	"Select a value from the given range for the aspect refered to by theSelector of all events."	"someEventList chooseRange: (500 to: 700) toProp: #duration"	"someEventList chooseRange: #(36 38 40 41 43 45) toProp: #pitch"		| size |	size := theRange size.	self applyBlock: [ :v | (v class new value: 					(theRange at: ((Random new next * size) truncated + 1)))] 			toProp: theSelector!edit	"Open your favorite graphical editor on the receiver (left-shift-sensitive)"	HauerSteffensView openOnEventList: self"	InputState default  shiftDown		ifTrue: [CMNView openOn: ((EventListEditor new) list: self)]		ifFalse: [InputState default  ctrlDown			ifTrue: [SequenceView openOn: 						((EventListEditor new) list: self)]			ifFalse: [HauerSteffensView openOn: 					((EventListEditor new) list: self)]]"!scale: theSelector by: theValue	"Multiply the aspect refered to by theSelector of all events by theValue."	"someEventList scale: #duration by: 2"	self applyBlock: [ :v | (v class new value: (v value * theValue))] 			toProp: theSelector!scaleStartTimesBy: theValue	"Multiply the start times all events by theValue."	self events do: [ :assoc | assoc key: (assoc key * theValue) ].	self recomputeDuration!scaleValue: theValue toProp: theSelector	"Multiply the aspect refered to by theSelector of all events by theValue."	"someEventList scaleValue: 3 toProp: #duration"	self applyBlock: [ :v | (v class new value: (v value * theValue))] 			toProp: theSelector!setValue: theValue toProp: theSelector	"Set the aspect refered to by theSelector of all events to theValue."	"someEventList scaleValue: (MSecondDuration value: 10) toProp: #duration"	self applyBlock: [ :v | theValue] 			toProp: theSelector!spreadValue: theRandomPercent toProp: theSelector	"Spread the given property of all events by the given random range (%+-)."	self applyBlock: [ :v | (v class new value: (v value 				* (1 + ((Random new next - 0.5) 					* theRandomPercent / 50) rounded)))] 			toProp: theSelector! !!Siren.EventList methodsFor: 'collecting'!collect: aBlock	"Iterate over the receiver's events with the given block"	| newList |	newList := EventList new.	self events do: 		[ :anE |		newList add: (aBlock value: anE)].	^newList!collectAll: aBlock	"Iterate over the receiver's events with the given block"	| newList |	newList := EventList new.	self events do: 		[ :anE |		anE isEventList				"hierarchical tree descent"			ifTrue: [(anE collectAll: aBlock) do:				[ :evt | newList add: (evt key + anE key) => evt value]]			ifFalse: [newList add: (aBlock value: anE)]].	^newList!do: aBlock	"Iterate over the receiver's event associations with the given block"	self events do: aBlock!eventsDo: aBlock	"Iterate over the receiver's events with the given block"	^self events do: [:assoc | aBlock value: (assoc event) ]!excerptFrom: start to: end	"Answer a hierarchical list delineated by the given times."	| newList newEvent |	newList := EventList newAnonymous.	events do: 		[ :anAssoc |				"iterate over all my events"		(anAssoc key value between: start and: end) 			ifTrue: [newEvent := anAssoc value.				(newEvent isEventList)	"map and add normal events"					ifFalse: [newList add: anAssoc]									"unfold sub-event lists recursively"					ifTrue: [newList add:							(newEvent excerptFrom: 0 									to: (end - anAssoc key))]]].	^newList!expanded	"Expand all sub-event lists and answer one large flat list."	| newList newEvent |	newList := EventList newAnonymous.	events do: [ :anEvent |				"iterate over all my events"		newEvent := anEvent value "copy".	"copy them"		(newEvent species == EventList) 			ifTrue:						"unfold sub-lists recursively"				[newEvent expanded do: [ :aSubEvent |					newList add: (newEvent map: 						((anEvent key + aSubEvent key) 								-> aSubEvent value))]]			ifFalse: 						"map and add normal events"				[newList add: ( anEvent key -> newEvent)]].	^newList!expandedFrom: start to: end	"Expand all sub-event lists and answer one flat list with events between the given times."	| newList newEvent |	((start value = 0) and: [end > duration])		ifTrue: [^self expanded].	newList := EventList newAnonymous.	events do: 		[ :anEvent |				"iterate over all my events"		newEvent := anEvent value.		(anEvent key between: start and: end) 			ifTrue: [newEvent isEventList							 "map and add normal events"				ifFalse: [newList add: 							(anEvent key => newEvent copy)]								"unfold sub-event lists recursively"				ifTrue: [(newEvent							expandedFrom: (MSecondDuration value: 0)							to: (end - anEvent key)) 						do: [ :aSubEvent |							newList add: (newEvent map: 									((anEvent key + aSubEvent key) 										=> aSubEvent value))]]]].	^newList!group: selection	"Group the argument's events as a sub-event list in the receiver's list."	| temp startTime |	selection isEventList		ifFalse: [self remove: selection.			self add: ((EventList newAnonymous) add: (selection key: 0))						at: selection key]		ifTrue: [startTime := selection events first key.			selection do:				[ :anAss |				temp := self remove: anAss.				temp == nil					ifTrue: [selection remove: anAss].				startTime = 0					ifFalse: [anAss key: (anAss key - startTime)]].			selection duration: (selection duration value - startTime).			self add: selection at: startTime]!includes: anAss	"Answer whether the given association is in the receiver's event list."	^self events includes: anAss!keysAndValuesDo: aBlock	^self events do:		[ :assoc |		aBlock value: assoc key value: assoc value].!remove: anA	"Remove the given event from the receiver's  collection"	| victims |	victims := self events removeAllSuchThat:		[ :item |		(item key = anA key) and: [item value = anA value]].	victims isEmpty		ifTrue: [^self error: 'no such event in list...'].	self changed: #deleted.	^victims size = 1		ifTrue: [victims first]		ifFalse: [victims]!select: aBlock	"Iterate over the receiver's events with the given block"	| newList |	newList := EventList new.	self events do: 		[ :anE |		(aBlock value: anE)			ifTrue: [newList add: anE]].	^newList!selectAll: aBlock	"Iterate over the receiver's events with the given block"	| newList |	newList := EventList new.	self events do: 		[ :anE |			anE isEventList				"hierarchical tree descent"			ifTrue: [(anE selectAll: aBlock) do:				[ :evt | newList add: (evt key + anE key) => evt value]]			ifFalse: [(aBlock value: anE)				ifTrue: [newList add: anE]]].	^newList!selectKey: aBlock	"Iterate over the receiver's events with the given block"	| newList |	newList := EventList new.	self events do: 		[ :anE |		anE isEventList				"hierarchical tree descent"			ifTrue: [(anE selectKey: aBlock) do:				[ :evt | newList add: (evt key + anE key) => evt value]]			ifFalse: [(aBlock value: anE key)				ifTrue: [newList add: anE]]].	^newList!selectValue: aBlock	"Iterate over the receiver's events with the given block"	| newList |	newList := EventList new.	self events do: 		[ :anE |		anE isEventList				"hierarchical tree descent"			ifTrue: [(anE selectValue: aBlock) do:				[ :evt | newList add: (evt key + anE key) => evt value]]			ifFalse: [(aBlock value: anE value)				ifTrue: [newList add: anE]]].	^newList!timesDo: aBlock	"Iterate over the receiver's events' relative start times with the given block"	^self events do: [ :assoc | aBlock value: (assoc key) ]! !!Siren.EventList methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same events."	^anObject isEventList		ifFalse: [false]		ifTrue: [((self duration = anObject duration) and:				[self events = anObject events])]! !!Siren.EventList methodsFor: 'accessing'!addModifier: aModifier	"Add the given event modifier to the receiver's special modifier collection"	properties == nil		ifTrue: [properties := Dictionary new].	(properties includesKey: #modifiers)		ifFalse: [properties at: #modifiers put: OrderedCollection new].	(properties at: #modifiers) add: aModifier!code	"Answer a symbol about the receiver's events' coding, usually #durations or #noteOnOff"	^properties at: #code ifAbsent: [nil]!code: aSymbol	"Set the code about the receiver's events, usually #durations or #noteOnOff"	self propCheck.	properties at: #code put: aSymbol!deepCopy	"Answer a careful deep copy."	| newEL |	newEL := EventList newAnonymous.	self name == nil		ifFalse: [newEL name: self name deepCopy asSymbol].		properties == nil ifFalse:		[properties associationsDo: [ :anAssociation |			newEL at: anAssociation key copy put: anAssociation value copy]].	self events do: [ :anAssociation |		newEL add: ((anAssociation key copy) => (anAssociation value copy)) ].	^newEL!defaultEventClass	"Answer the default note event class."	^MusicEvent!duration	"Answer the receiver's duration."	| du |	du := events first key + events first value duration.	events do:		[ :assoc | | eDu |			eDu := assoc key + assoc value duration.			du := du max: eDu].	^du!name	"Answer the receiver's name."	self propCheck.	^properties at: #name ifAbsent: ['']!name: aName	"Set the receiver's name."	properties at: #name put: aName asSymbol!next	"Answer the next event in the list."	index ifNil: [index := 0].	^self events at: (index := index + 1)!removeModifier: aModifier	"Remove the given event modifier from the receiver's collection."	^(properties == nil or: [(properties includesKey: #modifiers) not])		ifTrue: [nil]		ifFalse: [(properties at: #modifiers) remove: aModifier ifAbsent: [nil]]!shallowCopy	"Answer a shallow copy of the receiver's events."	| newEL |	newEL := super shallowCopy.	newEL events: SortedCollection new.	self events do: 		[ :anAssociation |		newEL add: ((anAssociation key copy) => (anAssociation value copy))].	^newEL!size	"Answer the number of events in the receiver."	events ifNil: [^0].	^events size!tempo: someValue	"Set the tempo to scale the events by."	self propCheck.	properties at: #tempoScale put: someValue!voices	"Answer the collection of voices used by thereceiver  event list."	"EventList randomExample voices"	| coll ev |	coll := OrderedCollection new.	events do:		[ :ass |		ev := ass event.		ev voice ifNotNil:			[(coll includes: ev voice)				ifFalse: [coll add: ev voice]]].	^coll! !!Siren.EventList methodsFor: 'code conversion'!continueProperties	"Fill in missing properties with values that are continued from previous ones."	"((440 Hz, (1/4 beat), (#voice -> #flute)), (1/4 => 460 Hz), (1/2 => 500 Hz), (3/4 => 320 Hz), (4/4 => 440 Hz)) continueProperties"	| opitch oduration oloudness ovoice ev |	ev := events first value.	ev pitch == nil ifFalse: [opitch := ev pitch].	ev duration == nil ifFalse: [oduration := ev duration].	ev loudness == nil ifFalse: [oloudness := ev loudness].	ev voice == nil ifFalse: [ovoice := ev voice].	events do: [ :evt |		evt pitch == nil ifTrue: [evt pitch: opitch]					ifFalse: [opitch := evt pitch].		evt duration == nil ifTrue: [evt duration: oduration]					ifFalse: [oduration := evt duration].		evt loudness == nil ifTrue: [evt loudness: oloudness]					ifFalse: [oloudness := evt loudness].		evt voice == nil ifTrue: [evt voice: ovoice]					ifFalse: [ovoice := evt voice]]!findNoteOff: anAssociation	"Locate the noteOff event that corresponds to anAssociation; answer the sum of the delta times between (the duration)"	| instrument time assoc1 assoc2 event2 event1 |	instrument := anAssociation value voice.	time := 0.	event1 := anAssociation value.	assoc1 := anAssociation.	[true] whileTrue:		[[assoc2 := events after: assoc1]  		"check next"			on: Error			do: [ :ex | assoc2 := nil].		assoc2 isNil ifTrue: [^time].			"if missing."		time := time + (assoc2 key value).			"sum delta times"		event2 := assoc2 value.		event2 voice = instrument						"if same instrument"			ifTrue: [event2 ampl asMIDI = 0				"if ampl = 0"				ifTrue: [event2 pitch = event1 pitch		"if same note"					ifTrue: [^assoc2 key - anAssociation key]]]. "^time"		event1 := event2.		assoc1 := assoc2].						"next event"!setDurations	"Take a delta-time encoded event list and determine the durations."	| time sTime event newEventList anAss ind |	(self code == #noteOnOff)				"if i'm delta not coded"		ifFalse: [^nil ].	newEventList := SortedCollection new.	ind := 1.	[ind <= events size] whileTrue:			"for all note on events"		[ | am |		anAss := events at: ind.		sTime := anAss key.		event := anAss value copy.		am := event ampl value.		(am notNil and: [am > 0])			"until note off found"			ifTrue: [((event command) bitAnd: 16rF0) = 16r90				ifTrue: [time := self findNoteOff: anAss.					time isNil						ifTrue: [self error: 'no note off found...' ].					event duration: (Duration value: time).									"strip the Midi command"					event voice: (event voice bitAnd: 16r0F).					newEventList add: (sTime => event).					Transcript show: ind printString, ' ']								"meta or control event"				ifFalse: ["Transcript show: 'meta event'; cr."					newEventList add: (sTime => event)]].		ind := ind + 1].	self code: #durations.						"now remove noteOffs"	newEventList isEmpty		ifFalse: [self events: newEventList.			self start: newEventList first key].	self at: #events put: (events size).	self changed! !!Siren.EventList methodsFor: 'testing'!hasItems	"Answer whether or not the receiver has items or components (true)."	^true!isEmpty	"Answer whether the receiver is an event list (true)."	^events isEmpty!isEventList	"Answer whether the receiver is an event list (true)."	^true!species	"Answer EventList."	^EventList! !!Siren.EventList methodsFor: 'private'!map: anAssociation	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value.	self pitch == nil 			"if i'm transposed"		ifFalse: [anE pitch: (Pitch value: (anE pitch + self pitch))].	self loudness == nil 		"or scaled"		ifFalse: [anE loudness: (anE loudness + self loudness)].	(properties == nil) 		"or have props"		ifFalse: [properties associationsDo: [ :ass |			ass key == #tempo				ifTrue: [aTime := aTime * ass value.						anE duration: anE duration * ass value]				ifFalse: [anE at: ass key put: ass value]]].	^anAssociation!map: anAssociation at: startTime	"Map the receiver's special properties and/or eventModifiers onto the given event."	| aTime anE |	aTime := anAssociation key.	anE := anAssociation value copy.	(self at: #pitch) == nil 			"if i'm transposed"		ifFalse: [anE pitch: (anE pitch + (self pitch))].	(self at: #loudness) == nil 			"or scaled"		ifFalse: [anE loudness: (anE loudness + (self at: #loudness))].	(self at: #tempo) == nil 			"or have a tempo map"		ifFalse: [aTime := aTime * ((self at: #tempo) at: aTime).			anE duration: anE duration * ((self at: #tempo) at: anE duration)].	^anE! !!Siren.EventList methodsFor: 'initialize-release'!empty	"Throw away the receiver's events."	self duration: 0.	self index: 1.	self events: SortedCollection new.!initializeAnonymous	"Initialize an un-named instance with default state."	self initialize.	self propCheck.	duration := Duration value: 0.	self name: #anonymous.	self events: SortedCollection new.	index := nil.!initializeNamed: aName	"Initialize a named instance with default state."	self initializeAnonymous.	self name: aName asSymbol.	SirenSession eventList: aName asSymbol put: self!release	"Flush the receiver."	super release.	events == nil		ifFalse: [events do: [ :e | e release]].	events := nil.	index := nil! !!Siren.EventList methodsFor: 'event accessing'!, anEorA	"Add a new event or association to the receiver."	^self add: anEorA!add: anEorA	"Add a new event or association to the receiver."	| newAss val |	anEorA isAssociation		ifTrue: [newAss := anEorA key copy => anEorA value.			val := anEorA value.			newAss key species == Duration				ifFalse: [newAss key: (Duration value: newAss key)].			val isEvent				ifFalse: [val isMusicMagnitude					ifTrue: [val := (self defaultEventClass new)							perform: val species propertyName with: val]					ifFalse: [self error: 'Unknown EventAssociation value']].			self events add: newAss.			val duration == nil				ifTrue: [self duration: (duration max: newAss key)]				ifFalse: [self duration: (duration max: (newAss key + val duration))]]		ifFalse: [self events add: (duration => anEorA).			anEorA duration ifNotNil: [self duration: duration + anEorA duration]].	self changed: #added!add: anEvent at: aTime	"Add a new event to the receiver at the given relative start time."	| t |	t := Duration value: aTime.	self events add: (t => anEvent).	anEvent duration == nil		ifFalse: [duration := duration max: (t + anEvent duration)].	self changed: #added!addAll: anEventList	"Add the given event list's events to the receiver."	anEventList events do:		[ :assoc |			self events add: (assoc key copy => assoc value copy).			assoc value duration == nil 				ifTrue: [duration := duration max: assoc key]				ifFalse: [duration := duration 							max: (assoc key + assoc value duration)]].	self changed: #added!addAll: anEventList at: aTime	"Add the given event list's events to the receiver."	anEventList events do:		[ :assoc |			self events add: (assoc key copy * aTime => assoc value copy).			assoc value duration == nil 				ifTrue: [duration := duration max: assoc key]				ifFalse: [duration := duration 							max: (assoc key + assoc value duration)]].	self changed: #added!addAllAtEnd: anEventList	"Add the given event list's events to the receiver."	| aTime |	aTime := self duration.	anEventList events do:		[ :assoc |			self events add: (assoc key copy + aTime => assoc value copy).			assoc value duration == nil 				ifTrue: [duration := duration max: assoc key]				ifFalse: [duration := duration 							max: (assoc key + assoc value duration)]].	self changed: #added!eventKeys	"Answer the keys (durations) of the receiver's eventDictionary."	^events keys!eventNear: aPoint	"Answer an event within a reasonable distance (100 msec.) of the given point's x."	| margin oldAss |	(events includesKey: aPoint x)		ifTrue: [^events at: aPoint x].	margin := 100. "ms"	oldAss := nil.	events do:		[ :anAss |		anAss key > aPoint x			ifTrue: [oldAss == nil				ifTrue: [(anAss key - aPoint x) abs < margin					ifTrue: [^anAss]					ifFalse: [^nil]]				ifFalse: [(anAss key - aPoint x) abs < margin						ifTrue: [^anAss].					(oldAss key - aPoint x) abs < margin						ifTrue: [^oldAss].					^nil]].		oldAss := anAss].	^nil!eventNearTime: aTime	"Answer an event within a reasonable distance (32 msec.) of the given point."	| margin oldAss t |	margin := 32. "ms"	oldAss := events first.	events do:		[ :anAss | 		t := anAss key value.		t > aTime			ifTrue: [oldAss == nil				ifTrue: [(t - aTime) abs < margin					ifTrue: [^anAss]					ifFalse: [^nil]]				ifFalse: [(t - aTime) abs < margin						ifTrue: [^anAss].					(oldAss key - aTime) abs < margin						ifTrue: [^oldAss].					^nil]].		oldAss := anAss].	^nil!eventNearestTime: aTime	"Answer an event within a reasonable distance (32 msec.) of the given point."	| margin ass d |	ass := events first.	margin := ass key value - aTime abs.	events do:		[ :anAss | 		d := (anAss key value - aTime) abs.		d < margin ifTrue: 			[margin := d.			ass := anAss]].	^ass!eventValues	"Answer the values (events) of the receiver's eventDictionary."	^events values!events	"Answer the receiver's eventDictionary."	^events!events: anEL	"Set the receiver's eventDictionary."	events := anEL.	self changed: #added!recomputeDuration	"Recompute the total duration of the receiver."	| tDur t d |	tDur := 0 msec.	events do:		[ :ass |		t := ass key.		d := ass event duration.		tDur := tDur max: (t +d)].	duration := tDur.	self changed: #duration! !!Siren.EventList methodsFor: 'printing'!asExplorerString	^self name!asExplorerString: ignored	^self name!printOn: aStream	"Print out the receiver's events on the argument."	| anEvent count |	aStream nextPutAll: '(EList ', (self name printString), ' (d: ', duration printString.	events == nil		ifTrue: [aStream nextPutAll: ', ', self size printString, ' events'].	aStream nextPut: $)."	self pitch == nil		ifFalse: [aStream nextPutAll: ' pitch: ', self pitch printString]."	(self at: #tempo) == nil		ifFalse: [aStream nextPutAll: ' tempo: ', (self at: #tempo) printString].	aStream cr.	InputState default shiftDown			ifFalse: [count := self size min: 20]			ifTrue: [count := self size].	1 to: count do: [ :ind |		anEvent := events at: ind.		aStream tab; nextPutAll: anEvent key printString, ' => '.		anEvent value printOn: aStream].	count = self size 			ifTrue: [aStream nextPut: $); cr]			ifFalse: [aStream nextPutAll: ' ... )'; cr]!readDataFrom: aDataStream size: size	"Read a new event list from the given stream using the compact format."	| cntEvents time evt |	super readDataFrom: aDataStream size: size.	"MusicEvent's compact format"	cntEvents := (aDataStream byteStream nextNumber: 4) - EventList instSize.	self events: (SortedCollection new: cntEvents).	cntEvents timesRepeat:		["aDataStream byteStream next == 192			ifFalse: [self error: 'Missing event key in data stream']."				"check key for events"		time := MusicMagnitude readDataFrom: aDataStream.		evt := aDataStream next.		self add: evt at: time]!storeDataOn: aDataStream	"Store myself on a DataStream. Answer self."	"Format is: inst header, 4 'normal' inst vars, properties as key/val (or nil)	# of events, events as key/val."	"Skip index and startedAt inst vars."	| cntEvents ass |	super storeDataOn: aDataStream.		"MusicEvent's compact format"	cntEvents := events size.	aDataStream byteStream nextNumber: 4 			put: cntEvents + EventList instSize.	1 to: cntEvents do:		[ :i | 		ass := events at: i.		"aDataStream byteStream nextPut: 192."		"key for events"		MusicMagnitude store: ass key on: aDataStream.		aDataStream byteStream nextPut: 9.		ass value storeDataOn: aDataStream]!storeOn: aStream	"Store source code for the receiver's events on the argument."	"(((EventList named: #Bach) expandedFrom: 0 to: 12000) 				name: #Bach3) storeOnFile: 'Bach3.el'"	| count title1 title2 anAssoc tempo |	tempo := self at: #tempo.	(self pitch == nil and: [tempo == nil])		ifFalse: [aStream nextPutAll: '((', self class name, ' named: ',							self name storeString, ')'.			self pitch == nil					ifFalse: [aStream nextPutAll: '	pitch: ',								self pitch printString].			tempo == nil					ifFalse: [self pitch == nil							ifFalse: [aStream nextPut: $;].				aStream nextPutAll: '	tempo: ', tempo printString].			aStream nextPut: $); cr].	properties == nil		ifFalse: [properties associationsDo:			[ :ass |			ass key = #name				ifFalse: [aStream nextPutAll: '(', self class name, ' named: ',							self name storeString, ')'; tab.						aStream nextPutAll: ass key, ': ',							ass value storeString, '.'; cr]]].	title1 := '(', self class name, ' named: ', self name storeString, ')add: ('.	title2 := '); add: ('.	count := events size.	aStream nextPutAll: title1.	1 to: count do: [ :ind |		(ind \\ 10) = 0			ifTrue: [aStream nextPutAll: ')!!'; cr; nextPutAll: title1].		anAssoc := events at: ind.		aStream nextPutAll: anAssoc key asMS value printString, ' => '.		anAssoc value storeOn: aStream.		((ind \\ 10) = 9 or: [ind = count])			ifFalse: [aStream nextPutAll: title2]].	aStream nextPutAll: ')!!'; cr!storeOnFile: aName	"Store out the receiver's events on the file named by the argument."	| fs |	fs := (Filename named: aName) writeStream.	self storeOn: fs.	fs close.!templateFields	"Answer the field names for the instances of the receiver class."	| coll |	coll := super templateFields.	coll remove: #index.	coll remove: #startedAt.	^coll! !!Siren.EventList methodsFor: 'scheduling'!loop	"Play the event list by passing it off to the event scheduler."	EventScheduler addClient: self in: 1 msec loop: true.	EventScheduler run!nextTime: now	"Answer the time of the next appointment""	startedAt ifNil: [startedAt := Time microsecondClock].""	Transcript show: ((self events at: index) key asMsec value) printString; cr."	^(self events at: index) key asUsec value + startedAt!nextTimeFor: ass	"Answer the time delay between the given event association and the one that follows it."	| ind next |	ind := events indexOf: ass ifAbsent: [0].	ind = 0 ifTrue: [^0 sec].	ind = events size ifTrue: [^0 sec].	next := events at: ind + 1.	^(next start - ass start)!play	"Play the event list by passing it off to the event scheduler."	EventScheduler addClient: self in: 1 msec.	EventScheduler run!playOn: aVoice	"Play the event list on the voice by expanding its events"	voice := aVoice.	self play"	self playOn: aVoice at: Time microsecondClock"!playOn: aVoice at: startTime	"Play the event list on the voice by expanding its events"	aVoice play: self at: startTime.!scheduleAt: aTime 	"Expand an eventList for the appointment scheduler."	| theEvent |	self events isEmpty ifTrue: [^nil].	index ifNil: 		[index := 1.		startedAt := Time microsecondClock].	index > self events size		ifTrue: [index := nil. ^nil].	theEvent := self events at: index.	theEvent := self map: theEvent at: aTime.	theEvent voice ifNil:		[theEvent voice: voice].	theEvent play.			"play the next event"	index := index + 1.	index > self events size		ifTrue: [^theEvent duration isNil			ifTrue: [startedAt + duration asUsec value]			ifFalse: [aTime + theEvent duration asUsec value]].	^self nextTime: aTime!stop	"Play the event list by passing it off to the event scheduler."	EventScheduler instance removeClientNamed: self name! !!Siren.EventList class methodsFor: 'examples'!creationExamples	"Select the expressions below one-at-a-time and inspect the results.""	EventList named: (EventList nextName) 		fromPitches: #(36 38 40 43 45).""	(EventList named: (EventList nextName) 		fromStartTimes: #(0 500 1000 1500 2000 2500 3000)) inspect."	((440 Hz, 250 msec, (#voice -> #flute)), 		((1/4) => (471 Hz, (1/4) beat, (#voice -> #flute)))) inspect!randomExample	"Create an event list with random data."	"EventList randomExample"	"EventList randomExample edit"	"PitchTimeView randomExample"	"(EventList newNamed: #pRand)			addAll: (EventList randomExample);			addAll: (EventList randomExample)"	| rand size arr1 arr2 arr3 arr4 |	rand := Random new.	size := 64.	arr1 := Array new: size.	arr2 := Array new: size.	arr3 := Array new: size.	arr4 := Array new: size.	1 to: size do: [ :i | arr1 at: i put: (rand nextIntFrom: 150 to: 300)].	"dur"	1 to: size do: [ :i | arr2 at: i put: (rand nextIntFrom: 40 to: 100)].		"amp"	1 to: size do: [ :i | arr3 at: i put: (rand nextIntFrom: 1 to: 1)].			"voice"	1 to: size do: [ :i | arr4 at: i put: (rand nextIntFrom: 36 to: 60)].		"pitch"	^EventList named: 'random1'  		fromSelectors: #(duration: loudness: voice: pitch:) 		values: (Array with: arr1 with: arr2 with: arr3 with: arr4)!randomExample: length	"Create an event list with random data."	"EventList randomExample: 200"	"PitchTimeView randomExample"	"(EventList randomExample: 40) playOn: MIDIVoice default"	| rand arr1 arr2 arr3 arr4 |	rand := Random new.	arr1 := Array new: length.	arr2 := Array new: length.	arr3 := Array new: length.	arr4 := Array new: length.	1 to: length do: [ :i | arr1 at: i put: (rand nextFrom: 0.2 to: 0.3)].	1 to: length do: [ :i | arr2 at: i put: (rand nextIntFrom: 32 to: 80)].	1 to: length do: [ :i | arr3 at: i put: (rand nextIntFrom: 1 to: 1)].	1 to: length do: [ :i | arr4 at: i put: (rand nextIntFrom: 48 to: 72)].	^EventList named: 'random1'  		fromSelectors: #(duration: loudness: voice: pitch:) 		values: (Array with: arr1 with: arr2 with: arr3 with: arr4)!randomExample: length from: data	"Create an event list with random data."	"(EventList randomExample: 64 		from: ((#duration: -> (0.1 to: 0.2)), (#pitch: -> (36 to: 60)),				(#ampl: -> (48 to: 64)), (#voice: -> (1 to: 4)))) edit"	| rand arr sels i a |	rand := Random new.	arr := Array new: data size.	sels := Array new: data size.	i := 1.	data associationsDo: [ :item | | int |		int := item value.		a := Array new: length.		(int isMemberOf: Interval)			ifTrue: [int first isInteger				ifTrue: [1 to: length do: [ :c | 					a at: c put: (rand nextIntFrom: int first to: int stop)]]				ifFalse: [1 to: length do: [ :c | 					a at: c put: (rand nextFrom: int first to: int stop)]]]			ifFalse: [(int hasItems)				ifTrue: [1 to: length do: [ :c | 					a at: c put: (int atRandom: rand)]]				ifFalse: [1 to: length do: [ :c | 					a at: c put: int]]].		arr at: i put: a.		sels at: i put: item key.		i := i + 1].	^EventList named: EventList nextName		fromSelectors: sels 		values: arr!randomSWSSExample	"Create an event list with random data appropriate for software sound synthesis."	"EventList randomSWSSExample edit"	"(EventList newNamed: #sRand)			addAll: (EventList randomSWSSExample);			addAll: (EventList randomSWSSExample)"	| rand size params data |	rand := Random new.	size := 128.	params := 9.	data := Array new: params.	1 to: params do:		[ :i | data at: i put: (Array new: size)].	1 to: size do: 		[ :i | (data at: 1) at: i put: (rand nextIntFrom: 200 to: 450)].	"dur"	1 to: size do: 		[ :i | (data at: 2) at: i put: (rand nextFrom: 0.3 to: 0.7)].		"ampl"	1 to: size do: 		[ :i | (data at: 3) at: i put: (rand nextFrom: 60 to: 500)].		"pitch"	1 to: size do: 		[ :i | (data at: 4) at: i put: (rand nextIntFrom: 1.0 to: 5.0)].	"ratio"	1 to: size do: 		[ :i | (data at: 5) at: i put: (rand nextFrom: 1.0 to: 8.0)].		"index"	1 to: size do: 		[ :i | (data at: 6) at: i put: (rand nextFrom: 0.05 to: 0.1)].	"attack"	1 to: size do: 		[ :i | (data at: 7) at: i put: (rand nextFrom: 0.05 to: 0.1)].	"decay"	1 to: size do: 		[ :i | (data at: 8) at: i put: (rand nextFrom: 0.01 to: 0.1)].	"i:=attack"	1 to: size do: 		[ :i | (data at: 9) at: i put: (rand nextFrom: 0.05 to: 0.1)].	"i:=decay"	^EventList named: #SWSSExample		fromSelectors: #(duration: loudness: pitch: cmratio: index: 					attack: decay: iAttack: iDecay:) 		values: data!randomSWSSExample2	"Create an event list with random data appropriate for software sound synthesis."	"EventList randomSWSSExample2 edit"	"((EventList newNamed: #sRand)			addAll: (EventList randomSWSSExample2);			addAll: (EventList randomSWSSExample2)) edit"	| rand size params data |	rand := Random new.	size := 64.	params := 6.	data := Array new: params.	1 to: params do:		[ :i | data at: i put: (Array new: size)].	1 to: size do: 		[ :i | (data at: 1) at: i put: (rand nextIntFrom: 300 to: 750)].	"dur"	1 to: size do: 		[ :i | (data at: 2) at: i put: (rand nextFrom: 0.35 to: 1.0)].		"ampl"	1 to: size do: 		[ :i | (data at: 3) at: i 					put: ((rand nextIntFrom: 36 to: 80) truncateTo: 2)].	"pitch"	1 to: size do: 		[ :i | (data at: 4) at: i put: (LinearFunction exampleEnvelope)].	"envelope"	1 to: size do: 		[ :i | (data at: 5) at: i put: (rand nextFrom: 0.0 to: 1.0)].		"position"	1 to: size do: 		[ :i | (data at: 6) at: i put: (rand nextFrom: 0.3 to: 1.0)].		"duty"	^EventList named: #SWSSExample		fromSelectors: #(duration: loudness: pitch: envelope: position: duty:) 		values: data!scaleExample2	"Answer a scale where the event property types are mixed."	"EventList scaleExample2"	| el start stop size arr4 dur ndur |	start := 48.	stop := 60.	size := stop - start.	dur := 2000.	"msec"	ndur := (dur / size) truncated.	arr4 := Array new: size + 1.	0 to: size do: [ :i | arr4 at: i+1 put: (start + i)].	el := EventList named: EventList nextName		fromSelectors: #(duration: loudness: pitch:) 		values: (Array with: ndur with: 72 with: arr4)."Scramble the property types"	el eventsDo:		[ :ev |		ev dur: (ev dur perform: (#(asMsec asBeat asSeconds) atRandom)).		ev pitch: (ev pitch perform: (#(asHz asMIDI asSymbol) atRandom)).		ev ampl: (ev ampl perform: (#(asDB asMIDI asSymbol asRatio) atRandom))].	^el!scaleFrom: start to: stop in: dur	"Answer an event list with a scale."	"(EventList scaleFrom: 48 to: 60 in: 1.5) open"	"(EventList scaleFrom: 36 to: 84 in: 2) play"	| size arr4 ndur |	size := (stop - start) abs.	ndur := (dur / size).	arr4 := Array new: size + 1.	start > stop		ifTrue: [0 to: size do: [ :i | arr4 at: i+1 put: (start - i)]]		ifFalse: [0 to: size do: [ :i | arr4 at: i+1 put: (start + i)]].	^EventList named: EventList nextName  		fromSelectors: #(duration: loudness: pitch:) 		values: (Array with: ndur with: 127 with: arr4)!sentenceExample	"Create an event list for a beautiful sentence."	"EventList sentenceExample"	EventList named: 'phrase2'  		fromSelectors: #(duration: loudness: phoneme:) 		values: (Array with: #(420 420 720 354    408 420 615 570 					369 312 369    690 462 477 660 ) 				with: #(0.4 0.3 0.9 0.6    0.42 0.32 0.8 0.5 					0.44 0.52 0.2   0.94 0.62 0.46 0.34 ) 				with: #(#und #die #fra #gen    #sind #die #sae #tze 					#die #ich #nicht    #aus #spre #chen #kann)).	^EventList named: 'phrase2'!serialExample: length from: data	"Create an event list with serial data."	"(EventList serialExample: 64 		from: ((#duration: -> #(0.1 0.1 0.1 0.2)), (#pitch: -> #(48 50 52 53 52)),				(#ampl: -> #(48 64)), (#voice: -> #(1)))) open"	| arr sels i a |	arr := Array new: data size.	sels := Array new: data size.	i := 1.	data associationsDo: [ :item | | list |		list := item value.		a := Array new: length.		1 to: length do: [ :c | 					a at: c put: (list at: c - 1 \\ list size + 1)].		arr at: i put: a.		sels at: i put: item key.		i := i + 1].	^EventList named: EventList nextName		fromSelectors: sels 		values: arr!wordExample	"Create an event list for a long word."	"EventList wordExample"	EventList named: 'phrase1'  		fromSelectors: #(duration: loudness: phoneme:) 		values: (Array with: #(595 545 545 540 570 800 540) 				with: #(0.8 0.4 0.5 0.3 0.2 0.7 0.1) 				with: #(#dun #kel #kam #mer #ge #sprae #che)).	(EventList named: 'phrase1') inspect! !!Siren.EventList class methodsFor: 'class initialization'!flush	"Erase the shared EventList dictionary and try to clean up all events."	"EventList flush."	SirenSession initializeEventLists.	EventList allInstancesDo: [ :el | el release].	ObjectMemory garbageCollect.	Transcript cr; show: EventList instanceCount printString, ' event lists  	',			MusicEvent instanceCount printString, ' events  	',			Duration instanceCount printString, ' durations'; cr.!initialize	"Initialize the shared EventList dictionary."	"EventList initialize."	"EventList someInstance"	SirenSession initializeEventLists!storeAll	"Write out all event lists."	"EventList storeAll"	| fname fstream |	fname := Dialog request: 'File name for storing event lists'			initialAnswer: 'events.st'.	fname isEmpty ifTrue: [^self].	fstream := (Filename named: fname) writeStream.	fstream ifNil: [^self].	Cursor write showWhile:		[SirenSession eventLists do:			[ :list |			list storeOn: fstream.			fstream cr; cr]].	fstream close.! !!Siren.EventList class methodsFor: 'named constants'!named: aName	"Answer the named instance from the dictionary or a new EL."	"EventList named: #random1"	| el |	el := SirenSession eventListNamed: aName asSymbol.	^el isNil		ifTrue: [self newNamed: aName]		ifFalse: [el]!named: aName ifAbsent: theBlock	"Answer the named instance from the dictionary or the result of the block."	| el |	el := SirenSession eventListNamed: aName asSymbol.	^el isNil		ifTrue: [theBlock value]		ifFalse: [el]!namedLists	"Answer the dictionary of named event lists."	"EventList namedLists"	^SirenSession eventLists!newNamed	"Answer the named instance with a temp name."	"EventList newNamed"	^self named: EventList nextName!newNamed: aName	"Create and answer a new named (and stored) instance."	^super new initializeNamed: aName!nextName	"Answer a gensym-type ('te6') event list name for which no EL exists in the dictionary."	| temp |	temp := 1.	[(SirenSession eventLists at: #Temp) includesKey: (('te', temp printString) asSymbol)]			whileTrue: [temp := temp + 1].	^'te', temp printString asSymbol! !!Siren.EventList class methodsFor: 'instance creation'!basicNew: ignored	"Create and answer a new default-named instance of me"	^self basicNew!fromFile: theName	"Create and answer a new default un-named (and therefore un-persistent) instance of me"	"EventList fromFile: (SirenUtility findFile: 'CALYPSO.MID')"	| tail fName |	tail := theName asFilename tail.	fName := SirenUtility findFile: theName.	[(('*.mid' match: tail) or: ['*.midi' match: tail])		ifTrue: [ | el mv |			el := EventList newAnonymous.			mv := MIDIFileVoice newOn: fName.			mv readOnto: el.			mv close.			^el].	(('*.ev' match: tail) or: ['*.sm' match: tail])		 ifTrue: [ | fn | 			fn := (Filename named: fName).			fn fileIn.			^EventList named: fn base]]	on: Error	do: [ :ex | ex pass. Transcript show: 'Error reading score file ', theName; cr. ^nil]!named: myName fromPitches: pitchCollection	"Answer an event list made with the given collection of pitches."	"EventList named: (EventList nextName) fromPitches: #(36 38 40 43 45)"	| me |	me := self newNamed: (myName asSymbol).	pitchCollection do:		[ :item |		me add: (me defaultEventClass pitch: item)			at: 0].	^me!named: myName fromSelectors: selArray values: valueArrayArray	"Answer an event list made with the given collection of values applied to the given array of selectors."	"EventList named: 'phrase1'  		fromSelectors: #(duration: loudness: phoneme:) 		values: (Array with: #(595 545 545 540 570 800 540) 				with: #(0.8 0.6 0.4 0.3 0.4 0.5 0.2) 				with: #(dun kel kam mer ge sprae che))"	| me size evt start selector data|	me := self newNamed: (myName asSymbol).	size := (valueArrayArray detect: [ :d | d hasItems]) size.	1 to: size do:		[ :evtIndex |		evt := me defaultEventClass new.		start := nil.		1 to: (selArray size) do:			[ :selIndex |			selector := selArray at: selIndex.			data := valueArrayArray at: selIndex.			selector == #start: 				ifTrue: [start := (Duration value: (data at: evtIndex))]				ifFalse: [data hasItems					ifTrue: [evt perform: selector with: (data at: (evtIndex - 1 \\ data size + 1))]					ifFalse: [evt perform: selector with: data]]].		start == nil			ifTrue: [me add: evt]			ifFalse: [me add: evt at: start]].	^me!named: myName fromStartTimes: timeCollection	"Answer an event list with the given collection of relative start times."	"EventList named: (EventList nextName) fromStartTimes: #(0 500 1000 1500 2000 2500 3000)"	| me |	me := self newNamed: (myName asSymbol).	timeCollection do:		[ :item |		me add: (me defaultEventClass new)			at: item].	^me!new	"Create and answer a new default-named instance of me"	^self newAnonymous!new: ignored	"Create and answer a new default-named instance of me"	^self newAnonymous!newAnonymous	"Create and answer a new default un-named (and therefore un-persistent) instance of me"	^super new initializeAnonymous! !!Siren.EventGenerator methodsFor: 'playing'!edit	"edit me"	self eventList edit!eventList	"Answer an eventList for the receiver."	self subclassResponsibility!play	"Play the receiver's event list."	self eventList play! !!Siren.EventGenerator class methodsFor: 'accessing instances'!all	"Find the and return instances of me or any subclasses of me."	| coll |	coll := Set new.	self allSubInstancesDo: [ :anI | coll add: anI ].	^coll!allPlaying	"Find all playing instances of me or my subclasses."	| coll |	coll := Set new.	self allSubInstancesDo: [ :anI | anI playing ifTrue: [coll add: anI]].	^coll!named: aName 	"Find the named instance of me or a subclass of me."	^SirenSession eventLists at: aName		ifAbsent: [SirenSession events at: aName ifAbsent: [nil]]!stopAll	"Find all playing instances of me or my subclasses and terminate them."	self allSubInstancesDo: [ :anI | anI playing ifTrue: [anI stop]].! !!Siren.EventGenerator class methodsFor: 'examples'!randomExample	"Play random examples from the set of examples in my subclasses"	"[Sensor anyButtonPressed] whileFalse: [EventGenerator randomExample]"	((Smalltalk at: 			(#(Cloud DynamicCloud SelectionCloud DynamicSelectionCloud "Peal") 					atRandom)) 		randomExample) play! !!Siren.Cluster methodsFor: 'playing'!eventList	"make the cluster's events"	| pattern |	pattern := EventList newAnonymous.	self events do:		[ :anEvent |		pattern add: (MusicEvent 			dur: self duration			pitch: ((anEvent isAssociation) 					ifTrue: [anEvent value pitch]					ifFalse: [anEvent])			ampl: self loudness			voice: self voice)			at: 0 ].	^pattern! !!Siren.Cluster class methodsFor: 'examples'!example1	"Cluster example1"	"play a 2 second c-major chord"	(Cluster  dur: 2.0		pitchSet: (#(0 4 7  12 16 19  24 28 31  36 40 43  48) collect: [ :val | val + 24])		ampl: 100		voice: 1) play!example2	"Cluster example2"	"play a low 2 second cluster"	(Cluster  dur: 2.0		pitchSet: #(48  50  52  54 56)		ampl: 100		voice: 6) play! !!Siren.Cluster class methodsFor: 'instance creation'!dur: aD list: anEL ampl: anA	"return an initialized Cluster with the given list as pitches"	^self new duration: aD; 		events: anEL; 		loudness: anA!dur: aD list: anEL ampl: anA voice: aV	"return an initialized Cluster with the given list as pitches"	^self new duration: aD; 		events: anEL; 		loudness: anA; 		voice: aV!dur: aD pitchSet: aColl ampl: anA voice: aV	"return an initialized Cluster with the given list as pitches"	^self new duration: aD; 		events: aColl; 		loudness: anA; 		voice: aV! !!Siren.Chord methodsFor: 'generating events'!majorTetrad	"return a three-note major chord on the given tonic in the given inversion"	"Chord majorTetradOn: 'c3' inversion: 0"	| me rootNote |	me := EventList newAnonymous.	rootNote := me defaultEventClass dur: duration pitch: root ampl: 100.	inversion = 0 ifTrue:		[ me add: rootNote at: 0;			add: (rootNote copy transposeBy: 4) at: 0;			add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0 ].	inversion = 1 ifTrue:		[ me add: (rootNote copy transposeBy: 4) at: 0;			add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0;			add: (rootNote copy transposeBy: 16) at: 0 ].	inversion = 2 ifTrue:		[ me add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0;			add: (rootNote copy transposeBy: 16) at: 0;			add: (rootNote copy transposeBy: 19) at: 0 ].	^me!majorTriad	"return a three-note major chord on the given tonic in the given inversion"	"Chord majorTriadOn: 'c3' inversion: 0"	| me rootNote |	me := EventList newAnonymous.	rootNote := me defaultEventClass dur: duration pitch: root ampl: 100.	inversion = 0 ifTrue:		[ me add: rootNote at: 0;			add: (rootNote copy transposeBy: 4) at: 0;			add: (rootNote copy transposeBy: 7) at: 0 ].	inversion = 1 ifTrue:		[ me add: (rootNote copy transposeBy: 4) at: 0;			add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0 ].	inversion = 2 ifTrue:		[ me add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0;			add: (rootNote copy transposeBy: 16) at: 0 ].	^me!minorTetrad	"return a three-note minor chord on the given tonic in the given inversion"	"Chord minorTetradOn: 'c3' inversion: 0"	| me rootNote |	me := EventList newAnonymous.	rootNote := me defaultEventClass dur: duration pitch: root ampl: 100.	inversion = 0 ifTrue:		[ me add: rootNote at: 0;			add: (rootNote copy transposeBy: 3) at: 0;			add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0 ].	inversion = 1 ifTrue:		[ me add: (rootNote copy transposeBy: 3) at: 0;			add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0;			add: (rootNote copy transposeBy: 15) at: 0 ].	inversion = 2 ifTrue:		[ me add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0;			add: (rootNote copy transposeBy: 15) at: 0;			add: (rootNote copy transposeBy: 19) at: 0 ].	^me!minorTriad	"return a three-note minor chord on the given tonic in the given inversion"	"Chord minorTriadOn: 'c3' inversion: 0"	| me rootNote |	me := EventList newAnonymous.	rootNote := me defaultEventClass dur: duration pitch: root ampl: 100.	inversion = 0 ifTrue:		[ me add: rootNote at: 0;			add: (rootNote copy transposeBy: 3) at: 0;			add: (rootNote copy transposeBy: 7) at: 0 ].	inversion = 1 ifTrue:		[ me add: (rootNote copy transposeBy: 3) at: 0;			add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0 ].	inversion = 2 ifTrue:		[ me add: (rootNote copy transposeBy: 7) at: 0;			add: (rootNote copy transposeBy: 12) at: 0;			add: (rootNote copy transposeBy: 15) at: 0 ].	^me! !!Siren.Chord methodsFor: 'accessing'!arity: aNumber	"set the number of notes of the receiver chord"	arity := aNumber!duration: aDuration	"set the durations of my notes"		| realDuration |	aDuration class == Duration 		ifTrue: [ realDuration := aDuration ]		ifFalse: [ realDuration := Duration value: aDuration ].	events do: [ :anAssociation |		anAssociation value duration: realDuration ].	duration := realDuration asMS!eventList	"Answer the receiver's events"	type == #major		ifTrue: [arity = 3			ifTrue: [^self majorTriad]			ifFalse: [^self majorTetrad]]		ifFalse: [arity = 3			ifTrue: [^self minorTriad]			ifFalse: [^self minorTetrad]].	self error: 'Unknown chord type/arity'!inversion: number	"set the inversion of the receiver chord"	inversion := number!root: tonic	"set the root of the receiver chord"	root := tonic!type: aSymbol	"set the type symbol of the receiver chord"	type := aSymbol! !!Siren.Chord class methodsFor: 'instance creation'!majorTetradOn: tonic inversion: inversion	"return a three-note major chord on the given tonic in the given inversion"	"Chord majorTetradOn: 'c3' inversion: 0"	| me |	me := self newAnonymous.	me root: tonic;		inversion: inversion;		type: #major;		arity: 4.	^me!majorTriadOn: tonic inversion: inversion	"return a three-note major chord on the given tonic in the given inversion"	"Chord majorTriadOn: 'c3' inversion: 0"	| me |	me := self newAnonymous.	me root: tonic;		inversion: inversion;		type: #major;		arity: 3.	^me!minorTetradOn: tonic inversion: inversion	"return a three-note minor chord on the given tonic in the given inversion"	"Chord minorTetradOn: 'c3' inversion: 0"	| me |	me := self newAnonymous.	me root: tonic;		inversion: inversion;		type: #minor;		arity: 4.	^me!minorTriadOn: tonic inversion: inversion	"return a three-note minor chord on the given tonic in the given inversion"	"Chord minorTriadOn: 'c3' inversion: 0"	| me |	me := self newAnonymous.	me root: tonic;		inversion: inversion;		type: #minor;		arity: 3.	^me! !!Siren.Chord class methodsFor: 'examples'!example	"Create and edit some chords."	"(Chord majorTriadOn: 'c3' inversion: 0) inspect"	"((Chord majorTetradOn: 'f2' inversion: 2) duration: 1.0) inspect"	((Chord majorTetradOn: 'g5' inversion: 1) duration: 1.0) edit! !!Siren.Scale methodsFor: 'degres'!degreDeAccord: unAccord	^(root intervalBetween: unAccord root) type!degreeOfNote: aNote 	^(root intervalBetween: aNote) type! !!Siren.Scale methodsFor: 'accessing'!allNotes	^ AllNotes at: self ifAbsent: [AllNotes at: self put: (self class allIntervals collect: [:s | root perform: s])]!noteAfter: aNote	"aNote can be a pitchClass, a pitch (ODNote) or even a PlayableNote.	coputation takes into accont circularity and is approximative  wrt aNote	alterations"	"N B majorScale noteAfter: ( N B flat  @ 3)"	| targetIndex answer |	targetIndex := notes indexOf: (self closestPitchClassTo: aNote pitchClass).	targetIndex = notes size		ifTrue: [answer := notes first]		ifFalse: [answer := notes at: targetIndex + 1].	(aNote isKindOf: PitchClass) 		ifTrue: [^answer].	"octave computation"	(aNote pitchClass natural pitchEqual: N B)			ifTrue: [^answer octave: aNote oct +1]		ifFalse: [^answer octave: aNote oct]!noteBefore: aNote	"aNote can be a pitchClass, a pitch (ODNote) or even a PlayableNote.	coputation takes into accont circularity and is approximative  wrt aNote	alterations"	"N C majorScale noteBefore: ( N C  @ 3)"	| targetIndex answer |	targetIndex := notes indexOf: (self closestPitchClassTo: aNote pitchClass).	targetIndex = 1		ifTrue: [answer := notes last]		ifFalse: [answer := notes at: targetIndex - 1].	(aNote isKindOf: PitchClass) 		ifTrue: [^answer].	"octave computation"	(aNote pitchClass natural pitchEqual: N C)			ifTrue: [^answer octave: aNote oct - 1]		ifFalse: [^answer octave: aNote oct]!notes	^notes!root	^root!root: value	root := value! !!Siren.Scale methodsFor: 'testing'!= g  	^root = g root and: [self class == g class]!containsAllOfTheseNotes: listOfNotes	listOfNotes do: 		[:each | 		(self containsNote: each) 			ifFalse: [^false]].	^true!containsNote: n	^(self notes detect: [:each | each pitchClass = n pitchClass]			ifNone: [nil]) notNil!isMajor	| tonic int |	tonic := notes first.	notes do: 			[:each | 			int := tonic intervalBetween: each.			int type = 3				ifTrue: [^int isA: #majorThird]].	^false!isMinor	| tonic int |	tonic := notes first.	notes do: 			[:each | 			int := tonic intervalBetween: each.			int type = 3				ifTrue: [^int isA: #minorThird]].	^false!isValid	^(notes detect: [:n | (n isKindOf: PitchClassDoubleSharp)			or: [n isKindOf: PitchClassDoubleFlat]]		ifNone: [nil]) == nil! !!Siren.Scale methodsFor: 'comparing'!hash	^root hash + self class hash! !!Siren.Scale methodsFor: 'scale tone chords'!arpeggioFrom: startNote poly: n interval: int 	"yields n notes from startNote by intervals of int"	| arp x |	arp := OrderedCollection with: startNote.	x := startNote.	(1 to: n - 1)		do: [:i | arp add: (x := self following: x by: int)].	^arp!chordFromNotes: l	^PitchClassChord newFromNotes: l!following: noteDepart by: x 	"rend la x ieme note a partir de noteDepart dans mes notes"	| i |	i := self indexDe: noteDepart.	^notes at: (((x + i - 2) \\ 7) + 1)!generateChordsPoly: n 	"generate the list of 7 scale tone chords from my notes with polyphony n"	| o startNote theNotes |	o := Array new: 7.	startNote := self root.	(1 to: 7)		do: 			[:i | 			theNotes := self arpeggioFrom: startNote poly: n interval: 3.			startNote := self following: startNote by: 2.			o at: i put: (self chordFromNotes: theNotes copy)].	^o!generateChordsPoly: n inOctave: oct	"generate the list of 7 scale tone chords from my notes with polyphony n"	"(HungarianMinor root: N do) generateChordsPoly: 5 inOctave: 3"	| o p startNote theNotes |	o := Array new: 7.	startNote := self root.	(1 to: 7) do: 		[ :i | 		theNotes := self arpeggioFrom: startNote poly: n interval: 3.		startNote := self following: startNote by: 2.		o at: i put: (self chordFromNotes: theNotes copy)].	p := Array new: 7.	(1 to: 7) do: 		[ :i | 		p at: i put: ((o at: i) notes collect: [ :each | (each octave: oct) semiToneCount])].	^p!indexDe: uneNote 	^notes indexOf: uneNote!scaleToneTriads	"N C majorScale scaleToneTriads 	(NeapolitanMinor root: N D ) scaleToneTriads"	^self generateChordsPoly: 3! !!Siren.Scale methodsFor: 'octave-dependent notes'!asPitchesInOctave: o	^self notes collect: [ :n| (n octave: o) semiToneCount]!ascendingFromOctave: o 	"first note is in octave o. others follow (and may shift octave!!)"	| oc |	oc := o.	^self notes		collect: 			[:n | 			n natural = PitchClass C ifTrue: [oc := oc + 1].			n octave: oc]!closestPitchClassTo: aPc 	self notes do: [:pc | pc natural == aPc natural ifTrue: [^pc]].	self error: 'impossible'!decendingFromOctave: o 	"first note is in octave o. others follow (and may shift octave!!)"	| oc |	oc := o.	^self reverseNotes		collect: 			[:n | 			n natural = PitchClass B ifTrue: [oc := oc - 1].			n octave: oc]!diatonicNotesFrom: dep to: arr 	"assumes a and b belong to the scale.	N re  minorScale diatonicNotesFrom: (N do sharp  octave: 3) to: (N re octave: 4)"	|  currentNote currentPc currentOctave res a b pc |	dep <= arr ifTrue: [a:= dep. b := arr] ifFalse: [a:= arr. b := dep].	pc := self closestPitchClassTo: a pitchClass.	currentNote := pc octave: a oct.	currentPc := self notes indexOf: pc.	currentOctave := a oct.	res := OrderedCollection new.	[currentNote <= b] whileTrue: 			[res add: currentNote.			currentNote pitchClass natural == N si				ifTrue: [currentOctave := currentOctave + 1].			currentPc = 7 ifTrue: [currentPc := 1] ifFalse: [currentPc := currentPc + 1].			currentNote := (notes at: currentPc) octave: currentOctave].	^res!octave: o	^self notes collect: [:n| n octave: o]! !!Siren.Scale methodsFor: 'computing notes'!computeNotes	"intervalList depends on the type of the scale. It is redefined in each 	subclass of Scale"	notes := self class intervalList collect: [:s | root perform: s]!intervalList	"yields the list of interval. Redefined in subclasses"	^self class intervalList!leadingNote	"N la minorScale leadingNote"	^self notes last!reverseNotes	"first is root, others following descending order"	^(notes copyFrom: 2 to: notes size) asOrderedCollection reverse			addFirst: notes first; yourself!tonic	"N re minorScale tonic"	^self notes first! !!Siren.Scale methodsFor: 'querying'!flatNotesInSignature	"Warning: doubles sharps are not sharps!!"	^(notes select: [:n | n isFlat])!numberOfFlats	"Attention les doubles bemols ne sont pas des bemols!!"	^(notes select: [:n | n isFlat]) size!numberOfSharps	"Attention les doubles dieses ne sont pas des dieses!!"	^(notes select: [:n | n isSharp]) size!sharpNotesInSignature	"Warning: doubles sharps are not sharps!!"	^(notes select: [:n | n isSharp])! !!Siren.Scale methodsFor: 'printing'!printOn: s 	| str |	str := root printString , (self isMajor ifTrue: ['M'] ifFalse: ['m']).	str size = 2 ifTrue: [str := str , ' '].	s nextPutAll: str!storeOn: s	s nextPutAll: '(', self class name asString.	s nextPutAll: ' root: ', root storeString.	s nextPut: $).! !!Siren.Scale methodsFor: 'Paleo'!costForPitch: n	self subclassResponsibility!enharmonicScale	^ self subclassResponsibility!pitchClassFor: p	"N C majorScale pitchClassFor: N A"	| count |	count := root numberOfSemiTonesBetween: p.	count = 0 ifTrue: [^ root].	^ self allNotes at: (1 + (count \\ 12))! !!Siren.Scale methodsFor: 'transpose'!transposeOf: anInterval 	^self class root: (root transposeOf: anInterval)! !!Siren.Scale class methodsFor: 'examples'!example"	N la flat majorScale notes ->  #(Lab Sib Do Reb Mib Fa Sol )	N do harmonicMinorScale notes ->  #(Do Re Mib Fa Sol Lab Si )		N re majorScale numberOfSharps -> 2	N do majorScale generateChordsPoly: 4 ->OrderedCollection ([Do #maj7 ] [Re #min 7 ] [Mi #min 7 ] [Fa #maj7 ] [Sol 7 ] [La #min 7 ] [Si #halfDim7 ] ) 	N do majorScale generateChordsPoly: 6-> OrderedCollection (Do #maj7 9 11  Re #min 7 9 11  Mi #min 7 #dim9 11  Fa #maj7 9 #aug11  Sol 7 9 11  La #min 7 9 11  Si #min #dim5 7 #dim9 11  )	N do majorScale generateChordsPoly: 7-> OrderedCollection (Do #maj7 9 11 13  Re #min 7 9 11 13  Mi #min 7 #dim9 11 #dim13  Fa #maj7 9 #aug11 13  Sol 7 9 11 13  La #min 7 9 11 #dim13  Si #min #dim5 7 #dim9 11 #dim13  )N re  HarmonicMinorScale generateChordsPoly: 3	N do majorScale degreDeAccord: (FPChord new fromString: 'Fa min 7')-> 4"! !!Siren.Scale class methodsFor: 'Paleo class initialize'!initialize	AllNotes := Dictionary new! !!Siren.Scale class methodsFor: 'creation'!askScale	"self askScale"	| scales scaleType pitch |	scales := Scale subclasses asArray.	scaleType := (Menu labelArray: (scales collect: [:s | s printString])) startUp.	scaleType = 0 ifTrue: [^nil].	pitch := N noteNamed: (Dialog request: 'note' initialAnswer: 'Do').	^(scales at: scaleType)		root: pitch!root: aNote 	| g |	g := self new.	g root: aNote; computeNotes.	"g isValid ifFalse: [self warn: 'invalid scale']."	^g!standardScales	^Array		with: MajorScale		with: HarmonicMinorScale		with: MelodicMinorScale!warn: s 	Transcript show: s; cr! !!Siren.Scale class methodsFor: 'interval list'!intervalList	^self subclassResponsibility! !!Siren.MajorScale methodsFor: 'Paleo'!costForPitch: n	(notes includes: n) ifTrue: [ ^ 0].	(self allNotes includes: n) ifTrue: [^ 1].	^ 2!enharmonicScale	root = N C sharp ifTrue: [^ N D flat majorScale].	root = N D sharp ifTrue: [^ N E flat majorScale].	root = N F sharp ifTrue: [^ N G flat majorScale].	root = N G sharp ifTrue: [^ N A flat majorScale].	root = N A sharp ifTrue: [^ N B flat majorScale].	root = N D flat ifTrue: [^ N C sharp majorScale].	root = N E flat ifTrue: [^ N D sharp majorScale].	root = N G flat ifTrue: [^ N F sharp majorScale].	root = N A flat ifTrue: [^ N G sharp majorScale].	root = N B flat ifTrue: [^ N A sharp majorScale].	^ nil! !!Siren.MajorScale class methodsFor: 'interval list'!allIntervals	^#(#unison #augmentedUnison #second #augmentedSecond #majorThird #perfectFourth augmentedFourth #perfectFifth #augmentedFifth #majorSixth #minorSeventh #majorSeventh )!intervalList	^#(#unison #second #majorThird #perfectFourth #perfectFifth #majorSixth #majorSeventh )! !!Siren.Voice methodsFor: 'events'!eventList	"Answer an event list read from the receiver."	| e |	e := EventList newAnonymous.	self readOnto: e.	^e!play: anEventList	"Expand the list and play it now."	^self play: anEventList at: Time microsecondClock!play: anEventOrList at: start	"Expand the list and play it at the given time."	| t e |	anEventOrList hasItems		ifFalse: [^self playEvent: anEventOrList at: start].	anEventOrList events do:		[ :ass |		t := ass key asMsec.		e := ass value.		e hasItems 			ifTrue: [self play: e at: t + start]			ifFalse: [self playEvent: e at: t + start]]!playEvent: anEvent	"Play the argument now."	self playEvent: anEvent at: 0!playEvent: anEvent at: aTime	"make sure my subclasses implement this"	self subclassResponsibility!readOnto: eventList	"Read events from the receiver into the argument."	self subclassResponsibility! !!Siren.Voice methodsFor: 'accessing'!instrument	"return my instrument."	^instrument!instrument: newValue	"set my instrument."	instrument := newValue!name	"return my name."	^name!name: newValue	"set my name."	name := newValue!stream	"answer the stream of the receiver voice"	^stream!stream: someStream	"plug in a stream to the receiver voice"	stream := someStream! !!Siren.Voice methodsFor: 'testing'!isVoice	"Answer true"	^true! !!Siren.Voice methodsFor: 'printing'!printOn: aStream	"Print the receivcer on the argument."	aStream nextPutAll: 'a ', self class name! !!Siren.Voice methodsFor: 'initialize-release'!close	"Close the stream, devise, or whatever."	self subclassResponsibility!initialize	"Set up a Voice."	^self!initializeNamed: aName 	"Set up a named Voice."	self initialize.	(aName isKindOf: Number)		ifTrue: [name := aName printString]		ifFalse: [name := aName].	SirenSession voices ~~ nil		ifTrue: [SirenSession voices at: name asSymbol put: self]! !!Siren.Voice class methodsFor: 'class initialization'!initialize	"set up the shared dictionary for caching voices"	"Voice initialize"	"Voice allSubclassesDo: [ :each | each initialize]"	SirenSession initializeVoices.	DefaultVoiceClass := #OSCVoice.!reset	"Reset all sub-instances of Voice."	"Voice reset"	self allSubInstancesDo: [ :aV | aV reset ]!setDefault: className	"Set the default class to use for new voices"	"Voice initialize."	DefaultVoiceClass := className! !!Siren.Voice class methodsFor: 'instance creation'!default	"Answer a voice."	DefaultVoiceClass == #MIDIVoice ifTrue: [^MIDIVoice default].	DefaultVoiceClass == #OSCVoice ifTrue: [^OSCVoice default].	DefaultVoiceClass == #SoundVoice ifTrue: [^SoundVoice default].	DefaultVoiceClass == #SuperColliderVoice ifTrue: [^SuperColliderVoice default].	(SirenSession voices == nil or: [SirenSession voices isEmpty])		ifFalse: [^SirenSession voices associations asOrderedCollection first value]		ifTrue: [self error: 'Unknown default voice class'].!named: aName	"Answer the shared dictionary's voice item at the given name (or the name itself if it's a voice)"	(aName isKindOf: Voice)		ifTrue: [^aName].	(aName class == SmallInteger)		ifTrue: [^MIDIVoice default].	(SirenSession voices ~~ nil and: 			[SirenSession voices includesKey: aName printString asSymbol])		ifTrue: [^SirenSession voices at: aName printString asSymbol]			ifFalse: [Voice default].!on: someStream	"Answer a new voice instance on the given stream."	| me |	me := self new initialize.	me stream: someStream.	^me! !!Siren.NotelistVoice methodsFor: 'events'!dump: aStringOrValue 	"The case I handle is strings. Subclasses may override."	stream nextPutAll: aStringOrValue!endLine	"Put the proper command terminator on the receiver's stream."	stream cr!mapProperty: item of: ass within: list 	"Write the given event association to the receiver's stream in the appropriate format."	| event time |	event := ass value.	time := ass key asSec value.	item isSymbol		ifTrue: [item == #start				ifTrue: [self dump: time printString]				ifFalse: [item == #delay						ifTrue: [self dump: (list nextTimeFor: ass) asSec value printString]						ifFalse: [self dump: ((event perform: item) asFloat printString: 4)]].			^self].	item isString		ifTrue: [self dump: item.			^self].	(item isMemberOf: BlockClosure)		ifTrue: [item numArgs = 1				ifTrue: ["1-arg blocks = send event"					self dump: (item value: event)					"2-arg blocks = send ass and list"]				ifFalse: [self dump: (item value: ass value: list)]]		ifFalse: [self error: 'unknown voice map item type.']!play: anEL	"Perform the argument."	self writeHeader.	self play: anEL at: 0.	self writeFooter!play: anEL at: start	"Perform the argument."	| time event |	anEL do: 		[ :ass |		time := ass key asSec value.		event := ass value.		event isEventList			ifTrue: [self play: event at: time + start]			ifFalse: [self playAssociation: ass in: anEL]].!playAssociation: ass in: list	"Write the given event association to the receiver's stream in the appropriate format."	stream == nil ifTrue: [^self].	parameterMap do:			"print out the fields in my p-map"		[ :item |		self mapProperty: item of: ass within: list ]		separatedBy: [self space].	self endLine!space	"Put the proper field separator on the receiver's stream."	stream space; tab!writeFooter	"Write a notelist file footer on the receiver's stream."	^self!writeHeader	"Write a notelist file header on the receiver's stream."	^self! !!Siren.NotelistVoice methodsFor: 'accessing'!addMap: anItem	"Add the argument (a symbol or block), to the parameterMap of the receiver"	parameterMap addLast: anItem!header: aString	"Set the file header string of the receiver."	header := aString!parameterMap	"Answer the parameterMap of the receiver."	^parameterMap!parameterMap: anOrderedCollection	"Set the parameterMap of the receiver."	parameterMap := anOrderedCollection! !!Siren.NotelistVoice methodsFor: 'initialize-release'!close	"Close the receiver's output stream (if it's a file)."	stream flush; close!initialize	"Initialize the receiver."	self parameterMap: self class defaultPMap!initializeNamed: aName onStream: theStream	"Answer a new named NotelistVoice on the given stream."	self initializeNamed: aName.	stream := theStream!initializeOnStream: theStream	"Answer a new named NotelistVoice on the given stream."	self initialize.	stream := theStream! !!Siren.NotelistVoice class methodsFor: 'instance creation'!defaultPMap	"Answer the default parameterMap of the receiver class's instances."	self subclassResponsibility!newNamed: aName onFile: fName	"Set up a NotelistVoice on the given output file"	"CmusicVoice newNamed: 'violin' onFile: 't.out.cmusic'"	^self new initializeNamed: aName onStream: (Filename named: fName) readStream!newNamed: aName onStream: aStream	"Set up a NotelistVoice on the given output stream"	"CmusicVoice newNamed: 'violin' onStream: Transcript"	^self new initializeNamed: aName onStream: aStream!onFileNamed: fName	"Set up a NotelistVoice on the given output file"	"CmusicVoice onFile: 't.out.cmusic'"	^self new initializeOnStream: fName asFilename writeStream! !!Siren.OSCVoice methodsFor: 'events'!oscMessageFrom: event 	"Answer a message for the given event by passing it to my parameter-mapper block"	^parameterMap value: event!play: anEL 	"Expand the list and play it now."	self play: anEL at: Time microsecondClock!playAssociation: ass in: list 	"Play the association..."	| realTime |	realTime := ass key asMsec value.	self waitTill: realTime.	port send: (parameterMap value: ass value).	^self"	stream := OrderedCollection new.	parameterMap do: [ :item | self			mapProperty: item			of: ass			within: list].	stream size = 0 ifTrue: [^self].	stream size = 1 ifTrue: [^port send: (stream at: 1)]."!playEvent: event at: start 	"Expand the list and play it at the given time."	start ifNotNil:		[self waitTill: start].	event hasItems ifTrue: [^self play: event at: start].	port send: (self oscMessageFrom: event)!waitTill: time	| now |	time ifNotNil: 			[now := Time microsecondClock.			time > now				ifTrue: [(Delay forMicroseconds: time - now) wait]				ifFalse: [nil]].	^self! !!Siren.OSCVoice methodsFor: 'accessing'!port	"Return the OSCPort"	^port!port: aPort 	"Set the OSCPort"	port := aPort.	^self! !!Siren.OSCVoice methodsFor: 'utilities'!send: command args: args	"Send an OSC command with the given arguments"	port send: (TypedOSCMessage for: command with: args)! !!Siren.OSCVoice class methodsFor: 'parameter maps'!defaultPMap	"Answer the default parameterMap for use with OSC."	^[ :e |  | arr |	arr := Array			with: e duration asSec value			with: e pitch asHz value			with: e ampl asRatio value.	TypedOSCMessage for: '/note' with: arr]!pMapForCSLAdditive	"Answer the default parameterMap for use with the CSL sum-of-sines instrument.		This creates an OSC bundle with a 'ps' message for the spectrum followed		by a 'pn' message to play a note.		CSL SOSInstrument args: dur, ampl, freq, pos, [att, dec, sus, rel] "	"OSCVoice sosExample1"		"EventScheduler flush"	^[ :e | | arr spect |	spect := e at: #spectrum.	spect := spect copyFrom: 1 to: 10.			"just the first 5 partials for now"	arr := Array new: 4.	arr at: 1 put: e duration asSec value.			"required fields"	arr at: 2 put: e ampl value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pos.													"optional fields""	arr at: 5 put: e att.	arr at: 6 put: e dec.	arr at: 7 put: e sus.	arr at: 8 put: e rel.""	Transcript show: arr printString; cr."	OSCBundle 		with: (Array 								"spectrum set message"			with: (TypedOSCMessage for: '/i1/ps' with: spect)													"note-on message"			with: (TypedOSCMessage for: '/i1/pn' with: arr))]!pMapForCSLFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| inst cnt |	cnt := 1.	^[ :e | | arr |	arr := Array new: 14.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pitch asHz value * e ratio.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos.	arr at: 7 put: e att.	arr at: 8 put: e dec.	arr at: 9 put: e sus.	arr at: 10 put: e rel.	arr at: 11 put: e iatt.	arr at: 12 put: e idec.	arr at: 13 put: e isus.	arr at: 14 put: e irel."	Transcript show: arr printString; cr."	inst := '/i', cnt printString, '/pn'.	cnt := cnt +1.	cnt > 4 ifTrue: [cnt := 1].	TypedOSCMessage for: inst with: arr]!pMapForCSLSimpleFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos"	^[ :e | | arr |	arr := Array new: 6.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl asRatio value.	arr at: 3 put: e pitch asHz value.	arr at: 4 put: e pitch asHz value * e ratio.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]!pMapForCSLSnd	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL SndFileInstrument has args: ampl, pos, start, stop"	^[ :e | | arr |	arr := Array new: 4.				"set up the parameter map"	arr at: 1 put: e ampl value.	arr at: 2 put: e pos.	arr at: 3 put: e start.	arr at: 4 put: e stop."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]!pMapForMIDI	"Answer the default parameterMap for use with OSC-to-MIDI. 	In this class, we create and return a OSCMessage with data taken from the given event."	^[ :e | 	| arr timestamp |	arr := Array			with: (e voice isInteger ifTrue: [e voice] ifFalse: [1])			with: e pitch asMIDI value			with: e ampl asMIDI value.	timestamp := Timestamp now.	OSCBundle with: (Array 			with: (TypedOSCMessage for: '/osc/midi/out/noteOn' with: arr)			with: (OSCBundle 				with: (Array with: (TypedOSCMessage for: '/osc/midi/out/noteOff' with: arr))				at: (timestamp addMilliseconds: e duration asMsec value)))		at: timestamp]!pMapForMIDItoFM	"Answer the default parameterMap for use with the CSL FM example instrument."	"CSL FMInstrument has args: dur, ampl, pch, index, pos"	^[ :e | | arr |	arr := Array new: 6.				"set up the parameter map"	arr at: 1 put: e duration asSec value.	arr at: 2 put: e ampl asRatio value.	arr at: 3 put: e pitch asHz value.	arr at: 5 put: e modIndex.	arr at: 6 put: e pos."	Transcript show: arr printString; cr."	TypedOSCMessage for: e inst with: arr]!pMapWithBundle	"Answer the default parameterMap for use with OSC-to-MIDI. In this class, we create and return a TypedOSCMessage with data taken from the given event. This allows us to have other versions that create OSC bundles."	^[ :e | | arr |	arr := Array with: 1			with: e pitch asMIDI value			with: e ampl asMIDI value.	OSCBundle 		with: (Array with: (TypedOSCMessage for: '/osc/midi/out/noteOn' with: arr)				with: (OSCBundle 						with: (TypedOSCMessage for: '/osc/midi/out/noteOff' with: arr)						at: (Timestamp now addMilliseconds: e duration asMsec value)))]! !!Siren.OSCVoice class methodsFor: 'examples'!fmExample1	"Play a few random notes on the CSL FM instrument"	"OSCVoice fmExample1"	"Startup up the CSL OSC demo (or dumpOSC) and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos, att, dec, sus, rel, i_att, i_dec, i_sus, i_rel"	| events voice  |	events := (EventList randomExample: 15 					"create the event list"		from: ((#duration: -> (0.2 to: 0.5)), 			(#pitch: -> (110.1 to: 220.1)), 			(#ratio: -> (0.8 to: 5.0)),			(#ampl: -> (0.2 to: 0.8)), 			(#modIndex: -> (0.0 to: 8.0)), 			(#pos: -> (-0.7 to: 0.7)),			(#att: -> (0.01 to: 0.05)),			(#dec: -> (0.03 to: 0.05)),			(#sus: -> (0.3 to: 0.7)),			(#rel: -> (0.1 to: 0.15)),			(#iatt: -> (0.05 to: 0.1)),			(#idec: -> 0.005),			(#isus: -> 1.0),			(#irel: -> 0.1))).	voice := self default.	voice  instrument: '/i1/pn'.										"default instrument"	voice parameterMap: self pMapForCSLFM.					"plug in the parameter map"	events voice: voice.	events play.!fmExample2	"Play molto legato notes on 4 CSL FM instruments and loop until interrupted "	"OSCVoice fmExample2"		"EventScheduler flush"	"Startup up the CSL OSC demo and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos"	| evList voice |						"create the event list"	evList := (EventList randomExample: 20 		from: ((#duration: -> 1.0),				(#pitch: -> (40.1 to: 100.1)),				(#ratio: -> (0.8 to: 1.5)),				(#ampl: -> (0.1 to: 0.25)), 				(#modIndex: -> (1.0 to: 4.0)),				(#pos: -> (-1.0 to: 1.0)))).	1 to: evList events size do: 		[ :ind | | ev |			"plug in instruments and expand durations (molto legato)"		ev := (evList events at: ind) event.		ev inst: ('/i', (ind - 1 \\ 4 + 1) printString, '/pn').		ev duration: ev duration * 4].	voice := self onPort: (OSCPort to: #[127 0 0 1] port: 54321).	"edit this to taste."	voice parameterMap: self pMapForCSLSimpleFM.	"plug in the parameter map"	evList voice: voice.	evList loop										"loop until you stop the scheduler"!fmExample3	"Play a long CSL FM note and apply some real-time control functions to it"	"OSCVoice fmExample3"	"Startup up the CSL OSC demo and run these"	"CSL FMInstrument has args: dur, ampl, c_fr, m_fr, ind, pos"	| evList voice voice2 gliss map2 pan map3 voice3 |	evList := ((EventList newNamed: #LongNote) add:		(10.0 sec, 66.0 Hz, -3 dB, (#pos -> -1.0), (#ratio -> 1.17), 				(#modIndex -> 2.64), (#inst -> '/i1/pn'))).	voice := self default.	voice parameterMap: self pMapForCSLSimpleFM.	"plug in the parameter map"	evList voice: voice.	evList play.										"start the note"	2 wait.			"pause 2 sec""Now make a glissando down"	gliss := FunctionEvent new function: (LinearFunction from: #((0 66.0) (8 30.0))).	gliss interval: 0.1 sec.						"10 per sec"	map2 :=  [ :e | TypedOSCMessage for: '/i1/cf' with: (Array with: e value)].	voice2 := self default.	voice2 parameterMap: map2.					"plug in the parameter map"	gliss voice: voice2.	gliss play."and pan it"	pan := FunctionEvent new function: (LinearFunction from: #((0 -1.0) (8 1.0))).	pan interval: 0.1 sec.						"10 per sec"	map3 :=  [ :e | TypedOSCMessage for: '/i1/po' with: (Array with: e value)].	voice3 := self default.	voice3 parameterMap: map3.					"plug in the parameter map"	pan voice: voice3.	pan play.!fmExample4	"Play an FM bell using CSL; fork a block that plays a note and waits a bit; 		stop the scheduler to stop the block."	"OSCVoice fmExample4"	| evList voice rand |	rand := Random new.	EventScheduler run.	[[EventScheduler isRunning] whileTrue:		"repeat block to play a bell sound"		[evList := ((EventList newNamed: #Bell) add:		(3.0 sec, (rand nextFrom: 1000.0 to: 1200.0) Hz , -18 dB, 				(#pos -> (rand nextFrom: -1.0 to: 1.0)), 				(#ratio -> 1.414), 				(#modIndex -> 2.0), 				(#inst -> '/i9/pn'))).		voice := OSCVoice onPort: (OSCPort to: #[127 0 0 1] port: 54321).		voice parameterMap: self pMapForCSLSimpleFM.	"plug in p-map"		evList voice: voice.		evList play.		(rand nextFrom: 5 to: 10) wait]] forkAt: (Processor userBackgroundPriority - 1)!functionExample	"Play a function out to OSC"	"OSCVoice functionExample"	| event voice map |							"create the function and event"	event := FunctionEvent new function: (LinearFunction default scaleBy: 5@1).	event interval: 0.25 sec.						"4 per sec"	map :=  [ :e | TypedOSCMessage for: '/osc/1/ampl' with: (Array with: e value)].	voice := self default.	voice parameterMap: map.					"plug in the parameter map"	event voice: voice.	event play!midiScaleExample	"OSCVoice midiScaleExample"	 | list voice |	list := EventList scaleFrom: 48 to: 60 in: 2.5.	voice := self default.	list voice: voice.	list play.!sndExample1	"Play random notes on the CSL sound file instruments"	"OSCVoice snd_Example1"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	rand := Random new.	events := EventList named: EventList nextName.	25 timesRepeat:		[ | in |		in := rand nextIntFrom: 5 to: 8.		events add: (MusicEvent new duration: (rand nextFrom: 0.1 to: 0.2); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.05 to: 0.5); 				pos: (rand nextFrom: -1.0 to: 1.0) ; 				start: (rand nextFrom: 0.0 to: 0.5); 				stop: (rand nextFrom: 0.5 to: 1.0))].	voice := self default.	voice parameterMap: self pMapForCSLSnd.	"plug in the parameter map"													"load 4 sound files"	voice send: '/i5/fi' args: (Array with: (SirenUtility findFile: 'moon.snd')).	voice send: '/i6/fi' args: (Array with: (SirenUtility findFile: 'wet.snd')).	voice send: '/i7/fi' args: (Array with: (SirenUtility findFile: 'round.snd')).	voice send: '/i8/fi' args: (Array with: (SirenUtility findFile: 'shine.snd')).	events voice: voice.	events play!sndExample2	"Play random notes on the CSL sound file instruments; loop until interrupted"	"OSCVoice sndExample2"		"EventScheduler flush"	"Startup up the CSL OSC demo and run these"	"CSL SndFileInstrument has args: ampl, pos, start, stop"	| events voice rand |	rand := Random new.	events := EventList named: EventList nextName.	25 timesRepeat:		[ | in |		in := rand nextIntFrom: 5 to: 8.		events add: (MusicEvent new duration: (rand nextFrom: 0.1 to: 0.2); 				inst: ('/i', in printString, '/pn');				ampl: (rand nextFrom: 0.01 to: 0.3); 				pos: (rand nextFrom: -1.0 to: 1.0) ; 				start: (rand nextFrom: 0.0 to: 0.5); 				stop: (rand nextFrom: 0.5 to: 1.0)).		(rand next > 0.5) 							"add 50% rests"			ifTrue: [events add: (DurationEvent new duration: rand next sec)]].	voice := self default.	voice parameterMap: self pMapForCSLSnd.	"plug in the parameter map"													"load voice files into instruments 5-8"	voice send: '/i5/fi' args: (Array with: (SirenUtility findFile: 'moon.snd')).	voice send: '/i6/fi' args: (Array with: (SirenUtility findFile: 'wet.snd')).	voice send: '/i7/fi' args: (Array with: (SirenUtility findFile: 'round.snd')).	voice send: '/i8/fi' args: (Array with: (SirenUtility findFile: 'shine.snd')).	events voice: voice.							"set-up and loop list"	events loop!sosExample1	"Play random notes on the CSL sum-of-sines instruments; loop until interrupted"	"OSCVoice sosExample1"		"EventScheduler flush"	"Startup up the CSL/OSC additive and run these"	"CSL AdditiveInstrument has args: dur, ampl, freq, pos, att, dec, sus, rel"	| events voice rand instr notes pitches freq0 key spect |	rand := Random new.	instr := SHARCInstrument fromDir: 'tuba'.			"load a tuba sample"	notes := Dictionary new.	instr samples associationsDo:						"make a dict of sample freq -> SOS-array"		[ :ass |		notes at: (ass key pitch asHz value) put: (ass value asSumOfSines)].	pitches := notes keys asSortedCollection. "get the pitches in Hz"	freq0 := pitches removeFirst.	pitches := (pitches collect: [ :pt | | int | 				"make a list of freq-interval -> base-freq"			int := freq0 to: pt. 			freq0 := pt. 			int]) asSortedCollection: [ :x :y | x first <= y first ].	events := EventList EventList newNamed.		"temp event list"	1 to: 25 do:										"add 25 notes + some rests"		[ :counter | | pch |		pch := rand nextFrom: 80.0 to: 440.0.			key := pitches detect: [ :pt | pt includes: pch] ifNone: [nil].			key ifNil: [pch < pitches first first				ifTrue: [spect := notes at: pitches first first]				ifFalse: [pch > pitches last last					 ifTrue: [spect := notes at: pitches last last]]]			ifNotNil: [spect := notes at: key first].		events add: (MusicEvent new 				duration: (rand nextFrom: 0.1 to: 0.2); 				inst: ('/i', (counter \\ 16 + 1) printString);				ampl: (rand nextFrom: 0.01 to: 0.3); 				pitch: pch; 				pos: (rand nextFrom: -1.0 to: 1.0);				spectrum: spect).		(rand next > 0.8) 							"add 20% rests"			ifTrue: [events add: (DurationEvent new duration: (rand next / 4) sec)]].	voice := self default.	voice parameterMap: self pMapForCSLAdditive.	"plug in the parameter map"													"load voice files into instruments 5-8"	events voice: voice.							"set-up and loop list"	events play! !!Siren.OSCVoice class methodsFor: 'instance creation'!default	"Answer an OSC voice for use with OSC-to-MIDI by default."	^self onPort: OSCPort default!localhost	"Answer an instance on the local host"	^self onPort: OSCPort localhost!map: mapSelector	"Answer a default instance that uses the given parameter map name"	"OSCVoice map: #pMapForCSLSimpleFM"	| inst |	inst := self default.	inst parameterMap: (self perform: mapSelector).	^inst!onPort: pt	"Answer an instance on the given port"	| me |	(me := self new initialize) port: pt.	^me!scHost	"Answer the default voice for SC over OSC"	^self onPort: OSCPort scHost! !!Siren.SirenExternalInterface methodsFor: 'initialize-release'!initialize	"ignored"	^self! !!Siren.SirenExternalInterface class methodsFor: 'class var accessing'!flush	instance := nil!instance	"Answer the singleton."	^singleton! !!Siren.SirenExternalInterface class methodsFor: 'initialization'!unload	"SirenExternalInterface unload"	SirenExternalInterface allSubclassesDo: [ :cl | cl flush. cl unloadLibraries]! !!Siren.SirenExternalInterface class methodsFor: 'instance creation'!new	"Answer a new instance, OR the singleton"	instance ifNil: [instance := super new initialize].	^instance! !!Siren.LibSndFileInterface class methodsFor: 'class initialization'!const: flag		^SF_Constants at: flag!initialize	"Set up the class constants dictionary"	"LibSndFileInterface initialize" 	"	/* file formats */	SF_FORMAT_WAV			= 0x010000,		/* Microsoft WAV format (little endian default). */	SF_FORMAT_AIFF			= 0x020000,		/* Apple/SGI AIFF format (big endian). */	SF_FORMAT_AU				= 0x030000,		/* Sun/NeXT AU format (big endian). */	SF_FORMAT_RAW			= 0x040000,		/* RAW PCM data. */	SF_FORMAT_PAF			= 0x050000,		/* Ensoniq PARIS file format. */	SF_FORMAT_SVX			= 0x060000,		/* Amiga IFF / SVX8 / SV16 format. */	SF_FORMAT_NIST			= 0x070000,		/* Sphere NIST format. */	SF_FORMAT_VOC			= 0x080000,		/* VOC files. */	SF_FORMAT_IRCAM			= 0x0A0000,		/* Berkeley/IRCAM/CARL */	/* Subtypes from here on. */	SF_FORMAT_PCM_S8		= 0x0001,		/* Signed 8 bit data */	SF_FORMAT_PCM_16		= 0x0002,		/* Signed 16 bit data */	SF_FORMAT_PCM_24		= 0x0003,		/* Signed 24 bit data */	SF_FORMAT_PCM_32		= 0x0004,		/* Signed 32 bit data */	SF_FORMAT_PCM_U8		= 0x0005,		/* Unsigned 8 bit data (WAV and RAW only) */	SF_FORMAT_FLOAT			= 0x0006,		/* 32 bit float data */	SF_FORMAT_DOUBLE		= 0x0007,		/* 64 bit float data */	SF_FORMAT_ULAW			= 0x0010,		/* U-Law encoded. */	SF_FORMAT_ALAW			= 0x0011,		/* A-Law encoded. */	        /* Modes for opening files. */	#define LSFM_READ 0x10	#define LSFM_WRITE 0x20	#define LSFM_RDWR 0x30	"	SF_Constants := IdentityDictionary new.	SF_Constants at: #LSF_FORMAT_WAV put: 16r010000.	SF_Constants at: #LSF_FORMAT_AIFF put: 16r020000.	SF_Constants at: #LSF_FORMAT_AU put: 16r030000.	SF_Constants at: #LSF_FORMAT_RAW put: 16r040000.	SF_Constants at: #LSF_FORMAT_IRCAM put: 16r0A0000.	SF_Constants at: #LSF_FORMAT_PCM_S8 put: 16r0001.	SF_Constants at: #LSF_FORMAT_PCM_16 put: 16r0002.	SF_Constants at: #LSF_FORMAT_PCM_24 put: 16r0003.	SF_Constants at: #LSF_FORMAT_PCM_32 put: 16r0004.	SF_Constants at: #LSF_FORMAT_FLOAT put: 16r0006.	SF_Constants at: #LSF_FORMAT_DOUBLE put: 16r0007.	SF_Constants at: #LSF_FORMAT_ULAW put: 16r0010.	SF_Constants at: #LSFM_READ put: 16r10.	SF_Constants at: #LSFM_WRITE put: 16r20.	SF_Constants at: #LSFM_RDWR put: 16r30.	SF_Constants at: #SEEK_SET put: 0.	SF_Constants at: #SEEK_CURRENT put: 1.	SF_Constants at: #SEEK_END put: 2.! !!Siren.LibSndFileInterface class methodsFor: 'examples'!example1: filename	"Demonstrate using the LibSndFileInterface; this will dump some messages to the transcript"	"LibSndFileInterface example1: 'unbelichtet.aiff'"	| interface index val data frames channels |	interface := LibSndFileInterface new."Open a sound file"	index := interface lsf_open: (SirenUtility findFile: filename) with: (self const: #LSFM_READ).	Transcript cr; show: 'Open returned: ', index printString; cr."Read the file format, rate, # of channels, etc."	val := interface lsf_get_format: index.	Transcript show: 'getSndFileFormat returned: ', (val printStringRadix: 16); cr.	val := interface lsf_get_rate: index.	Transcript show: 'getSndFileRate returned: ', val printString; cr.	channels := interface lsf_get_channels: index.	Transcript show: 'getSndFileChannels returned: ', channels printString; cr.	frames := interface lsf_get_frames: index.	Transcript show: 'getSndFileFrames returned: ', frames printString; cr."Allocate a buffer of shorts"	data := (WordArray new: frames * channels) copyToHeapAsSigned: #malloc:.	data beGarbageCollectable."Read samples into it"	val := interface lsf_read_Isamples: index with: data with: frames.	Transcript show: 'readSndFileISamples returned: ', val printString; cr."Dump the first 100 samples"	0 to: 99 do:		[ :in | Transcript show: (data at: in) printString; tab]."Close the file"	val := interface lsf_close: index.	Transcript cr; show: 'closeSndFile returned: ', val printString; cr.! !!Siren.MIDIPacket methodsFor: 'accessing'!ampl	"Answer the receiver's MIDI velocity."	^data at: 3!ampl: a	"Set the receiver's MIDI velocity."	data at: 3 put: a!channel	"Answer the receiver's MIDI channel."	^(data at: 1) bitAnd: 16r0F!command	"Answer the receiver's MIDI command nibble."	^(data at: 1) bitAnd: 16rF0!data	"Answer the receiver's 'data' byte array."	^data!data: anObject	"Set the receiver's instance variable 'data' to be anObject."	data := anObject!duration	"Answer the receiver's duration."	^duration!duration: d	"Set the receiver's duration."	duration := d!key	"Answer the receiver's MIDI key number."	^data at: 2!key: k	"Set the receiver's MIDI key number."	^data at: 2 put: k!length	"Answer the receiver's 'length'."	^length!length: anObject	"Set the receiver's instance variable 'length' to be anObject."	length := anObject!pitch	"Answer the receiver's MIDI key number."	^data at: 2!pitch: aValue	"Set the receiver's MIDI key number."	data at: 2 put: aValue!second: aValue	"Set the receiver's MIDI key number."	data at: 2 put: aValue!setPitch: p dur: d loudness: vol	"Answer an instance of the class with the given parameters."	self pitch: p; velocity: vol; duration: d!status: s	"Set the receiver's MIDI command."	data at: 1 put: s!third: aValue	"Set the receiver's MIDI key velocity."	data at: 3 put: aValue!time	"Answer the receiver's 'time'."	^time!time: anObject	"Set the receiver's instance variable 'time' to be anObject."	time := anObject!vel	"Answer the receiver's MIDI velocity."	^data at: 3!vel: v	"Set the receiver's MIDI velocity."	^data at: 3 put: v!voice	"Answer the receiver's MIDI channel."	^(data at: 1) bitAnd: 16r0F!voice: v	"Set the receiver's MIDI channel."	(data at: 1) put: (((data at: 1) bitAnd: 16rF0) bitOr: v)! !!Siren.MIDIPacket methodsFor: 'printing'!print: x on: aStream	"Store a two-digit hexadecimal version of the 8-bit argument x on the stream."	| digs |	digs := '01234567890ABCDEF'.	aStream nextPut: (digs at: ((x bitAnd: 16r00F0) bitShift: -4) + 1).	aStream nextPut: (digs at: (x bitAnd: 16r000F) + 1)!printOn: aStream	"Store a readable version of the receiver on the argument."	length ifNil: [length := data size].	aStream nextPutAll: (MIDICommands keyAtValue: (data first bitAnd: 16rF0) ifAbsent: ['unknown status']).	aStream nextPutAll: "(time isNil			ifFalse: [' t: ', time printString]			ifTrue: ['']), "		((flags isNil and: [flags ~= 0])			ifFalse: [' f: ', flags printString]			ifTrue: ['']), 		' d: ['.	1 to: length do:		[ :ind | 		self print: (data at: ind) on: aStream.		aStream space].	aStream skip: -1; nextPut: $]! !!Siren.MIDIPacket methodsFor: 'initialize release'!initialize	"Set the receiver's time stamp"	time := Time microsecondClock! !!Siren.MIDIPacket class methodsFor: 'instance creation'!bytesFor14BitValue: val	"Answer a two-element array with the 14-bit values that correspond to the given value."	"val should be +- 8192"	| int |	val abs > 8191		ifTrue: [self error: '14-bit value out of range.'].	int := val + 8192.	^Array with: (int bitAnd: 16r7F) with: ((int bitShift: -7) bitAnd: 16r7F)!fromBytes: aByteArray	"Answer a new instance of a MIDI packet instantiated from the given byte array."	^super new data: aByteArray!fromInt: anInt at: aTime	"Answer a new instance of a MIDI packet instantiated from the given 3-byte long value."	| bytes |	bytes := ByteArray new: 3.	bytes at: 3 put: ((anInt bitShift: -16) bitAnd: 16rff).	bytes at: 2 put: ((anInt bitShift: -8) bitAnd: 16rff).	bytes at: 1 put: (anInt bitAnd: 16rff).	^(self new data: bytes) time: aTime!new	"Answer a new instance."	^super new initialize!new: size	"Answer a new instance with a data array of the given size."	^self fromBytes: (ByteArray new: size)!setPitch: p dur: d loudness: vol	"Answer an instance of the class with the given parameters."	^self new pitch: p; velocity: vol; duration: d! !!Siren.MusicModel class methodsFor: 'generality'!generality	"Answer the class inst var for the generality table."	^generalityTable!generalize: aMag and: otherMag	"Answer an array of the two arguments with the most general first."	^(generalityTable at: aMag class) > (generalityTable at: otherMag class)		ifTrue: [Array with: aMag with: otherMag]		ifFalse: [Array with: otherMag with: aMag]! !!Siren.MusicModel class methodsFor: 'examples'!examples	"Pitch generalize: (#c pitch) and: (21 key)"	"Pitch generalize: (#c pitch) and: (220 Hz)"	"Pitch generalize: (220 Hz) and: (#c pitch)"	"Amplitude generalize: (21 dB) and: (88 velocity)"	"Amplitude generalize: (#ff ampl) and: (127 velocity)"	"Duration generalize: (100 msec) and: ((1/4) beat)"	"Duration generalize: (100 msec) and: (0.3 sec)"	 (#ff ampl) - (32 velocity)! !!Siren.Pitch class methodsFor: 'class constants'!color	"Answer the default color to display instances with."	^ColorValue green!initialize	"Set up the class inst var, a generality table."	"Pitch initialize"	"Pitch generalize: (#c pitch) and: (21 key)"	"Pitch generalize: (#c pitch) and: (220 Hz)"	"Pitch generalize: (220 Hz) and: (#c pitch)"	generalityTable :=		((HertzPitch -> 80),		(RatioPitch -> 60),		(MIDIPitch -> 40),		(SymbolicPitch -> 20))!initializeGenerality	"Set up the class inst var, a generality table."	"Pitch initializeGenerality"	"Pitch generalize: (#c pitch) and: (21 key)"	"Pitch generalize: (#c pitch) and: (220 Hz)"	"Pitch generalize: (220 Hz) and: (#c pitch)"	generalityTable :=		((HertzPitch -> 80),		(RatioPitch -> 60),		(MIDIPitch -> 40),		(SymbolicPitch -> 20))!mostGeneral	"Answer the most general-purpose duration--Hertz"	^#asHz!propertyName	"Answer the receiver class's default property name."	^#pitch:!relativeMember	"Answer the receiver class's species member used as a relative magnitude."	^RatioPitch!species	"Answer Pitch."	^Pitch! !!Siren.Pitch class methodsFor: 'examples'!example	"Print a simple message to the transcript demonstrating the various types."	"SymbolicPitch nameMap inspect"	"Pitch example"	| me |	me := Pitch value: 'c3'.	Transcript show: me printString; cr;		show: me asHertz printString; cr;		show: me asMIDI printString; cr.	me inspect!exampleAdC"Pitch exampleAdC"		"Some examples of where current Pitch implementation is problematic:"	"440.0 Hz asSymbol"	"shows up as a5, not the standard MIDIname a3."	"445 Hz asMIDI"		"is quantized down OK, but should be a3/note 69 also."		"439.9 Hz asSymbol"			"gets quantized down to g#!!"	"60 key asHertz asMIDI"		"does not survive conversion as MIDInote 60."	"My suggestions:"	"438 Hz asSymbol"  	"rounds to nearest chromatic note, a3."	"443.5 Hz asMIDI"	"detto."	"265 Hz asFracMIDI"	"converts to float chromatics; can be rounded, used 						for MIDI pitch bend or for precise synthesis in Hz."	"61.26 key asHertz"	"float chromatics can also be used directly; for 					microtonal scales this is clearer than Hz (to me at least)."	"260.0 Hz asFracSymbol inspect" 	"is rounded, but keeps track of offsets in  						an inst var (fracPitch); survives conversions etc."	"Note that asMIDI and asSymbol can now be used to round pitches to 	chromatics, while asFracMIDI and asFracSymbol keep microtonal 	precision."! !!Siren.Pitch class methodsFor: 'instance creation'!value: aValue	"Answer a new instance of a member of my species."	aValue species == Pitch ifTrue: [^aValue].	(aValue isMemberOf: SmallInteger)			ifTrue: [^MIDIPitch new value: aValue].	(aValue isKindOf: LimitedPrecisionReal)			ifTrue: [^HertzPitch new value: aValue].	(aValue isMemberOf: Fraction)			ifTrue: [^RatioPitch new value: aValue].	(aValue isKindOf: String)			ifTrue: [^SymbolicPitch new value: aValue asSymbol].	^self new value: aValue! !!Siren.OctaveDependentNote methodsFor: 'alterations'!flat	^pc flat octave: oct!isDoubleFlat	^pc isDoubleFlat!isDoubleSharp	^pc isDoubleSharp!isFlat	^pc isFlat!isNatural	^pc isNatural!isSharp	^pc isSharp!natural	natural == nil ifTrue: [natural := pc natural octave: oct].	^natural!sharp	^pc sharp octave: oct! !!Siren.OctaveDependentNote methodsFor: 'leading'!isLeadingToneTo: n	| int |	int := (self intervalBetween: n).	^int type = 2 		or: [int semiTones = 1]!lowerLeadingToneInScale: s	^s noteBefore: self!upperLeadingToneInScale: s	^s noteAfter: self! !!Siren.OctaveDependentNote methodsFor: 'public intervals'!alterate: note toReach: i 	"Join semitons to note in order to obtain the required number of 	semitones with self. 	Redefined here because interval computation must take octave 	into account ..."	| delta |	delta := (self semiTonesWith: note) - i.	delta = 0 ifTrue: [^note].	delta = 1 ifTrue: [^note flat].	delta = -1 ifTrue: [^note sharp].	delta = 2 ifTrue: [^note flat flat].	delta = -2 ifTrue: [^note sharp sharp].	delta = 3 ifTrue: [^note flat flat flat].	"to deal with cases like N B flat flat augmentedOctave"	delta = -3 ifTrue: [^note sharp sharp sharp].	^self error: 'illegal interval !!'!alterateBelow: note toReach: i 	"Join semitons to note in order to obtain the required number of 	semitones with self. 	Redefined here because interval computation must take octave 	into account ..."	| delta |	delta := (note semiTonesWith: self) - i.	delta = 0 ifTrue: [^note].	delta = 1 ifTrue: [^note sharp].	delta = -1 ifTrue: [^note flat].	delta = 2 ifTrue: [^note sharp sharp ].	delta = -2 ifTrue: [^note flat flat].	delta = 3 ifTrue: [^note flat flat flat].	"to deal with cases like N B flat flat augmentedOctave"	delta = -3 ifTrue: [^note sharp sharp sharp].	^self error: 'illegal interval !!'!augmentedEleventh	^MusicalInterval augmentedEleventh topIfBottomIs: self!augmentedFifth	^MusicalInterval augmentedFifth topIfBottomIs: self!augmentedFourth	^MusicalInterval augmentedFourth topIfBottomIs: self!augmentedNinth	^MusicalInterval augmentedNinth topIfBottomIs: self!augmentedOctave	^MusicalInterval augmentedOctave topIfBottomIs: self!augmentedSecond	^MusicalInterval augmentedSecond topIfBottomIs: self!diminishedFifth	^MusicalInterval diminishedFifth topIfBottomIs: self!diminishedNinth	^MusicalInterval diminishedNinth topIfBottomIs: self!diminishedOctave	^MusicalInterval diminishedOctave topIfBottomIs: self!diminishedSeventh	^MusicalInterval diminishedSeventh topIfBottomIs: self!diminishedThirteenth	^MusicalInterval diminishedThirteenth topIfBottomIs: self!eleventh	^MusicalInterval eleventh topIfBottomIs: self!fifth	^MusicalInterval fifth topIfBottomIs: self!flatFifth	^MusicalInterval flatFifth topIfBottomIs: self!flatNinth	^MusicalInterval flatNinth topIfBottomIs: self!flatThirteenth	^MusicalInterval flatThirteenth topIfBottomIs: self!fourth	^MusicalInterval fourth topIfBottomIs: self!majorNinth	^MusicalInterval majorNinth topIfBottomIs: self!majorSecond	^MusicalInterval majorSecond topIfBottomIs: self!majorSeventh	^MusicalInterval majorSeventh topIfBottomIs: self!majorSixth	^MusicalInterval majorSixth topIfBottomIs: self!majorThird	^MusicalInterval majorThird topIfBottomIs: self!majorThirteenth	^MusicalInterval majorThirteenth topIfBottomIs: self!minorNinth	^MusicalInterval minorNinth topIfBottomIs: self!minorSecond	^MusicalInterval minorSecond topIfBottomIs: self!minorSeventh	^MusicalInterval minorSeventh topIfBottomIs: self!minorSixth	^MusicalInterval minorSixth topIfBottomIs: self!minorThird	^MusicalInterval minorThird topIfBottomIs: self!minorThirteenth	^MusicalInterval minorThirteenth topIfBottomIs: self!ninth	^MusicalInterval ninth topIfBottomIs: self!octave	^MusicalInterval octave topIfBottomIs: self!perfectEleventh	^MusicalInterval perfectEleventh topIfBottomIs: self!perfectFifth	^MusicalInterval perfectFifth topIfBottomIs: self!perfectFourth	^MusicalInterval perfectFourth topIfBottomIs: self!second	^MusicalInterval second topIfBottomIs: self!seventh	^MusicalInterval seventh topIfBottomIs: self!sixth	^MusicalInterval sixth topIfBottomIs: self!thirteenth	^MusicalInterval thirteenth topIfBottomIs: self!unison	^self! !!Siren.OctaveDependentNote methodsFor: 'mutations'!duration: d	^MusicEvent dur: d pitch: self! !!Siren.OctaveDependentNote methodsFor: 'printing'!printOn: s 	pc printOn: s.	s nextPutAll: oct printString.!storeOn: s 	"(N C sharp sharp octave: 3) storeString = '(N C sharp sharp @ 3)'"	s nextPut: $(.	s nextPutAll: pc storeString.	s nextPutAll: ' @ ' , oct printString.	s nextPut: $)! !!Siren.OctaveDependentNote methodsFor: 'private-pacts'!respectsBassTessitura	^true	"self >= BassPlayer minPitch		and: [self <= BassPlayer maxPitch]"! !!Siren.OctaveDependentNote methodsFor: 'access'!oct	^oct!oct: o 	oct := o.	midiPitch := nil.	natural := nil!octave: o	self oct: o.!pitchClass	^pc!pitchClass: aPc 	pc := aPc.	midiPitch := nil.	natural := nil! !!Siren.OctaveDependentNote methodsFor: 'mutations more'!dottedEighth	^self lapse: Lapse dottedEighth!dottedFull	^self lapse: Lapse dottedFull!dottedHalf	^self lapse: Lapse dottedHalf!dottedQuarter	^self lapse: Lapse dottedQuarter!eighth	^self lapse: Lapse eighth!eighthInTriplet	^self lapse: Lapse eighthInTriplet!full	^self lapse: Lapse full!half	^self lapse: Lapse half!quarter	^self lapse: Lapse quarter!quarterInTriplet	^self lapse: Lapse quarterInTriplet!sixteenth	^self lapse: Lapse sixteenth! !!Siren.OctaveDependentNote methodsFor: 'comparing'!< aNote	^self midiPitch < aNote midiPitch!<= aNote	^self midiPitch <= aNote midiPitch!= x 	^(pc == x pitchClass) and: [oct == x oct]!> aNote	^self midiPitch > aNote midiPitch!>= aNote	^self midiPitch >= aNote midiPitch!hash	^super hash * oct!isNearerTo: n1 than: n2	^(self semiTonesWith: n1) abs < (self semiTonesWith: n2) abs!isbetween: n1 and: n2	^n1 < self and: [self < n2]!midiPitchEquals: aNote	^self midiPitch = aNote midiPitch!pitchEqual: aNote 	^self midiPitchEquals: aNote!theNearestPitch: list	"(N A flat @ 2) theNearestPitch: (Array with:  (N C  @ 2) with: (N C @ 3))"	| nearest |	nearest := list at: 1.	2 to: list size do: 		[:i |		(self isNearerTo: (list at: i) than: nearest)			ifTrue: [nearest :=  (list at: i)]].	^nearest! !!Siren.OctaveDependentNote methodsFor: 'intervals'!closestEnharmonic	| new |	new :=  self pitchClass enharmonic octave: oct.	new midiPitch = self midiPitch		ifTrue: [^new].	new midiPitch < self midiPitch		ifTrue: [^new octave: oct + 1].	new midiPitch > self midiPitch		ifTrue: [^new octave: oct - 1].!diatonicStepsTo: aNote 	"returns the number of diatonic steps to aNote"	"(N B octave: 3) diatonicStepsTo: (N C octave: 4)"	| all |	all := PitchClass naturalNotes.	^((aNote oct - oct) * 7) + ((all indexOf: aNote pitchClass natural) - (all indexOf: pc natural))!following	"the next diatonic note of self's natural note"	"(N C octave: 2) following"	| nat |	nat := self natural.	^ nat pitchClass following octave: (nat pitchClass = N si			ifTrue: [oct + 1]			ifFalse: [oct])!newdiatonicStepsTo: aNote 	"returns the number of diatonic steps to aNote"	"(N B octave: 3) diatonicStepsTo: (N C octave: 4)"	| all |	all := PitchClass naturalNotes.	^((aNote oct - oct) * 7) + ((all indexOf: aNote pitchClass natural) - (all indexOf: pc natural))!nthFollowing: i 	"yields the nth diatonic note following self. 	Takes octave shifts into account"	| nth |	(i < 0) ifTrue: [^self nthPreceding: i negated].	nth := self.	i timesRepeat: [nth := nth following].	^nth!nthPreceding: i 	"yields the nth diatonic note preceding self. 	Takes octave shifts into account"	| nth |	(i < 0) ifTrue: [^self nthFollowing: i negated].	nth := self.	i timesRepeat: [nth := nth preceding].	^nth!oldEquals: x 	"important pour l'integrite des operations sur les melodies"	^self == x!olddiatonicStepsTo: aNote 	"returns the number of diatonic steps to aNote"	"(N C octave: 4) diatonicStepsTo: (N D octave: 2)"	| b b2 n |	n := 0.	b := self natural.	b2 := aNote natural. self halt.	b <= b2		ifTrue: 			[[b2 <= b]				whileFalse: 					[b := b following.					n := n + 1].			^n].	b >= b2		ifTrue: 			[[b2 >= b]				whileFalse: 					[b := b preceding.					n := n - 1].			^n]!preceding	"the next diatonic note of self's natural note"	"(N C sharp octave: 3) preceding"	| nat |	nat := self natural.	^nat pitchClass preceding octave: (nat pitchClass == PitchClassDo			ifTrue: [oct - 1]			ifFalse: [oct])!semiToneCount	"related to OctaveDependentNote fromMidiPitch"	^pc semiToneCount + (oct + 2 * 12) - 1!semiTonesWith: aNote	^aNote semiToneCount - self semiToneCount! !!Siren.OctaveDependentNote methodsFor: 'interval testing'!intervalBetween: aNote 	"returns the interval between the two octaveDependentNotes. 		Assume that aNote is really a OctaveDependentNote"	| type |	type := self intervalTypeBetween: aNote.	(self natural < aNote natural		or: [self natural = aNote natural 			and: [self <= aNote]])		ifTrue: [^MusicalInterval type: type semiTones: (self semiTonesWith: aNote)].	(self natural > aNote natural		or: [self natural = aNote natural 			and: [self > aNote]])		ifTrue: [^MusicalDescendingInterval type: type semiTones: (aNote semiTonesWith: self)].	^self error: 'it doesnt work'.!intervalTypeBetween: aNote 	"returns the type of the interval between the two notes modulo one 	octave	(N C octave: 6) intervalTypeBetween: (N re octave: 3)	"	| b b2 type |	type := 1.	b := self natural.	b2 := aNote natural.	b <= b2		ifTrue: 			["ascending interval"			[b2 midiPitchEquals: b]			whileFalse: 				[b := b following.				type := type + 1]]		ifFalse: 			["descending interval"			[b2 midiPitchEquals: b]			whileFalse: 				[b := b preceding.				type := type + 1]].	^type!isLessThanA: interval from: od	" ascending or descending direction"	| int |	interval isSymbol		ifTrue: [int := MusicalInterval perform: interval]		ifFalse: [int := interval].	^(self intervalBetween: od)  < int!realIntervalTypeBetween: aNote 	"returns the type of the interval between the two notes		(N C octave: 6) realIntervalTypeBetween: (N C octave: 3) "	| b b2 type temp |	type := 1.	b := self natural.	b2 := aNote natural.	b > b2		ifTrue: 			[temp := b2.			b2 := b.			b := temp].	[b2 oct = b oct and: [b2 pitchClass = b pitchClass]]		whileFalse: 			[b := b following.			type := type + 1].	^type!testIntervalsFrom: pitch1 to: pitch2	"(N C sharp @ 3) testIntervalsFrom: (N A @ 1) to: (N A @ 4)"	| odn ena |	pitch1 midiPitch to: pitch2 midiPitch do: [:mp |		odn := OctaveDependentNote fromMidiPitch: mp.		Transcript show: self printString, ' intervalBetween: ', odn printString, ' = ' ,					(self intervalBetween: odn) printString; cr.		ena := odn closestEnharmonic.		ena = odn			ifFalse: [Transcript show: self printString, ' intervalBetween: ', ena printString, ' = ' ,					(self intervalBetween: ena) printString; cr]]! !!Siren.OctaveDependentNote methodsFor: 'constraining'!intervalTypeModuloOctaveBetween: n 	^(self intervalTypeBetween: n) - 1 \\ 7+ 1! !!Siren.OctaveDependentNote methodsFor: 'modifying'!inTessitura: qualTessitura	"modify octave according to the given tessitura"	self oct: (pc inTessitura: qualTessitura) oct! !!Siren.OctaveDependentNote methodsFor: 'transpose'!beDownAnOctave	^self octave: oct - 1!beTransposedBy: i 	| n |	n := self transposeOf: i.	oct := n oct.	pc := n pitchClass.	midiPitch := n midiPitch.	natural := nil!beTransposedOneStepDown	"used by the score editor as diatonic step!!"	| n |	n := self preceding.	oct := n oct.	pc := n pitchClass.	midiPitch := nil.	natural := nil!beTransposedOneStepUp	"used by the score editor as diatonic step!!"	| n |	n := self following.	oct := n oct.	pc := n pitchClass.	midiPitch := nil.	natural := nil!beUpAnOctave	^self octave: oct + 1!downAnOctave	^OctaveDependentNote octave: oct - 1 pc: pc!setPitchTo: aPitch 	oct := aPitch oct.	pc := aPitch pitchClass.	midiPitch := aPitch midiPitch.	natural := nil!switchTo: aNote 	pc := aNote pitchClass.	oct := aNote oct.	midiPitch := aNote midiPitch.	natural := nil!transposeOf: anInterval 	"three cases: integer (+/-), method name (= ascending interval), or interval 	object"	anInterval isInteger ifTrue: [^(ChromaticInterval semiTones: anInterval)			from: self].	anInterval isSymbol ifTrue: [^self perform: anInterval].	(anInterval isKindOf: MusicalInterval) ifTrue: [^anInterval topIfBottomIs: self].	^self error: 'type d''intervalle indefini'!upAnOctave	^OctaveDependentNote octave: oct + 1 pc: pc! !!Siren.OctaveDependentNote methodsFor: 'accessing delegation'!downAndUpOctaves: odNote	^pc downAndUpOctaves: odNote! !!Siren.OctaveDependentNote class methodsFor: 'examples'!examples"(N do octave: 3) minorThird sharp sharp E#3(N C octave: 3) semiTonesWith: (N la  octave: 4) 21(#(do re mi fa sol la si ) collect: [:x | (N perform: x) octave: 3])	collect: [:y | y - #octave](N B octave: 3) intervalBetween: (N B flat octave: 4)(N B octave: 3) intervalBetween: (N B flat octave: 2)(N C octave: 3) intervalBetween: (N C octave: 2)    descending  octave(N C octave: 2) intervalBetween: (N C octave: 3)   octave "! !!Siren.OctaveDependentNote class methodsFor: 'vocal ranges'!altoRange	"retourne la collection des notes de l'alto"	^self from: (N sol octave: 3)		to: (N re octave: 5)!altoRangeInScale: aScale	"OctaveDependentNote sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N sol octave: 3)		to: (N re octave: 5)!baseRange	"retourne la collection des notes de la basse"	^self from: (N sol octave: 2)		to: (N re octave: 4)!baseRangeInScale: aScale	"OctaveDependentNote sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N sol octave: 2)		to: (N re octave: 4)!sopranoRange	"retourne la collection des notes du soprano"	^self from: (N re octave: 4)		to: (N do octave: 6)!sopranoRangeInScale: aScale	"OctaveDependentNote sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N re octave: 4)		to: (N do octave: 6)!tenorRange	"retourne la collection des notes du tenor"	^self from: (N re octave: 3)		to: (N la octave: 4)!tenorRangeInScale: aScale	"OctaveDependentNote sopranoRangeInScale: (N do sharp minorScale)"	^aScale diatonicNotesFrom: (N re octave: 3)		to: (N la octave: 4)! !!Siren.OctaveDependentNote class methodsFor: 'creation'!from: aNote to: n2 	| r b |	r := OrderedCollection new.	b := aNote.	r add: b.	[b following >= n2]		whileFalse: 			[b := b following.			r add: b].	^r!fromMidiPitch: n 	"yields the note that has n as midiPitch. Only natural and sharp 	notes are created as there is no possible way of knowing the 	intention"	"C3 is 60.	C0 is 24	C-2 is 0""OctaveDependentNote fromMidiPitch: 24"	| o delta  |	o := (n  quo: 12) - 2.  	delta := (n + 1  \\ 12).	delta = 1 ifTrue: [^(N C  octave: o)].	delta = 2 ifTrue: [^(N C sharp octave: o)].	delta = 3 ifTrue: [^(N D octave: o)].	delta = 4 ifTrue: [^(N D sharp octave: o)].	delta = 5 ifTrue: [^(N E octave: o)].	delta = 6 ifTrue: [^(N F octave: o)].	delta = 7 ifTrue: [^(N F sharp octave: o)].	delta = 8 ifTrue: [^(N G octave: o)].	delta = 9 ifTrue: [^(N G sharp octave: o)].	delta = 10 ifTrue: [^(N A octave: o)].	delta = 11 ifTrue: [^(N A sharp octave: o)].	delta = 0 ifTrue: [^(N B octave: o)]!named: s 	"self named: 'Re#2'"	| o |	o := s last.	^(PitchClass noteNamed: (s copyFrom: 1 to: s size - 1))		octave: o asInteger - 48!octave: o pc: pc	^self new oct: o; pitchClass: pc! !!Siren.DoubleHarmonic class methodsFor: 'interval list'!intervalList	"tire de McLaughlin et le Mahavishnu Orchestra"	^#(#unison #minorSecond #majorThird #perfectFourth #perfectFifth #minorSixth #majorSeventh )! !!Siren.PitchClassSharp methodsFor: 'accessing'!flat	^natural!semiToneCount	^natural semiToneCount + 1!sharp	^sharp!sharp: value	sharp := value! !!Siren.PitchClassSharp methodsFor: 'testing'!isSharp	^true! !!Siren.PitchClassSharp methodsFor: 'printing'!printOn: s 	natural printOn: s.	s nextPut: $#!storeOn: s 	"N C sharp storeString"	s nextPutAll: 'N ' , self natural name , ' sharp '! !!Siren.PitchClassSharp methodsFor: 'saving'!representBinaryOn: s	^MessageSend receiver: natural selector:  #sharp! !!Siren.PitchClassSharp methodsFor: 'intervals'!alterate: note toReach: i 	| n |	n := natural alterate: note toReach: i.	^n sharp!alterateBelow: note toReach: i 	| n |	n := natural alterateBelow: note toReach: i.	^n sharp!closestEnharmonic	^self alterate: self following toReach: 0.!semiTonesToNatural	^-1! !!Siren.Function methodsFor: 'processing'!averagedTo: size	"Answer an averaged version of the receiver of the given size."	"(Function readFloatsFrom: (MusicMagnitude modeRootName, 'data/y2.2.env')) averagedTo: 32" 	| ilen factor fcn sum index |	ilen := self size.	fcn := Function ofSize: size.	size > ilen		ifTrue: [^self interpolatedTo: size].	factor := (size / ilen) asFloat.	1 to: size do:			[ :i |			sum := 0.			0 to: size do:				[ :j |				index :=  (i + j * factor) truncated max: 1.				sum := sum + (data at: index)].			fcn add: (sum/size)].	^fcn!freeData	"Release the receiver's 'data'."	data := nil!maxTo: size win: wsize	"Answer a version of the receiver of the given size taking the maximum value of each window."	"(Function readFloatsFrom: 'snd/yy/ec/syl/y2.env') maxTo: 32 win: 8" 	| ilen factor fcn step maxv |	ilen := self size.	fcn := Function ofSize: size.	size > ilen		ifTrue: [^self interpolatedTo: size].	factor := (1/size) asFloat.	step := (factor / wsize) asFloat.	0 to: size -1 do:			[ :i |			maxv := 0.			0 to: wsize -1 do:				[ :j |				maxv := maxv max: (self at: (i*factor)+(j+step)) abs].			fcn add: maxv].	^fcn!sampledTo: size	"Answer a down-sampled version of the receiver of the given size."	"((Function readFloatsFrom: (MusicMagnitude modeRootName, 'data/y2.2.env')) sampledTo: 64) edit" 	| ilen factor fcn |	ilen := self size.	fcn := Function ofSize: size.	size > ilen		ifTrue: [^self interpolatedTo: size].	factor := (size / ilen) asFloat.	1 to: size do:			[ :i |			fcn add: (self at: i*factor)].	^fcn!smoothed	"Answer a version of the receiver smoothed to about 32 points."	"| arr snd fcn|	arr := Array new: 512.	snd := 'Nomad:Squeak:Siren:sounds:kombination.1.aiff' asSoundFile.	snd rmsFrom: 1 to: snd size into: arr.	fcn := (Function from: arr).	fcn smoothed edit"	| nu avgs sc bre prev epsilon |	nu := 64.	avgs := Array new: nu.	sc := (data size / nu) truncated."get the running averages"	1 to: nu do:		[ :in | | sum |		1 to: sc do:			[ :sa | | val |			sum := 0.0.			val := data at: (in - 1 * sc + sa).			sum := sum + val].		avgs at: in put: (sum / sc)]."try to find constant regions and jumps"	bre := OrderedCollection new: nu / 2.	prev := avgs first.	bre add: 0 @ prev.		"first breakpoint"	epsilon := 0.33.	2 to: nu - 1 do:		[ :in | | this diff dif2 next |		this := avgs at: in.		next := avgs at: in + 1.		diff := this - prev.		this / (diff abs) > epsilon			ifTrue: [dif2 := next - this.				diff sign = dif2 sign ifFalse: [bre add: ((in * sc) @ this)]].		prev := this].	bre add: (data size @ avgs last).	^LinearFunction from: bre!updateRange	| min max |	data first isPoint		ifTrue: [domain := data first x to: data last x]		ifFalse: [domain := 1 to: data size].	min := 1.0e30.  max := -1.0e30.	data do: [ :d |		d < min ifTrue: [min := d].		d > max ifTrue: [max := d]].	self range: (min to: max)! !!Siren.Function methodsFor: 'accessing'!add: aValue	"Add the argument to the receiver's point collection."	data add: aValue.	aValue < range first		ifTrue: [self range: (aValue to: range last)].	aValue > range stop		ifTrue: [self range: (range first to: aValue)].!at: anIndex 	"Answer the value at the given index (between 0 and 1 -or- 1 and data size)."	| val |	anIndex isSymbol		ifTrue: [^super at: anIndex].	anIndex isInteger		ifTrue: [val := data at: ((anIndex max: 1) min: data size)]			ifFalse: [val := data at: ((anIndex max: 1) min: data size) truncated].	^(val * scale) + offset!at: anIndex put: aValue 	"Put the given value at the given index (between 0 and 1)."	anIndex isSymbol		ifTrue: [^ super at: anIndex put: aValue].	^ data at: ((self size * anIndex max: 1)			min: data size) truncated put: aValue!atX: anIndex	"Answer the value at the given index (between 0 and 1)."	^self at: anIndex!data	"Answer the receiver's 'data'."	^data!data: anObject	"Set the receiver's instance variable 'data' to be anObject."	data := anObject!dataClass	"Answer the class of the elements in the receiver's data collection."	data ifNil: [^nil].	data ifEmpty: [^nil].	^data first class!domain	"Answer the receiver's 'domain'."	^domain!domain: anObject	"Set the receiver's instance variable 'domain' to be anObject."	domain := anObject!duration	"Answer the domain of the receiver's collection of breakpoints."	^duration isNil		ifTrue: [domain last - domain first]		ifFalse: [duration]!nextXMoreThan: delta from: thisIndex	"Answer the next X value after index whose Y value is more than delta from the value at thisIndex"	"(LinearFunction from: #((0 0.2) (0.6 0.3) (0.62 1.0) (1.0 0.3))) edit"	"(LinearFunction from: #((0 0.2) (0.6 0.3) (0.62 1.0) (1.0 0.3))) nextXMoreThan: 0.01 from: 0.1"	"(LinearFunction from: #((0 0.2) (0.6 0.3) (0.62 1.0) (1.0 0.3))) nextXMoreThan: 0.1 from: 0.6"	| step |	self duration <= 10		ifTrue: [step := 0.005]			"default 200 steps"		ifFalse: [step := 1].	^self nextXMoreThan: delta from: thisIndex step: step!nextXMoreThan: delta from: thisIndex step: step	"Answer the next X value after thisIndex whose Y value is more than delta from the value at thisIndex"	"(LinearFunction from: #((0@0.2) (0.6@0.3) (0.62@1.0) (1.0 0.3))) nextXMoreThan: 0.05 from: 0.1"	"(LinearFunction from: #((0@0.2) (0.6@0.3) (0.62@1.0) (1.0 0.3))) nextXMoreThan: 0.1 from: 0.6"	| val1 val2 newIndex |	val1 := self at: thisIndex.	newIndex := thisIndex + step.	val2 := self at: newIndex.	[((val2 - val1) abs > delta) or: [newIndex >= self duration]]		whileFalse: [newIndex := newIndex + step.				val2 := self at: newIndex].	^newIndex!offset: offVal	"Set the receiver's 'offset'."	offset := offVal!pointAt: index	"Answer the given value in the receiver's breakpoint collection."	^data at: index!pointAt: index put: value	"Assign the given values in the receiver's breakpoint collection."	data at: index put: value.	value < range first		ifTrue: [self range: (value to: range last)].	value > range last		ifTrue: [self range: (range first to: value)].!points	"Answer the receiver's 'data'."	| i |	data ifNil: [^nil].	data first isPoint ifTrue: [^data].	i := 0.	^data collect: [ :d | i := i + 1. (i@d) ].!range	"Answer the receiver's 'range'."	^range!range: anObject	"Set the receiver's instance variable 'range' to be anObject."	range := anObject!realPointAt: index	"Answer the given value in the receiver's breakpoint collection (this is not overridden in ExpSeg)."	^data at: index!sampleAt: anIndex	"Answer the value at the given index (between 0 and 1)."	^self at: anIndex!scale	"Answer the receiver's 'scale'."	^range extent!scale: scaleVal	"Set the receiver's 'scale'."	scale := scaleVal!selection	^nil!size	"Answer the size of the receiver's collection of breakpoints."	^data size"	| si |	si := domain last - domain first.	^(si = 0)		ifTrue: [data size]		ifFalse: [si]"! !!Siren.Function methodsFor: 'arithmetic'!* aFcnOrNum	"Answer a function graph with the argument multiplied by the receiver"	^FunctionGraph opL: self opR: aFcnOrNum operation: #*!+ aFcnOrNum	"Answer a function graph with the argument added to the receiver"	^FunctionGraph opL: self opR: aFcnOrNum operation: #+!- aFcnOrNum	"Answer a function graph with the argument subtracted from the receiver"	^FunctionGraph opL: self opR: aFcnOrNum operation: #-!/ aFcnOrNum	"Answer a function graph with the receiver divided by the argument"	^FunctionGraph opL: self opR: aFcnOrNum operation: #/! !!Siren.Function methodsFor: 'enumerating'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value!do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	data do: aBlock!isEmpty	^data isEmpty! !!Siren.Function methodsFor: 'initialize-release'!initialize: size	"Initialize the receiver for the given size."	data := OrderedCollection new: size."	data := Array new: size withAll: 0."	range := 0.0 to: 0.0.	domain := 1 to: size.	scale := 1.0.	offset := 0.0! !!Siren.Function methodsFor: 'geometry'!hasPointNear: anXValue	"Answer whether or not the receiver has a function breakpoint near the given x value."	^(self detect: [ :pt | (pt x - anXValue) abs < 0.01] ifNone: [nil]) ~= nil!indexOfPointNearestX: anXValue	"Answer the receiver`s point nearest the given x value."	"(LinSeg from: #((0@0) (0.3@1) (0.6@0.6) (1@0))) indexOfPointNearestX: 0.7"	| ind |	ind := 1.	2 to: data size do:		[ :i |		((data at: ind) x - anXValue) abs < 			((data at: i) x - anXValue) abs		ifFalse: [ind := i]		ifTrue: [^ind]].	^data size! !!Siren.Function methodsFor: 'printing'!printOn: aStream	"Format and print the receiver on the argument."	| pt howMany |	data size > 4096		ifTrue: [howMany := 2048]		ifFalse: [howMany := data size].	aStream nextPutAll: self class name, ' from: '.	aStream nextPutAll: '#('.	data isEmpty		ifTrue: [^aStream nextPutAll: ' <empty> )'].	data first isPoint		ifTrue: [1 to: howMany do: 			[ :i |			pt := data at: i.			aStream nextPut: $(.			pt x printOn: aStream.			aStream space.			pt y printOn: aStream.			aStream nextPut: $); space].			aStream nextPut: $)]		ifFalse: [1 to: howMany do: 			[ :i |			pt := data at: i.			pt printOn: aStream.			aStream space.].		howMany < data size			ifTrue: [aStream nextPutAll: ' ... '].			aStream nextPut: $)]!storeOn: aStream	"Format and print the receiver on the argument."	| pt |	aStream nextPutAll: '(Siren.', self class name, ' from: '.	aStream nextPut: $#; nextPut: $(.	1 to: data size do: 			[ :i |			pt := data at: i.			aStream nextPut: $(.			pt x printOn: aStream.			aStream space.			pt y printOn: aStream.			aStream nextPut: $); space].	aStream nextPutAll: '))'; cr.! !!Siren.Function methodsFor: 'ui'!edit	"Open a function view on the receiver."	"(LinearFunction default scaleBy: 256@1) edit"	FunctionView onFunction: self!edit: extent	"Open a function view on the receiver."	"(LinearFunction default scaleBy: 256@1) edit"	extent isPoint		ifTrue: [FunctionView onFunction: self x: extent x y: extent y]		ifFalse: [FunctionView onFunction: self x: extent y: 256]!updateSelector	^#ratio! !!Siren.Function class methodsFor: 'class constants'!defaultSize	"Answer the default size for the instances' storage array."	^1024! !!Siren.Function class methodsFor: 'examples'!averagedFunctionFileExample	"Function usage example; read a function from a binary file and view it."	"Function averagedFunctionFileExample"	FunctionView onFunction:			 ((Function readFloatsFrom: 				(SirenUtility findFile: 'y2.2.env')) 		averagedTo: 32)!fileExample	"Function usage example; read a function from a binary file and view it."	"Function fileExample inspect"	^Function readFloatsFrom: (SirenUtility findFile: 'G1.2a1.env')!functionFileExample	"Function usage example; read a function from a binary file and view it."	"Function functionFileExample"	FunctionView onFunction: Function default!functionPlayExample	"Function usage example; make a roll-type eventList and apply a crescendo/decrescendo to it"	"Function functionPlayExample"	| temp fcn |	temp := EventList newNamed: #test3.	(0 to: 4000 by: 50) do: 	"4 seconds, 20 notes per second"			[ :index |			"add the same note"			temp add: (MusicEvent dur: 100 pitch: 36 ampl: 100) 					at: index].	fcn := LinearFunction from: #((0 @ 0) (0.5 @ 1) (1 @ 0)).	temp applyFunction: fcn to: #loudness.	temp play!functionViewExample	"Function usage example; make a z-z function and view it."	"Function functionViewExample"	FunctionView onFunction: (Function from: #( 0 1 0 0.5 1.0 0.5 0 1 0 0.3 0.6 0.9 1 0 1 0))!maxedFunctionFileExample	"Function usage example; read a function from a binary file and view it."	"Function maxedFunctionFileExample"	FunctionView onFunction: ((Function readFloatsFrom: (SirenUtility findFile: 'y2.2.env')) maxTo: 128 win: 32)!randomViewExample	"Function usage example; make a random walk fcn and view it."	"Function randomViewExample"	FunctionView onFunction: (Function randomOfSize: 64 from: 0.1 to: 0.9)!randomViewExample2	"Function usage example; make a random walk fcn and view it."	"Function randomViewExample2"	FunctionView onFunction: (Function randomWalkSize: 128 from: 0.3 to: 0.7)! !!Siren.Function class methodsFor: 'standard functions'!exponentialADSR1	"Answer a exponential attack/decay/sustain/release envelope."	"Function exponentialADSR1"	"FunctionView onFunction: Function exponentialADSR1"	^ExponentialFunction from: #((0 0 5) (0.2 1 -3) (0.8 0.5 -2) (1 0))!exponentialADSR2	"Answer a exponential attack/decay/sustain/release envelope."	"Function exponentialADSR2"	"FunctionView openOn: Function exponentialADSR2"	^ExponentialFunction from: #((0 0 5) (0.05 1 -3) (0.8 0.5 -2) (1 0))!linearADSR1	"Answer a linear attact/decat/sustain/release envelope."	"Function linearADSR1"	"FunctionView openOn: Function linearADSR1"	^LinearFunction from: #((0 0) (0.1 1) (0.2 0.6) (0.9 0.4) (1 0))!linearADSR2	"Answer a linear attact/decat/sustain/release envelope."	"Function linearADSR2"	"FunctionView openOn: Function linearADSR2"	^LinearFunction from: #((0 0) (0.05 1) (0.1 0.5) (0.9 0.4) (1 0))!spline	"Answer a generic spline curve."	"Function spline"	"FunctionView openOn: Function spline"	^SplineFunction from: #((0 0.5) (0.35 0.6) (0.65 0.2) (1 0.6))!sumOfSines	"Answer a simple Fourier summation."	"Function sumOfSines"	"FunctionView openOn: Function sumOfSines"	^FourierSummation from: #((1 0.5 0) (3 0.3 0) (5 0.2 0) (7 0.17 0) (9 0.15 0) (11 0.1 0))! !!Siren.Function class methodsFor: 'instance creation'!default	"Answer a default instance of the receiver class."	^Function fileExample!from: anArray	"Answer a function with the given array of collections, points, or data values."	"(Function from: #( 0 1 0 1 0 1 0 1 0 1 0)) at: 0.4"	"(LinearFunction from: #((0 0) (0.5 1) (1 0))) at: 0.2"	| me |	me := self ofSize: anArray size.	(anArray first hasItems)		ifTrue: [anArray do: 			[ :anCollection | me add: (anCollection first @ anCollection last)]]		ifFalse: [anArray do: 				[ :aValue | me add: aValue]].	me updateRange.	^me!fromFile: fName	"Load 1 or more functions from a text file."	"(Function fromFile: 'G1.2a1.env') first edit"	| strm envs fullName coll |	fullName := SirenUtility findFile: fName.	fullName ifNil: [self error: 'Cannot find function file ', fName].	strm := fullName asFilename readStream.	envs := strm fileIn.	strm close.	envs ifNil: [self error: 'Cannot load function file ', fName].	coll := OrderedCollection new.	envs do: [ :def |		coll add:  ((Smalltalk at: (def at: 1) asSymbol) 					perform: (def at: 2) asSymbol 					with: (def at: 3))].	^coll size = 1		ifTrue: [coll first]		ifFalse: [coll]!new	"Answer an instance of the receiver class."	^(super new) initialize!ofSize: size	"Answer an instance of the receiver class of the requested size."	"Function ofSize: 8"	^(super new) initialize: size!randomOfSize: size from: low to: high	"Answer a function with the given number of data points in the given range."	"FunctionView onFunction: (Function randomOfSize: 256 from: 0.1 to: 0.9)"	| rand me |	me := self ofSize: size.	rand := Random new.	1 to: size do: [ :i | me add: (rand nextFrom: low to: high)].	me domain: (1 to: size).	^me!randomWalkSize: size from: low to: high	"Answer a function with the given number of data points in the given range."	"FunctionView onFunction: (Function randomWalkSize: 128 from: 0.3 to: 0.7)"	| rand me val step v t |	me := self ofSize: size.	rand := Random new.	val :=rand nextFrom: low to: high.	step := high - low / 4.	1 to: size do: [ :i | 		v := rand nextFrom: step negated to: step.		t := (val + v).		((t  > high or: [t < low])) ifTrue: [v := v negated].		val := val + v.		me add: val].	^me!readFloatsFrom: filename	"Answer a function with the given points."	"Function readFloatsFrom: 'snd/yy/ec/syl/y2.env'"	| file stream size me |	file := filename asFilename.	file exists ifFalse: [^self error: 'non-extant file ', filename].	size := file fileSize / 4.		"assume floating-point values"	me := self ofSize: size.	stream := file readStream binary.	1 to: size do: [ :i | me add: stream nextFloat].	^me! !!Siren.LinearFunction methodsFor: 'processing'!normalize	"Normalize the receiver to the range and domain of 0-1, inclusive."	| xs ys |	self updateRange.	xs := domain stop "- domain first".	ys := range stop "- range first".	((xs abs > 1) or: [ys abs > 1]) ifTrue: 		[data := data collect: [ :pt |			pt setX: (pt x / xs) setY: (pt y / ys)].		range := 0 to: 1.		domain := 0 to: 1]!scaleBy: scalePt	"Scale the receiver's points by the given scale."	"LinearFunction default scaleBy: 5@1"	| newD |	newD := Array new: data size.	1 to: data size do:		[ :i | newD at: i put: (data at: i) * scalePt].	data := newD.	self updateRange!updateRange	| minx maxx miny maxy |	domain := 1 to: data size.	minx := 1.0e30.  maxx := -1.0e30.	miny := 1.0e30.  maxy := -1.0e30.	data do: [ :d |		d x < minx ifTrue: [minx := d x].		d x > maxx ifTrue: [maxx := d x].		d y < miny ifTrue: [miny := d y].		d y > maxy ifTrue: [maxy := d y]].	self range: (miny to: maxy).	self domain: (minx to: maxx)! !!Siren.LinearFunction methodsFor: 'accessing'!add: anItem	"Add the argument to the receiver's point collection."	data add: anItem.	domain ifNil: [self domain: (anItem x to: anItem x)].	range ifNil: [self range: (anItem y to: anItem y)].	anItem x < domain first		ifTrue: [self domain: (anItem x to: domain last)].	anItem x > domain stop		ifTrue: [self domain: (domain first to: anItem x)].	anItem y < range first		ifTrue: [self range: (anItem y to: range last)].	anItem y > range stop		ifTrue: [self range: (range first to: anItem y)]!at: anIndex	"Answer the value at the given index in my range--do linear interpolation."	| val xVal count x1 x2 y1 y2|	xVal := data first x.	count := 1.	[xVal < anIndex] whileTrue:		[count := count + 1.		count > data size			ifTrue: [val := data last y].		xVal := (data at: count) x].	xVal = anIndex 		ifTrue: [val := (data at: count) y]		ifFalse: [x1 := (data at: (count - 1)) x.			x2 := (data at: count) x.			y1 := (data at: (count - 1)) y.			y2 := (data at: count) y.			val := y1 + ((anIndex - x1) / (x2 - x1) * (y2 - y1))].	^(val * scale) + offset!size	"Answer the size of the receiver's collection of breakpoints."	| si |	si := domain stop - domain first.	^(si = 0)		ifTrue: [data size]		ifFalse: [si]! !!Siren.LinearFunction class methodsFor: 'examples'!exampleEnvelope	"Answer a LinSeg of a typical envelope function."	"LinearFunction exampleEnvelope"	"FunctionView onFunction: (LinearFunction exampleEnvelope)"	| rand pts size x y |	rand := Random new.	size := rand nextIntFrom: 5 to: 15.	pts := Array new: size.	pts at: 1 put: 0@0.	pts at: size put: 1@0.	x := 0.	y := 0.8.	2 to: size - 1 do:		[ :i |		x := x + (rand nextFrom: 0.05 to: 0.15).		y := ((y + (rand nextFrom: -0.3 to: 0.3)) min: 1.0) max: 0.0.		pts at: i put: (x@y)].	^LinearFunction from: pts!linearExample	"Make a LinSeg and answer a value."	"LinearFunction linearExample"	| fcn |	fcn := LinearFunction ofSize: 2.	fcn add: (0@0.5); add: (1@1).	Transcript show: (fcn at: 0.14) printString; cr.	fcn inspect!linearViewExample	"Make an ADSR-shaped LinSeg and open a view on its form."	"LinearFunction linearViewExample"	FunctionView onFunction: 		(LinearFunction from: #((0 0) (0.1 1) (0.2 0.6) (0.9 0.4) (1 0)))! !!Siren.LinearFunction class methodsFor: 'instance creation'!a: att d: dec s: sus r: rel	"Answer an ADSR envelope."	"FunctionView onFunction: (LinearFunction a: 0.03 d: 0.03 s: 0.4 r: 0.3)"	| susT arr |	susT := 1.0 - (att + dec).	arr := Array new: 5.	arr at: 1 put: (0 @ 0).	arr at: 2 put: (att @  1).	arr at: 3 put: ((att + dec) @ sus).	arr at: 4 put: (susT @ sus).	arr at: 5 put: (1 @ 0).	^self from: arr!default	"Answer a default instance of the receiver class - an ADSR shape."	^LinearFunction from: #((0 0) (0.15 1.0) (0.25 0.75) (0.75 0.5) (1 0))!fromLorisData: data size: siz duration: dur	"Create a linear envelope from the given Loris linear envelope."	| inst step |	inst := self ofSize: siz.	step := dur / siz.	0 to: siz do: [ :ind |		inst add: ((step * ind) asFloat @ (data valueAt: (step * ind)) asFloat)].	inst updateRange.	^inst! !!Siren.SplineFunction methodsFor: 'accessing'!at: anIndex	"Answer the value at the given index in my range--take it out of my computed form."	| val |	linSeg == nil		ifTrue: [self computeCurve].	val := linSeg at: anIndex.	^(val * scale) + offset! !!Siren.SplineFunction methodsFor: 'computing'!computeCurve	"Compute the receiver by cubic interpolation; use the Geometric spline."	| points spline |	points := OrderedCollection new: data size.	data do: [ :pt |			points add: (pt * 100)].	spline := Spline controlPoints: points.	points := spline computeCurve; computePoints.	1 to: points size do: [ :i |			points at: i put: ((points at: i) / 100)].	linSeg := LinearFunction from: points! !!Siren.SplineFunction class methodsFor: 'examples'!splineExample	"Make a SplineSeg."	"SplineFunction splineExample"	| fcn |	fcn := SplineFunction from: #((0 1) (0.35 1.3) (0.65 0.7) (1 1)).	fcn inspect."	^fcn at: 0.14 "!splineViewExample	"Make a SplineSeg and open a view on its form."	"SplineFunction splineSegViewExample"	FunctionView onFunction: 		(SplineFunction from: #((0 0.5) (0.35 0.7) (0.65 0.2) (1 0.5)))! !!Siren.SplineFunction class methodsFor: 'instance creation'!default	"Answer a default instance of the receiver class."	^SplineFunction from: #((0 0.5) (0.35 0.7) (0.65 0.35) (1 0.5))! !!Siren.Arpeggio methodsFor: 'accessing'!delay: aValue	"set the delay between the onset of my notes"	delay := aValue.	self setDelays.! !!Siren.Arpeggio methodsFor: 'playing'!edit	"edit me""	HauerSteffensView openWith8ButtonsAndHAndVScrollingOn: self"!eventList	"return my event list"	^events!play	"don't expand me"	^self playAt: 0! !!Siren.Arpeggio methodsFor: 'private'!setDelays	"set the start times of my notes"	| counter |	counter := 0.	events do:		[ :anAss |		anAss key: (MSecondDuration value: (anAss key value + (counter * delay))).		counter := counter + 1]! !!Siren.Arpeggio class methodsFor: 'instance creation'!on: aChordOrList delay: aDelay	"create an Arpeggio on the given chord or event list"	| me |	me := self newAnonymous.	me events: aChordOrList events copy.	me delay: aDelay.	^me! !!Siren.DeviceModel methodsFor: 'accessing'!debug	^debug!debug: aValue	debug := aValue!in	^in!in: aValue	in := aValue!name	^name!name: aValue	name := aValue!out	^out!out: aValue	out := aValue!port	^port!port: aValue	port := aValue!rate	^rate!rate: aValue	rate := aValue!stream	^stream!stream: aValue	stream := aValue! !!Siren.DeviceModel methodsFor: 'printing'!printOn: aStream 	"Append to the argument aStream a sequence of characters 	that identifies the collection."	aStream print: self class; nextPutAll: ' ('.	name ifNotNil: [aStream nextPutAll: name asString].	port ifNotNil: [aStream nextPutAll: ' - p ', port printString].	rate ifNotNil: [aStream nextPutAll: ' - r ', rate printString].	in ifNotNil: [aStream nextPutAll: ' - ', in printString, ' i '].	out ifNotNil: [aStream nextPutAll: ' - ', out printString, ' o '].	aStream nextPut: $)! !!Siren.MIDIDevice methodsFor: 'note events'!play: anEvent at: aTime	"Play the given event on my port as a default MIDI noteOn/noteOff pair."	| p d a v now strm ch |	now := Time microsecondClock.	strm := stream.	strm ifNil: [strm := SirenUtility defaultMIDIOut].	(Delay forMicroseconds: aTime - now) wait.	self checkPort.	v := self mapVoice: anEvent voice.	anEvent pitch isNil		ifFalse: [p := self mapPitch: anEvent pitch.			d := self mapDuration: anEvent dur.			a := self mapAmplitude: anEvent ampl.			debug ifNotNil: [MStream nextPutAll: 					aTime value printString, ' ', p printString, ' ', 					d printString,' ', a printString,' ', v printString; cr].			port play: strm pitch: p value dur: d amp: a voice: v]		ifTrue: [a := anEvent value rounded.		"if it's a control change"			ch := anEvent controller.			ch ifNotNil: [port controlChange: v controller: ch to: a]]! !!Siren.MIDIDevice methodsFor: 'initialization'!checkPort	"Ensure that the receiver's output port is initialized."	port == nil		ifTrue: [port := MIDIPort default].!close	"Release the receiver's hold on the port.""	Transcript show: 'MidiDevice reset: ', port printString; cr."	port close.	port := nil!initialize	"Set the receiver up on the default output port." "	Transcript show: 'MidiDevice init...'; cr.""	port == nil		ifTrue: [port := MIDIPort default].	stream := 1."!initialize: thePort	"Set the receiver up on the given output port.""	Transcript show: 'MidiDevice init...'; cr."	port == nil		ifTrue: [port := thePort].!play: anAss on: channelNumber	"play the given event on my port as a default MIDI noteOn/noteOff pair"	| s e |	s := anAss key.	e := anAss value.	self checkPort.	port ifNil:		[^MIDIPort default play: (self mapPitch: e pitch) 			at: s value 			dur: (self mapDuration: e dur) 			amp: (self mapAmplitude: e ampl) 			voice: channelNumber].	port play: (self mapPitch: e pitch) 			at: s value 			dur: (self mapDuration: e dur) 			amp: (self mapAmplitude: e ampl) 			voice: channelNumber! !!Siren.MIDIDevice methodsFor: 'accessing'!port	"Answer the receiver's I/O port."	^port!port: aPort	"Set the receiver's I/O port."	port := aPort!stream	"Answer the receiver's MIDI stream ID."	^stream!stream: aNumber	"Set the receiver's MIDI stream ID."	stream := aNumber! !!Siren.MIDIDevice methodsFor: 'parameter mapping'!mapAmplitude: aVal	"Map a numerical or symbolic amplitude to a MIDI-compatible 	 volume number (key velocity)"	^(aVal species == Amplitude 		ifTrue: [aVal asMIDI value]		ifFalse: [aVal class == SmallInteger 			ifTrue: [^aVal]		"assume a volume number"									"assume a dynamic name"			ifFalse: [(aVal isNil or: [aVal value isNil])				ifTrue: [64]				ifFalse: [Amplitude value: aVal asMIDI]]])!mapDuration: aVal	"Map a numerical or symbolic duration value to a 	 MIDI-compatible duration in msec."	^(aVal species == Duration		ifTrue: [aVal asMS value]"if duration type, answer msec"		ifFalse: [aVal class == SmallInteger			ifTrue: [aVal]		"if Int, assume mec"									"else assume a symbolic or float dur"			ifFalse: [aVal isNil				ifTrue: [nil]				ifFalse: [Duration value: aVal asMidi]]])!mapPitch: aVal	"Map a numerical or symbolic pitch to a MIDI-compatible note number."	aVal ifNil: [^nil].	^(aVal species == Pitch		ifTrue: [aVal asMIDI value]		ifFalse: [aVal class == SmallInteger			ifTrue: [aVal]			"assume a note number"										"assume a note name or freq"			ifFalse: [Pitch value: aVal asMidi]])!mapVoice: aVal	"Map a numerical or symbolic pitch to a MIDI-compatible note number."	^(aVal isInteger		ifTrue: [(aVal truncated min: 15) max: 0]		ifFalse: [aVal species == Voice			ifTrue: [aVal asNumber]			ifFalse: [1]])! !!Siren.MIDIDevice class methodsFor: 'examples'!playOnDevice	"Play a note out MIDI from the device level."	"self halt. MIDIDevice playOnDevice"	"MIDIPort allNotesOff"	"MIDIDevice initialize"	"MStream inspect"	| device port |	port := MIDIPort new openOutput.	device := MIDIDevice on: port.	device play: (60 key, 500 msec, 96 velocity, (#voice -> 0)) at: 0.	(Delay forSeconds: 1) wait.	port allNotesOff.	device close.	Transcript show: ' done.'; cr.!scheduleExample	"Play MIDI using the event scheduler."	"MIDIDevice scheduleExample"	"EventScheduler interrupt; flush"	 | device port voice scale start |	port := MIDIPort default. 	device := MIDIDevice on: port.	voice := MIDIVoice on: device.	scale := EventList scaleFrom: 36 to: 60 in: 2.0.	scale scale: #duration by: 2.	start := Time microsecondClock + 500000.	scale events do: [ :ass |		ass event voice: voice.		ass key: (ass key value + start) usec.		EventScheduler addClient: ass].	"self halt."	EventScheduler run! !!Siren.MIDIDevice class methodsFor: 'class initialization'!initialize	"Set up the one class variable"	"MIDIDevice initialize""	MStream := Transcript.	MStream := WriteStream on: (String new: 4096)."	MStream := nil! !!Siren.MIDIDevice class methodsFor: 'instance creation'!new	"Open a generic MidiDevice on the default Port"	"MIDIDevice new"	| me |	me := super new initialize."	me port: MIDIPort default open."	^me!on: port	"Open a generic MidiDevice on the given Port"	| me |	me := super new initialize.	me port: port.	^me! !!Siren.MIDIFB01 methodsFor: 'note events'!play: anEvent on: aChannel	"send FB01-specific code for note with fraction and duration		2n k f v d1 d2 = cmd:channel, noteNum, frac, vel, durLow, durHigh"	| bytes realDur |	bytes := ByteArray new: 6.	bytes at: 1 put: (16r20 + aChannel).	bytes at: 2 put: (self mapPitch: anEvent pitch).	bytes at: 3 put: 0.	bytes at: 4 put: (self mapAmplitude: anEvent ampl).	realDur := self mapDuration: anEvent duration.	bytes at: 5 put: (realDur bitAnd: 127).	bytes at: 6 put: (realDur bitShift: -7 ).	port == nil		ifTrue: [MStream nextPutAll: 'FB01: ', bytes printString; cr]		ifFalse: [port put: bytes length: 6]! !!Siren.MIDIDump methodsFor: 'updating'!update: aspect with: aParameter from: aSender	"The model (port) changed; add the event to our event list."	"MIDIDump exampleList"	| packet evt cmd found time |	packet := aSender input removeFirst.	SirenUtility log: packet printString.	eventList ifNil: [^self].	cmd := packet command.	live		ifTrue: [(cmd = (MIDICommands at: #noteOn) and: [packet ampl ~= 0])			ifTrue: [^notesOn add: (MusicEvent dur: packet time pitch: packet pitch 								ampl: packet ampl voice: packet voice)].			(cmd = (MIDICommands at: #noteOff) or: [packet ampl = 0])			ifTrue: [found := notesOn removeAllSuchThat: 					[ :ev | ((ev pitch value = packet pitch) and: [ev voice =  packet voice])].				found isEmpty					ifTrue: [^Transcript show: 'No note-on found for ', packet printString; cr].				evt := found first.				time := evt dur value.				evt dur: (packet time - time).			"fix the event's duration"				^eventList add: evt at: time - startedAt]]		ifFalse: [^eventList add: ((MusicEvent pitch: packet pitch 							ampl: packet ampl voice: packet voice) 						command: cmd) at: (packet time - startedAt)].	SirenUtility log: 'Unrecognized packet: ', packet printString! !!Siren.MIDIDump methodsFor: 'accessing'!eventList	^eventList!eventList: aValue	eventList := aValue!live: aValue	live := aValue! !!Siren.MIDIDump methodsFor: 'initialize release'!initialize	"Setup the receiver's instance variables."	live := false.	notesOn := OrderedCollection new.	startedAt := Time microsecondClock! !!Siren.MIDIDump class methodsFor: 'instance creation'!new	^super new initialize! !!Siren.MIDIDump class methodsFor: 'examples'!example	"Set up a MIDI dump object as a dependent of the input port. Dump for 10 seconds,	then turn off. The default update: method just dumps the MIDI packet into the transcript; 	customize this by writing your own update: method."	"MIDIDump example"	| inst port |"Get a MIDIDump and the input port."	inst := MIDIDump new.	port := MIDIPort new openInput."Add the dump as a dependent of the port."	port addDependent: inst."Turn on the port for input."	port stopMIDIEcho.	port stopControllerCaching.	port startMIDIInput."Wait"	Cursor wait showWhile: [(Delay forSeconds: 5) wait]."Turn the port off"	port stopMIDIInput.	port close."Don't forget to remove the dependent."	port removeDependent: inst.!exampleEditor	"Set up a MIDI dump object as a dependent of the input port. Capture it to an event list and update the view in real time BROKEN."	"MIDIDump exampleEditor"	| inst port list |"Get a MIDIDump and the input port."	inst := MIDIDump new.	inst live: true.	list := EventList newAnonymous.	list edit.	inst eventList: list.	port := MIDIPort new openInput."Add the dump as a dependent of the port."	port addDependent: inst."Turn on the port for input."	port stopMIDIEcho.	port stopControllerCaching.	port startMIDIInput."Wait"	Cursor wait showWhile: [(Delay forSeconds: 5) wait]."Turn the port off"	port stopMIDIInput.	port close."Don't forget to remove the dependent."	port removeDependent: inst.!exampleList	"Set up a MIDI dump object as a dependent of the input port. Capture it to an event list."	"MIDIDump exampleList"	"PortMidiInterface unloadLibraries"	| inst port list |"Get a MIDIDump and the input port."	inst := MIDIDump new.	list := EventList newAnonymous.	list code: #noteOnOff.	inst eventList: list.	port := MIDIPort new openInput."Add the dump as a dependent of the port."	port addDependent: inst."Turn on the port for input."	port stopMIDIEcho.	port stopControllerCaching.	port startMIDIInput."Wait"	Cursor wait showWhile: [(Delay forSeconds: 5) wait]."Turn the port off"	port stopMIDIInput.	port close."Don't forget to remove the dependent."	port removeDependent: inst.	list setDurations.	list "inspect" edit! !!Siren.Amplitude class methodsFor: 'class constants'!color	"Answer the default color to display instances with."	^ColorValue blue!initialize	"Set up the class inst var, a generality table."	"Amplitude initialize"	"Amplitude generalize: (21 dB) and: (88 velocity)"	"Amplitude generalize: (#ff ampl) and: (127 velocity)"	generalityTable :=		((DBLoudness -> 80),		(RatioLoudness -> 80),		(MIDIVelocity -> 40),		(SymbolicLoudness -> 20))!initializeGenerality	"Set up the class inst var, a generality table."	"Amplitude initialize"	"Amplitude generalize: (21 dB) and: (88 velocity)"	"Amplitude generalize: (#ff ampl) and: (127 velocity)"	generalityTable :=		((DBLoudness -> 80),		(RatioLoudness -> 80),		(MIDIVelocity -> 40),		(SymbolicLoudness -> 20))!mostGeneral	"Answer the most general-purpose duration--relative"	^#asRatio!propertyName	"Answer the receiver class's default property name."	^#loudness:!relativeMember	"Answer the receiver class's species member used as a relative magnitude."	^RatioLoudness!species	"Answer Amplitude."	^Amplitude! !!Siren.Amplitude class methodsFor: 'examples'!example	"Print a simple message to the transcript demonstrating the various types."	"SymbolicLoudness nameMap inspect"	"Amplitude example"	| me |	me := Amplitude value: #mf.	Transcript show: me printString; cr;		show: me asRatio printString; cr;		show: me asMIDI printString; cr.	me inspect! !!Siren.Amplitude class methodsFor: 'instance creation'!value: aValue	"Answer a new instance of a member of my species."	aValue species == Amplitude ifTrue: [^aValue].	(aValue isMemberOf: SmallInteger)			ifTrue: [^MIDIVelocity new value: aValue].	(aValue isKindOf: LimitedPrecisionReal)			ifTrue: [^RatioLoudness new value: aValue].	(aValue isMemberOf: Fraction)			ifTrue: [^RatioLoudness new value: aValue].	(aValue isKindOf: String)			ifTrue: [^SymbolicLoudness new value: aValue asSymbol].	^self new value: aValue! !!Siren.Sound methodsFor: 'cue accessing'!addCueNamed: cName from: start to: stop	"Add the given named cue region to the receiver's list."	| list key |	self cueList == nil		ifTrue: [self cueList: OrderedCollection new].	list := self cueList.	key := cName asSymbol.	1 to: list size do:		[ :ind |		((list at: ind) key == key)			ifTrue: [^list at: ind put: (key -> (start to: stop))]].	list add: (cName asSymbol -> (start to: stop)).!cueList	"Answer the receiver's 'cueList'."	properties ifNil: [^nil].	^properties at: #cueList ifAbsent: [nil]!cueList: CollectionOfCues	"Set the receiver's 'cueList' to be the given OrderedCollection of (#name -> (start to: stop)) cues."	^properties at: #cueList put: CollectionOfCues!cueNamed: cName	"Answer a sound derived from the receiver using the samples between the named cue points."	^self subclassResponsibility!cueRegionNamed: cName	"Answer a indices for the samples between the named cue points."	| q |	self cueList == nil		ifTrue: [self error: 'There is no cue by the name ', 				cName printString, ' in this sound.'].	q := self cueList detect: [ :c | c key == cName] ifNone: [nil].	q == nil		ifTrue: [self error: 'There is no cue by the name ', 				cName printString, ' in this sound.'].	^q value! !!Siren.Sound methodsFor: 'testing'!isSound	"Answer true."	^true! !!Siren.Sound methodsFor: 'initialize-release'!finalize	"Free the receiver's external data, if any"	| fileNumber |	fileNumber := self at: #fileIndex.	fileNumber ifNotNil:		[SoundFile releaseFileIndex: fileNumber]!initialize	"Set up a default sound."	self propCheck.	range := -1.0 to: 1.0! !!Siren.Sound class methodsFor: 'instance accessing'!named: aName	"Answer the sound by the given name, or nil."	^SirenSession sounds at: aName asSymbol ifAbsent: [nil]!named: aName put: aSound	"Put the given sound in the shared dictionary under the given name."	SirenSession sounds ifNil: [^nil].	^SirenSession sounds at: aName asSymbol put: aSound! !!Siren.Sound class methodsFor: 'utilities'!fromFile: nameString	"Open the given file (AIFF, IRCAM, NeXT, or SPARC soundfile format)"	"Sound fromFile: 'kombination.snd'"	| snd |	[snd := (SoundFile readFileNamed: nameString).	snd ifNotNil: [snd := snd sound]]		on: Core.Error		do: [ :ex |  "ignore " "self error: 'Cannot read sound file named ', nameString"].	^snd!playFile: theName	"Play the sound file with the given name"	SirenUtility playSoundFile: theName! !!Siren.SampledSound methodsFor: 'envelopes'!average	"Answer the average sample value of the receiver (normally the DC offset)."	| value min max samp |	min := max := self sampleAt: 1.	value := 0.	1 to: self size do:		[ :i |		samp := self sampleAt: i.		value := value + samp.		(samp > max) ifTrue: [max := samp].		(samp < min) ifTrue: [min := samp]].	self domain: (min to: max).	value := (value / self size) asFloat.	self at: #average put: value.	^value!computeEnvelope: type	"Compute a sample envelope for the receiver with 128 points per second."	| eSize env fcn |	self size = 0 ifTrue: [^self].	Cursor execute showWhile:		[eSize := (self duration value truncated max: 1) * 128."		Transcript show: 'Creating envelope of size: ', eSize printString; cr."		env := (Array new: eSize).		type == #peak			ifTrue: [self peaksFrom: 1 to: self size into: env]			ifFalse: [self rmsFrom: 1 to: self size into: env]].	fcn := Function from: env.	self envelope: fcn.	self hasFile		ifTrue: [Cursor write showWhile: [self writeEnvelope: type]].!computePeakEnvelope	"Compute a windowed peak sample envelope for the receiver with 1024 points per 4 seconds."	self computeEnvelope: #peak!computeRMSEnvelope	"Compute a windowed root-mean-square sample envelope for the receiver."	self computeEnvelope: #RMS!edit	"Edit the receiver."	SoundView openOn: self!max	"Answer the maximum value of the samples."	| max t |	max := 0.	1 to: self size do:		[ :i | 		t := self sampleAt: i.		(t abs > max) ifTrue: [max := t abs]].	^max!offsetBy: aFactor	"Answer a copy of the receiver offset by the given factor."	^self offsetFrom: 1 to: self size by: aFactor!offsetFrom: aStart to: aStop by: anOffset	"Answer a copy of the receiver offset by the given factor."	| newSound |	newSound := self copyAllButSamples.	1 to: self size do:		[ :i |		newSound sampleAt: i put: ((self sampleAt: i) + anOffset)].	^newSound!peakEnvelope	"Answer the receiver's peak-detected envelope, or compute a new one."	| env |	env := self envelope.	(env ~~ nil and: [env size > 0])		ifTrue: [^env].	(self readEnvelope: #peak)		ifFalse: [self computePeakEnvelope].	^self envelope!peaksFrom: aStart to: aStop into: anArray	"Place a version of the root-mean-square energy of the receiver in the argument array."	"	| arr snd |	arr := Array new: 1024.	snd := 'Nomad:Squeak:Siren:sounds:kombination.1.aiff' asSoundFile.	TimeProfileBrowser onBlock: [10 timesRepeat: 		[snd rmsFrom: 1 to: snd size into: arr]].	(Function from: arr) edit.""	<primitive: 17082>"	| aSize factor max maxPos peak sample |	aSize := anArray size.	aSize > self size		ifTrue: [^self error: 'Cannot take and rms into a larger array...'].	factor := ((aStop - aStart) asFloat / (aSize)).	max := 0.	aStart = 0		ifTrue: [0 to: aSize - 1 do:				[ :i | 				peak := 0.				(i * factor) truncated to: (i + 1 * factor) truncated do:					[ :j |					sample := (self sampleAt: j) abs.					sample > max						ifTrue: [max := sample.							maxPos := j].					sample > peak						ifTrue: [peak := sample]].				anArray at: i + 1 put: peak truncated]]		ifFalse: [0 to: aSize - 1 do:				[ :i |				peak := 0.0.				(i * factor) truncated to: (i + 1 * factor) truncated do:					[ :j |					sample := (self sampleAt: (aStart + j)) abs.					sample > max						ifTrue: [max := sample.							maxPos := aStart + j].					sample > peak						ifTrue: [peak := sample]].				anArray at: i + 1 put: peak truncated]].	self at: #maxSample put: max.	self at: #maxSamplePos put: maxPos!readEnvelope: type	"Try to read the sample envelope for the receiver from a file named XXX.env."	| sfName ext index eName eStream eSize env |	sfName := self name.	sfName isEmpty ifTrue: [^false].	ext := (type == #peak ifTrue: ['pk'] ifFalse: ['env']).	^self hasFile		ifTrue: [index := sfName indexOfSubCollection: '.snd' startingAt: 1.			eName := (sfName copyFrom: 1 to: index), ext.			eName asFilename exists				ifTrue: [eStream := eName asFilename readStream binary.					eSize := eName asFilename fileSize / 2."					Transcript show: 'Reading env ', eName, 							' size ', eSize printString; cr."					env := Array new: eSize.					1 to: eSize do:						[ :i | env at: i put: eStream nextWord].					eStream close.					self envelope: env.					true]			ifFalse: ["Transcript show: 'No envelope file found ', 						(sfName copyFrom: 1 to: index), ext; cr. "					false]]		ifFalse: [self envelope ~~ nil]!rmsEnvelope	"Answer the receiver's envelope, or compute a new one."	| env |	env := properties at: #envelope ifAbsent: [nil].	(env ~~ nil and: [env size > 0])		ifTrue: [^env].	(self readEnvelope: #RMS)		ifFalse: [self computeRMSEnvelope].	^self envelope!rmsFrom: aStart to: aStop into: anArray	"Place a version of the root-mean-square energy of the receiver in the argument array."	"	| arr snd |	arr := Array new: 512.	snd := StoredSound fileExample.	snd rmsFrom: 1 to: snd size into: arr.	(Function from: arr) edit."	| aSize factor max maxPos sum sample |	aSize := anArray size.	aSize > self size		ifTrue: [^self error: 'Cannot take and rms into a larger array...'].	factor := ((aStop - aStart) asFloat / (aSize)).	max := -1.0e30.	0 to: aSize - 1 do:		[ :i | 		sum := 0.0.		(i * factor) truncated to: (i + 1 * factor) truncated do:			[ :j |			sample := self sampleAt: (aStart + j) abs.			sample > max				ifTrue: [max := sample.						maxPos := aStart + j].			sum := sum + (sample * sample)].		anArray at: i + 1 put: (sum sqrt / factor) truncated].	self at: #maxSample put: max.	self at: #maxSamplePos put: maxPos!rmsTo: anArray	"Place a version of the root-mean-square energy of the receiver in the argument array."	^self rmsFrom: 1 to: self size into: anArray!scaleBy: aScaleFactor	"Scale the receiver's samples by the given factor."	^self scaleFrom: 1 to: self size by: aScaleFactor!scaleFrom: aStart to: aStop by: aScaleFactor	"Scale the receiver's damples by the given factor."	1 to: self size do:		[ :i |		self sampleAt: i put: ((self sampleAt: i) * aScaleFactor)].	^self!scaledBy: aScaleFactor	"Answer a copy of the receiver scaled by the given factor."	^self scaledFrom: 1 to: self size by: aScaleFactor!scaledByEnvelopeArray: anArray	"Answer a copy of the receiver scaled by the given envelope array."	^self scaledFrom: 1 to: self size byEnvelopeArray: anArray!scaledByFunction: aFunction	"Answer a copy of the receiver scaled by the given breakpoint envelope expressed as points."	^self scaledFrom: 1 to: self size byFunction: aFunction!scaledFrom: aStart to: aStop by: aScaleFactor	"Answer a copy of the receiver scaled by the given factor.""	<primitive: 17084>"	| newSound |	newSound := self copyAllButSamples.	1 to: self size do:		[ :i |		newSound sampleAt: i put: ((self sampleAt: i) * aScaleFactor)].	^newSound!scaledFrom: aStart to: aStop byEnvelopeArray: anArray	"Answer a copy of the receiver scaled by the given envelope array."	<primitive: 17086>!scaledFrom: aStart to: aStop byFunction: aFunction	"Answer a copy of the receiver scaled by the given breakpoint envelope expressed as points."	"SoundView openOn: (StoredSound sawtooth scaledByFunction: (LinearFunction from: #((0 0) (1 1))))""	<primitive: 17085>"	| newSound ssize |	newSound := self copyAllButSamples.	ssize := 1.0 / self size.	1 to: self size do:		[ :i |		newSound sampleAt: i put: ((self sampleAt: i) * (aFunction at: (i * ssize)))].	^newSound!writeEnvelope: type	"Write the sample envelope for the receiver to a file named XXX.env or XXX.pk."	| sfName index eName env eStream eSize |	sfName := self name.	index := sfName indexOfSubCollection: '.snd' startingAt: 1.	type == #peak		"or #RMS"		ifTrue: [eName := (sfName copyFrom: 1 to: index), 'pk']		ifFalse: [eName := (sfName copyFrom: 1 to: index), 'env'].	eName asFilename exists		ifTrue: [(Dialog confirm: 					'Do you really want to overwrite the envelope file ', eName)			ifFalse: [^self]].	eStream := eName asFilename writeStream binary.	env := self envelope.	eSize := env size."	Transcript show: 'Writing envelope file ', eName, 						' size ', eSize printString; cr."	1 to: eSize do:		[ :i | 		 eStream nextWordPut: (env at: i)].	eStream commit; close! !!Siren.SampledSound methodsFor: 'sample accessing'!at: anIndex 	"Answer the value at the given index (between 0 and 1)."	anIndex isSymbol		ifTrue: [^ super at: anIndex].	^ self sampleAt: anIndex					"ignore scale/offset here"!at: anIndex put: aValue	"Stuff the given sample at the given index (after lots of checking and testing)."	| newIndex |	anIndex isSymbol		ifTrue: [^ super at: anIndex put: aValue].	newIndex := self mapSampleIndex: anIndex.	newIndex <= self size		ifFalse: [self error: 'Attempt to store past the end of a sound.'].	(newIndex <= samplesInMemory)		ifFalse: ["Transcript show: 'Reading next page of sample file.'; cr."				self realSound readSamplesFrom: newIndex + firstIndex.				^self sampleAt: newIndex put: aValue].	^self privateSampleAt: anIndex put: aValue!cutFrom: startSample to: stopSample	"Cut the designated section from the receiver; answer a new sound (!!)."	^GapSound on: self cutFrom: startSample to: stopSample!floatSampleAt: index	"Answer the sample at the given index as a normalized floating-point number."	^(self intSampleAt: index) asFloat / self class maxSample!floatSampleAt: index put: aValue	"Stuff the given floating-point sample at the given index after scaling."	self intSampleAt: index put: (aValue * self class maxSample) truncated!intSampleAt: index	"Answer the sample at the given index as an integer."	^self sampleAt: index!intSampleAt: index put: aValue	"Stuff the given integer sample at the given index."	self sampleAt: index put: aValue!paste: aSound from: startSample to: stopSample at: index	"Paste the given sound into the receiver; answer a new sound (!!)."	^CompositeSound on: self paste: aSound from: startSample to: stopSample at: index!sampleAt: index	"Answer the sample at the given index, mapping and paging as necessary."	| newIndex |	self samples == nil			ifTrue: [^self error: 'There are no samples for this sound.'].	newIndex := self mapSampleIndex: index.	newIndex > domain last		"answer 0 after end of samples."		ifTrue: [^0].	newIndex < domain first		"or before start of samples."		ifTrue: [^0].	newIndex <= samplesInMemory		ifTrue: [^self privateSampleAt: newIndex]		ifFalse: ["Transcript show: 'Reading next page of sample file.'; cr."				self realSound readSamplesFrom: newIndex + firstIndex.				^self sampleAt: newIndex].	self error: 'Indexing off the end of a sound.'!sampleAt: anIndex put: aValue	"Stuff the given sample at the given index (after lots of checking and testing)."	| newIndex |	newIndex := self mapSampleIndex: anIndex.	newIndex <= self size		ifFalse: [self error: 'Attempt to store past the end of a sound.'].	(newIndex <= samplesInMemory)		ifFalse: ["Transcript show: 'Reading next page of sample file.'; cr."				self realSound readSamplesFrom: newIndex + firstIndex.				^self sampleAt: newIndex put: aValue].	^self privateSampleAt: anIndex put: aValue! !!Siren.SampledSound methodsFor: 'accessing'!allocateData	| samps |	samps := self size * channels."	((#lin16Bit -> [data := WordArray new: samps withAll: 0]),"	((#lin16Bit -> [data := UninterpretedBytes new: samps * 4]),	(#float32Bit -> [data := UninterpretedBytes new: samps * 4.			0 to: samps - 1 do: [ :i | data floatAt: (i * 4 + 1) put: 0.0]]))		case: format		otherwise: [self error: 'Unknown sound format.'].	samplesInMemory := samps!channels	"Answer the receiver's 'channels'."	^channels!channels: anObject	"Set the receiver's instance variable 'channels' to be anObject."	channels := anObject!copy	"Answer a 'clean' copy of the receiver."	| newMe |	newMe := SampledSound named: self name			size: self size format: self format.	self properties associationsDo:		[ :ass |		newMe at: (ass key) put: (ass value copy)].	1 to: self size do:		[ :index |		newMe sampleAt: index put: (self sampleAt: index)].	^newMe!copyAllButSamples	"Answer a 'clean' copy of the receiver, but don't write in the samples yet."	| newMe |	newMe := SampledSound named: self name			size: self size 			rate: self rate			channels: self channels 			format: self format.	self properties associationsDo:		[ :ass |		newMe at: (ass key) put: (ass value copy)].	^newMe!copyFrom: start to: stop	"Answer a copy of the receiver for the given sample range."	"((StoredSound sweepDur: 1.0 rate: 44100 from: 50 to: 5000 chans: 1)				copyFrom: 10000 to: 10512) edit"	| newMe |	newMe := self copyAllButSamples.	newMe size: stop - start + 1.	newMe allocateData.	start to: stop - 1 do:		[ :index |		newMe sampleAt: index - start + 1 put: (self sampleAt: index)].	^newMe!cueNamed: cName	"Answer a sound derived from the receiver using the samples between the named cue points."	| snd start stop region |	region := self cueRegionNamed: cName.	start := region first.	stop := region last.	snd := self copyAllButSamples.	snd size: (stop - start).	snd samples: (ByteArray new: (stop - start * self sampleSize)).	start to: stop do:		[ :ind |		snd sampleAt: (ind - start + 1) put: (self sampleAt: ind)].	^snd.!envelope	"Answer the receiver's envelope."	properties ifNil: [^nil].	^properties at: #envelope ifAbsent: [nil]!envelope: anEnv	"Set the receiver's envelope property."	properties at: #envelope put: anEnv!file	"Answer the sound file for the receiver (if present)."	| file |	self hasFile		ifTrue: [file := SoundFile named: self name.			file sound: self.			^file]		ifFalse: [^nil]!firstIndex	"Answer the receiver's 'firstIndex'."	^firstIndex!firstIndex: anObject	"Set the receiver's instance variable 'firstIndex' to be anObject."	firstIndex := anObject!floatsFrom: aStart to: aStop	"Answer a copy of the receiver's data within the given sample range."	| samps |	samps := ByteArray new: (aStop - aStart) * 4.	aStart to: aStop - 1 do:		[ :i | samps floatAt: (i - aStart + 1) put: (self floatSampleAt: i)].	^samps!format	"Answer the receiver's 'format'."	^format!format: fSymbol	"Set the receiver's instance variable 'format' to be fSymbol."	format := fSymbol.	range := ((#lin16Bit -> [-32768 to: 32767]), (#float32Bit -> [-1.0 to: 1.0])) 		case: fSymbol otherwise: [-1.0 to: 1.0]!frameRate	"Answer the receiver's 'rate'."	^rate!from: aStart to: aStop	"Answer a copy of the receiver within the given time range."	| sound |	sound := SampledSound named: self name			size: ((aStart - aStop) asSec * self rate) asInteger			format: self format.	((aStart * 2 - 1) max: 1) to: (aStop * 2) by: 2 do:		[ :i | sound sampleAt: i put: (self sampleAt: i)].	^sound!fromSample: start toSample: finish	"Answer a copy of the receiver within the given sample range."	| ssize sdata |	((start == nil) or: [finish == nil])		ifTrue: [^SampledSound new].	ssize := finish - start.	sdata := Array new: ssize.	1 to: ssize do:		[ :index |		sdata at: index put: (self sampleAt: index + start)].	^SampledSound fromData: sdata		rate: self rate		channels: self channels		format: self format!hasFile	"Answer whether the receiver is stored on a file of the same name."	self name isEmpty ifTrue: [^false].	^self name asFilename exists!longFormat	"Answer the receiver's format as a descriptive string."	^(	(#lin16Bit -> ['16-bit linear ints']),		(#float32Bit -> ['32-bit linear floats']),		(#Mu8Bit -> ['8-bit Mu-law']))	case: (properties at: #format ifAbsent: [nil])	otherwise: ['**unknown**']!name	"Answer the receiver's 'name'."	^name!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject!rate	"Answer the receiver's 'rate'."	^rate!rate: anObject	"Set the receiver's instance variable 'rate' to be anObject."	rate := anObject!sampleRate	"Answer the receiver's 'rate'."	^rate!sampleSize	"Answer the size in bytes of the receiver's samples (2)."	^2!samples	"Answer the instance variable 'data'."	data ifNil: [self getData].	^data!samples: theArray	"Accept the argument, 'theArray', (a Byte, Word, or Float array, or an UninterpretedBytes)	as the new instance variable 'samples'."	data := theArray.	samplesInMemory := theArray size "/ self sampleSize" .	self size: data size.!samplesInMemory	"Answer the receiver's 'samplesInMemory'."	^samplesInMemory!samplesInMemory: anObject	"Set the receiver's instance variable 'samplesInMemory' to be anObject."	samplesInMemory := anObject!size	"Return the receiver's size in sample frames."	domain ifNil: [^0].	domain isInteger ifTrue: [^domain].	^domain size!size: aNumber	"Set the receiver's 'size' in samples."	domain := 1 to: aNumber.	self duration: (Duration value: (aNumber asFloat / self rate)).	data ifNil: [self allocateData]!sizeInBytes	"Answer the size in bytes of the receiver."	^self size * self sampleSize!sizeInFrames	"Return the receiver's size in sample frames."	domain ifNil: [^0].	domain isInteger ifTrue: [^domain].	^domain size! !!Siren.SampledSound methodsFor: 'testing'!hasGaps	"Answer whether the receiver has any gaps."	^false!isComposite	"Answer whether the receiver is a composite sound."	^false!isEmpty	"Answer whether the receiver is empty."	^data isNil!isVirtual	"Answer whether the receiver is a virtual sound."	^false! !!Siren.SampledSound methodsFor: 'private'!getData	"Read samples in from the file if none in memory."	| realme |	samplesInMemory > 0		ifTrue: [data := nil].	realme := SampledSound fromFile: self fullName.	data :=  realme data.	samplesInMemory := realme samplesInMemory.	domain := realme domain.!mapSampleIndex: index	"Map the given sample index according to the 'page' (firstIndex) of the receiver."	^index truncated - firstIndex!privateSampleAt: anIndex	"Answer the sample at the given index as an integer."	^data isCPointer		ifTrue: [data isValid			ifTrue: [data at: anIndex - 1]			ifFalse: [0]]		ifFalse: [data shortAt: (anIndex * 2 - 1) bigEndian: (UninterpretedBytes isBigEndian)]!privateSampleAt: anIndex in: cPtr bigEndian: isBE	"Answer the sample at the given index as an integer, 		assuming the output is a cPointer; handle endianness."	| byteIndex word |	byteIndex := anIndex - 1 * 2.			"zero-based"	word := isBE		ifTrue: [((cPtr at: byteIndex) bitShift: 8) + (cPtr at: byteIndex + 1)]		ifFalse: [((cPtr at: byteIndex + 1) bitShift: 8) + (cPtr at: byteIndex)].	^(word bitAnd: 16r7FFF) - (word bitAnd: 16r8000)!privateSampleAt: anIndex in: cPtr put: value bigEndian: isBE	"Answer the sample at the given index as an integer, 		assuming the output is a cPointer; handle endianness."	| byteIndex word |	byteIndex := anIndex - 1 * 2.			"zero-based"	word := (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000).	isBE		ifTrue:			[cPtr at: byteIndex put: (word bitShift: -8).			cPtr at: byteIndex + 1 put: (word bitAnd: 16rFF)]		ifFalse:			[cPtr at: byteIndex + 1 put: (word bitShift: -8).			cPtr at: byteIndex put: (word bitAnd: 16rFF)]!privateSampleAt: anIndex put: aValue	"Stuff the given sample at the given index (safely)."	data shortAt: (anIndex * 2 - 1) put: (aValue truncated) bigEndian: (UninterpretedBytes isBigEndian)!readSamplesFrom: index	"Read in samples from disk starting a bit before the given index."	| file fSize offset |	file := self file.	file == nil		ifTrue: [self error: 'There is no sound file associated with this sound.'].	fSize := file size.	offset := index - 128.	(offset + samplesInMemory) > fSize		ifTrue: [offset := fSize - samplesInMemory].	Cursor read showWhile: [file readSamplesStartingAt: offset].	firstIndex := offset!realSound	"Answer the real sound for the receiver (overridden in virtual subclasses)."	^self!scaleSampleIndex: index	"Scale the given sample index according to the sample size of the receiver."	^index * self sampleSize - 1.! !!Siren.SampledSound methodsFor: 'enumerating'!do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	self samples do: aBlock! !!Siren.SampledSound methodsFor: 'initialize-release'!initialize	"Set up a default sound."	super initialize.	firstIndex := 0."	folder := ''."	name := ''.	rate := 44100.	channels := 1.	format := #lin16Bit.	samplesInMemory := 0! !!Siren.SampledSound methodsFor: 'play/record'!nextBufferInto: outBuffer frames: bufferSize channels: outChannels format: sformat startingAt: startFrame	"Copy data from the receiver into the given output buffer; answer the current sample index."	| frames numToDo isBE |"	Transcript show: startFrame printString; cr."	frames := self size.	startFrame >= frames ifTrue: [^nil].	sformat == format ifFalse: [self error: 'Output format not supported.'].	numToDo := bufferSize min: (frames - startFrame).	isBE := UninterpretedBytes isBigEndian."If the sound and the output buffer are the same # of channels -- copy samples"	outChannels = channels		ifTrue: [1 to: (numToDo * channels) do:				[ :frm | | current samp |				current := self privateSampleAt: frm in: outBuffer bigEndian: isBE.				samp := self sampleAt: (startFrame + frm).				self privateSampleAt: frm in: outBuffer put: (current + samp) bigEndian: isBE].			^numToDo = bufferSize				ifFalse: [nil]				ifTrue: [startFrame + numToDo]]."else copy mono sound to multi-channel output"	channels = 1		ifTrue: [1 to: numToDo do:				[ :frm | | samp |				samp := self sampleAt: (startFrame + frm).				0 to: outChannels - 1 do:					[ :cha | | pos current |					pos := frm + cha.					current := self privateSampleAt: pos in: outBuffer bigEndian: isBE.					self privateSampleAt: pos in: outBuffer put: (current + samp) bigEndian: isBE]].			^numToDo = bufferSize				ifFalse: [nil]				ifTrue: [startFrame + numToDo]].	self error: 'unhandled sound output channel mismatch.'!play	"Play the receiver out over the default sound port."	"(SampledSound sweepDur: 2 rate: 44100 from: 20 to: 1000 chans: 1) play"	SoundPort default play: self! !!Siren.SampledSound methodsFor: 'interpolating'!autoCorrelationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| error i1 e |	error := 0.	i1 := index1.	index2 to: (index2 + length - 1) do: [:i2 |		e := (self sampleAt: i1) - (self sampleAt: i2).		e < 0 ifTrue: [e := 0 - e].		error := error + e.		i1 := i1 + 1].	^ error!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error := 0.	1 to: sampleArray1 size do: [:i |		e := (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e := 0 - e].		error := error + e].	^ error!fadeInOver: fTime	"Apply a fade-in ramp to the receiver with the given time."	| fDur |	fTime > self duration asSec value		ifTrue: [Transcript show: 'Illegal fade-in time'; cr. ^nil].	fDur := fTime * self rate * self channels.	1 to: fDur do:		[ :index |		self sampleAt: index 			put: (self sampleAt: index) * (index / fDur)]!fadeOutOver: fTime	"Apply a fade-in ramp to the receiver with the given time."	| fDur s0 |	fTime > self duration asSec value		ifTrue: [Transcript show: 'Illegal fade-in time'; cr. ^nil].	fDur := fTime * self rate * self channels.	s0 := domain - fDur.	s0 to: domain do:		[ :index |		self sampleAt: index 			put: (self sampleAt: index) * (1.0 - (index - s0 / fDur))]!interpolatedWindowAt: anIndex width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale := 10000.	anIndex isInteger		ifTrue: [^ (anIndex to: anIndex + nSamples - 1) collect: [ :i | self sampleAt: i]].	baseIndex := anIndex truncated.	scaledFrac := ((anIndex asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac := scale - scaledFrac.	prevSample := data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample := self sampleAt: i.		v := ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample := nextSample.		v].!sampleMaxFrom: aStart to: aStop into: anArray	"Place a version of the root-mean-square energy of the receiver in the argument array."	"	| arr snd |	arr := Array new: 64 withAll: 0.0.	snd := StoredSound fileExample.	snd sampleMaxFrom: 1 to: snd size into: arr.	(Function from: arr) edit.""	<primitive: 17082>"	| factor max |	anArray size > self size		ifTrue: [^self error: 'Cannot take and rms into a larger array...'].	factor := ((aStop - aStart) / (anArray size)) asFloat.	0 to: anArray size - 1 do:		[ :i | 		max := 0.		(i * factor) asInteger to: (i + 1 * factor) asInteger do:			[ :j |			max := max max: (self sampleAt: (aStart + j))].		anArray at: i + 1 put: (max asFloat / 32767.0) asFloat].!sampledFrom: aStart to: aStop into: anArray	"Place a down-sampled version of the receiver in the argument array."	<primitive: 17081> "ca n'existe pas"!sampledTo: anArray	"Place a down-sampled version of the receiver in the argument array."	^self sampledFrom: 1 to: self size into: anArray! !!Siren.SampledSound methodsFor: 'printing'!printOn: aStream	"pretty-print the receiver."	aStream nextPutAll: '(', self class name, ' '; cr.	name == nil		ifFalse: [aStream tab; nextPutAll: 'named: ', name printString; cr].	duration == nil		ifFalse: [aStream tab; nextPutAll: 'duration: ', duration printString; cr].	rate == nil		ifFalse: [aStream tab; nextPutAll: 'rate: ', rate printString; cr].	channels == nil		ifFalse: [aStream tab; nextPutAll: 'channels: ', channels printString; cr].	format == nil		ifFalse: [aStream tab; nextPutAll: 'format: ', format printString; cr].	range == nil		ifFalse: [aStream tab; nextPutAll: 'range: ', range printString; cr].	properties == nil		ifFalse: [properties associationsDo:			[ :ass |			ass key == #envelope				ifFalse: [aStream tab; nextPutAll: ass key, ': ', ass value printString; cr]]].	self envelope == nil		ifFalse: [aStream tab; nextPutAll: 'envelope: ', self envelope size printString, ' values'; cr].	self cueList == nil		ifFalse: [aStream tab; nextPutAll: 'cue list: ', self cueList size printString, ' regions'; cr].	self printSamplesOn: aStream.	aStream nextPutAll: ')'; cr.!printSamples	"pretty-print a few samples."	| stream |	stream := WriteStream on: (String new: 4096).	1 to: 512 do:		[ :i | stream nextPutAll: ((self sampleAt: i) printString); cr].	^stream contents!printSamplesOn: aStream	"Pretty-print a few samples--32 by default, 1024 if shift-down, *all* of ctrl and shift down."	| number |	data ifNil: [^aStream nextPutAll: '(no samples)'].	number := 128 min: self size.	aStream tab; nextPutAll: 'samples: #('.	1 to: number do:		[ :i | aStream nextPutAll: ((self sampleAt: i) printString), ' '].	aStream nextPutAll: '...'.	aStream nextPut: $);  cr.!storeOnFileNamed: aName	"Save the receiver on the sound file named by the argument."	(SoundFile named: aName) saveSound: self! !!Siren.SampledSound methodsFor: 'merging'!extractChannel: cNumber into: aSound	"Extract the given channel from the receiver into the argument sound."	<primitive: 17021>!mergeChannel: cNumber from: aSound	"Merge the argument sound into the given channel of the receiver."	<primitive: 17022>! !!Siren.SampledSound class methodsFor: 'class constants'!formatSymbol	"Answer the symbolic code used for the format of the receiver's instances."	^#lin16Bit!maxSample	"Answer the maximum value of the receiver class."	^32767!minSample	"Answer the minimum value of the receiver class."	^-32768! !!Siren.SampledSound class methodsFor: 'examples'!immediateInspect	"Answer a sampled sound from immediate data; inspect it."	"StoredSound immediateInspect"	| t |	 t := Array new: 64000. 	 0 to: 255 do: 		[ :i | 1 to: 250 do:			[ :j | t at: ((i * 250) + j) 			put: (j / 250 * 32000 - 16000) asInteger]].	(SampledSound fromData: t named: 'ramp' 			rate: 32000 channels: 1 format: #lin16Bit) inspect!rmsViewExample	"Read a sampled sound from the file, take the rms into 64 values, and edit that."	"SampledSound rmsViewExample"	| arr snd |	arr := Array new: 128 withAll: 0.0.	snd := SampledSound fileExample.	snd sampleMaxFrom: 1 to: snd size into: arr.	(Function from: arr) edit.!sweepExample	"Open a sound view on a swept sine wave."	"SampledSound sweepExample"	^self sweepDur: 2.0 rate: 44100 from: 20 to: 100 chans: 1!sweepView	"Open a sound view on a swept sine wave."	"SampledSound sweepView"	(SampledSound sweepDur: 2.0 rate: 44100 from: 20 to: 100 chans: 1) edit! !!Siren.SampledSound class methodsFor: 'standard wave forms'!constantOfDur: dur value: value rate: rate chans: chans	"Answer a sound with a constant value."	"SoundView openOn: (StoredSound constantOfDur: 1 value: 10000 rate: 16000 chans: 1)"	| snd |	snd := self duration: dur rate: rate channels: chans 						format: self formatSymbol.	1 to: (dur * rate * chans) truncated do: 		[ :i | snd sampleAt: i put: value].	^snd!expSweepDur: dur rate: rate from: start to: stop chans: chans	"Answer a SampledSound with a swept sine wave."	"SoundView openOn: (SampledSound expSweepDur: 1.0 rate: 44100 from: 20 to: 2000 chans: 1)"	"SoundView openOn: (SampledSound expSweepDur: 1.0 			rate: 44100 from: 20 to: 2000 chans: 1)"	| scale1 snd incr |	snd := self duration: dur rate: rate channels: chans format: self formatSymbol.	scale1 := start asFloat / rate * Float pi * 2.	incr := (stop / start) ln / (rate * dur) + 1.0.	chans = 1		ifTrue: [1 to: (dur * rate) truncated do: 			[ :i | snd intSampleAt: i put: ((i - 1 * scale1) sin * 32767) truncated.				scale1 := scale1 * incr]]		ifFalse: [(1 to: ((dur * rate) truncated - 1) by: 2) do: 			[ :i | | val |				val := ((i - 1 * scale1) sin * 32767) truncated.				snd intSampleAt: i put: val.				snd intSampleAt: ( i + 1) put: val.				scale1 := scale1 * incr]].	^snd!impulseOfDur: dur width: width rate: rate chans: chans	"Create a sound with an impulse of the given characteristics."	"SoundView openOn: (StoredSound impulseOfDur: 1 width: 0.001 rate: 16000 chans: 1)"	"(SoundFile named: 'impulse.snd') saveSound: 			(StoredSound impulseOfDur: 1 width: 0.001 			rate: 16000)"	| snd pulseLen nsamps samps |	nsamps := (rate * dur * chans) truncated.	samps := Array new: nsamps.	pulseLen := (width * rate * chans) truncated.	1 to: pulseLen do: 		[ :i | samps at: i put: 32766].	pulseLen  to: nsamps do: 		[ :i | samps at: i put: 0].	snd := SampledSound fromData: samps 			rate: rate channels: chans format: self formatSymbol.	^snd!linearSweepDur: dur rate: rate from: start to: stop chans: chans	"Answer a StoredSound with a swept sine wave."	"SoundView openOn: (StoredSound linearSweepDur: 1.0 rate: 8000 from: 20 to: 2000 chans: 1)"	| scale snd incr |	snd := self duration: dur rate: rate channels: chans format: self formatSymbol.	scale := start asFloat / rate * Float pi * 2.	incr := ((stop asFloat / rate * Float pi * 2) - scale) / (rate * dur).	chans = 1		ifTrue: [1 to: (dur * rate) truncated do: 			[ :i | snd intSampleAt: i put: ((i - 1 * scale) sin * 32767) truncated.				scale := scale + incr]]		ifFalse: [(1 to: (dur * rate) truncated by: 2) do: 			[ :i | snd intSampleAt: i put: ((i - 1 * scale) sin * 32767) truncated.				snd intSampleAt: ( i + 1) put: ((i - 1 * scale) sin * 32767) truncated.				scale := scale + incr]].	^snd!pulseTrainDur: dur rate: rate freq: freq width: width chans: chans	"Answer a StoredSound with a pulse train."	"SoundView openOn: (StoredSound pulseTrainDur: 1.0 rate: 22050 freq: 10 				width: 0.001 chans: 1 zero: 0)"	"(StoredSound pulseTrainDur: 5.0 rate: 16000 freq: 250 width: 0.001 chans: 1) storeOnFileNamed: 'snd/new/square2.snd'"	^self pulseTrainDur: dur rate: rate freq: freq width: width chans: chans zero: 0!pulseTrainDur: dur rate: rate freq: freq width: width chans: chans zero: zero	"Answer a StoredSound with a pulse train."	"SoundView openOn: (StoredSound pulseTrainDur: 1.0 rate: 22050 freq: 10 				width: 0.001 chans: 1 zero: 0)"	"(StoredSound pulseTrainDur: 5.0 rate: 16000 freq: 250 width: 0.001 chans: 1) storeOnFileNamed: 'snd/new/square2.snd'"	| waveLen snd pSamps |	snd := self duration: dur rate: rate channels: chans 					format: self formatSymbol.	waveLen := (rate / freq) truncated.	pSamps := (rate * width) truncated.	chans = 1		ifTrue: [0 to: (dur * freq - 1) truncated do: 			[ :i |1 to: pSamps do:				[ :j | snd intSampleAt: ((i * waveLen + j) min: pSamps) put: 32767].			pSamps + 1 to: waveLen do:				[ :j | snd intSampleAt: (i * waveLen + j) put: zero]]]		ifFalse: [(0 to: (dur * freq - 1) truncated by: 2) do: 			[ :i |1 to: (pSamps * 2) do:				[ :j | snd intSampleAt: (i * waveLen + j) put: 32767].			(pSamps * 2 + 1) to: (waveLen * 2) do:				[ :j | snd intSampleAt: (i * waveLen + j) put: zero]]].	^snd!rampDur: dur rate: rate chans: chans	"Answer a StoredSound with a single ramp of samples."	"SoundView openOn: (StoredSound rampDur: 2.0 rate: 16000 chans: 1)"	| incr snd |	snd := self duration: dur rate: rate channels: chans format: self formatSymbol.	incr :=  65536.0 / (rate * dur) asFloat.	snd size: (dur * rate * chans) truncated.	chans = 1		ifTrue: [1 to: snd size do: 			[ :i | snd intSampleAt: i put: (-32768.0 + (i - 1 * incr)) truncated]]	ifFalse: [(1 to: snd size by: 2) do: 			[ :i | snd intSampleAt: i put: (-32768.0 + (i - 1 * incr)) truncated.				snd intSampleAt: (i + 1) put: (-32768.0 + (i - 1 * incr)) truncated]].	^snd!sawtooth	"Answer a StoredSound with raw sawtooth samples."	"SampledSound sawtooth"	"SoundView openOn: SampledSound sawtooth"	^self sawtoothDur: 1.0 rate: 44100 freq: 50 chans: 1!sawtoothDur: dur rate: rate freq: freq chans: chans	"Answer a StoredSound with raw sawtooth samples."	"StoredSound sawtooth"	"SoundView openOn: (SampledSound sawtoothDur: 1.0 rate: 22050 freq: 100 chans: 1)"	| waveLen incr snd index |	snd := self duration: dur rate: rate channels: chans format: self formatSymbol.	waveLen := (rate / freq) asFloat.	incr :=  65536.0 / waveLen.	chans = 1		ifTrue: [1 to: (dur * rate) do: 			[ :i | 			index := ((i \\ waveLen) asFloat) max: 1.0.			snd intSampleAt: i put: (-32768.0 + (index - 1.0 * incr))]]		ifFalse: [(1 to: (dur * rate) truncated by: 2) do: 			[ :i |			index := ((i \\ waveLen) asFloat) max: 1.0.			snd intSampleAt: i put: (-32768.0 + (index - 1.0 * incr)).			snd intSampleAt: (i + 1) put: (-32768.0 + (index - 1.0 * incr))]].	^snd!sineDur: dur rate: rate freq: freq chans: chans	"Answer a StoredSound with a pulse train."	"SoundView openOn: (StoredSound sineDur: 0.5 rate: 22050 freq: 200 chans: 1)"	"(StoredSound sineDur: 5 rate: 16000 freq: 800 chans: 1) storeOnFileNamed: 'snd/new/sine.snd'"	| scale snd |	snd := self duration: dur rate: rate channels: chans format: self formatSymbol.	scale := freq / rate * Float pi * 2.	chans = 1		ifTrue: [1 to: (dur * rate) truncated do: 			[ :i | snd intSampleAt: i put: ((i - 1 * scale) sin * 32767) truncated]]		ifFalse: [(1 to: (dur * rate) truncated by: 2) do: 			[ :i | snd intSampleAt: i put: ((i - 1 * scale) sin * 32767) truncated.				snd intSampleAt: ( i + 1) put: ((i - 1 * scale) sin * 32767) truncated]].	^snd!squareDur: dur rate: rate freq: freq chans: chans	"Answer a StoredSound with a square wave."	"SoundView openOn: (StoredSound squareDur: 1.0 rate: 1000 freq: 20 chans: 1)"	^self pulseTrainDur: dur rate: rate freq: freq width: (0.5 / freq) chans: chans zero: -32767!sweepDur: dur rate: rate from: start to: stop chans: chans	"Answer a StoredSound with a swept sine wave."	"SoundView openOn: (SampledSound sweepDur: 0.5 rate: 8000 from: 20 to: 500 chans: 1)"	"SoundView openOn: (FloatSound sweepDur: 0.5 rate: 8000 from: 20 to: 500 chans: 1)"	"(SampledSound sweepDur: 2.0 rate: 44100 from: 50 to: 500 chans: 1) 				storeOnFileNamed: 'snd/new/sweep.snd'"	^self expSweepDur: dur rate: rate from: start to: stop chans: chans! !!Siren.SampledSound class methodsFor: 'instance creation'!default	"Answer the default empty sound."	"StoredSound default"	^self duration: 0.5 rate: 44100 channels: 1!duration: aDur named: nameString rate: aRate channels: aChannels format: aFormat	"Answer a new 16-bit linear sound with the given properties."	^self named: nameString size: (aDur * aRate) truncated rate: aRate 				channels: aChannels format: aFormat!duration: aDur rate: aRate channels: aChannels	"Answer a new sound with the given properties."	^self named: nil size: (aDur * aRate) truncated rate: aRate 				channels: aChannels format: self formatSymbol!duration: aDur rate: aRate channels: aChannels format: aFormat	"Answer a new sound with the given properties."	^self named: nil size: (aDur * aRate) truncated rate: aRate 				channels: aChannels format: aFormat!fromData: anArray named: nameString rate: aRate channels: aChannels format: aFormat	"Answer a new sound from the given data."	"Example: 		| t |		 t := Array new: 65536. 		 0 to: 255 do: 			[ :i | 1 to: 256 do:				[ :j | t at: ((i * 256) + j) put: (j / 256 * 32000 - 16000) asInteger]].		^StoredSound fromData: t named: 'ramp' 				rate: 16000 channels: 1 format: #lin16Bit"	| sound |	sound := self named: nameString size: (anArray size / aChannels) truncated				rate: aRate channels: aChannels format: aFormat.	1 to: anArray size do:		[ :i | sound sampleAt: i  put: (anArray at: i)].	^sound!fromData: anArray rate: aRate channels: aChannels format: aFormat	"Answer a new 16-bit linear sound from the given data."	"StoredSound immediateInspect"	^self fromData: anArray named: nil rate: aRate channels: aChannels format: aFormat!fromDblData: anArray rate: aRate channels: aChannels size: siz	"Answer a new sound from the given data."	| sound scale |	sound := self size: (siz * aChannels) truncated rate: aRate channels: aChannels format: #lin16Bit.	scale := self maxSample.	1 to: siz do:		[ :i | sound sampleAt: i  put: ((anArray valueAt: (i asFloat / aRate)) * scale) truncated].	^sound!headerFromFile: nameString	"Open the given file (EBICSF, NeXT, or SPARC soundfile format)"	"StoredSound headerFromFile: 'snd/new/orchestra.snd'"	"FileDirectory on: (FileDirectory dirPathFor: nameString) entries"	| file sound size |	file := SoundFile openFileNamed: (SirenUtility findFile: nameString).	file == nil ifTrue: [^nil]."	ver := nameString betweenPeriodsIfEmpty: '1.0.0'."	size := file size.	sound := self named: nameString size: size rate: file rate 				channels: file channels format: file format.	sound duration: (Duration value: (size / sound channels / sound rate) asFloat)."	ver isEmpty		ifTrue: [sound version: '1a00']		ifFalse: [sound version: ver]."	file properties == nil		ifFalse: [file properties associationsDo: 			[ :ass | sound at: ass key put: ass value]].	file close.	^sound!named: aName size: aSize format: formatSymbol	"Answer a new Sound with the given name and storage size."	| sound |	sound := self size: aSize format: formatSymbol channels: 1.	sound name: aName.	^sound!named: nameString size: size rate: rate channels: chans format: formatSymbol	"Answer a new Sound with the given storage size (in sample frames), etc."	| sound  nam |	(((#lin16Bit -> [sound := SampledSound new initialize])),	(#float32Bit -> [sound := FloatSound new initialize]))		case: formatSymbol		otherwise: [sound := SampledSound new initialize				"self error: 'Unknown sound format.'"].	sound channels: chans.	sound rate: rate.	sound format: formatSymbol.	sound size: size.	sound allocateData.	((nameString == nil) or: [nameString isEmpty])		ifFalse: [nam :=  nameString asFilename tail.			sound name: nam.			sound folder: nameString asFilename head.			self named: nam put: sound].	^sound!named: nameString size: size rate: rate channels: chans format: formatSymbol data: data	"Answer a new Sound with the given storage size (in sample frames), etc."	| sound nam |	((#lin16Bit -> [sound := self new initialize.			sound samples: data]),	(#float32Bit -> [sound := FloatSound new initialize.			sound samples: data]))		case: formatSymbol		otherwise: [self error: 'Unknown sound format.'].	sound channels: chans.	sound rate: rate.	sound format: formatSymbol.	sound size: size.	nameString == nil		ifFalse: [nam :=  nameString asFilename tail.			sound name: nam.			sound folder: nameString asFilename head.			self named: nam put: sound].	^sound!size: size format: formatSymbol channels: chans	"Answer a new Sound with the given storage size, etc."	^self named: nil size: size rate: (SoundPort default class rate) 				channels: chans format: formatSymbol!size: size rate: aRate channels: chans	"Answer a new Sound with the given storage size, etc."	^self named: nil size: size rate: aRate channels: chans format: self formatSymbol!size: size rate: rate channels: chans format: formatSymbol	"Answer a new Sound with the given storage size, etc."	^self named: nil size: size rate: rate channels: chans format: formatSymbol!size: size rate: rate format: formatSymbol channels: chans	"Answer a new Sound with the given storage size, etc."	^self named: nil size: size rate: rate channels: chans format: formatSymbol! !!Siren.VirtualSound methodsFor: 'sample accessing'!sampleAt: index put: aValue	"Stuff the given sample at the given index **after transforming into a 'real' sound**."	self getReal.	^super sampleAt: index put: aValue! !!Siren.VirtualSound methodsFor: 'accessing'!cue: cueName	"Set the cue name of the receiver"	properties at: #cue put: cueName.	domain := source cueRegionNamed: cueName.	duration := SecondDuration value: (self size / self rate) asFloat.	self name: self name, '.', cueName!source	"Answer the receiver's source sound."	^source!source: aSound	"Set the receiver's source sound."	source := aSound.	self rate: source rate.	self channels: source channels.	self name: source name.	self domain: aSound domain!start: start	"Set the argument as the starting sample of the receiver."	properties at: #start put: start.	(properties includesKey: #stop)		ifTrue: [self size: (properties at: #stop) - start].!stop: stop	"Set the argument as the ending sample of the receiver."	properties at: #stop put: stop.	(properties includesKey: #start)		ifTrue: [self size: stop - (properties at: #start)].! !!Siren.VirtualSound methodsFor: 'testing'!isVirtual	"Answer whether the receiver is a virtual sound."	^true! !!Siren.VirtualSound methodsFor: 'private'!getReal	"Answer a 'real sound' based on the receiver."	| newSound |	newSound := self copyAllButSamples.	1 to: self size do:		[ :ind |		newSound sampleAt: ind put: (self sampleAt: ind)].	self become: newSound!mapSampleIndex: index	"Map the given sample index according to the 'page' (firstIndex) of the source and the receiver's relative offset."	^(source mapSampleIndex: index) + firstIndex!realSound	"Answer the real sound for the receiver."	^source! !!Siren.VirtualSound class methodsFor: 'instance creation'!from: source cue: cName	"Answer a VirtualSound derived from the argument and named cue region."	"VirtualSound exampleView"	| me |	me := self new initialize.	me source: source.	me cue: cName.	^me! !!Siren.VirtualSound class methodsFor: 'examples'!exampleView	"Open a sound view on a ramp with a chunk cut out of it."	"VirtualSound exampleView"	SoundView openOn: (VirtualSound from: 			(SampledSound fromFile: 'snd/AllGatesAreOpen/nml1.8e.snd') 				cue: #stream3)! !!Siren.MIDIPort methodsFor: 'accessing'!input	"Answer the receiver's Q of input data."	"MIDIPort default input"	^inputData!isActive	"Answer whether the receiver is active."	self subclassResponsibility!reader	"Answer the receiver's read process"	^readProcess!resetInput	"Reset the receiver's Q of input data."	"MIDIPort instance resetInput"	inputData := OrderedCollection new: 16! !!Siren.MIDIPort methodsFor: 'control commands'!allNotesOff	"Turn all MIDI notes off using the channel message 123."	"MIDIPort default allNotesOff"	self isActive ifFalse: [self open].	0 to: 15 do:		[ :chan |		self controlChange: chan controller: 123 to: 0]!allNotesOffVerbose	"Turn all MIDI notes off (the verbose way)."	"MIDIPort instance allNotesOff"	| bytes answer |	bytes := ByteArray new: 3.	bytes at: 3 put: 0.	0 to: 15 do:		[ :chan |		0 to: 127 do:			[ :key |			bytes at: 1 put: (16r80 bitOr: chan).			bytes at: 2 put: key.			answer := self put: bytes length: 3.			answer = 3				ifFalse: [self error: 'Error sending note-off.']]]!controlChange: chan controller: controller to: value	"Send out a control-change command now."	"No range-checking on arguments."	| data |	data := ByteArray new: 3.	data at: 1 put: ((MIDICommands at: #ctrlChange) bitOr: chan);		at: 2 put: controller;		at: 3 put: value.	^self put: data length: 3!pitchBend: chan to: value	"Send out a pitch-bend command at the given time."	| data pitchBytes |	data := ByteArray new: 3."Get the two-byte 14-bit value for the argument."	pitchBytes := MIDIPacket bytesFor14BitValue: value.	data at: 1 put: ((MIDICommands at: #pitchWheel) bitOr: chan);		at: 2 put: pitchBytes first;		at: 3 put: (pitchBytes at: 2).	self put: data length: 3!programChange: chan to: value	"Send out a program-change command at the given time."	"No range-checking on arguments."	| data prog answer |	data := ByteArray new: 2.	value isInteger		ifTrue: [prog := value]		ifFalse: [prog := GeneralMIDIMap at: value asSymbol						ifAbsent: [self error: 'Instrument not found']].	data at: 1 put: ((MIDICommands at: #progChange) bitOr: chan);		at: 2 put: prog - 1.	answer := self put: data length: 2.	(Delay forMilliseconds: 50) wait.		"Give the synth some time..."	^answer!sysex: command	"Send out a MIDI system exclusive data packet at the given time."	| data size |	size := command size + 2.	data := ByteArray new: size.	data at: 1 put: (MIDICommands at: #sysEx).	1 to: command size do:		[ :i | data at: (i + 1) put: (command at: i)].	data at: size put: 16rF7.	self put: data length: size! !!Siren.MIDIPort methodsFor: 'initialize release'!initialize	"Setup the receiver's instance variables."	status := #Init.	device := self class out!release	"Release--break and dependencies on the error value."	super release.! !!Siren.MIDIPort methodsFor: 'read/write'!get: packet	"Read the data from the receiver into the argument (a MIDIPacket). Answer the number of data bytes read."	self subclassResponsibility!nextEventInto: anEventAssociation	"Record via the receiver into the argument."	"Answer a MusicEvent; if there's no note-off yet, put nil in the duration."	| pa1 |	pa1 := inputData first.	pa1 length = 3		ifFalse: [self error: ('Unknown MIDI packet (len = ', pa1 length printString, ')')].	pa1 command = 16r90		"if note-on command..."		ifTrue: [inputData do:	"look for note off."			[ :pa2 | 			pa2 pitch = pa1 pitch				ifTrue: [(pa2 command = 16r80 or: [pa2 ampl = 0])					ifTrue: [inputData removeFirst.						inputData remove: pa2.						^MusicEvent dur: (pa2 time - pa1 time) 							pitch: pa1 pitch ampl: pa1 ampl voice: pa1 voice]]]]		ifFalse: [self error: ('Unknown MIDI packet (cmd = ', 						pa1 command printString, ')')].	^MusicEvent dur: nil pitch: pa1 pitch ampl: pa1 ampl voice: pa1 voice!nextMessage	"Answer the first (length -> bytes) association from the input data collection."	"MIDIPort instance nextMessage"	^inputData isEmpty		ifTrue: [nil]		ifFalse: [inputData removeFirst]!play: aPitch dur: aDur amp: anAmp voice: aVoice	"Play a note (on/off message pair) with the given parameters on the receiver."	"This is the default method for drivers with no 1-call noteOn/Off command."	"Dur is assumed to be in msec."	self playOn: aPitch amp: anAmp voice: aVoice."Schedule note-off in a forked wait block."	aDur isNil		ifFalse: [[(Delay forMilliseconds: aDur) wait.				self playOff: aPitch amp: anAmp voice: aVoice] fork]!play: streamID pitch: aPitch dur: aDur amp: anAmp voice: aVoice	"Play a note (on/off message pair) with the given parameters on the receiver."	"This is the default method for drivers with no 1-call noteOn/Off command."	 | s v |	v := (aVoice - 1) max: 0.		"zero-based stream and voice index"	s := (streamID) " max: 0".	(#open == status) ifFalse: [self openOutput].	self playOn: s pitch: aPitch amp: anAmp voice: v."Schedule note-off in a forked wait block."	aDur isNil		ifFalse: [[(Delay forMilliseconds: aDur) wait.				self playOff: s pitch: aPitch amp: anAmp voice: v] fork]!playOff: streamID pitch: aPitch amp: anAmp voice: aVoice	"Play a note-on command with the given parameters on the receiver."	self subclassResponsibility!playOn: streamID pitch: aPitch amp: anAmp voice: aVoice	"Play a note-on command with the given parameters on the receiver."	self subclassResponsibility!put: data length: size	"Send the argument data to the receiver now."	self subclassResponsibility!readController: index	"Read the given controller value."	| array |	array := WordArray new: 1.	array gcCopyToHeap.	self readControllersFrom: index to: index into: array.	^array first!readControllersFrom: lo to: hi into: array	"Read a range of controllers"	self subclassResponsibility! !!Siren.MIDIPort methodsFor: 'open/close'!close	"Close MIDI."	"MIDIPort instance close"	self subclassResponsibility!open	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	self openOutput: self class out!openInput	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	self openInput: self class in!openInput: which	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	self subclassResponsibility!openOutput	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	self openOutput: self class out!openOutput: which	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	self subclassResponsibility!reset	"Reset the port."	self allNotesOff! !!Siren.MIDIPort methodsFor: 'ioctl'!eventsAvailable	"Answer the number of events in the input Q."	"MIDIPort instance eventsAvailable"	^inputData size!hasBuffer	"Answer whether the MIDI driver has a time-stamped output buffer."	^false!hasClock	"Answer whether the MIDI driver has its own clock."	^false!hasControllerCache	"Answer whether the MIDI driver supports a controller data buffer."	^false!hasDurs	"Answer whether the MIDI driver supports a 1-call note-on/off command."	^false!readLoop	"polling or waiting loop"	self subclassResponsibility!startControllerCaching	"Start caching MIDI controller in the driver."	self subclassResponsibility!startMIDIEcho	"Start echoing MIDI input from the driver."	^self			"ignored"!startMIDIInput	"Start the polling loop (or semaphore waiter) MIDI input."	"Create and start the reader process."	self resetInput.	readProcess := [self readLoop] newProcess.	readProcess priority: (Processor userBackgroundPriority - 1).	readProcess resume.!stopControllerCaching	"Stop caching MIDI controller in the driver."	self subclassResponsibility!stopMIDIEcho	"Stop echoing MIDI input from the driver."	^self			"ignored"!stopMIDIInput	"Stop signalling the read semaphore on MIDI input."	readProcess ifNotNil: 			[readProcess terminate.			readProcess release].	readProcess := nil.	self breakDependents.! !!Siren.MIDIPort class methodsFor: 'message tests'!functionExample	"Demonstrate control commands by playing a note and making a crescendo with the volume pedal."	"MIDIPort functionExample""Set the sound to organ."	| event |	MIDIPort default openOutput; programChange: 0 to: 'Church Organ'."Play a note."	(5 sec, 60 key, 40 velocity, (#voice -> 0)) play."Fade it."	event := FunctionEvent new function: (LinearFunction from: #((0 40) (4 120))).	event interval: 0.2 sec.							"5 updates per sec"	event controller: 4.								"tell it what to do, i.e., its MIDI controller"	event voice: 0.	event play!testBend	"Demonstrate pitch-bend by playing two notes and bending them."	"MIDIPort testBend"	| port |	port := self new.	port openOutput."Set the recorder instrument."	port programChange: 0 to: 'Recorder'.	port programChange: 1 to: 'Recorder'."Play two notes."	port play: 76 dur: 5000 amp: 60 voice: 0.	port play: 80 dur: 5000 amp: 60 voice: 1."Bend them--one up, one down."	0 to: 250 do:		[ :i |		port pitchBend: 0 to: 4096 + (i * 16).		port pitchBend: 1 to: 4096 - (i * 16).		(Delay forMilliseconds: 5) wait].	2 wait.	port close.!testControlContinuous	"Demonstrate control commands by playing a note and making a crescendo with the volume pedal."	"MIDIPort testControlContinuous"	| port |	port := self new.	port openOutput."Set the sound to organ."	port programChange: 0 to: 'Church Organ'."Play a note."	port play: 60 dur: 5000 amp: 30 voice: 0."Fade it."	0 to: 120 do:		[ :i |		port controlChange: 0 controller: 4 to: i.		(Delay forMilliseconds: 30) wait].	port close.!testProgramChange	"Demonstrate program change by setting up an organ instrument to play on."	"MIDIPort testProgramChange"	| port |	port := self default.	port open."Set the flute instrument."	port programChange: 0 to: 'Church Organ'."Play a note."	port play: 72 dur: 1000 amp: 70 voice: 0.	port play: 76 dur: 900 amp: 70 voice: 0.!testSysex	"Demonstrate system exclusive commands by loading the Santur scale	and playing a scale."	"Note that this is a Roland GS sysEx, but it should work on QuickTime Musical Instruments."	"MIDIPort testSysex"	| port command |	port := self default.	port open."Set the flute instrument."	port programChange: 0 to: 'Sitar'."Down-load an alternate tuning scale."	command := #(16r41 16r10 16r42 16r12 16r40 16r11 "address"			16r40 16r40 16r72 16r40 16r40 16r0E 16r40 16r40 16r40 16r0E 16r40 16r40 "scale"			16r0E 16r53 "checksum").	port sysex: command."Play a scale."	MIDIPort testAScale! !!Siren.MIDIPort class methodsFor: 'input tests'!dumpExample	"Set up a MIDI dump object as a dependent of the input port. Dump for 10 seconds,	then turn off. The default update: method just dumps the MIDI packet into the transcript; 	customize this by writing your own update: method."	"MIDIPort dumpExample"	"MIDIPort testInputStop"	| inst port |"Get a MIDIDump and the input port."	inst := MIDIDump new.	port := MIDIPort new openInput."Add the dump as a dependent of the port."	port addDependent: inst."Turn on the port for input."	port startMIDIInput."Wait"	Cursor wait showWhile: [(Delay forSeconds: 5) wait]."Turn the port off"	port stopMIDIInput.	port close."Don't forget to remove the dependent."	port removeDependent: inst.!testInput	"Open MIDI, try to read something--dump it to the transcript."	"MIDIPort testInput"	"MIDIPort testInputStop"	"MIDIPort concreteClass someInstance eventsAvailable"	| port |	port :=  self new.	SirenUtility verbosity: 2.	port openInput.	port stopMIDIEcho.	port stopControllerCaching.	port startMIDIInput."Execute this to end the test""	| port |	port :=  MIDIPort concreteClass someInstance.	port stopMIDIEcho.	port stopMIDIInput"!testInputStop	"Execute this to end the input test"	"MIDIPort testInputStop"	| port |	port := self concreteClass someInstance.	SirenUtility verbosity: 1.	port stopMIDIEcho.	port stopMIDIInput.	port close.! !!Siren.MIDIPort class methodsFor: 'class initialization'!initializeData	"Set up the dictionaries of commands, ioctl primitive selectors and arguments, and general MIDI maps."	"MIDIPort initializeData"	singleton := nil.	Streams := IdentityDictionary new.	useSingleton := true.	MIDIPort initializeMIDITables.	self concreteClass initializeData!initializeMIDITables	"MIDIPort initializeMIDITables"	Siren at: #MIDICommands put: Dictionary new.	(Siren at: #MIDICommands) at: #noteOn put: 16r90.	(Siren at: #MIDICommands) at: #noteOff put: 16r80.	(Siren at: #MIDICommands) at: #polyTouch put: 16rA0.	(Siren at: #MIDICommands) at: #chanTouch put: 16rD0.	(Siren at: #MIDICommands) at: #ctrlChange put: 16rB0.	(Siren at: #MIDICommands) at: #progChange put: 16rC0.	(Siren at: #MIDICommands) at: #pitchWheel put: 16rE0.	(Siren at: #MIDICommands) at: #sysEx put: 16rF0.	Siren at: #GeneralMIDIMap put: Dictionary new.	(Siren at: #GeneralMIDIMap) add: ('Acoustic Grand Piano' asSymbol -> 1).	(Siren at: #GeneralMIDIMap) add: ('Bright Acoustic Piano' asSymbol -> 2).	(Siren at: #GeneralMIDIMap) add: ('Electric Grand Piano' asSymbol -> 3).	(Siren at: #GeneralMIDIMap) add: ('Honky-tonk Piano' asSymbol -> 4).	(Siren at: #GeneralMIDIMap) add: ('Electric Piano 1' asSymbol -> 5).	(Siren at: #GeneralMIDIMap) add: ('Electric Piano 2' asSymbol -> 6).	(Siren at: #GeneralMIDIMap) add: ('Harpsichord' asSymbol -> 7).	(Siren at: #GeneralMIDIMap) add: ('Clavinet' asSymbol -> 8).	(Siren at: #GeneralMIDIMap) add: ('Celesta' asSymbol -> 9).	(Siren at: #GeneralMIDIMap) add: ('Glockenspiel' asSymbol -> 10).	(Siren at: #GeneralMIDIMap) add: ('Music Box' asSymbol -> 11).	(Siren at: #GeneralMIDIMap) add: ('Vibraphone' asSymbol -> 12).	(Siren at: #GeneralMIDIMap) add: ('Marimba' asSymbol -> 13).	(Siren at: #GeneralMIDIMap) add: ('Xylophone' asSymbol -> 14).	(Siren at: #GeneralMIDIMap) add: ('Tubular Bells' asSymbol -> 15).	(Siren at: #GeneralMIDIMap) add: ('Dulcimer' asSymbol -> 16).	(Siren at: #GeneralMIDIMap) add: ('Drawbar Organ' asSymbol -> 17).	(Siren at: #GeneralMIDIMap) add: ('Percussive Organ' asSymbol -> 18).	(Siren at: #GeneralMIDIMap) add: ('Rock Organ' asSymbol -> 19).	(Siren at: #GeneralMIDIMap) add: ('Church Organ' asSymbol -> 20).	(Siren at: #GeneralMIDIMap) add: ('Reed Organ' asSymbol -> 21).	(Siren at: #GeneralMIDIMap) add: ('Accordion' asSymbol -> 22).	(Siren at: #GeneralMIDIMap) add: ('Harmonica' asSymbol -> 23).	(Siren at: #GeneralMIDIMap) add: ('Tango Accordion' asSymbol -> 24).	(Siren at: #GeneralMIDIMap) add: ('Acoustic Guitar (nylon)' asSymbol -> 25).	(Siren at: #GeneralMIDIMap) add: ('Acoustic Guitar (steel)' asSymbol -> 26).	(Siren at: #GeneralMIDIMap) add: ('Electric Guitar (jazz)' asSymbol -> 27).	(Siren at: #GeneralMIDIMap) add: ('Electric Guitar (clean)' asSymbol -> 28).	(Siren at: #GeneralMIDIMap) add: ('Electric Guitar (muted)' asSymbol -> 29).	(Siren at: #GeneralMIDIMap) add: ('Overdriven Guitar' asSymbol -> 30).	(Siren at: #GeneralMIDIMap) add: ('Distortion Guitar' asSymbol -> 31).	(Siren at: #GeneralMIDIMap) add: ('Guitar harmonics' asSymbol -> 32).	(Siren at: #GeneralMIDIMap) add: ('Acoustic Bass' asSymbol -> 33).	(Siren at: #GeneralMIDIMap) add: ('Electric Bass (finger)' asSymbol -> 34).	(Siren at: #GeneralMIDIMap) add: ('Electric Bass (pick)' asSymbol -> 35).	(Siren at: #GeneralMIDIMap) add: ('Fretless Bass' asSymbol -> 36).	(Siren at: #GeneralMIDIMap) add: ('Slap Bass 1' asSymbol -> 37).	(Siren at: #GeneralMIDIMap) add: ('Slap Bass 2' asSymbol -> 38).	(Siren at: #GeneralMIDIMap) add: ('Synth Bass 1' asSymbol -> 39).	(Siren at: #GeneralMIDIMap) add: ('Synth Bass 2' asSymbol -> 40).	(Siren at: #GeneralMIDIMap) add: ('Violin' asSymbol -> 41).	(Siren at: #GeneralMIDIMap) add: ('Viola' asSymbol -> 42).	(Siren at: #GeneralMIDIMap) add: ('Cello' asSymbol -> 43).	(Siren at: #GeneralMIDIMap) add: ('Contrabass' asSymbol -> 44).	(Siren at: #GeneralMIDIMap) add: ('Tremolo Strings' asSymbol -> 45).	(Siren at: #GeneralMIDIMap) add: ('Pizzicato Strings' asSymbol -> 46).	(Siren at: #GeneralMIDIMap) add: ('Orchestral Harp' asSymbol -> 47).	(Siren at: #GeneralMIDIMap) add: ('Timpani' asSymbol -> 48).	(Siren at: #GeneralMIDIMap) add: ('String Ensemble 1' asSymbol -> 49).	(Siren at: #GeneralMIDIMap) add: ('String Ensemble 2' asSymbol -> 50).	(Siren at: #GeneralMIDIMap) add: ('SynthStrings 1' asSymbol -> 51).	(Siren at: #GeneralMIDIMap) add: ('SynthStrings 2' asSymbol -> 52).	(Siren at: #GeneralMIDIMap) add: ('Choir Aahs' asSymbol -> 53).	(Siren at: #GeneralMIDIMap) add: ('Voice Oohs' asSymbol -> 54).	(Siren at: #GeneralMIDIMap) add: ('Synth Voice' asSymbol -> 55).	(Siren at: #GeneralMIDIMap) add: ('Orchestra Hit' asSymbol -> 56).	(Siren at: #GeneralMIDIMap) add: ('Trumpet' asSymbol -> 57).	(Siren at: #GeneralMIDIMap) add: ('Trombone' asSymbol -> 58).	(Siren at: #GeneralMIDIMap) add: ('Tuba' asSymbol -> 59).	(Siren at: #GeneralMIDIMap) add: ('Muted Trumpet' asSymbol -> 60).	(Siren at: #GeneralMIDIMap) add: ('French Horn' asSymbol -> 61).	(Siren at: #GeneralMIDIMap) add: ('Brass Section' asSymbol -> 62).	(Siren at: #GeneralMIDIMap) add: ('SynthBrass 1' asSymbol -> 63).	(Siren at: #GeneralMIDIMap) add: ('SynthBrass 2' asSymbol -> 64).	(Siren at: #GeneralMIDIMap) add: ('Soprano Sax' asSymbol -> 65).	(Siren at: #GeneralMIDIMap) add: ('Alto Sax' asSymbol -> 66).	(Siren at: #GeneralMIDIMap) add: ('Tenor Sax' asSymbol -> 67).	(Siren at: #GeneralMIDIMap) add: ('Baritone Sax' asSymbol -> 68).	(Siren at: #GeneralMIDIMap) add: ('Oboe' asSymbol -> 69).	(Siren at: #GeneralMIDIMap) add: ('English Horn' asSymbol -> 70).	(Siren at: #GeneralMIDIMap) add: ('Bassoon' asSymbol -> 71).	(Siren at: #GeneralMIDIMap) add: ('Clarinet' asSymbol -> 72).	(Siren at: #GeneralMIDIMap) add: ('Piccolo' asSymbol -> 73).	(Siren at: #GeneralMIDIMap) add: ('Flute' asSymbol -> 74).	(Siren at: #GeneralMIDIMap) add: ('Recorder' asSymbol -> 75).	(Siren at: #GeneralMIDIMap) add: ('Pan Flute' asSymbol -> 76).	(Siren at: #GeneralMIDIMap) add: ('Blown Bottle' asSymbol -> 77).	(Siren at: #GeneralMIDIMap) add: ('Shakuhachi' asSymbol -> 78).	(Siren at: #GeneralMIDIMap) add: ('Whistle' asSymbol -> 79).	(Siren at: #GeneralMIDIMap) add: ('Ocarina' asSymbol -> 80).	(Siren at: #GeneralMIDIMap) add: ('Lead 1 (square)' asSymbol -> 81).	(Siren at: #GeneralMIDIMap) add: ('Lead 2 (sawtooth)' asSymbol -> 82).	(Siren at: #GeneralMIDIMap) add: ('Lead 3 (calliope)' asSymbol -> 83).	(Siren at: #GeneralMIDIMap) add: ('Lead 4 (chiff)' asSymbol -> 84).	(Siren at: #GeneralMIDIMap) add: ('Lead 5 (charang)' asSymbol -> 85).	(Siren at: #GeneralMIDIMap) add: ('Lead 6 (voice)' asSymbol -> 86).	(Siren at: #GeneralMIDIMap) add: ('Lead 7 (fifths)' asSymbol -> 87).	(Siren at: #GeneralMIDIMap) add: ('Lead 8 (bass + lead)' asSymbol -> 88).	(Siren at: #GeneralMIDIMap) add: ('Pad 1 (new age)' asSymbol -> 89).	(Siren at: #GeneralMIDIMap) add: ('Pad 2 (warm)' asSymbol -> 90).	(Siren at: #GeneralMIDIMap) add: ('Pad 3 (polysynth)' asSymbol -> 91).	(Siren at: #GeneralMIDIMap) add: ('Pad 4 (choir)' asSymbol -> 92).	(Siren at: #GeneralMIDIMap) add: ('Pad 5 (bowed)' asSymbol -> 93).	(Siren at: #GeneralMIDIMap) add: ('Pad 6 (metallic)' asSymbol -> 94).	(Siren at: #GeneralMIDIMap) add: ('Pad 7 (halo)' asSymbol -> 95).	(Siren at: #GeneralMIDIMap) add: ('Pad 8 (sweep)' asSymbol -> 96).	(Siren at: #GeneralMIDIMap) add: ('FX 1 (rain)' asSymbol -> 97).	(Siren at: #GeneralMIDIMap) add: ('FX 2 (soundtrack)' asSymbol -> 98).	(Siren at: #GeneralMIDIMap) add: ('FX 3 (crystal)' asSymbol -> 99).	(Siren at: #GeneralMIDIMap) add: ('FX 4 (atmosphere)' asSymbol -> 100).	(Siren at: #GeneralMIDIMap) add: ('FX 5 (brightness)' asSymbol -> 101).	(Siren at: #GeneralMIDIMap) add: ('FX 6 (goblins)' asSymbol -> 102).	(Siren at: #GeneralMIDIMap) add: ('FX 7 (echoes)' asSymbol -> 103).	(Siren at: #GeneralMIDIMap) add: ('FX 8 (sci-fi)' asSymbol -> 104).	(Siren at: #GeneralMIDIMap) add: ('Sitar' asSymbol -> 105).	(Siren at: #GeneralMIDIMap) add: ('Banjo' asSymbol -> 106).	(Siren at: #GeneralMIDIMap) add: ('Shamisen' asSymbol -> 107).	(Siren at: #GeneralMIDIMap) add: ('Koto' asSymbol -> 108).	(Siren at: #GeneralMIDIMap) add: ('Kalimba' asSymbol -> 109).	(Siren at: #GeneralMIDIMap) add: ('Bag pipe' asSymbol -> 110).	(Siren at: #GeneralMIDIMap) add: ('Fiddle' asSymbol -> 111).	(Siren at: #GeneralMIDIMap) add: ('Shanai' asSymbol -> 112).	(Siren at: #GeneralMIDIMap) add: ('Tinkle Bell' asSymbol -> 113).	(Siren at: #GeneralMIDIMap) add: ('Agogo' asSymbol -> 114).	(Siren at: #GeneralMIDIMap) add: ('Steel Drums' asSymbol -> 115).	(Siren at: #GeneralMIDIMap) add: ('Woodblock' asSymbol -> 116).	(Siren at: #GeneralMIDIMap) add: ('Taiko Drum' asSymbol -> 117).	(Siren at: #GeneralMIDIMap) add: ('Melodic Tom' asSymbol -> 118).	(Siren at: #GeneralMIDIMap) add: ('Synth Drum' asSymbol -> 119).	(Siren at: #GeneralMIDIMap) add: ('Reverse Cymbal' asSymbol -> 120).	(Siren at: #GeneralMIDIMap) add: ('Guitar Fret Noise' asSymbol -> 121).	(Siren at: #GeneralMIDIMap) add: ('Breath Noise' asSymbol -> 122).	(Siren at: #GeneralMIDIMap) add: ('Seashore' asSymbol -> 123).	(Siren at: #GeneralMIDIMap) add: ('Bird Tweet' asSymbol -> 124).	(Siren at: #GeneralMIDIMap) add: ('Telephone Ring' asSymbol -> 125).	(Siren at: #GeneralMIDIMap) add: ('Helicopter' asSymbol -> 126).	(Siren at: #GeneralMIDIMap) add: ('Applause' asSymbol -> 127).	(Siren at: #GeneralMIDIMap) add: ('Gunshot' asSymbol -> 128).	Siren at: #GeneralMIDIDrums put: Dictionary new.	(Siren at: #GeneralMIDIDrums) add: ('Open Cuica' asSymbol -> 79).	(Siren at: #GeneralMIDIDrums) add: ('Mute Triangle' asSymbol -> 80).	(Siren at: #GeneralMIDIDrums) add: ('Open Triangle' asSymbol -> 81).	(Siren at: #GeneralMIDIDrums) add: ('Acoustic Bass Drum' asSymbol -> 35).	(Siren at: #GeneralMIDIDrums) add: ('Bass Drum 1' asSymbol -> 36).	(Siren at: #GeneralMIDIDrums) add: ('Side Stick' asSymbol -> 37).	(Siren at: #GeneralMIDIDrums) add: ('Acoustic Snare' asSymbol -> 38).	(Siren at: #GeneralMIDIDrums) add: ('Hand Clap' asSymbol -> 39).	(Siren at: #GeneralMIDIDrums) add: ('Electric Snare' asSymbol -> 40).	(Siren at: #GeneralMIDIDrums) add: ('Low Floor Tom' asSymbol -> 41).	(Siren at: #GeneralMIDIDrums) add: ('Closed Hi Hat' asSymbol -> 42).	(Siren at: #GeneralMIDIDrums) add: ('High Floor Tom' asSymbol -> 43).	(Siren at: #GeneralMIDIDrums) add: ('Pedal Hi-Hat' asSymbol -> 44).	(Siren at: #GeneralMIDIDrums) add: ('Low Tom' asSymbol -> 45).	(Siren at: #GeneralMIDIDrums) add: ('Open Hi-Hat' asSymbol -> 46).	(Siren at: #GeneralMIDIDrums) add: ('Low-Mid Tom' asSymbol -> 47).	(Siren at: #GeneralMIDIDrums) add: ('Hi Mid Tom' asSymbol -> 48).	(Siren at: #GeneralMIDIDrums) add: ('Crash Cymbal 1' asSymbol -> 49).	(Siren at: #GeneralMIDIDrums) add: ('High Tom' asSymbol -> 50).	(Siren at: #GeneralMIDIDrums) add: ('Ride Cymbal 1' asSymbol -> 51).	(Siren at: #GeneralMIDIDrums) add: ('Chinese Cymbal' asSymbol -> 52).	(Siren at: #GeneralMIDIDrums) add: ('Ride Bell' asSymbol -> 53).	(Siren at: #GeneralMIDIDrums) add: ('Tambourine' asSymbol -> 54).	(Siren at: #GeneralMIDIDrums) add: ('Splash Cymbal' asSymbol -> 55).	(Siren at: #GeneralMIDIDrums) add: ('Cowbell' asSymbol -> 56).	(Siren at: #GeneralMIDIDrums) add: ('Crash Cymbal 2' asSymbol -> 57).	(Siren at: #GeneralMIDIDrums) add: ('Vibraslap' asSymbol -> 58).	(Siren at: #GeneralMIDIDrums) add: ('Ride Cymbal 2' asSymbol -> 59).	(Siren at: #GeneralMIDIDrums) add: ('Hi Bongo' asSymbol -> 60).	(Siren at: #GeneralMIDIDrums) add: ('Low Bongo' asSymbol -> 61).	(Siren at: #GeneralMIDIDrums) add: ('Mute Hi Conga' asSymbol -> 62).	(Siren at: #GeneralMIDIDrums) add: ('Open Hi Conga' asSymbol -> 63).	(Siren at: #GeneralMIDIDrums) add: ('Low Conga' asSymbol -> 64).	(Siren at: #GeneralMIDIDrums) add: ('High Timbale' asSymbol -> 65).	(Siren at: #GeneralMIDIDrums) add: ('Low Timbale' asSymbol -> 66).	(Siren at: #GeneralMIDIDrums) add: ('High Agogo' asSymbol -> 67).	(Siren at: #GeneralMIDIDrums) add: ('Low Agogo' asSymbol -> 68).	(Siren at: #GeneralMIDIDrums) add: ('Cabasa' asSymbol -> 69).	(Siren at: #GeneralMIDIDrums) add: ('Maracas' asSymbol -> 70).	(Siren at: #GeneralMIDIDrums) add: ('Short Whistle' asSymbol -> 71).	(Siren at: #GeneralMIDIDrums) add: ('Long Whistle' asSymbol -> 72).	(Siren at: #GeneralMIDIDrums) add: ('Short Guiro' asSymbol -> 73).	(Siren at: #GeneralMIDIDrums) add: ('Long Guiro' asSymbol -> 74).	(Siren at: #GeneralMIDIDrums) add: ('Claves' asSymbol -> 75).	(Siren at: #GeneralMIDIDrums) add: ('Hi Wood Block' asSymbol -> 76).	(Siren at: #GeneralMIDIDrums) add: ('Low Wood Block' asSymbol -> 77).	(Siren at: #GeneralMIDIDrums) add: ('Mute Cuica' asSymbol -> 78).	Siren at: #GeneralMIDIFamilies put: Dictionary new.	(Siren at: #GeneralMIDIFamilies) add: ('Pianos' asSymbol -> (1 to: 8)).	(Siren at: #GeneralMIDIFamilies) add: ('Tuned Pecussion' asSymbol -> (9 to: 16)).	(Siren at: #GeneralMIDIFamilies) add: ('Organs' asSymbol -> (17 to: 24)).	(Siren at: #GeneralMIDIFamilies) add: ('Guitars' asSymbol -> (25 to: 32)).	(Siren at: #GeneralMIDIFamilies) add: ('Bass' asSymbol -> (33 to: 40)).	(Siren at: #GeneralMIDIFamilies) add: ('Solo Strings' asSymbol -> (41 to: 48)).	(Siren at: #GeneralMIDIFamilies) add: ('Ensembles' asSymbol -> (49 to: 56)).	(Siren at: #GeneralMIDIFamilies) add: ('Brass' asSymbol -> (57 to: 64)).	(Siren at: #GeneralMIDIFamilies) add: ('Reeds' asSymbol -> (65 to: 72)).	(Siren at: #GeneralMIDIFamilies) add: ('Pipes' asSymbol -> (73 to: 80)).	(Siren at: #GeneralMIDIFamilies) add: ('Synth Lead' asSymbol -> (81 to: 88)).	(Siren at: #GeneralMIDIFamilies) add: ('Synth Pad' asSymbol -> (89 to: 96)).	(Siren at: #GeneralMIDIFamilies) add: ('Synth Effects' asSymbol -> (97 to: 104)).	(Siren at: #GeneralMIDIFamilies) add: ('Ethnic' asSymbol -> (105 to: 112)).	(Siren at: #GeneralMIDIFamilies) add: ('Percussion' asSymbol -> (113 to: 120)).	(Siren at: #GeneralMIDIFamilies) add: ('Sound Effects' asSymbol -> (121 to: 128)).! !!Siren.MIDIPort class methodsFor: 'examples'!examples	"Select and execute the following for usage examples.""Try to open and close the MIDI port (report to transcript)."	"MIDIPort testOpenClose""Open MIDI, play a 1-sec. note."	"MIDIPort testANote""Open MIDI, play a fast scale."	"MIDIPort testAScale""Open MIDI, play notes based on the mouse position (x --> voice; y --> pitch) until mouse down."	"MIDIPort testMouseMIDI""Open MIDI, try to read something--dump it to the transcript."	"MIDIPort testInput""Execute this to end the input test"	"MIDIPort testInputStop""Get the port's pending input."	"MIDIPort default eventsAvailable"	"MIDIPort default readAll"	"MIDIPort default input"	"MIDIPort default resetInput""Set up a MIDI dump object as a dependent of the input port. Dump for 30 seconds,then turn off. The default update: method just dumps the MIDI packet into the transcript; customize this by writing your own update: method."	"MIDIPort dumpExample""Set up uncached controller reading and dump input to the transcript."	"MIDIPort testControllerInput"	"MIDIPort testInputStop""Set up uncached controller reading--read controllers from lo to hi as an array and print it; stop on mouse press."	"MIDIPort testControllerCachingFrom: 48 to: 52""Play 'num' random pitches spaced 'dur' msec apart.""This test creates the messages and does the scheduling right here."	"MIDIPort testRandomPlayLowLevel: 64 dur: 80""Play a roll of 'num' notes spaced 'dur' msec apart.""This version uses the 1-call note command and driver-side scheduler."	"MIDIPort testRollHighLevel: 64 dur: 50""Play a roll of 'num' notes spaced 'dur' msec apart.""This test creates the messages and does the scheduling right here."	"MIDIPort testRollLowLevel: 64 dur: 50""Demonstrate control commands by playing a note and making a crescendo with the volume pedal."	"MIDIPort testControlContinuous""Demonstrate pitch-bend by playing two notes and bending them."	"MIDIPort testBend""Demonstrate program change by setting up an organ instrument to play on."	"MIDIPort testProgramChange""Down-load a general MIDI patch for a 4-voice organ."	"MIDIPort setupOrgan. MIDIPort default test""Down-load a general MIDI patch for a 16-voice percussion ensemble."	"MIDIPort setupTunedPercussion. MIDIPort testAScale""ANO"	"MIDIPort allNotesOff""Close down and clean up."	"MIDIPort cleanUp"!scaleFrom: lo to: hi in: dur	"Answer array of (start dur pitch amp)"	"MIDIPort scaleFrom: 48 to: 72 in: 2000"	| arr size ndur |	size := hi - lo + 1.	ndur := (dur / size) truncated.	arr := Array new: size.	1 to: size do:		[ :ind |		arr at: ind put: (Array with: (ind - 1 * ndur) with: ndur with: (ind + lo - 1) with: 96)].	^arr! !!Siren.MIDIPort class methodsFor: 'controller tests'!testControllerCaching	"Set up uncached controller reading--make a loop that reads and prints controller 48 		twice a second (until you press the shift button)."	"MIDIPort testControllerCaching"	"MIDIPort testInputStop"	| inst |	inst := self new.	inst openInput: self concreteClass in.			"Edit your controller device # here"	inst startControllerCaching.	inst startMIDIInput.	[InputState default shiftDown]		whileFalse:		[Transcript show: 'Ctrl 48: ', (inst readController: 48) printString; cr.		(Delay forMilliseconds: 500) wait].	MIDIPort testInputStop!testControllerCaching2	"Set up uncached controller reading--read controllers 48-52 as an array and print it; stop on mouse press."	"MIDIPort testControllerCaching2"	"MIDIPort testInputStop"	| array inst |	inst := self new.	inst openInput: self concreteClass in.			"Edit your controller device # here"	inst startControllerCaching.	inst startMIDIInput.	array := Array new: 5.	[InputState default shiftDown]		whileFalse:		[inst readControllersFrom: 48 to: 52 into: array.		Transcript tab; show: array printString; cr.		(Delay forMilliseconds: 500) wait].	MIDIPort testInputStop!testControllerCachingFrom: lo to: hi	"Set up uncached controller reading--read controllers from lo to hi (inclusive) as an array and print it; 		stop on <SHIFT> press."	"MIDIPort testControllerCachingFrom: 48 to: 55"	"MIDIPort testInputStop"	| inst array count |	inst := self new.	inst openInput: 3.			"Edit your controller device # here"	inst startControllerCaching.	inst startMIDIInput.	array := WordArray new: (hi - lo + 1).	array gcCopyToHeap.		"this is so that you can pass this ptr to C"	count := 0.	[InputState default shiftDown]		whileFalse:		[inst readControllersFrom: lo to: hi into: array.		Transcript tab; show: count printString, '	', array printString; cr.		(Delay forMilliseconds: 500) wait.		count := count + 1.].		Transcript show: 'Done'; cr.	MIDIPort testInputStop!testControllerRecording	"Set up uncached controller reading--make a loop that reads and prints controller 48 		40 times a second for 5 seconds."	"MIDIPort testControllerRecording"	"MIDIPort testInputStop"	| inst fcn |	inst := self new.	inst openInput: 3.			"Edit your controller device # here"	inst startControllerCaching.	fcn := Function ofSize: 200.	inst startMIDIInput.	200 timesRepeat:		[fcn add: (inst readController: 48) asFloat / 127.0.		(Delay forMilliseconds: 25) wait].	MIDIPort testInputStop.	fcn edit! !!Siren.MIDIPort class methodsFor: 'utilities'!allNotesOff	"MIDIPort allNotesOff"	| port |	port := self concreteClass someInstance.	port ifNil: [port := self new].	port allNotesOff!cleanUp	"Close down and clean up all MIDI, sound IO, event lists, etc."	"MIDIPort cleanUp"	"self concreteClass instanceCount"	"self concreteClass allInstances"	singleton := nil.	self concreteClass instanceCount = 0		ifFalse: [self concreteClass allInstances do: 			[ :p | 			p isActive ifTrue: [p stopMIDIInput]. 			p isActive ifTrue: [p close]. 			p release]]. 	EventScheduler instance flush.	MIDIVoice flushDefault!showInput	"Open MIDI, wait to read something, then dump it to the transcript."	"This toggles on and off if called repeatedly."	"MIDIPort showInput"	"singleton input"	self default open.	(singleton reader == nil)		ifTrue: [Transcript cr; show: 'Stopping MIDI Dump'; cr; cr.			singleton stopMIDIEcho.			singleton stopMIDIInput]		ifFalse: [Transcript cr; cr; show: 'Starting MIDI Dump'; cr.			singleton startMIDIEcho.			singleton stopControllerCaching.			singleton startMIDIInput]! !!Siren.MIDIPort class methodsFor: 'general MIDI patches'!setAllInstrumentsTo: iname	"Set instruments 0-15 to the General MIDI name iname"	"MIDIPort setAllInstrumentsTo: 'Tenor Sax'. MIDIPort testAScale"	"MIDIPort setAllInstrumentsTo: 'Music Box'. MIDIPort testAScale"	| port |	port := self default.	0 to: 15 do:		[ :ind |		port programChange: ind to: (GeneralMIDIMap at: iname asSymbol)]!setEnsemble: orch	"Down-load a general MIDI patch for the given ensemble (a collection of 	[chan -> name] associations)."	"MIDIPort setEnsemble: 			(Array with: (0 -> 'Reed Organ') with: (1 -> 'Rock Organ')					with: (2 -> 'Church Organ') with: (3 -> 'Drawbar Organ')					with: (4 -> 'Percussive Organ') with: (5 -> 'Accordion'))"	| port |	port := self default.	port open.	orch do:		[ :item |		port programChange: item key to: (GeneralMIDIMap at: item value asSymbol)]!setEnsembleInOrder: orch	"Down-load a general MIDI patch for the given ensemble (a collection of symbolic keys 	into the General MIDI voice map) mapping the first element to MIDI channel 1, etc."	| port |	port := self default.	port open.	1 to: orch size do:		[ :ind |		port programChange: (ind - 1) to: (GeneralMIDIMap at: (orch at: ind) asSymbol)]!setupDefaultGeneralMIDI	"Down-load a general MIDI patch for a 16-voice percussion ensemble."	"MIDIPort setupDefaultGeneralMIDI. MIDIPort testAScale"	MIDIPort setEnsembleInOrder: 			#('Acoustic Grand Piano' 'Bright Acoustic Piano' 'Electric Grand Piano' 'Honky-tonk Piano'				'Electric Piano 1' 'Electric Piano 2' 'Harpsichord' 'Clavinet' 'Celesta' 'Glockenspiel' 				'Music Box' 'Vibraphone' 'Marimba' 'Xylophone' 'Tubular Bells' 'Dulcimer').!setupOrgan	"Down-load a general MIDI patch for a 4-voice organ."	"MIDIPort setupOrgan. MIDIPort testAScale"	MIDIPort setEnsemble: 			(OrderedCollection with: (0 -> 'Reed Organ') with: (1 -> 'Rock Organ')					with: (2 -> 'Church Organ') with: (3 -> 'Drawbar Organ')					with: (4 -> 'Percussive Organ') with: (5 -> 'Accordion'))!setupTunedPercussion	"Down-load a general MIDI patch for a 16-voice percussion ensemble."	"MIDIPort setupTunedPercussion. MIDIPort testAScale"	MIDIPort setEnsembleInOrder: 			#(Agogo 'Tinkle Bell' Timpani Xylophone 				Applause 'Taiko Drum' Glockenspiel 'Synth Drum'				Gunshot 'Steel Drums' Helicopter Vibraphone				Woodblock 'Telephone Ring' Kalimba 'Blown Bottle')!setupWindOrchestra	"Down-load a general MIDI patch for a 16-voice wind ensemble."	"This could be done more tersely with the setEnsembleInOrder: method."	"MIDIPort setupWindOrchestra. MIDIPort default test"	"GeneralMIDIMap keys asSortedCollection"	| port orch |	port := self default.	port open.	orch := #(Flute 'English Horn' Bassoon Clarinet Piccolo 'Pan Flute' Recorder 'Tenor Sax'			  Flute 'English Horn' Bassoon Clarinet Piccolo 'Pan Flute' Recorder 'Tenor Sax').	1 to: orch size do:		[ :ind |		port programChange: (ind - 1) to: (GeneralMIDIMap at: (orch at: ind) asString)]! !!Siren.MIDIPort class methodsFor: 'driver performance tests'!testRandomPlayHighLevel: num dur: dur	"Play 'num' random pitches (molto legato) spaced 'dur' msec apart."	"This version uses the 1-call note command and driver-side scheduler."	"MIDIPort testRandomPlayHighLevel: 64 dur: 80"	| inst rand time |	rand := Random new.	inst := MIDIPort default.	time := Time microsecondClock + 100000.	num timesRepeat:		[inst play: (rand next * 36 + 24) truncated "random pitches"				at: time 				dur: (dur * 4) truncated 		"molto legato"				amp: 96 voice: 0.		time := time + dur].	(Delay forMicroseconds: ((num * dur) + 1000000)) wait!testRandomPlayLowLevel: num dur: dur	"Play 'num' random pitches spaced 'dur' msec apart."	"This test creates the messages and does the scheduling right here."	"MIDIPort testRandomPlayLowLevel: 64 dur: 80"	| inst data rand |	rand := Random new.	inst := MIDIPort new.	inst open.	data := ByteArray new: 3.	data at: 3 put: 96.				"velocity""	data at: 2 put: 60."	num timesRepeat:		[data at: 1 put: 16r90.		"note-on"		data at: 2 put: (rand next * 36 + 24) truncated.	"pitch"		inst put: data length: 3.		(Delay forMilliseconds: dur) wait.		Processor yield.		data at: 1 put: 16r80.			"note-off"		inst put: data length: 3]!testRollLowLevel: num dur: dur	"Play a roll of 'num' notes spaced 'dur' msec apart."	"This test creates the messages and does the scheduling right here."	"MIDIPort testRollLowLevel: 64 dur: 80"	| inst data |	inst := MIDIPort new.	inst open.	data := ByteArray new: 3.	data at: 3 put: 96.				"velocity"	data at: 2 put: 60.				"pitch"	num timesRepeat:		[data at: 1 put: 16r90.		"note-on"		inst put: data length: 3.		(Delay forMilliseconds: dur) wait.		data at: 1 put: 16r80.			"note-off"		inst put: data length: 3]! !!Siren.MIDIPort class methodsFor: 'instance creation'!concreteClass	"Answer the class to use for MIDI"	"MIDIPort concreteClass instanceCount"	^PortMIDIPort! !!Siren.MIDIPort class methodsFor: 'output tests'!testANote	"Open MIDI, play a note."	"MIDIPort release"	"MIDIPort testANote"	| inst |	inst := MIDIPort new.	inst openOutput: self concreteClass out.	inst play: 50 dur: 500 amp: 120 voice: 0.	1 wait.	inst close.!testARandomNote	"Open MIDI, play a note."	"MIDIPort testARandomNote"	| inst err data rand |	rand := Random new.	inst := MIDIPort new.	err := inst open.	Transcript cr; show: 'open --> ', err printString; cr.	data := ByteArray new: 3.	data at: 1 put: 16r90.			"note-on"	data at: 2 put: (rand next * 36 + 24) truncated.		"pitch"	data at: 3 put: 96.		"velocity"	err := inst put: data length: 3.	Transcript show: 'note-on --> ', err printString; cr.	(Delay forMilliseconds: 1000) wait.	data at: 1 put: 16r80.		"silence = note-off"	err := inst put: data length: 3.	Transcript show: 'note-off --> ', err printString; cr.!testAllNotesOff	"Try to open and close the MIDI port."	"MIDIPort testAllNotesOff"	| inst err data |	inst := MIDIPort new.	err := inst open.	Transcript cr; show: 'open --> ', err printString; cr.	data := ByteArray new: 3.	data at: 1 put: 16r90.		"note-on"	data at: 2 put: 60.			"pitch"	data at: 3 put: 127.		"velocity"	err := inst put: data length: 3.	err := inst allNotesOff.	Transcript show: 'ANO --> ', err printString; cr.	err := inst close.	Transcript show: 'close --> ', err printString; cr.!testInspect	"Inspect a MIDI port."	"MIDIPort testInspect"	| inst err |	inst := MIDIPort new.	inst inspect."	err := inst open.	Transcript cr; show: 'open --> ', err printString; cr.	err := inst test.	Transcript show: 'test --> ', err printString; cr.	err := inst close.	Transcript show: 'close --> ', err printString; cr."!testMouseMIDI	"Open MIDI, play notes based on the mouse position."	"x --> voice; y --> pitch."	"MIDIPort testMouseMIDI"	| inst moPt ht |	inst := MIDIPort default.	inst open.	MIDIPort setupTunedPercussion.	(Delay forMilliseconds: 200) wait.	ht := Screen default bounds height.	[InputState default mouseButtons = 0] whileTrue:		[moPt := InputSensor cursorPoint.		inst play: (ht - moPt y // 20 + 24) dur: 250 amp: 96 				voice: (moPt x // 50).		(Delay forMilliseconds: 100) wait].!testNoteOnOff	"Open MIDI, play a note, and close it."	"MIDIPort testNoteOnOff"	| inst err data |	inst := MIDIPort new.	data := ByteArray new: 3.	data at: 1 put: 16r90.	data at: 2 put: 64.	data at: 3 put: 96.	err := inst open.	Transcript cr; show: 'open --> ', err printString; cr.	err := inst put: data length: 3.	Transcript show: 'play --> ', err printString; cr.	data at: 3 put: 0.	err := inst put: data length: 3.	Transcript show: 'play --> ', err printString; cr.	err := inst close.	Transcript show: 'close --> ', err printString; cr.!testOpenClose	"Try to open and close the MIDI port."	"MIDIPort testOpenClose"	"MIDIPort default close"	"MIDIPort cleanUp"	| inst err |	inst := MIDIPort new.	err := inst open.	Transcript cr; show: 'open --> ', err printString; cr.	err := inst close.	singleton := nil.	Transcript show: 'close --> ', err printString; cr.!testOutput	"Open MIDI, play some random notes, and close it."	"MIDIPort testOutput"	| inst err |	inst := MIDIPort new.	err := inst open.	Transcript cr; show: 'open --> ', err printString; cr.	err := inst test.	Transcript show: 'test --> ', err printString; cr.	err := inst close.	Transcript show: 'close --> ', err printString; cr.! !!Siren.FourierSummation methodsFor: 'computing'!computeCurve	"Compute the block by sine summation--set the values in the cached array."	| width twoPi scale |	width := self class defaultSize.	myArray := Array new: width.	twoPi := 2.0 * Float pi.	scale := twoPi / width.	1 to: width do:		[ :x |		myArray at: x put: (self computeValueAt: (x * scale))].!computeValueAt: anIndex	"Compute the answer by sine summation."	"(Fourier from: #((1 1 0))) computeValueAt: (Float pi / 4)"	| value twoPi |	twoPi := 2.0 * Float pi.	value := 0.	data do:		[ :aZPoint |		"each point is (number @ amplitude @ phase)"		value := value + (((anIndex * aZPoint x) asFloat						+ (aZPoint z asFloat / 360.0 * twoPi)) sin					* aZPoint y asFloat)].	^value! !!Siren.FourierSummation methodsFor: 'accessing'!add: a3DPoint	"Add the argument to the receiver's point collection.""	| y |"	data add: a3DPoint."	y := a3DPoint y.	y < domain first		ifTrue: [self domain: (y to: domain last)].	y > domain last		ifTrue: [self domain: (domain first to: y)]."!at: theIndex	"Answer the value from my array--assume an index in the range 0 to 1"	| val |	lazy		ifTrue: [val := self computeValueAt: theIndex]		ifFalse: [myArray ifNil: [self computeCurve].				val := myArray at: ((theIndex * myArray size) truncated max: 1)].	^(val * scale) + offset! !!Siren.FourierSummation methodsFor: 'initialize-release'!initialize: size	"Initialize the receiver for the given size."	super initialize: size.	domain := 0 to: 1.	range := -1 to: 1.	lazy := false		"i.e., pre-compute the curve"! !!Siren.FourierSummation class methodsFor: 'examples'!fourierExample	"Make a Sine summation that approaches a square wave"	"FourierSummation fourierExample"	| fcn |	fcn := FourierSummation from: #((1 1 0) (3 0.3 0) (5 0.2 0) 							(7 0.15 0) (9 0.11 0) (11 0.09 0)).	Transcript show: (fcn at: 0.14) printString; cr.	fcn inspect!fourierViewExample	"Make a Sine summation that approaches a square wave and open a view on it."	"FourierSummation fourierViewExample"	FunctionView onFunction: (FourierSummation from: #((1 0.5 0) (3 0.3 0) (5 0.2 0) 							(7 0.17 0) (9 0.15 0) (11 0.1 0)))! !!Siren.FourierSummation class methodsFor: 'instance creation'!default	"Answer a default instance of the receiver class."	^FourierSummation from: #((1 0.5 0) (3 0.3 0) (5 0.2 0) 							(7 0.17 0) (9 0.15 0) (11 0.1 0))!from: anArrayOfZPoints	"Answer a sum-of-sines function with the given points."	| me |	me := self ofSize: anArrayOfZPoints size.	anArrayOfZPoints do: 			[ :anArray | 			me add: (anArray first @ (anArray at: 2) @ anArray last)].	^me! !!Siren.PhraseView methodsFor: 'layout manager access'!generateItemFor: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	| ampV |	ampV := anAss value loudness value * 32.	^(DisplayList new		model: anAss;		add: ((DisplayString new)			offset: 2@12;			model: anAss);		add: ((DisplayLine new)			offset: (0@(26 - ampV));			extent: (0@ampV));		add: ((DisplayLine new)			offset: 0@26;			extent: (anAss value duration value / xScale - 4)@0))!itemFor0: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	^(DisplayList new		model: anAss;		add: ((DisplayItem new)			offset: 1@0;			model: anAss;			visual: (anAss value phoneme asDisplayText form));		add: ((DisplayLine new)"			offset: 0@12;			extent: 0@(anAss value loudness value * 24 negated);"			offset: 0@18;			extent: (anAss value loudness value * 32)@0);		add: ((DisplayLine new)			offset: 0@14;			extent: (anAss value duration value / xScale - 4)@0))!itemFor: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	| ampV |	ampV := anAss value loudness value * 32.	^(DisplayList new		model: anAss;		add: ((DisplayString new)			offset: 2@12;			model: anAss);		add: ((DisplayLine new)			offset: (0@(26 - ampV));			extent: (0@ampV));		add: ((DisplayLine new)			offset: 0@26;			extent: (anAss value duration value / xScale - 4)@0))! !!Siren.PhraseView class methodsFor: 'examples'!example	"PhraseView example"	"NOT WORKING"	PhraseView openOn:		((EventListEditor new) eventList: (EventList named: #phrase1) copy)! !!Siren.ActionEvent methodsFor: 'scheduling'!play	"Play the receiver by executing its action block."		^action value!playAt: aTime	"Play the receiver by executing its action block."		^action value! !!Siren.ActionEvent methodsFor: 'accessing'!action	"Answer the receiver's 'action'."	^action!action: anObject	"Set the receiver's instance variable 'action' to be anObject."	action := anObject! !!Siren.ActionEvent class methodsFor: 'examples'!eventExample	"Demonstrate the creation of an ActionEvent."	"ActionEvent eventExample play"	^ActionEvent dur: 250 msec action: 		[ | gc |		gc := Window currentWindow graphicsContext.	 	gc paint: ColorValue red.		gc displayRectangle: ((20@20) extent: (20@20)).		(Delay forSeconds: 1) wait.		Window currentWindow refresh]!listExample	"Demonstrate the creation of an ActionEvent by making a list of events that draw rectangles on the top window."	"ActionEvent listExample"	"ActionEvent playExample"	"EventScheduler addClient: ActionEvent listExample; run"	"Window currentWindow refresh"	| list gc bounds rand |	list := EventList newAnonymous.	rand := Random new.	gc := Window currentWindow graphicsContext.	bounds := gc clippingBounds.	100 timesRepeat:		[list add: (ActionEvent dur: 50 msec action: 			[gc paint: ColorValue random.			gc displayRectangle: (((rand next * bounds width) truncated							@ (rand next * bounds height) truncated)				extent: ((rand next * 60) truncated)							@ (rand next * 60) truncated)])].	^list!playExample	"Demonstrate the performance of a list of ActionEvents."	"ActionEvent playExample"	EventScheduler instance addClient: self listExample in: (100 msec).	EventScheduler instance run.	(Delay forSeconds: 6) wait.	Window currentWindow refresh! !!Siren.ActionEvent class methodsFor: 'instance creation'!dur: aD action: actionBlock	"Answer an ActionEvent instance initialized with the arguments."	^self new duration: aD; action: actionBlock!dur: aD block: actionBlock	"Answer an ActionEvent instance initialized with the arguments."	^self new duration: aD; action: actionBlock! !!Siren.SoundEvent methodsFor: 'accessing'!sound	^sound!sound: aSnd	sound := aSnd.	self duration: aSnd duration.	self action: [sound play]! !!Siren.SoundEvent class methodsFor: 'instance creation'!sound: theSnd	"Create and answer a new sound event for the given sound"	| inst |	inst := self new initialize.	inst sound: theSnd.	^inst! !!Siren.SoundEvent class methodsFor: 'examples'!example	"Create and play an event list that plays the same file a few times."	"SoundEvent example"	| snd list |	snd := Sound fromFile: 'wet.snd'.	list := EventList newNamed: 'SndTest'.	0 to: 5 do:		[ :start |		list add: (SoundEvent sound: snd) at: start].	list play!exampleLoops	"Create and play an event list that loops 2 samples, with one of the loops starting with a rest."	"SoundEvent exampleLoops"	| list1 drum bass list2 |	drum := Sound fromFile: 'JAZZ02.AIF'.	list1 := EventList newNamed: 'Drums'.	list1 add: (SoundEvent sound: drum) at: 0.	list1 loop.	bass := Sound fromFile: 'JAZZ01.AIF'.	list2 := EventList newNamed: 'Bass'.	list2 add: (DurationEvent new duration: 2.99 sec).	"rest"	list2 add: (SoundEvent sound: bass).	list2 loop.! !!Siren.DisplayListController methodsFor: 'control defaults'!blueButtonActivity	"Drag scroll amplified by 2@2 with the blue button."	| pt1 pt2 |	pt1 := InputSensor cursorPoint.	[self sensor anyButtonPressed] whileTrue:		[pt2 := InputSensor cursorPoint.		(pt2 = pt1) 			ifFalse: [view scroll: (pt2 - pt1) * 2."				Transcript show: (pt2 - pt1) printString; cr."				pt1 := pt2]]!redButtonActivity	"Hit-detect items from the display list or drag a selection."	| pt1 pt2 selRect | self halt.	model == nil ifTrue: [^nil].	((model selection == nil) or: [InputState default shiftDown])		ifTrue: [pt1 := InputSensor cursorPoint.			self selectRangeWhile: [self sensor anyButtonPressed].			pt2 := InputSensor cursorPoint."			Transcript show: 'Select: ', pt1 printString, ' to ', pt2 printString; cr."			self selectFromPoint: pt1 - view pageOffset - view inset					toPoint: pt2 - view pageOffset - view class inset]		ifFalse: [selRect := model selection bounds.			pt1 := InputSensor cursorPoint - view pageOffset.			(selRect containsPoint: pt1 r)	"if you click off the selection, clear it"				ifFalse: [model select: nil.					Transcript show: 'clear'; cr.					self sensor waitNoButton]											"if you click near the selection, drag it"				ifTrue: [self dragSelectionWhile: [self sensor anyButtonPressed].					model moveSelectionTo: InputSensor cursorPoint]]!redButtonPressedAt: pt	"Handle the red mouse click"	| item |self halt.	item := self selectAtPoint: pt.!yellowButtonActivity0	"Drag scroll amplified by 2@2 with the blue button."	| pt1 pt2 |	pt1 := self sensor cursorPoint.	[self sensor anyButtonPressed] whileTrue:		[pt2 := InputSensor cursorPoint.		(pt2 = pt1) 			ifFalse: [view scrollBy: (pt2 - pt1) * 2."				Transcript show: (pt2 - pt1) printString; cr."				pt1 := InputSensor cursorPoint]]! !!Siren.DisplayListController methodsFor: 'accessing'!selection	"Answer the receiver's 'selection'."	^model selection!selection: anObject	"Set the receiver's instance variable 'selection' to be anObject."	model select: anObject!selectionTracker	^DisplayListTracker on: self! !!Siren.DisplayListController methodsFor: 'selecting'!selectAtPoint: aPoint	"Hit-detect the model for the given pt."	| item transPt |	transPt := view transformPoint: aPoint.	item := view list itemWithin: 8 of: transPt."	Transcript show: aPoint printString, '(', transPt rounded printString, ') -- sel: ', item printString; cr."	model select: item.	item == nil		ifTrue: [selOffset := nil]		ifFalse: [selOffset := aPoint - item bounds origin].	^item!selectFromPoint: aPoint toPoint: anotherPoint	"Hit-detect the model for the given range."	| item |	(aPoint dist: anotherPoint) < 8		ifTrue: [item := view list itemWithin: 24 of: aPoint.			Transcript show: 'Select ', item printString; cr.			item == nil				ifTrue: [model select: item]				ifFalse: [model select: item]]		ifFalse: [model select:				(view list itemsWithin: 						(aPoint corner: anotherPoint))]!selectRangeWhile: durationBlock	"Hit-detect items from the display list or drag a selection as long as the block is true."	| pt1 pt2 gc color1 color2 |	gc := view graphicsContext.	color1 := LookPreferences defaultForWindows backgroundColor.	color2 := LookPreferences defaultForWindows foregroundColor.	pt1 := InputSensor cursorPoint.	pt2 := pt1 + (4@4).	InputSensor cursorPoint: pt2.	durationBlock whileTrue:		[gc paint: color1.		gc displayRectangularBorder: (pt1 corner: pt2).		pt2 := InputSensor cursorPoint.		gc paint: color2.		gc displayRectangularBorder: (pt1 corner: pt2)]! !!Siren.DisplayListController methodsFor: 'menu messages'!again	"Repeat the last operation"!copyItem	"Copy the selection."	model copyBuffer: model selection copy.!cutItem	"Cut the selection."	| sel |	sel := model selection.	model copyBuffer: sel.	model list remove: sel.	model select: nil.	model changed!doInspect	"Inspect the view (if leftShiftDown) or the model."	InputState default shiftDown		ifTrue: [self inspect]		ifFalse: [model inspect]!flattenItems	"Flatten the hierarchy of the selection."!groupItems	"Group the selection."	self halt!inspectDisplayList	"Inspect the display list."	view displayList inspect!inspectEditor	"Inspect the display list editor."	model inspect!inspectModel	"Inspect the model."	model list inspect!optionsDialog	"Run the options dialog box."!pasteFromBuffer	"Paste the selection."!pasteItem	"Paste the selection."	model list add: model copyBuffer.	model changed!redraw	"Redraw the view and clear the selection."	view invalidate.	model == nil		ifFalse: [model select: nil]!redrawView	"redraw the display list."	view invalidate!undo	"Un-do the last operation"!ungroupItems	"Un-group the selection."!zoom	"Prompt the user for a scale point, zoom the view's scale, and redraw."self halt."	| pt prompt |	prompt := (view xScale == nil)		ifTrue: ['1@1']		ifFalse: [(view xScale @ view yScale) printString].	pt := DialogView request: 'zoom to scale:'			initialAnswer: prompt.	pt = '' ifFalse: [pt := Compiler evaluate: pt.			pt class == Point				ifTrue: [view xScale: pt x; yScale: pt y; redraw]]"!zoomInPoint	"Zoom the view's scale, and redraw."	view xScale: 1.0; yScale: 1.0; redraw!zoomOutPoint	"Zoom the view's scale, and redraw."	view xScale: 1.0; yScale: 1.0; redraw!zoomTo1	"Zoom the view's scale, and redraw."	view zoom: (1.0 @ 1.0)! !!Siren.DisplayListController methodsFor: 'initialize-release'!initializeMenu	"Set up the receiver's YellowButtonMenu""	| menu |	menu := Menu new.	menu addItem:  ((MenuItem labeled: 'group') value: #group).	menu addItem:  ((MenuItem labeled: 'inspect') value: #inspectModel).	menu addItem:  ((MenuItem labeled: 'redraw') value: #redraw).	menu addItem:  ((MenuItem labeled: 'zoom') value: #zoom).	menuHolder := menu asValue"	self menuHolder: self class defaultEditMenu asValue! !!Siren.DisplayListController methodsFor: 'events'!dragSelection: anEvent	"Dragging is event oriented."	model moveSelectionTo: (self sensor mousePointForEvent: anEvent) - selOffset!mouseMovedEvent: anEvent	"Mouse dragging"	anEvent redButtonPressed ifFalse: [^self].	model selection == nil		ifTrue: [self selectEvent: anEvent]		ifFalse: [self dragSelection: anEvent]!redButtonPressedEvent: event 	self selectEvent: event.!redButtonReleasedEvent: event 	selOffset := nil!selectEvent: anEvent	| point |	point := self sensor mousePointForEvent: anEvent.	self selectAtPoint: point! !!Siren.TimeSequenceController methodsFor: 'menu messages'!doInspect	"Inspect the editor (if leftShiftDown) or the list."	self sensor shiftDown		ifTrue: [model inspect]		ifFalse: [model eventList inspect]!group	"Group the current selection as a separate sub-event list in the model."	model selection == nil		ifTrue: [view flash.			^self].	model group: model selection.	model select: nil!pan	"Pan the view in x highlighting the time value until mouse press."	| time0 startTime now |	self sensor waitNoButton.	time0 := Time microsecondClock.	startTime := view offsetX * view xScale.	now := startTime.	[self sensor anyButtonPressed or: [now > model list duration value]]		whileFalse: [now := startTime + Time microsecondClock - time0.			view highlightTime: now."			Transcript show: now printString; cr.""			(Delay forMilliseconds: 100) wait."			view highlightTime: now].	self sensor waitNoButton!play	"Play the list."	model eventList play."	MIDIPort allNotesOffIn: (model eventList duration asSec value + 3)"!readList	"Copy the model list from the global dictionary."	| name |	name := Dialog request: 'EventList name for storing model:'			initialAnswer: model list name.	name = '' ifTrue: [^self].	(SirenSession eventLists includesKey: name)		ifTrue: [model eventList: (SirenSession eventLists at: name) copy]		ifFalse: [Transcript cr; show: 'No such event list.'; cr.]!storeList	"Copy the model list into the global dictionary."	| name count |	name := Dialog request: 'EventList name for storing model:'			initialAnswer: model list name.	name = '' ifTrue: [^self].	(SirenSession eventLists includesKey: name)		ifTrue: [(Dialog confirm: 'Store over existing event list?')			ifTrue: [SirenSession eventLists at: name put: model list copy]			ifFalse: [count := 2.				[SirenSession eventLists includesKey: (name, '.', count printString)]					whileTrue: [count := count + 1].				SirenSession eventLists at: (name, '.', count printString) asSymbol						put: (SirenSession eventLists at: name).				SirenSession eventLists at: name put: model list copy]]		ifFalse: [SirenSession eventLists at: name put: model list copy]! !!Siren.TimeSequenceController methodsFor: 'selecting'!selectFromPoint: aPoint toPoint: anotherPoint	"Hit-detect the model for the given range."	| collection eList |	collection := view list itemsFromX: aPoint x toX: anotherPoint x.	eList := EventList newAnonymous.	collection do:		[ :i | 		i model == nil			ifFalse: [eList add: i model]].	model select: eList.	self select: collection.	view invalidate! !!Siren.TimeSequenceController methodsFor: 'initialize-release'!initializeMenu	"Set up the receiver's YellowButtonMenu"	super initializeMenu"	self menuHolder: (ValueHolder with: (PopUpMenu			labelList: #(('group' 'inspect') ('play' 'pan') ('redraw') ('store' 'read'))			values: #(group doInspect play pan redraw storeList readList)))"! !!Siren.PitchTimeController methodsFor: 'selecting'!selectFromPoint: aPoint toPoint: anotherPoint	"Hit-detect the model for the given range."	| collection eList |	collection := view list itemsWithin: (aPoint corner: anotherPoint).	collection == nil ifTrue: [^self].	eList := EventList newAnonymous.	collection do:		[ :i | 		i model == nil			ifFalse: [eList add: i model]].	model select: eList.	self select: collection.	view invalidate! !!Siren.MIDIFileVoice methodsFor: 'initialize-release'!close	"Close the stream, device, or whatever."	stream close! !!Siren.MIDIFileVoice methodsFor: 'accessing'!defaultEventClass	^MusicEvent!tempo	^tempo!tempo: tem	tempo := tem! !!Siren.MIDIFileVoice methodsFor: 'private'!getVarLen	"Combine 1 or more input bytes from my stream into a variable length item"	| answer byte |	answer := 0.	byte := 16r80.	[(byte bitAnd: 16r80) == 0] whileFalse: [		byte := stream next. 		answer := (answer bitShift: 7) + (byte bitAnd: 16r7F)].	^answer! !!Siren.MIDIFileVoice methodsFor: 'read/write'!eventList	"load a MIDI file into anEventList."	"For file types 1 and 2, extra EventLists are created within anEventList, one per track."	"(MIDIFileVoice newOn: 'fuga1.midi') eventList inspect"	"(MIDIFileVoice newOn: 'fuga1.midi') eventList edit"	| anEventList subEventList |	anEventList := EventList newAnonymous.	self readMThd.	[stream atEnd] whileFalse:		[subEventList := EventList newAnonymous.		self readTrackOnto: subEventList.		anEventList add: subEventList at: 0]."	anEventList at: #tempo put: ((60000000/tempo) asInteger)."		"tempo in bpm"	Transcript show: ((anEventList events) size) printString, ' track EventLists'; cr.	^anEventList!readMThd	"Read the header chunk from MIDI binary file."	| word |	(SirenUtility verbosity > 1) ifTrue: [Transcript show: '	size: ', stream size printString; cr].	word := stream nextLong.			" 'MThd' "	(word = 16r4D546864)		ifFalse: [self error: 'Wrong value in MIDI file header: ', (word printStringRadix: 16); cr].	word := stream nextLong.			"length -- always 6"	fileType := stream nextWord.		"MIDI file type (0, 1, 2)"	(SirenUtility verbosity > 1) ifTrue: [Transcript show: '	MIDI file format ', fileType printString; cr].	tracks := stream nextWord.		"no. tracks"	(SirenUtility verbosity > 1) ifTrue: [Transcript show: '	number of tracks = ', tracks printString; cr].	ppq := stream nextWord.	"division (ticks per quarter beat)"	(SirenUtility verbosity > 1) ifTrue: [Transcript show: '	ticks per quarter beat = ', ppq printString; cr].!readMTrk	"Read a track chunk from MIDI binary file. Answer its length."	| length word  |	word := stream nextLong.			" 'MT' "	word == false ifTrue: [word := 0].	(word = 16r4D54726B)		ifFalse: [self error: 'Wrong value in MIDI track header: ', 						(word printStringRadix: 16); cr].	length := stream nextLong.		"length"	^length!readOnto: eventList 	"Read a MIDI file"	| track |	Transcript show: 'Reading MIDI file ', name; cr.	self readMThd.	[stream atEnd]		whileFalse: 			[track := EventList newAnonymous.			self readTrackOnto: track.			track events isEmpty				ifFalse: [eventList add: track at: 0]]."	Transcript show: eventList events size printString , ' tracks.'; cr."	^self!readTrackOnto: anEventList 	"Read a track of MIDI events from my stream into anEventList"	| fileTime trackTime deltaTime byte type vel  length startPos |	length := self readMTrk.			"read track chunk header"	startPos := stream position.	fileTime := 0.	trackTime := 0.	[stream position < (startPos + length)]		whileTrue: [fileTime := fileTime + self getVarLen.			"Get the delta time"																	"convert pulses to ms"			deltaTime := (fileTime / ppq * 600000 / 1000 asFloat - trackTime) asInteger.			trackTime := trackTime + deltaTime.			byte := stream next.									"Get the event itself"			byte ifNotNil:				[(byte bitAnd: 16r80) = 16r80						"if sysex" 				  ifTrue: [byte = 16rFF								"a meta-event?"					ifTrue: [type := stream next]					"read meta-type"					ifFalse: [type := byte.						type = 16rF0 ifFalse: [byte := stream next]]].			(type < 128 or: [type = 16rF0])							"Process a meta- or sysex event"				ifTrue: [type == 16r51								"tempo setting"						ifTrue: [tempo := 0.							self getVarLen timesRepeat: 								[tempo := tempo * 256 + stream next]]						ifFalse: [(SirenUtility verbosity > 1)							ifTrue: [Transcript show: '	meta or sysex, ' , 								(type printStringRadix: 16), ' -- '.								self getVarLen timesRepeat:		"skip over other sysex"									 [Transcript show: (stream next printStringRadix: 16), ' '].								Transcript cr]]]				ifFalse: [(type bitAnd: 16rE0) = 16rC0				"Process normal MIDI event"						ifTrue: [vel := nil]						ifFalse: [vel := stream next].				"program change or channel pressure"					anEventList 						add: ((self defaultEventClass pitch: byte ampl: vel 								voice: (type bitAnd: 15)) command: (byte bitAnd: 16rF0))						at: trackTime msec]]].	anEventList code: #noteOnOff.	anEventList setDurations."	Transcript show: anEventList events size printString , ' events'; cr"! !!Siren.MIDIFileVoice class methodsFor: 'instance creation'!newOn: fnam 	| inst realName |	realName := SirenUtility findFile: fnam.	(inst := self new) stream: (Filename named: realName) readStream binary.	inst name: fnam.	^inst! !!Siren.MIDIFileVoice class methodsFor: 'examples'!midiFileExample	"MIDIFileVoice midiFileExample"	(MIDIFileVoice newOn: 'K194.MID')		readOnto: (EventList newNamed: #K194).	(EventList named: #K194) edit.	^self! !!Siren.NumericalMagnitude methodsFor: 'double dispatching'!adaptInteger: val	^self class value: val!adaptToInteger	^self value! !!Siren.MeasureDuration methodsFor: 'private'!species	"Answer Duration."	^Duration! !!Siren.MeasureDuration methodsFor: 'printing'!units	"Answer the units string of the receiver."	^' measures'! !!Siren.HertzPitch methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a pitch string in Hertz."	aStream nextPutAll: value printString, ' Hz.'!units	"Answer the units string of the receiver."	^' Hz'! !!Siren.HertzPitch methodsFor: 'converting'!asFracMIDI	"Assuming value is a frequency, Answer a fractional key number"	"(Pitch value: 440.0) asFracMIDI"		"440.0 is MIDI key 69.0"	"(Pitch value: 445.0) asFracMIDI" 	"445.0 is MIDI key 69.195..."	"(8.17579891564371 Hz is the frequency of C0.)"	^MIDIPitch new value: (((value / 8.17579891564371) log: 2) * 12)!asFracSymbol	"Assuming value is a frequency, answer a symbolic note name"	"(Pitch value: 880.0) asSymbol"			"880.0 is a4"	"(438.0 Hz) asFracSymbol inspect"			"262.0 is a3 - an offset"	"(asSymbol throws away microtonal offset, asFracSymbol keeps it.)"		^SymbolicPitch fromFracMIDI: (self asFracMIDI)!asHertz	"Answer a HertzPitch."	^self!asHz	"Answer a HertzPitch."	^self!asMIDI	"Assuming value is a frequency, Answer a key number"	"(Pitch value: 440.0) asMIDI"		"440.0 is MIDI key 69"	"(Pitch value: 261.3) asMIDI"		"261.3 is MIDI key 60"			^MIDIPitch new value: (self asFracMIDI value rounded).!asSymbol	"Assuming value is a frequency, answer a symbolic note name"	"(Pitch value: 880.0) asSymbol"			"880.0 is a4"	"(438.0 Hz) asSymbol"			"438.0 is a3 - an offset."	"(asSymbol throws away microtonal offset, asFracSymbol keeps it.)"		^SymbolicPitch fromMIDI: (self asMIDI)! !!Siren.HertzPitch methodsFor: 'private'!species	"Answer Pitch."	^Pitch! !!Siren.HertzPitch class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asHz! !!Siren.DisplayListTracker methodsFor: 'private'!trackSelectionFor: aPoint 	| isInside |	isInside := self viewHasPoint: aPoint.	(inside == false)		ifFalse: [isInside				ifFalse: 					[controller mouseExitedAt: aPoint.					inside := false]]		ifTrue: [isInside				ifTrue: 					[controller mouseEnteredAt: aPoint.					inside := true]].	controller mouseMovedTo: aPoint! !!Siren.DisplayListTracker methodsFor: 'events'!mouseMovedEvent: aMouseMovedEvent	controller mouseMovedEvent: aMouseMovedEvent.	^nil!redButtonPressedEvent: aMouseButtonEvent 	aMouseButtonEvent isBlue ifTrue: [self halt].	controller redButtonPressedAt: (self cursorPointFor: aMouseButtonEvent)."	self trackSelectionFor: (self cursorPointFor: aMouseButtonEvent)."	aMouseButtonEvent initiator grabMouseEventFor: self.	^nil! !!Siren.MusicalInterval methodsFor: 'arithmetics'!+ anInterval 	"(MusicalInterval majorSecond) + (MusicalInterval perfectFifth)"	| note1 note2 |	note1 := self topIfBottomIs: PitchClassDo.	note2 := anInterval topIfBottomIs: note1.	^PitchClass do intervalBetween: note2! !!Siren.MusicalInterval methodsFor: 'comparing'!< anInterval	^semiTones < anInterval semiTones!<= anInterval	^semiTones <= anInterval semiTones!= anInterval 	^type = anInterval type and: [semiTones = anInterval semiTones]!> anInterval	^semiTones > anInterval semiTones!>= anInterval	^semiTones >= anInterval semiTones!hasSameDirectionAs: anInterval	^(self isAscending and: [anInterval isAscending])		or: [self isDescending and: [anInterval isDescending]]! !!Siren.MusicalInterval methodsFor: 'testing'!isA: anInterval	^self = (MusicalInterval perform: anInterval).!isAscending	^true!isDescending	^false! !!Siren.MusicalInterval methodsFor: 'automatic access'!orientedSemiTones	^semiTones!semiTones	^semiTones!semiTones: aValue	semiTones := aValue!type   ^type!type: aValue   type := aValue! !!Siren.MusicalInterval methodsFor: 'printing'!isPrintable	Object notFoundSignal handle: [:ex | ^false]		do: 			[self printPrintableOn: (WriteStream on: '').			^true]!printOn: s 	Object notFoundSignal handle: [:ex | s nextPutAll: 'non printable interval']		do: [self printPrintableOn: s]!printPrintableOn: s 	"Watch out : all Intervals cant print themselves.	You can convert a musicalInterval into a ChromaticInterval.	E.g. : Interval between Cbb and C ## (super super augmented 	unison!!!!).	There are here 40 printable intervals. Cf. method MusicalInterval allPrintableIntervals(put in protocol constants)"	type = 1 ifTrue: [s nextPutAll: (#(#superDiminished #Diminished '' #Augmented #superAugmented ) at: semiTones + 3)].	type = 2 ifTrue: [s nextPutAll: (#(#Diminished #Minor #Major #Augmented ) at: semiTones + 1)].	type = 3 ifTrue: [s nextPutAll: (#(#Minor #Major ) at: semiTones - 2)].	type = 4 ifTrue: [s nextPutAll: (#(#Diminished #Perfect #Augmented ) at: semiTones - 3)].	type = 5 ifTrue: [s nextPutAll: (#(#Diminished #Perfect #Augmented ) at: semiTones - 5)].	type = 6 ifTrue: [s nextPutAll: (#(#Minor #Major #Augmented ) at: semiTones - 7)].	type = 7 ifTrue: [s nextPutAll: (#(#Diminished #Minor #Major ) at: semiTones - 8)].	type = 8 ifTrue: [s nextPutAll: (#(#Diminished '' #Augmented ) at: semiTones - 10)].	type = 9 ifTrue: [s nextPutAll: (#(#Diminished '' #Augmented ) at: semiTones - 12)].	type = 10 ifTrue: [s nextPutAll: (#(#Diminished '' #Augmented ) at: semiTones - 14)].	type = 11 ifTrue: [s nextPutAll: (#(#Diminished '' #Augmented ) at: semiTones - 15)].	type = 12 ifTrue: [s nextPutAll: (#(#Diminished '' #Augmented ) at: semiTones - 17)].	type = 13 ifTrue: [s nextPutAll: (#(#Diminished '' #Augmented ) at: semiTones - 19)].	s nextPutAll: ' '.	s nextPutAll: (#(#unisson #second #third #fourth #fifth #sixth #seventh #octave #ninth #tenth #eleventh #twelvth #thirteenth ) at: type)!storeOn: s	s nextPutAll: '(', self class name asString.	s nextPutAll: ' type: ', type printString, ' semiTones: ', semiTones printString, ')'.! !!Siren.MusicalInterval methodsFor: 'computing notes'!topIfBottomIs: aNote 	"yields the note making the interval self with aNote"	"two cases :	- aNote is a pitch-class, in which case, no interval is 	greater than an octave	- aNote is anOctave-DependentNote, in which case octaves	should be counted"	"we want 1 -1, 2-2, 7-7, 8-1, 9-2, etc ..."	(aNote isKindOf: PitchClass)		ifTrue: [^aNote alterate: (aNote nthFollowing: type - 1 \\ 7)				toReach: semiTones \\ 12].	^aNote alterate: (aNote nthFollowing: type - 1)		toReach: semiTones! !!Siren.MusicalInterval methodsFor: 'mutations'!asChromaticInterval	^ChromaticInterval semiTones: semiTones!ascending	^self!descending	^MusicalDescendingInterval type: type semiTones: semiTones! !!Siren.MusicalInterval class methodsFor: 'examples'!allPrintableIntervals	"MusicalInterval allPrintableIntervals"	| m |	m := MusicalInterval class organization listAtCategoryNamed: 'all-printable' asSymbol.	^m collect: [:met | MusicalInterval perform: met]!example	"	MusicalInterval majorThird inverse		MusicalInterval perfectFourth topIfBottomIs: N C sharp -> Fa#	MusicalInterval perfectFourth bottomIfTopIs: N F sharp ->  Do#	N do intervalBetween: N re -> Major second 	N do flat intervalBetween: N sol -> Augmented fifth		N do flat intervalBetween: N do sharp ->  superAugmented unisson	N do flat intervalBetween: N do sharp sharp ->  non printable interval	(N do flat intervalBetween: N do sharp sharp) asChromaticInterval -> Chromatic 3	(N do intervalBetween: N sol) = (N re intervalBetween: N la) -> true	(N do intervalBetween: N fa sharp) = (N do intervalBetween: N sol flat)  -> false	MusicalInterval allIntervalsType: 3 ->  #(Major third Minor third )	MusicalInterval allIntervalsType: 2 ->	#(Augmented second Diminished second Major second Minor second )	MusicalInterval allIntervalsType: 1 -> #(Augmented unisson Diminished unisson superAugmented unisson superDiminished unisson  unisson )	"!exampleTranspositions	"three ways of of transposing pitch classes and od notes""(N re  flat) transposeOf: 3 E(N re  flat) transposeOf: -3 A#(N re  flat) transposeOf: #fourth Gb(N re  flat) transposeOf: (MusicalDescendingInterval augmentedOctave)  Dbb(N re  flat) transposeOf: (MusicalInterval fourth)   Gb(N re  flat @2) transposeOf: 3 E2(N re  flat @2) transposeOf: -3 A#1(N re  flat @2) transposeOf: #fourth Gb2(N re  flat @2) transposeOf: (MusicalDescendingInterval augmentedOctave)  Dbb1(N re  flat @2) transposeOf: (MusicalInterval fourth)  Gb2"! !!Siren.MusicalInterval class methodsFor: 'constants nick-names'!aug11	^self augmentedEleventh!aug4	^self augmentedFourth!aug5	^self augmentedFifth!aug9	"15 semitones"	^self augmentedNinth!dim13	^self diminishedThirteenth!dim5	"6 semitones"	^self diminishedFifth!dim7	"9  semitones"	^self diminishedSeventh!dim9	^self diminishedNinth!eleventh	^self type: 11 semiTones: 17!fifth	^self perfectFifth!flatFifth	^self diminishedFifth!flatNinth	"1 octave + 1  semitones"	^self diminishedNinth!flatThirteenth	^self diminishedThirteenth!fourth	^self perfectFourth!ninth	^self majorNinth!second	"2 semitones"	^self majorSecond!seventh	^self minorSeventh!sixth	^self majorSixth!thirteenth	^self majorThirteenth! !!Siren.MusicalInterval class methodsFor: 'creation'!allIntervalsType: t	"MusicalInterval allIntervalsType: 2"	^MusicalInterval allPrintableIntervals select: [:i | i type = t]!type: aType semiTones: d 	^(self new) type: aType; semiTones: d! !!Siren.MusicalInterval class methodsFor: 'all-printable'!augmentedEleventh	^self type: 11 semiTones: 18!augmentedFifth	"8 semitones"	^self type: 5 semiTones: 8!augmentedFourth	"6 semitones"	^self type: 4 semiTones: 6!augmentedNinth	"15  semitones"	^self type: 9 semiTones: 15!augmentedOctave	"3 semitones"	^self type: 8 semiTones: 13!augmentedSecond	"3 semitones"	^self type: 2 semiTones: 3!augmentedTenth	"17 semitones"	^self type: 10 semiTones: 17!augmentedTwelvth	"20 semitones"	^self type: 12 semiTones: 20!augmentedUnison	^self type: 1 semiTones: 1!diminishedFifth	"6 semitones"	^self type: 5 semiTones: 6!diminishedFourth	"5 semitones"	^self type: 4 semiTones: 4!diminishedNinth	"1 octave + 1  semitones"	^self type: 9 semiTones: 13!diminishedOctave	"11 semitones"	^self type: 8 semiTones: 11!diminishedSecond	"0 semitones"	^self type: 2 semiTones: 0!diminishedSeventh	"9  semitones"	^self type: 7 semiTones: 9!diminishedTenth	"15 semitones"	^self type: 10 semiTones: 15!diminishedThirteenth	^self type: 13 semiTones: 20!diminishedTwelvth	"18 semitones"	^self type: 12 semiTones: 18!diminishedUnison	"MusicalInterval diminishedUnison topIfBottomIs: N C"	^self type: 1 semiTones: -1!majorNinth	"14 semitones"	^self type: 9 semiTones: 14!majorSecond	"2 semitones"	^self type: 2 semiTones: 2!majorSeventh	"11  semitones"	^self type: 7 semiTones: 11!majorSixth	"9  semitones"	^self type: 6 semiTones: 9!majorTenth	"14 semitones"	^self type: 10 semiTones: 16!majorThird	"4 semitones"	^self type: 3 semiTones: 4!majorThirteenth	^self type: 13 semiTones: 21!majorTwelvth	"19 semitones"	^self type: 12 semiTones: 19!minorNinth	"1 octave + 1  semitones"	^self type: 9 semiTones: 13!minorSecond	"1 semitone"	^self type: 2 semiTones: 1!minorSeventh	"10  semitones"	^self type: 7 semiTones: 10!minorSixth	"8 semitones"	^self type: 6 semiTones: 8!minorThird	"3 semitones"	^self type: 3 semiTones: 3!minorThirteenth	^self type: 13 semiTones: 20!octave	^self type: 8 semiTones: 12!perfectEleventh	"5 semitones"	^self type: 11 semiTones: 17!perfectFifth	"7 semitones"	^self type: 5 semiTones: 7!perfectFourth	"5 semitones"	^self type: 4 semiTones: 5!superAugmentedUnison	"MusicalInterval superAugmentedUnison topIfBottomIs: N C"	^self type: 1 semiTones: 2!superDiminishedUnison	"MusicalInterval superDiminishedUnison topIfBottomIs: N C"	^self type: 1 semiTones: -2!unison	^self type: 1 semiTones: 0! !!Siren.SoundFileViewer methodsFor: 'actions'!deleteFile	"Delete the selected sound file"	(Dialog confirm: 'Delete file ', self selectedFilename asString, '?') ifFalse: [^self].	self selectedFilename delete.	self updateForNoSelection.!editFile	"Edit the selected sound file"	(SampledSound fromFile: self selectedFilename asString) edit!loadFile	"Load the selected file into the SirenSession"	| nam |	nam := self selectedFilename asString.	SirenSession sound: nam put: (SampledSound fromFile: nam)!makeS7	"Take the selected file anem make an s7 directory for it"	| selected name base tail dirName directory |	directory := browser selectedDirectory.	selected := browser selectedFile.	selected isNil ifTrue: [^nil].	name := selected asString.	base := name asFilename base.	tail := name asFilename tail.	dirName := base, 's7'.	dirName asFilename exists		ifTrue: [(Dialog confirm: 'File already exists. Should I overwrite it?')			ifFalse: [^self]]		ifFalse: [dirName asFilename makeDirectory].	name asFilename moveTo: (dirName, Filename separatorString, tail).	Transcript show: 'Created s7 file ', dirName; cr.	directory refresh.	browser directoryTreeHolder list refresh: directory.	browser selectDirectory: dirName asFilename!playFile	"Play the selected sound file"	Sound playFile: self selectedFilename asString! !!Siren.SoundFileViewer methodsFor: 'accessing'!printBlurbFor: aFilename on: stream	| snd |	snd := SoundFile openFileNamed: aFilename asString.	self		print: (#Path << #labels >> 'Path') value: [aFilename asString] on: stream;		print: (#Size << #labels >> 'Size') value: [aFilename fileSize printString] on: stream;		print: (#LastModified << #labels >> 'Last modified') 				value: [self timestampStringAt: #modified in: aFilename dates] on: stream;		print: (#Created << #labels >> 'Rate') value: [snd rate printString] on: stream;		print: (#Created << #labels >> 'Duration') 				value: [(snd size / (snd rate * snd channels)) asFloat printString] on: stream;		print: (#Created << #labels >> 'Frames') value: [snd size printString] on: stream;		print: (#Created << #labels >> 'Channels') value: [snd channels printString] on: stream;		print: (#Created << #labels >> 'Format') value: [snd sampleFormat printString] on: stream! !!Siren.SoundFileViewer class methodsFor: 'accessing'!isInterestedInFile: aFilename	('*.aiff' match: aFilename tail) ifTrue: [^true].	('*.aif' match: aFilename tail) ifTrue: [^true].	('*.snd' match: aFilename tail) ifTrue: [^true].	('*.au' match: aFilename tail) ifTrue: [^true].	('*.wav' match: aFilename tail) ifTrue: [^true].	^false!tabLabel	^(#FileInformation << #labels >> 'Sound File') asString! !!Siren.NominalMagnitude class methodsFor: 'class instance variables'!nameMap	"Answer the class instance variable NameMap."	^NameMap! !!Siren.SymbolicPitch methodsFor: 'accessing'!accidental	"Answer the receiver's accidental, if any."	| c |	(value size > 1)		ifFalse: [^nil]		ifTrue: [c := value at: 2].	^((c == $#) or: [c == $b])		ifTrue: [c]		ifFalse: [nil]!fracPitch	"return microtonal offset as fractions of a halfstep"	^fracPitch!fracPitch: aValue	"set microtonal offset as fractions of a halfstep"	fracPitch := aValue.! !!Siren.SymbolicPitch methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a symbolic pitch."	value printOn: aStream!units	"Answer the units string of the receiver."	^' pitch'! !!Siren.SymbolicPitch methodsFor: 'arithmetic'!+ aValue	"Answer the sum of the receiver and the argument-handle adding Integers as a special case."	^(aValue isMemberOf: self class)		ifTrue: [self class new value: (value + aValue value)]		ifFalse: [(aValue isMemberOf: SmallInteger)			ifTrue: [SymbolicPitch fromMIDI: (self asMIDI value + aValue)]			ifFalse: [super + aValue]]!- aValue	"Answer the sum of the receiver and the argument-handle adding Integers as a special case."	^(aValue isMemberOf: self class)		ifTrue: [self class new value: (value - aValue value)]		ifFalse: [(aValue isMemberOf: SmallInteger)			ifTrue: [SymbolicPitch fromMIDI: (self asMIDI value - aValue)]			ifFalse: [super - aValue ]]!transposeBy: aValue	"transpose a SymbolicPitch by aValue in fractional halfsteps"	^((self asFracMIDI transposeBy: aValue) asFracSymbol).! !!Siren.SymbolicPitch methodsFor: 'converting'!asFracMIDI	"Assuming value is a symbolic note name, answer a key number."	"MIDI is 0=c-based, NameMap is 0=a-based"	"(Pitch value: #c3) asFracMIDI"	"(Pitch value: 'c#3' asSymbol) asFracMIDI"	"( 'c#3' pitch fracPitch: -0.4) asFracMIDI"	(fracPitch isNil)	ifTrue: [^self asMIDI]	ifFalse: [^(self asMIDI value + fracPitch) key].!asHertz	"assuming value is a symbolic note name, return a frequency "	"(Pitch value: #a6) asHertz"		"440.0 is Midi key 69"	"(Pitch value: #c5) asHertz"		"261.0 is Midi key 60 or middle C"	^(self asFracMIDI) asHertz!asHz	"assuming value is a symbolic note name, return a frequency "	"(Pitch value: #a6) asHertz"		"440.0 is Midi key 69"	"(Pitch value: #c5) asHertz"		"261.0 is Midi key 60 or middle C"	^self asHertz!asMIDI	"Assuming value is a symbolic note name, answer a key number."	"MIDI is 0=c-based, NameMap is 0=a-based"	"(Pitch value: #c3) asMIDI"	"(Pitch value: 'c#3' asSymbol) asMIDI"	| noteName octave |	octave := '3'.	"if no octave is given, assume c3 - b3."	noteName := self value.	noteName last isDigit		ifTrue: [octave := noteName last.			noteName := noteName copyFrom: 1 to: noteName size - 1].	(noteName last == $-)	"if octave has minus sign...."		ifTrue: [octave := octave digitValue negated.			noteName := noteName copyFrom: 1 to: noteName size - 1].	^MIDIPitch new value: (self class nameMap detect: [:item | item key == noteName asSymbol]) value - 3 + (octave asString asNumber + 2 * 12)!asSymbol	"Answer a SymbolicPitch."	^self.!mostGeneral	"Answer the most numerically meaningful version of the receiver."	^self asHertz! !!Siren.SymbolicPitch methodsFor: 'private'!species	"Answer Pitch."	^Pitch! !!Siren.SymbolicPitch class methodsFor: 'class initialization'!initialize	"Set up the class name mapping array."	"SymbolicPitch initialize"	NameMap := OrderedCollection new: 32.	NameMap add: ('a' asSymbol -> 0);			add: ('a#' asSymbol -> 1);			add: ('as' asSymbol -> 1);			add: ('a-sharp' asSymbol -> 1);			add: ('bb' asSymbol -> 1);			add: ('b-flat' asSymbol -> 1);			add: ('b' asSymbol -> 2);			add: ('cb' asSymbol -> 2);			add: ('c-flat' asSymbol -> 2);			add: ('c' asSymbol -> 3);			add: ('c#' asSymbol -> 4);			add: ('cs' asSymbol -> 4);			add: ('c-sharp' asSymbol -> 4);			add: ('d-flat' asSymbol -> 4);			add: ('db' asSymbol -> 4);			add: ('d' asSymbol -> 5);			add: ('d#' asSymbol -> 6);			add: ('ds' asSymbol -> 6);			add: ('d-sharp' asSymbol -> 6);			add: ('e-flat' asSymbol -> 6);			add: ('eb' asSymbol -> 6);			add: ('e' asSymbol -> 7);			add: ('f-flat' asSymbol -> 7);			add: ('fb' asSymbol -> 7);			add: ('f' asSymbol -> 8);			add: ('f#' asSymbol -> 9);			add: ('fs' asSymbol -> 9);			add: ('f-sharp' asSymbol -> 9);			add: ('g-flat' asSymbol -> 9);			add: ('gb' asSymbol -> 9);			add: ('g' asSymbol -> 10);			add: ('g#' asSymbol -> 11);			add: ('gs' asSymbol -> 11);			add: ('g-sharp' asSymbol -> 11);			add: ('a-flat' asSymbol -> 11);			add: ('ab' asSymbol -> 11).! !!Siren.SymbolicPitch class methodsFor: 'instance creation'!fromFracMIDI: aValue	"Assuming value is a key number, answer a symbolic pitch name"	"SymbolicPitch fromMIDI: (Pitch value: 69)"	"SymbolicPitch fromMIDI: (Pitch value: 68.9 key)"	"(fromMIDI throws away microtonal offset, fromFracMIDI keeps it.)"		| tempSym tempKey |	tempKey := aValue value.	tempSym := self value: ((NameMap detect: 					[ :ass | 					ass value = (tempKey rounded + 3 \\ 12)]) key, 		(aValue value // 12 - 2) printString).	tempSym fracPitch: (tempKey - tempKey rounded).	^tempSym.!fromMIDI: aValue	"Assuming value is a key number, answer a symbolic pitch name"	"SymbolicPitch fromMIDI: (Pitch value: 69)"	"SymbolicPitch fromMIDI: (Pitch value: 68.9 key)"	"(fromMIDI throws away microtonal offset, fromFracMIDI keeps it.)"		^self value: ((NameMap detect: 					[ :ass | 					ass value = (aValue value rounded + 3 \\ 12)]) key, 		(aValue value // 12 - 2) printString).! !!Siren.SymbolicPitch class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asNote! !!Siren.EventScheduler methodsFor: 'updating'!update: anAspect	"Check if clients are waiting"	(appointments isEmpty and: [timers isEmpty])		ifTrue: [Transcript show: 'Sched stopped'; cr]! !!Siren.EventScheduler methodsFor: 'accessing'!addClient: theApp	"Add the argument, 'theApp', to the instance variable 'appointments'."	appointments add: theApp loop: false.	self changed: #appointments!addClient: theApp at: start	"Add the argument, 'theApp', to the instance variable 'appointments'."	^self addClient: theApp at: start loop: false!addClient: theApp at: start loop: aBool	"Add the argument, 'theApp', to the instance variable 'appointments'."	appointments add: (start -> theApp) loop: aBool.	self changed: #appointments!addClient: theApp in: start	"Add the argument, 'theApp', to the instance variable 'appointments'."	^self addClient: theApp at: (Time microsecondClock + start asUsec value) loop: false!addClient: theApp in: start loop: loopBool	"Add the argument, 'theApp', to the instance variable 'appointments'."	^self addClient: theApp at: (Time microsecondClock + start asUsec value) loop: loopBool!addClient: theApp loop: aBool	"Add the argument, 'theApp', to the instance variable 'appointments'."	^self addClient: theApp at: Time microsecondClock + 1000 loop: false!addTimer: start	"Add the argument, 'theApp', to the instance variable 'timers'."	^self addTimer: start interval: 1.0!addTimer: start interval: int	"Add the argument, 'theApp', to the instance variable 'timers'."	| timer |	timer := Timer new interval: int.	timer name: ('Timer', (timers size + 1) printString) asSymbol.	timers add: (timer startTime usec => timer).	self changed: #timers.	self run.	^timer!clientNamed: aName	"Answer a named client"	^appointments detect: [ :ass | ass value name == aName]!clients	"Get the instance's clients"	^appointments!clock	"Answer the instance's clock (in usec)"	startTime ifNil: [startTime := Time microsecondClock].	^Time microsecondClock - startTime!delay	"Get the instance's delay"	^delay!delay: aTime	"Set the instance's delay"	^delay delay: aTime!dontWait	"Specify that the scheduler should NOT do the waiting--i.e., there is a lower level of scheduling going on"	"Schedule dontWait"	doWait := false!isRunning	"Answer the instance variable 'running'."	^running!removeClient: aClient	"Add the argument, 'theApp', to the instance variable 'timers'."	appointments removeAllSuchThat: [ :ass | ass value == aClient].	self changed: #appointments.!removeClientNamed: aClient	"Add the argument, 'theApp', to the instance variable 'timers'."	appointments removeAllSuchThat: [ :it | it value name = aClient].	self changed: #appointments.!removeTimer: aTimer	"Add the argument, 'theApp', to the instance variable 'timers'."	timers removeAllSuchThat: [ :ass | ass value == aTimer].	self changed: #timers.!removeTimerNamed: aTimer	"Add the argument, 'theApp', to the instance variable 'timers'."	timers removeAllSuchThat: [ :ass | ass key == aTimer].	self changed: #timers.!resetClock	"Reset the instances clock (in usec)"	"Schedule resetClock"	startTime := Time microsecondClock!timerNamed: aName	"Answer a named timer"	^timers detect: [ :ass | ass value name == aName]!timers	"Answer the instance's timers"	^timers!wait	"Specify that the scheduler should do the waiting--i.e., Smalltalk-level real-time."	"Schedule wait"	doWait := true! !!Siren.EventScheduler methodsFor: 'running'!callNextAppointment	"Calls upon the next appointment to be made and then reschedules the next one"	| entry nextTime now todo |	now := Time microsecondClock.	todo :=  false.	(((SirenUtility verbosity > 1) 					"if really verbose and <shift>, print time and update log time"		and: [InputState default shiftDown])		and: [now - logTime > 250000])			"only print 4 per second"			ifTrue: [logTime := now.				SirenUtility log: '  S: ', ((now - startTime) / 1000000.0 printString: 5)].	(timers ready: now) 							"If there's a timer ready"		ifTrue: [todo := true.			entry := timers removeFirst.			nextTime := self processEvent: entry at: now.			nextTime ifNotNil:				[timers add: (nextTime => entry value)].			entry clear.			^self changed: #timer with: entry].	(appointments ready: now) 					"If there's an event ready"		ifTrue: [todo := true.			entry := appointments removeFirst.			nextTime := self processEvent: entry at: now.			nextTime ifNotNil:				[appointments add: (nextTime => entry value) loop: entry loop].			entry clear.			^self changed: #event with: entry].	todo ifFalse: [delay wait]!flush	"Reset the appointment list."	"EventScheduler flush"	self interrupt.	appointments := SEventQueue new.	timers := SEventQueue new.	threads := OrderedCollection new.	SEventQueue initialize!interrupt	"Stop a running scheduler."	self run: false.	threads isEmpty not		ifTrue: [threads first terminate].	^self!processEvent: entry at: now	"Handle an event or timer"	| nextTime time event thisTime |	time := entry key.							"get the delta time"	event := entry value.						"get the event or timer"	doWait														"schedule the event now"		ifFalse: [nextTime := event scheduleAt: time]		ifTrue: [thisTime := time usec value.	"if running in own thread, wait"			thisTime > now				ifTrue: [(Delay forMicroseconds: (thisTime - now)) wait].			nextTime := event scheduleAt: thisTime].			"schedule the event later""	nextTime ifNotNil: [Transcript show: 'Wait: ', (thisTime - now) printString, 					' next ', (nextTime - startTime) printString; cr]."	nextTime ifNil:		[entry loop ifTrue: 			[event reset.			nextTime := now]].	^nextTime!run	"Set up the first meetings and then run them all till no one wants a meeting anymore."	| proc |	running ifTrue: [^nil].	startTime := Time microsecondClock.	self run: true.					"set flag"	threads isEmpty not		ifTrue: [threads do: [ :pr | pr terminate]].	threads := OrderedCollection new.			"enforce single-threading for now"									"LOOP: as long as on, try next appt or timer"	proc := [[running] whileTrue: [self callNextAppointment]] forkAt: (Processor userBackgroundPriority - 1).	threads add: proc.	self changed: #running with: true!run: theBool	"Accept the argument, 'theBool', as the instance variable 'running'."	running := theBool.	SirenUtility log: 'Sched: ', (theBool ifTrue: ['run'] ifFalse: ['stop']) level: 0.	threads isEmpty		ifFalse: [theBool 			ifTrue: [threads first resume]			ifFalse: [threads first terminate]].	self changed: #running with: theBool! !!Siren.EventScheduler methodsFor: 'initialize release'!initialize	"Set up the default Schedule"	"Schedule initialize"	doWait := true.	running := false.	appointments := SEventQueue new.	timers := SEventQueue new.	threads := OrderedCollection new.	delay := Delay forMicroseconds: 1000.			"default tick delay"	logTime := Time microsecondClock.!release	"Clean up the schedule."	delay disable.	running ifTrue: [self run: false].	threads isEmpty not		ifTrue: [threads do: [ :pr | pr terminate]].	self initialize! !!Siren.EventScheduler class methodsFor: 'instance control'!addClient: aT	"Add a timer to the instance"	self instance addClient: aT!addClient: aT at: theTime	"Add a timer to the instance"	self instance addClient: aT at: theTime!addClient: aT in: theTime	"Add a timer to the instance"	self instance addClient: aT in: theTime!addClient: aT in: theTime loop: loopBool	"Add a timer to the instance"	self instance addClient: aT in: theTime loop: loopBool!addTimer: aT	"Add a timer to the instance"	self instance addTimer: aT!addTimer: aT interval: int	"Add a timer to the instance"	self instance addTimer: aT interval: int!clients	"Get the instance's clients"	^self instance clients!clock	"Answer the instance's clock"	^self instance clock!flush	"Reset all running schedules by brute force."	"Schedule interrupt; flush"	EventScheduler allInstances do:		[ :thisOne |		thisOne flush]!interrupt	"Stop all running schedules by brute force."	"Schedule interrupt; flush"	EventScheduler allInstances do:		[ :thisOne |		thisOne interrupt]!isRunning	"Ask the instance if it's on"	^self instance isRunning!resetClock	"Answer the instance's clock"	^self instance resetClock!run	"Turn the instance on"	self instance run!timers	"Get the instance's timers"	^self instance timers! !!Siren.EventScheduler class methodsFor: 'class initialization'!initialize	"Set up the global Scheduler."	"EventScheduler initialize "	"EventScheduler instanceCount "	Schedule == nil		ifFalse: [self release].	Schedule := EventScheduler new initialize.!release	"Clear away the global EventScheduler."	"EventScheduler release"	EventScheduler instance release.	Schedule := nil! !!Siren.EventScheduler class methodsFor: 'examples'!scheduleExample	"Play MIDI using the event scheduler."	"EventScheduler scheduleExample"	"Schedule interrupt; flush"	 | scale start |	scale := EventList scaleFrom: 36 to: 60 in: 2.0.	scale scale: #duration by: 2.	start := Time microsecondClock + 100000.	scale events do: [ :ass |		ass event voice: MIDIVoice default.		ass key: (ass key value + start) usec.		EventScheduler addClient: ass].	"self halt."	EventScheduler run!scheduleExample2	"Play MIDI using the event scheduler."	"EventScheduler scheduleExample2"	"EventScheduler interrupt; flush"	| scale |	scale := EventList scaleFrom: 36 to: 60 in: 2.0.	scale scale: #duration by: 2.	scale voice: MIDIVoice default.	EventScheduler addClient: (Time microsecondClock + 500000) usec -> scale.	"self halt."	EventScheduler run!timerExample	"Start some timers in the event scheduler."	"EventScheduler timerExample"	"EventScheduler interrupt; flush"	EventScheduler addTimer: 0.0 interval: 2.0.	EventScheduler addTimer: 1.0 interval: 2.0.	EventScheduler  run.! !!Siren.EventScheduler class methodsFor: 'instance creation'!default	"EventScheduler instance"	Schedule ifNil: [self initialize].	^Schedule!instance	"EventScheduler instance"	Schedule ifNil: [self initialize].	^Schedule! !!Siren.PField methodsFor: 'accessing'!field	"Answer the instance variable 'field'."	^field!field: theNumber	"Accept the argument, 'theNumber', as the new instance nariable 'field'."	field := theNumber!name	"Answer the instance variable 'name'."	^name!name: theName	"Accept the argument, 'theName', as the new instance nariable 'name'."	name := theName! !!Siren.PField class methodsFor: 'instance creation'!field: aNumber value: aValue	"Answer an initialized instance."	^(self new) field: aNumber; value: aValue!field: aNumber value: aValue name: aName	"Answer an initialized instance."	^(self new) field: aNumber; value: aValue; name: aName! !!Siren.PitchTimeView methodsFor: 'transforming'!pitchFromY: aPoint	"Answer the transformed pitch represented by the y-coordinate of the argument."	^(aPoint y - self class inset y / yScale + pitchOffset) max: 0! !!Siren.PitchTimeView methodsFor: 'controller access'!defaultControllerClass	"Answer the class of the default controller for the receiver."	^PitchTimeController! !!Siren.PitchTimeView methodsFor: 'displaying'!highlightFrom: pt1 to: pt2	"Show selection of the range pt1--pt2""	pt1 x = pt2 x		ifTrue: [^self].	Display border: (pt1 corner: pt2)		width: 2		mask: Form gray."!zoom: aPoint	"Set the receiver's 'zoom' to be aPoint."	xScale := xScaleDefault * aPoint x.	yScale := yScaleDefault * aPoint y.	Cursor wait showWhile:		[self displayList: (self layoutManager displayListFor: self).		super zoom: aPoint]! !!Siren.PitchTimeView methodsFor: 'layout manager access'!generateItemFor: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	"ColorValue constantNames"	"EventList randomSWSSExample2 edit""	^super generateItemFor: anAss."	| yHeight x y list event |	event := anAss value.	yHeight := 24.	event duration == nil			ifTrue: [x := 250 / xScale]			ifFalse: [x := event duration asMS value / xScale].	((event ampl == nil) or: [event ampl value == nil])		ifFalse: [y := (event ampl asRatio value * yHeight) truncated]		ifTrue: [y := 0].	list := (DisplayList new) model: anAss.	list add: (super generateItemFor: anAss).	list add: ((DisplayLine new)				offset: 0@0;				extent: x@0;				color: (xColor == nil ifTrue: [ColorValue cyan] ifFalse: [xColor])).	list add: ((DisplayLine new)				offset: 0@0;				extent: 0@y negated;				color: (yColor == nil ifTrue: [ColorValue red] ifFalse: [yColor])).	(event at: #envelope) == nil		ifFalse: [ | fcn points | fcn := event at: #envelope.				points := fcn data collect: [ :pt | (pt x * x) @ (pt y * y negated)].				list add: ((DisplayPolyline offset: (1@0) vertices: points) color: ColorValue black)].	(event at: #position) == nil		ifFalse: [list add: ((DisplayLine new)				offset: 2@0;				extent: 0@((event at: #position) - 0.5 * yHeight);				color: (yColor == nil ifTrue: [ColorValue green] ifFalse: [yColor]))].	(event at: #duty) == nil		ifFalse: [list add: ((DisplayLine new)				offset: 0@2;				extent: ((event at: #duty) * x)@0;				color: (yColor == nil ifTrue: [ColorValue yellow] ifFalse: [yColor]))].	^list!itemFor: anAss	"Answer the correct visual item for the given assoc. (sent from layoutManagers)."	"ColorValue constantNames "	"PitchTimeView openOnEventList: (EventList scaleFrom: 48 to: 84 in: 4)"	| yHeight x y list event it |	event := anAss value.	yHeight := 24.	event duration == nil			ifTrue: [x := 250 / xScale]			ifFalse: [x := event duration asMS value / xScale].	((event ampl == nil) or: [event ampl value == nil])		ifFalse: [y := (event ampl asRatio value * yHeight) truncated]		ifTrue: [y := 0].	list := (DisplayList new) model: anAss.	it := super itemFor: anAss.	it == nil ifFalse: [list add: it].	list add: ((DisplayLine new)				offset: 0@ -2;				extent: x@0;				color: (xColor == nil ifTrue: [ColorValue blue] ifFalse: [xColor])).	list add: ((DisplayLine new)				offset: 0@0;				extent: 0@y negated;				color: (yColor == nil ifTrue: [ColorValue red] ifFalse: [yColor])).	(event at: #envelope) == nil		ifFalse: [ | fcn points | fcn := event at: #envelope.				points := fcn data collect: [ :pt | (pt x * x) rounded @ (pt y * y negated) rounded].				list add: ((DisplayPolyline offset: (1@0) vertices: points) color: ColorValue green)].	(event at: #position) == nil		ifFalse: [list add: ((DisplayLine new)				offset: 2@0;				extent: 0@((event at: #position) - 0.5 * yHeight);				color: (yColor == nil ifTrue: [ColorValue green] ifFalse: [yColor]))].	^list!layoutManager	"Answer a default layout manager for the receiver."	^(PitchTimeLayoutManager new)			timeScale: xScale;			timeOffset: page x;			pitchScale: yScale;			pitchOffset: pitchOffset! !!Siren.PitchTimeView methodsFor: 'initialize-release'!initialize	"Initialize the instance variables of the receiver."	super initialize.	xScale := 10.				"approx msec / pixel"	xScaleDefault := xScale.	yScale := 8.					"approx pix / quartertone"	yScaleDefault := yScale.	pitchOffset := 24! !!Siren.PitchTimeView class methodsFor: 'examples'!randomExample	"Open a p-t view on a random event list."	"PitchTimeView randomExample"	PitchTimeView openOnEventList: EventList randomExample!randomExampleLong	"Open a p-t view on a random event list."	"PitchTimeView randomExampleLong"	| list |	list := EventList randomExample: 1024.	list addAll: (EventList randomExample: 1024).	PitchTimeView openOnEventList: list! !!Siren.PitchTimeView class methodsFor: 'instance creation'!label	"Answer the view label for the receiver's instances."	^'Pitch-Time Editor'! !!Siren.PitchTimeView class methodsFor: 'subview creation'!addButtonsOn: me for: dled to: container in: rect	"Add the default button panel to the instance in the given rectangle."	| x0 y0 x1 y1 |	x0 := rect left.	x1 := rect right.	y0 := rect top.	y1 := rect bottom.	self addButtonOn: me labeled: 'Play'		doing: [:model :value | dled play] 		in: (LayoutFrame new leftFraction: 0; topFraction: y0; 							rightFraction: 0.12;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'File'		doing: [:model :value | dled doFile] 		in: (LayoutFrame new leftFraction: 0.12; topFraction: y0; 							rightFraction: 0.25;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'Edit'		doing: [:model :value | dled doEdit] 		in: (LayoutFrame new leftFraction: 0.25;	topFraction: y0; 							rightFraction: 0.37;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'Inspect'		doing: [:model :value | dled doInspect] 		in: (LayoutFrame new leftFraction: 0.37;	topFraction: 0.0; 							rightFraction: 0.5;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'Display'		doing: [:model :value | dled doDisplay] 		in: (LayoutFrame new leftFraction: 0.5;	topFraction: y0; 							rightFraction: 0.62;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'Zoom'		doing: [:model :value | dled doZoom] 		in: (LayoutFrame new leftFraction: 0.62;	topFraction: y0; 							rightFraction: 0.75;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'View'		doing: [:model :value | dled doViewEdit] 		in: (LayoutFrame new leftFraction: 0.75;	topFraction: y0; 							rightFraction: 0.87;	bottomFraction: y1) 		to: container.	self addButtonOn: me labeled: 'Properties'		doing: [:model :value | dled doPropEdit] 		in: (LayoutFrame new leftFraction: 0.87;	topFraction: y0; 							rightFraction: 1.0;	bottomFraction: y1) 		to: container.! !!Siren.PositionTimeView methodsFor: 'initialize release'!initialize	"Initialize the instance variables of the receiver."	super initialize.	xScale := 15.	yScale := 40.	pitchOffset := 40! !!Siren.PositionTimeView methodsFor: 'layout manager access'!layoutManager	"Answer a default layout manager for the receiver."	^(PositionTimeLayoutManager new)			timeScale: xScale;			timeOffset: page x;			pitchScale: yScale;			pitchOffset: pitchOffset! !!Siren.HauerSteffensView methodsFor: 'initialize-release'!initialize	"Initialize the instance variables of the receiver."	super initialize.	self initForm.	pitchOffset := 30! !!Siren.HauerSteffensView methodsFor: 'displaying'!zoom: aPoint	"Set the receiver's 'zoom' to be aPoint."	xScale := xScaleDefault * aPoint x.	yScale := yScaleDefault * aPoint y.	self initForm.	super zoom: aPoint! !!Siren.HauerSteffensView methodsFor: 'private'!clef: anInteger at: aPoint bottom: aBottom form: cForm	"Display a C clef for the given octave at the given point."	(aPoint y + 20) < aBottom ifTrue: 		[(Text string: ('c', anInteger printString) emphasis: 2) 				displayOn: cForm at: aPoint + (2 @ -3)]!drawStaff	"Display a Hauer-Stephens-type staff onto the given pixmap."	| box top1 bottom1 left1 right1  left2 right2 aGC cGC aNum count octave |	box := background bounds."	Transcript show: box printString; cr."	aGC := background graphicsContext.	aGC paint: self backgroundColor.	aGC displayRectangle: background bounds.	aGC paint: (clefColor == nil				ifTrue: [ColorValue darkGray]				ifFalse: [clefColor]).	cGC := clefForm graphicsContext.	cGC paint: self backgroundColor.	cGC displayRectangle: clefForm bounds.	cGC paint: (headColor == nil				ifTrue: [ColorValue darkGray]				ifFalse: [headColor]).	top1 := box top.	bottom1 := box bottom.	left1 := box left.	right1 := box right.	left2 := clefForm bounds left.	right2 := clefForm bounds right.							"count number of octaves"	octave := 8. "(bottom1 - top1 / (0 + (yScale * 2))) asInteger."	aNum := top1.	count := 3.	[aNum < bottom1] whileTrue: 	"loop from top1 to bottom1 drawing lines"		[aGC displayLineFrom: left1@aNum to: right1@aNum.		cGC displayLineFrom: left2@aNum to: right2@aNum.		count := count + 1.		count \\ 5 = 1			"skip @ c"			ifTrue: [(aNum + 20) < bottom1					ifTrue: [('c', (octave - 2) printString) displayOn: cGC at: (left1@aNum) + (2 @ 12)].				octave := octave - 1.				aNum := aNum + yScale].					count \\ 5 = 4			"skip @ e"			ifTrue: [aNum := aNum + yScale].		aNum := aNum +  (yScale * 2)]!initForm	"Copy the default backgroundForm and draw a H-S staff on it."	background := Pixmap extent: 2000@800.	background background: self backgroundColor.	clefForm := Pixmap extent: 32@800.	clefForm background: self backgroundColor.	yScale == nil		ifFalse: [self drawStaff]! !!Siren.HauerSteffensView class methodsFor: 'examples'!randomExample	"Open a HSView on two merged random event lists."	"HauerSteffensView randomExample"	HauerSteffensView openOnEventList:		((EventList newNamed: #pRand)				addAll:           (EventList randomExample);				addAllAtEnd: (EventList randomExample);				addAllAtEnd: (EventList randomExample);				addAllAtEnd: (EventList randomExample);				addAllAtEnd: (EventList randomExample))!randomSWSSExample	"Open a HSView on two merged random event lists."	"HauerSteffensView randomSWSSExample"	HauerSteffensView openOnEventList:		((EventList newNamed: #sRand)			addAll: (EventList randomSWSSExample2);			addAll: (EventList randomSWSSExample2);			addAll: (EventList randomSWSSExample2))! !!Siren.HauerSteffensView class methodsFor: 'constant access'!defaultCacheExtent	"Answer the default extent of the receiver's instances' cache."	^1000@600!inset	"Answer the default display inset."	^16@16! !!Siren.HauerSteffensView class methodsFor: 'instance creation'!label	"Answer the view label for the receiver's instances."	^'Hauer-Steffens Event List View'! !!Siren.NeapolitanMajor class methodsFor: 'interval list'!intervalList	"tire de McLaughlin et le Mahavishnu Orchestra"	^#(#unison #minorSecond #minorThird #perfectFourth #perfectFifth #majorSixth #majorSeventh )! !!Siren.PitchClassFlat methodsFor: 'accessing'!flat	^flat!flat: value	flat := value!semiToneCount	^natural semiToneCount - 1!sharp	^natural! !!Siren.PitchClassFlat methodsFor: 'testing'!isFlat	^true! !!Siren.PitchClassFlat methodsFor: 'printing'!printOn: s 	natural printOn: s.	s nextPut: $b!storeOn: s 	"N C flat storeString"	s nextPutAll: 'N ' , self natural name , ' flat'! !!Siren.PitchClassFlat methodsFor: 'saving'!representBinaryOn: s 	^MessageSend receiver: natural selector: #flat! !!Siren.PitchClassFlat methodsFor: 'intervals'!alterate: note toReach: i 	| n |	n := natural alterate: note toReach: i.	^n flat!alterateBelow: note toReach: i 	| n |	n := natural alterateBelow: note toReach: i.	^n flat!closestEnharmonic	^self alterate: self preceding toReach: 0.!semiTonesToNatural	^1! !!Siren.ChordNameEditor methodsFor: 'actions'!doHalfDim7	root value: #root.	third value: #min.	fifth value: #dim5.	seventh value: 7. 	ninth value: #no9.	eleventh value: #no11.	thirteenth value: #no13!doMaj	root value: #root.	third value: #major.	fifth value: #perfectFifth.	seventh value: #no7.	ninth value: #no9.	eleventh value: #no11.	thirteenth value: #no13!doMaj7	root value: #root.	third value: #major.	fifth value: #perfectFifth.	seventh value: #maj7.	ninth value: #no9.	eleventh value: #no11.	thirteenth value: #no13!doMin7	root value: #root.	third value: #min.	fifth value: #perfectFifth.	seventh value: 7.	ninth value: #no9.	eleventh value: #no11.	thirteenth value: #no13! !!Siren.ChordNameEditor methodsFor: 'change'!pitchClassIndexChanged	pitchClass value: (PitchClass allNotesButDoubles at: pitchClassIndex value) printString.	self structureChanged!structureChanged	| struct pc | 	struct := WriteStream on: ''. 	root value = #noRoot ifTrue: [struct nextPutAll: 'noRoot '].	third value = #major ifFalse: [struct nextPutAll: third value; space].	fifth value = #perfectFifth ifFalse: [struct nextPutAll: fifth value; space].	struct nextPutAll: (seventh value = 7 ifTrue: ['7'] ifFalse: [seventh value]); space.	struct nextPutAll: (ninth value = 9 ifTrue: ['9'] ifFalse: [ninth value]); space.	struct nextPutAll: (eleventh value = 11 ifTrue: ['11'] ifFalse: [eleventh value]); space.	struct nextPutAll: (thirteenth value = 13 ifTrue: ['13'] ifFalse: [thirteenth value]); space.	pc := PitchClassChord newFromString: pitchClass value,' ',struct contents.	structure value: pitchClass value, ' ',pc structureString.	noteNames value: pc notesString.! !!Siren.ChordNameEditor methodsFor: 'initialize'!initialize	super initialize.	pitchClassIndex := 1 asValue.	pitchClassIndex onChangeSend: #pitchClassIndexChanged to: self.	pitchClass := 'A' asValue.	noteNames := '' asValue.	root:= #root asValue.	root onChangeSend: #structureChanged to: self. 	third := #major asValue.	third onChangeSend: #structureChanged to: self.	fifth := #perfectFifth asValue.	fifth onChangeSend: #structureChanged to: self.	seventh:= #no7 asValue.	seventh onChangeSend: #structureChanged to: self.	ninth := #no9 asValue.	ninth onChangeSend: #structureChanged to: self.	eleventh := #no11 asValue.	eleventh onChangeSend: #structureChanged to: self.	thirteenth := #no13 asValue.	thirteenth onChangeSend: #structureChanged to: self.! !!Siren.ChordNameEditor methodsFor: 'aspects'!chord	^PitchClassChord newFromString: structure value!eleventh	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method." 	^eleventh isNil ifTrue: [eleventh := nil asValue] ifFalse: [eleventh]!fifth	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^fifth isNil ifTrue: [fifth := nil asValue] ifFalse: [fifth]!ninth	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^ninth isNil ifTrue: [ninth := nil asValue] ifFalse: [ninth]!noteNames	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^noteNames isNil ifTrue: [noteNames := String new asValue] ifFalse: [noteNames]!pitchClass	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^pitchClass isNil ifTrue: [pitchClass := String new asValue] ifFalse: [pitchClass]!pitchClassIndex	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^pitchClassIndex isNil ifTrue: [pitchClassIndex := 1 asValue] ifFalse: [pitchClassIndex]!root	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^root isNil ifTrue: [root := nil asValue] ifFalse: [root]!seventh	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^seventh isNil ifTrue: [seventh := nil asValue] ifFalse: [seventh]!structure	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^structure isNil ifTrue: [structure := String new asValue] ifFalse: [structure]!third	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^third isNil ifTrue: [third := nil asValue] ifFalse: [third]!thirteenth	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^thirteenth isNil ifTrue: [thirteenth := nil asValue] ifFalse: [thirteenth]! !!Siren.ChordNameEditor class methodsFor: 'interface specs'!windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec" 	^#(#FullSpec #window: #(#WindowSpec #label: 'Chord Name Editor' #min: #(#Point 20 20 ) #bounds: #(#Rectangle 87 495 481 870 ) #flags: 8 ) #component: #(#SpecCollection #collection: #(#(#SliderSpec #layout: #(#LayoutFrame 0 0.0297297 0 0.041791 0 0.118919 0 0.701493 ) #model: #pitchClassIndex #orientation: #vertical #start: 1 #stop: 21 #step: 1 ) #(#InputFieldSpec #layout: #(#LayoutFrame 0 0.164865 0 0.0507463 0 0.297297 0 0.134328 ) #model: #pitchClass ) #(#InputFieldSpec #layout: #(#LayoutFrame 0 0.159459 0 0.758209 0 0.678378 0 0.826866 ) #model: #structure ) #(#ActionButtonSpec #layout: #(#LayoutFrame 0 0.202703 0 0.185075 0 0.454054 0 0.277612 ) #model: #doMin7 #label: 'min 7' #defaultable: true ) #(#ActionButtonSpec #layout: #(#LayoutFrame 0 0.202703 0 0.295522 0 0.454054 0 0.385075 ) #model: #doMaj7 #label: 'maj 7' #defaultable: true ) #(#ActionButtonSpec #layout: #(#LayoutFrame 0 0.202703 0 0.414925 0 0.454054 0 0.504478 ) #model: #doHalfDim7 #label: 'half dim 7' #defaultable: true ) #(#ActionButtonSpec #layout: #(#LayoutFrame 0 0.202703 0 0.537313 0 0.454054 0 0.626866 ) #model: #doMaj #label: 'maj' #defaultable: true ) #(#InputFieldSpec #layout: #(#LayoutFrame 0 0.162162 0 0.844776 0 0.694595 0 0.913433 ) #model: #noteNames #isReadOnly: true ) #(#LabelSpec #layout: #(#LayoutOrigin 0 0.0216216 0 0.752239 ) #label: 'Name' ) #(#LabelSpec #layout: #(#LayoutOrigin 0 0.0189189 0 0.862687 ) #label: 'Notes' ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.0686567 ) #model: #root #label: 'Root' #select: #root ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.591892 0 0.0686567 ) #model: #root #label: 'No Root' #select: #noRoot ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.158209 ) #model: #third #label: 'minor' #select: #min ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.591892 0 0.158209 ) #model: #third #label: 'major' #select: #major ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.705405 0 0.158209 ) #model: #third #label: 'no 3' #select: #no3 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.238806 ) #model: #fifth #label: 'perfect' #select: #perfectFifth ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.602703 0 0.238806 ) #model: #fifth #label: 'dim 5' #select: #dim5 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.708108 0 0.238806 ) #model: #fifth #label: 'aug 5' #select: #aug5 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.821622 0 0.238806 ) #model: #fifth #label: 'no 5' #select: #no5 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.319403 ) #model: #seventh #label: 'min 7' #select: 7 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.594595 0 0.319403 ) #model: #seventh #label: 'major 7' #select: #maj7 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.735135 0 0.322388 ) #model: #seventh #label: 'dim 7' #select: #dim7 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.843243 0 0.322388 ) #model: #seventh #label: 'no 7' #select: #no7 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.402985 ) #model: #ninth #label: 'perfect 9' #select: 9 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.624324 0 0.402985 ) #model: #ninth #label: 'dim 9' #select: #dim9 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.72973 0 0.40597 ) #model: #ninth #label: 'aug 9' #select: #aug9 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.843243 0 0.40597 ) #model: #ninth #label: 'no 9' #select: #no9 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.486567 ) #model: #eleventh #label: 'perfect 11' #select: 11 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.651351 0 0.486567 ) #model: #eleventh #label: 'aug 11' #select: #aug11 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.843243 0 0.489552 ) #model: #eleventh #label: 'no 11' #select: #no11 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.472973 0 0.567164 ) #model: #thirteenth #label: 'perfect 13' #select: 13 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.651351 0 0.567164 ) #model: #thirteenth #label: 'dim 13' #select: #dim13 ) #(#RadioButtonSpec #layout: #(#LayoutOrigin 0 0.843243 0 0.570149 ) #model: #thirteenth #label: 'no 13' #select: #no13 ) ) ) )! !!Siren.ChordNameEditor class methodsFor: 'resources'!eleventhMenu	"UIMenuEditor new openOnClass: self andSelector: #eleventhMenu"	^#(#PopUpMenu #('perfect' 'aug' 'no eleventh' ) #() #(#'11' #aug11 #no11 ) ) decodeAsLiteralArray!fifthMenu	"UIMenuEditor new openOnClass: self andSelector: #fifthMenu"	^#(#PopUpMenu #('perfect' 'dim fifth' 'aug fifth' 'no fifth' ) #() #(#perfectFifth #dim5 #aug5 #no5 ) ) decodeAsLiteralArray!ninthMenu	"UIMenuEditor new openOnClass: self andSelector: #ninthMenu"	^#(#PopUpMenu #('dim' 'perfect' 'aug' 'no ninth' ) #() #(#dim9 #'9' #aug9 #no9 ) ) decodeAsLiteralArray!rootMenu	"UIMenuEditor new openOnClass: self andSelector: #rootMenu"	^#(#PopUpMenu #('root' 'no root' ) #() #(#root #noRoot ) ) decodeAsLiteralArray!seventhMenu	"UIMenuEditor new openOnClass: self andSelector: #seventhMenu"	^#(#PopUpMenu #('minor' 'major' 'dim' 'no seventh' ) #() #(#'7' #maj7 #dim7 #no7 ) ) decodeAsLiteralArray!thirdMenu	"UIMenuEditor new openOnClass: self andSelector: #thirdMenu"	^#(#PopUpMenu #('minor' 'major' 'no third' ) #() #(#min #major #no3 ) ) decodeAsLiteralArray!thirteenthMenu	"UIMenuEditor new openOnClass: self andSelector: #thirteenthMenu"	^#(#PopUpMenu #('dim' 'perfect' 'no thirteenth' ) #() #(#dim13 #'13' #no13 ) ) decodeAsLiteralArray! !!Siren.CompositeSound methodsFor: 'sample accessing'!sampleAt: index	"Answer the sample at the given index, mapping and paging as necessary."	| q |	1 to: components size do:		[ :ind | 		q := components at: ind.		(q includes: index)			ifTrue: [^q sound sampleAt: (index - q start + q offset)]].	self error: 'No sample by that name, Sir.'! !!Siren.CompositeSound methodsFor: 'accessing'!on: aSound	"Set the receiver's source sound."	components := SortedCollection sortBlock: [ :x :y | x start <= y start].	components add: (ComponentSound on: aSound start: 1 stop: aSound size).	self rate: aSound rate.	self channels: aSound channels.	self size: aSound size.	properties := aSound properties copy!paste: sound from: start to: stop at: index	"Paste the designated section into the receiver."	| newItem item number extent oldStop |	extent := stop - start.	newItem := ComponentSound on: sound 				start: index stop: stop - start + index offset: start.	index >= self size						"if pasting onto the end of the sound"		ifTrue: [components add: newItem.				^self].	number := 1.							" else locate where to put it"	[(number > components size) | ((components at: number) includes: index)] 		whileFalse: [number := number + 1].	item := components at: number.	index = item stop						"if we're pasting at the end of another splice"		ifTrue: [self rippleUpFrom: (number + 1) adding: extent.			components add: newItem.			^self].	index = item start						"if we're pasting at the start of another splice"		ifTrue: [self rippleUpFrom: number adding: extent.			components add: newItem.			^self].											"else we have to break up an existing component"	self rippleUpFrom: (number + 1) adding: extent.	oldStop := item stop.	item stop: index - item start.			"edit the old entry in place"	components add: newItem.			"insert the new item"								"add a copy of the old item with new interval and offset"	components add: (ComponentSound on: item sound 			start: (index + extent + 1) stop: (oldStop + extent) 			offset: (item offset + (index - item start) + extent)).	^self! !!Siren.CompositeSound methodsFor: 'testing'!isComposite	"Answer whether the receiver is a composite sound."	^true! !!Siren.CompositeSound methodsFor: 'private'!rippleUpFrom: start adding: insert	"Shift all the cues above the given one up by the given insert count."	| item |	start to: components size do:		[ :ind | 		item := (components at: ind).		item start: (item start + insert).		item stop: (item stop + insert)].! !!Siren.CompositeSound class methodsFor: 'instance creation'!on: source paste: newSound from: start to: stop at: index	"Answer a CompositeSound derived from the argument pasting in the given sound at the given index."	"CompositeSound exampleView"	| me |	me := self new initialize.	me on: source.	me paste: newSound from: start to: stop at: index.	^me! !!Siren.CompositeSound class methodsFor: 'examples'!exampleView	"Open a sound view on a ramp with a chunk of a sine pasted into it."	"CompositeSound exampleView"	| ramp sine |	ramp := SampledSound rampDur: 1.0 rate: 8000 chans: 1.	sine := SampledSound sineDur: 0.5 rate: 8000 freq: 400 chans: 1.	SoundView openOn: (ramp paste: sine from: 200 to: 400 at: 1000)! !!Siren.Track methodsFor: 'comparing'!<= other	(self name isNil or: [other name isNil])		ifTrue: [^self id <= other id].	^self name <= other name! !!Siren.Track methodsFor: 'accessing'!addDate	^addDate!addDate: aValue	addDate := aValue!addPlaylist: pl	"Add an item, initialize lazily"	playlists isNil ifTrue: [playlists := Set new].	playlists add: pl!album	^album!album: aValue	album := aValue asSymbol!artist	^artist!artist: aValue	artist := aValue asSymbol!bRate	^bRate!bRate: aValue	bRate := aValue!comment	^comment!comment: aValue	comment := aValue "asSymbol"!filename	^filename!filename: aValue	filename := aValue!folder	^folder!folder: aValue	folder := aValue!genre	^genre!genre: aValue	genre := aValue "asSymbol"!hasTags	^hasTags!hasTags: aValue	hasTags := aValue!id	^id!id: aValue	id := aValue asNumber!isEmpty	^true!isTag	^false!key	^key!key: aValue	key := aValue!kind	^kind!kind: aValue	kind := aValue!label: aValue	labels ifNil: [labels := OrderedCollection new].	labels addLast: aValue asSymbol!label: aKey put: aValue	^self at: aKey put: aValue!labels	^labels!modDate	^modDate!modDate: aValue	modDate := aValue!name	^name!name: aValue	name := aValue!persID	^persID!persID: aValue	persID := aValue!playlists	"Answer the playlists"	^playlists!sRate	^sRate!sRate: aValue	sRate := aValue!size	^size!size: aValue	size := aValue asNumber!title	^title!title: aValue	title := aValue!track	^track!track: aValue	track := aValue!tracks	^nil!type	^type!type: aValue	type := aValue asSymbol! !!Siren.Track methodsFor: 'printing'!printOn: aStream	"Format and print the receiver on the argument."	aStream nextPutAll: self title, ' -- ', self album."		self artist , '  --  ', self album."	self labels hasItems "		ifFalse: [self labels do: [ :it | aStream nextPutAll: (it asString, ' - ')]]"		ifTrue: [aStream cr.			self labels do: [ :it | aStream nextPutAll: it printString; cr]]		ifFalse: [aStream nextPutAll: ' -- ', self title, ' -- ', self artist , ' -- ', self album]! !!Siren.Track methodsFor: 'parsing'!cleanFilename	"Take out the URL-escapes, i.e., turn %20 into space."	| hd nm |	nm := filename.	nm isEmpty 	ifTrue: [nm := 'no-name']	ifFalse: [hd := 'file://localhost'.		(nm copyFrom: 1 to: hd size) = hd			ifTrue: [nm := nm copyFrom: hd size + 1 to: nm size].		nm := URLEncoder decode: nm. " copyReplaceAll: '%20' with: ' '. "  ].	^nm!dropVolume: fnam	"Strip the leading volume from the name"	| hd nm |	nm := fnam.	hd := '/Volumes/Content/iTunes/'.	((nm size > hd size) and: [(nm copyFrom: 1 to: hd size) = hd])		ifTrue: [nm := nm copyFrom: hd size + 1 to: nm size].	hd := '/Volumes/Content/Sound/'.	((nm size > hd size) and: [(nm copyFrom: 1 to: hd size) = hd])		ifTrue: [nm := nm copyFrom: hd size + 1 to: nm size].	^nm!escape: nam	"Turn the non-ASCII characters into '*' in the name"	| nst ost |	nst := ReadStream on: nam.	ost := WriteStream on: (String new: nst size).	ost nextPut: $".	[nst atEnd] whileFalse:		[| ch |		ch := nst next.		ch asInteger > 128			ifTrue: [ost nextPutAll: '"*"' ]			ifFalse: [ost nextPut: ch]].	ost nextPut: $".	^ost contents!loadTags	"Read the ID3 tags of the track from a tags file"	"Siren.Track someInstance loadTags"	| nam dict strm ass |	nam := self cleanFilename.			"de-URLize the name"	self parseFilename: nam.				"separate out the name levels""Check for file"								"silent for now""	nam asFilename exists ifFalse:				[Transcript show: ' - ', (self dropVolume: nam); cr].""Run tagreader file"	nam := nam, '.tags'.					"create tag name"	nam asFilename exists ifTrue:			"check for tag file"		[strm := nam asFilename readStream.		strm skipThroughAll: '-- TAG --'.	"look for tag data""		strm atEnd ifTrue: [].""Read cmd output into dict"		dict := Dictionary new.		[strm atEnd] whileFalse:			[ass := self parseAssociation: strm.			ass ifNotNil: [dict at: ass key asSymbol put: ass value]].	strm close."Parse dict"	dict keys isEmpty ifFalse: [hasTags := true].	dict associationsDo:		[ :as2 | | k v |		k := as2 key.		v := as2 value.		((#title -> [v ~= self title ifTrue: [self title: v]]),		(#artist -> [v ~= self artist ifTrue: [self artist: v asSymbol]]),		(#album -> [v ~= self album ifTrue: [self album: v asSymbol]]),		(#year -> [v ~= 0 ifTrue: [self year: v asNumber]]),		(#genre -> [v ~= self genre ifTrue: [self genre ifNotNil: [self label: self genre].				self genre: v asSymbol]]),		(#duration -> [self duration: v asNumber]))			case: k]]."Tags for /Volumes/Content/Sound/FASTLab/Folk/Bob Dylan/Blood On The Tracks/01 - Tangled Up In Blue.mp3-- TAG --title    Tangled Up In Blueartist   Bob Dylanalbum    Blood On The Tracksyear     1975comment  track    1genre    Folkbitrate      192sample rate  44100channels     2duration     343length       5:43"!loadTags0	"Read the ID3 tags of the track"	"Siren.Track someInstance loadTags"	"UnixProcess cshReply: 'ls -l /etc/passwd' "	"UnixProcess cshReply: '/usr/local/bin/tagreader /Volumes/Content/iTunes/iTunes Music/Smashing Pumpkins/Teargarden by Kaleidyscope/02 Widow Wake My Mind.mp3'" 	| nam dict repl strm ass |	nam := self cleanFilename.			"de-URLize the name"	self parseFilename: nam.				"separate out the name levels"	nam asFilename exists ifFalse:		"check for file"		[Transcript show: ' - ', (self dropVolume: nam); cr]."Run UNIX tagreader cmd"	repl := UnixProcess cshReply: ('/usr/local/bin/tagreader ', (self escape: nam))."	Transcript show: repl; cr.""Read cmd output into dict"	strm := ReadStream on: repl.	strm skipThroughAll: '-- TAG --'."	strm atEnd ifTrue: []."	dict := Dictionary new.	[strm atEnd] whileFalse:		[ass := self parseAssociation: strm.		ass ifNotNil: [dict at: ass key asSymbol put: ass value]]."Parse dict"	dict associationsDo:		[ :as2 | | k v |		k := as2 key.		v := as2 value.		((#title -> [v ~= self title ifTrue: [self title: v]]),		(#artist -> [v ~= self artist ifTrue: [self artist: v asSymbol]]),		(#album -> [v ~= self album ifTrue: [self album: v asSymbol]]),		(#genre -> [v ~= self genre ifTrue: [self genre ifNotNil: [self label: self genre].				self genre: v asSymbol]]),		(#length -> [v ~= self album ifTrue: [ | s d | 				s := ReadStream on: v.				d := s upTo: $:.				d isEmpty ifFalse: [d := d asNumber * 60].				d := d + s upToEnd asNumber.				self duration: d]]))			case: k]."******************** /Volumes/Content/iTunes/iTunes Music/Smashing Pumpkins/Teargarden by Kaleidyscope/02 Widow Wake My Mind.mp3 ********************-- TAG --title   - Widow Wake My Mindartist  - Smashing Pumpkinsalbum   - Teargarden by Kaleidyscopeyear    - 0comment - 0track   - 2genre   - Alternative-- AUDIO --bitrate     - 192sample rate - 44100channels    - 2length      - 4:27"!parseAssociation: strm	"Read a line like ' genre    Alternative ' "	 | k v |	strm skipSeparators.	k := (strm upTo: $ ) trimBlanks.	"first token"	strm skipSeparators.	v := (strm upTo: Character cr) trimBlanks.		"2nd token"	k ifNil: [^nil].	v ifNil: [^nil].	v isEmpty ifTrue: [^nil].	((v at: 1) == $") ifTrue: [v := v copyFrom: 2 to: v size].	v isEmpty ifTrue: [^nil].	((v at: v size) == $") ifTrue: [v := v copyFrom: 1 to: v size - 1].	v isEmpty ifTrue: [^nil].	^k -> v!parseFilename: nam	| fi sep strm |	fi := nam.	#('/Content/Sound/' '/Content/iTunes/') do: [ :head |			((fi size > head size) and: [(fi copyFrom: 1 to: head size) = head])				ifTrue: [fi := fi copyFrom: head size + 1 to: fi size]].	strm := ReadStream on: fi.	path := OrderedCollection new.	sep := $/.	[strm atEnd] whileFalse:		[ | el |		el := strm upTo: sep.		el isEmpty ifFalse: [path addLast: el]]!parseTags	"Take the receiver's genre/content and tokenize it"	"Track someInstance parseTags"	"Track allInstancesDo: [ :it | it parseTags]"	"Track allInstances detect: [ :it | it labels includes: #'Drama:News'] "	labels := OrderedCollection new."	Transcript clear."	self parseTags: self genre.	self parseTags: self comment."	(labels includes: #'www.megatrax.com')		ifTrue: [labels remove: #'www.megatrax.com'].	(labels includes: #'Toll Free 888-MEGA-555')		ifTrue: [labels remove: #'Toll Free 888-MEGA-555'].""	Transcript show: labels printString; cr"!parseTags0: field 	"Take the given string and tokenize it"	"Track someInstance parseTags: Track someInstance genre"	"Track someInstance parseTags: Track someInstance comment"	"DataSet defaultDataSet learnTags"	| sep strm tok tokstr prevSep toks |"	Transcript clear; cr; show: field; cr; cr."	strm := ReadStream on: field.	sep := #tok.	prevSep := false."Read through the stream"	[strm atEnd]		whileFalse: 			[| el |			sep == #tok ifTrue: [tokstr := WriteStream on: String new].			el := strm next.			el ifNotNil: "Token read loop"				[[el ~~ nil and: [el isAlphaNumeric]]					whileTrue: 						[tokstr nextPut: el.						prevSep := false.						el := strm next].				tok := tokstr contents.				tok isEmpty ifFalse: 					[el ifNotNil:"Handle separators"						[el isSeparator							ifFalse: [(($/ -> [sep := #slash]) ,									($# -> [sep := #hash]) , 									($_ -> [sep := #unders]) , 									($. -> [sep := #dot]) , 									($& -> [sep := #amps]) , 									($: -> [sep := #colon]) ,									($; -> [sep := #scolon]) , 									($- -> [sep := #dash]) , 									($, -> [sep := #comma])) 								case: el otherwise: [sep := #other]."Sep processing - some separators can be embedded..." 								(#(dot dash unders slash amps) includes: sep) ifTrue:										["labels addLast: sep."										prevSep											ifFalse: [tokstr nextPut: el.												sep := #sep]											ifTrue: [sep := #tok]]."Some are ignores"								(#("other" hash comma scolon amps comma colon) includes: sep) ifTrue: 										["labels addLast: sep." 										sep := #tok]."								(#(dot dash) includes: sep) ifTrue: []."								prevSep := false]							ifTrue: [tokstr nextPut: el.			"store separator"								sep := #sep.								prevSep := true]]."Add tok to list"				(el isNil or: [sep == #tok])					ifTrue: [tok last isSeparator ifTrue: [tok := tok copyFrom: 1 to: tok size - 1].						(tok size > 1) " ifFalse: [self halt] "							ifTrue: [toks := tok asSymbol.								(labels includes: toks)									ifFalse: [labels addLast: tok asSymbol].			"add 'em"						sep := #tok]]]]]."	Transcript show: labels printString; cr"!parseTags: field 	"Take the given string and tokenize it"	"Track someInstance parseTags: Track someInstance genre"		"':SFX - General'"	"Track someInstance parseTags: Track someInstance comment" 	"'Layered synth faller - Synth - N/A '"	" | ti | ti := Track someInstance. ti parseTags: ti genre. ti"	" | ti | ti := Track someInstance. ti parseTags: ti comment. ti"	" | ti | ti := Track someInstance. ti parseTags. ti"	"DataSet defaultDataSet learnTags"	| pos fsize done |"	Transcript cr; show: field; cr; cr.""Read through the stream"	pos := 1.	[DataSet isSeparator: (field at: pos)]		whileTrue: [pos := pos + 1].	fsize := field size.	done := false.	[done] whileFalse: 		[ | subs |		subs := field copyFrom: pos to: fsize."		Transcript show: subs; cr."		 DataSet tags associationsDo: 			[ :ass | | ret |"Do the name match"			ret := ass value detect: [ :val | (val, '*') match: subs ignoreCase: true] ifNone: [nil].			((ret ~~ nil) and: [ret size > 0]) ifTrue: 				[(labels detect: [ :val | (val key == ass key) and: [val value = ret]] ifNone: [nil])					ifNil: [labels addLast: (ass key -> ret)]]]."skip to and over next separator"		[(DataSet isSeparator: (field at: pos)) or: [pos = fsize]]			whileFalse: [pos := pos + 1].		[(DataSet isSeparator: (field at: pos)) and: [pos < fsize]]			whileTrue: [pos := pos + 1].		done := (pos >= fsize).	]."	Transcript cr; show: labels printString; cr"! !!Siren.Track class methodsFor: 'instance creation'!fromLine: line	"Create a new track from the given dictionary"	"Siren.Track key: 235 fromDictionary: ()"	"oid	title	artist	album	genre	comment"	"Siren.Track fromLine: '29	In Black	Megatrax - Intervox	INX146 - Blockbuster	Promos:Drama - Epic, Orchestral, Romance - Epic/Thematic, Film	Mystic & melancholic climactic score, thoughtful & slightly sorrowful mood, orchestral instruments - Full Mix - Medium Slow - www.megatrax.com - Toll Free 888-MEGA-555' "	| strm inst |	strm := ReadStream on: line.	inst := self new.	inst hasTags: false.	inst id: (strm upTo: Character tab).	inst title: (strm upTo: Character tab).	inst artist: (strm upTo: Character tab).	inst album: (strm upTo: Character tab).	inst genre: (strm upTo: Character tab).	inst comment: (strm upToEnd).	^inst!key: k fromDictionary: dict	"Create a new track from the given dictionary"	"Siren.Track key: 235 fromDictionary: ()"	| inst |	inst := self new.	inst hasTags: false.	inst key: k.	inst id: (dict at: #TrackID ifAbsent: ['']).	inst title: (dict at: #Name ifAbsent: ['']) .	inst artist: (dict at: #Artist ifAbsent: ['']) .	inst album: (dict at: #Album ifAbsent: ['']) .	inst genre: (dict at: #Genre ifAbsent: ['']) .	inst kind: (dict at: #Kind ifAbsent: ['']) ."	inst size: (dict at: #Size ifAbsent: ['']) .""	inst time: (dict at: #TotalTime ifAbsent: ['']) ."	inst track: (dict at: #TrackNumber ifAbsent: ['']) ."	inst modDate: (dict at: #DateModified ifAbsent: ['']) .""	inst addDate: (dict at: #DateAdded ifAbsent: ['']) ."	inst bRate: (dict at: #BitRate ifAbsent: ['']) .	inst sRate: (dict at: #SampleRate ifAbsent: ['']) ."	inst persID: (dict at: #PersistentID ifAbsent: ['']) ."	inst type: (dict at: #TrackType ifAbsent: ['']) .	inst filename: (dict at: #Location ifAbsent: ['']) ."	inst folder: (dict at: #Folder ifAbsent: [''])."	^inst"		<key>112482</key>		<dict>			<key>Track ID</key><integer>112482</integer>			<key>Name</key><string>Last Goodbye</string>			<key>Artist</key><string>Kenny Wayne Shepherd</string>			<key>Album</key><string>Live On</string>			<key>Genre</key><string>Electric Blues</string>			<key>Kind</key><string>MPEG audio file</string>			<key>Size</key><integer>6570106</integer>			<key>Total Time</key><integer>273658</integer>			<key>Track Number</key><integer>4</integer>			<key>Date Modified</key><date>2006-01-22T19:10:54Z</date>			<key>Date Added</key><date>2012-03-26T21:05:14Z</date>			<key>Bit Rate</key><integer>192</integer>			<key>Sample Rate</key><integer>44100</integer>			<key>Persistent ID</key><string>B515ECB9FE2F7173</string>			<key>Track Type</key><string>File</string>			<key>Location</key><string>file://localhost/Volumes/Content/iTunes/New/Kenny%20Wayne%20Shepherd/Live%20On/Last%20Goodbye.mp3</string>			<key>File Folder Count</key><integer>4</integer>			<key>Library Folder Count</key><integer>1</integer>		</dict>"! !!Siren.OctaveDependentChord methodsFor: 'mutations'!asMelody	^self asPlayableObject asMelody!asPlayableObject	^"PlayableChord new chord:" self!lapse: l	^self "(PlayableChord new chord: self) lapse: l"!startBeat: s duration: d	^self "(PlayableChord new chord: self) startBeat: s; duration: d"!startTime: s duration: d	^self "(PlayableChord new chord: self) startTime: s; duration: d"! !!Siren.OctaveDependentChord methodsFor: 'transposing'!beTransposedOneStepDown	root beTransposedOneStepDown.	self resetNotes!beTransposedOneStepUp	root beTransposedOneStepUp.	self resetNotes! !!Siren.OctaveDependentChord methodsFor: 'accessing'!addNote: c 	notes add: c!notes: value	notes := value!removeNote: c 	notes remove: c! !!Siren.OctaveDependentChord methodsFor: 'notes by  intervals'!computeNotesByInterval	"only for triad notes"	notesByInterval := Dictionary new.	notesByInterval at: #theTonic put: self reallyTheTonic.	notesByInterval at: #theThird put: self  reallyTheThird.	notesByInterval at: #theFifth put: self reallyTheFifth.	notesByInterval at: #theOctave put: self reallyTheOctave.	notesByInterval at: #theLowThird put: self reallyTheLowThird.	notesByInterval at: #theLowFifth put: self reallyTheLowFifth.	notesByInterval at: #theLowOctave put: self reallyTheLowOctave.!notesByInterval	notesByInterval isEmpty ifTrue: [self computeNotesByInterval].	^notesByInterval!reallyTheFifth	^super theFifth!reallyTheLowFifth	self  hasNoFifth		ifTrue: [^nil].	self hasADiminishedFifth		ifTrue: [^root transposeOf: MusicalDescendingInterval augmentedFourth].	self hasAnAugmentedFifth		ifTrue: [^root transposeOf: MusicalDescendingInterval diminishedFourth].	^root transposeOf: MusicalDescendingInterval fourth.!reallyTheLowOctave	^root transposeOf: MusicalDescendingInterval octave.!reallyTheLowThird	"attention: do not cofound with 'root downThird  interval"	self isSuspended		ifTrue: [^root transposeOf: MusicalDescendingInterval fifth]. 	self isMinor		ifTrue: [^root  transposeOf: MusicalDescendingInterval majorSixth].	^ root transposeOf: MusicalDescendingInterval minorSixth.!reallyTheOctave	^super theOctave!reallyTheThird	^super theThird!reallyTheTonic	^super theTonic!theFifth	^(self notesByInterval at: #theFifth) copy!theLowFifth	^(self notesByInterval at: #theLowFifth) copy!theLowOctave	^(self notesByInterval at: #theLowOctave) copy!theLowThird	^(self notesByInterval at: #theLowThird) copy!theOctave	^(self notesByInterval at: #theOctave) copy!theThird	^(self notesByInterval at: #theThird) copy!theTonic	^(self notesByInterval at: #theTonic) copy! !!Siren.OctaveDependentChord methodsFor: 'saving'!save	| bos fileName |	fileName := Dialog request: 'file name' initialAnswer: 'cc.chord'.	fileName isEmpty ifTrue: [^nil].	bos := BinaryObjectStorage onNew: (Filename named: fileName) writeStream.	[bos nextPut: self]		valueNowOrOnUnwindDo: [bos close]!storeOn: s	s nextPut: $(.	self quotedPrintOn: s.	s nextPutAll: ' asChordOct: '.	root oct printOn: s.	s nextPut: $).! !!Siren.OctaveDependentChord methodsFor: 'initialize'!initialize	super  initialize.	notesByInterval := Dictionary new.!resetNotes	"extend super class method for notesByIntevals"	super resetNotes.	(notesByInterval isEmpty or: [notesByInterval == nil])		ifFalse: [notesByInterval := Dictionary new]! !!Siren.OctaveDependentChord methodsFor: 'copy'!copy	| new |	new := self shallowCopy.	new root: root copy; structure: structure copy.	^new! !!Siren.OctaveDependentChord methodsFor: 'As yet unclassified'!theLowSeventh	"WARN: the calculatin of the seven is done in every request"	self  hasNoSeventh		ifTrue: [^nil].	self hasMajorSeventh		ifTrue: [^root - #minorSecond].	self hasADiminishedSeventh 		ifTrue: [^root - #minorThird].	^root - #majorSecond! !!Siren.OctaveDependentChord methodsFor: 'alteration'!octave: o	root oct: o.	self resetNotes!octaveFromNote: n 	"set octave from new root or chord note"	| int |	int :=  n pitchClass intervalBetween: root pitchClass.	int type = 1 	"n is the  root in a probably different octave"		ifTrue: [self octave: n oct].	"n is another chord note"	(self containsNote: n) 		ifFalse: [^self error: 'the given note is not note a chord note'].	self octave: (n - int) oct! !!Siren.OctaveDependentChord methodsFor: 'private-pact'!closestDownTriadNoteTo: n	"((FPChord newFromString: 'C  maj7') @ 3) closestTriadNoteTo: N B flat @ 2"	| l best smallestInt testInt |	l := self downTriadNotes.	best := l detect: [:nt | nt  respectsBassTessitura] ifNone: [nil].	best == nil ifTrue: [^nil].	smallestInt := n intervalBetween: best.	1 to: l size do: 		[:i | 		testInt := n intervalBetween: (l at: i).		(testInt < smallestInt and: [(l at: i) respectsBassTessitura])			ifTrue:			 [best := l at: i.			  smallestInt := testInt]].	^best!closestTriadNoteTo: n	"((FPChord newFromString: 'C  maj7') @ 3) closestTriadNoteTo: N B flat @ 2"	| l best smallestInt testInt |	l := self upAndDownTriadNotes.	best := l detect: [:nt | nt  respectsBassTessitura] ifNone: [nil].	best == nil ifTrue: [^nil].	smallestInt := n intervalBetween: best.	1 to: l size do: 		[:i | 		testInt := n intervalBetween: (l at: i).		(testInt < smallestInt and: [(l at: i) respectsBassTessitura])			ifTrue:			 [best := l at: i.			  smallestInt := testInt]].	^best!closestUpTriadNoteTo: n	"((PitchClassChord newFromString: 'C  maj7') @ 3) closestTriadNoteTo: N B flat @ 2"	| l best smallestInt testInt |	l := self upTriadNotes.	best := l detect: [:nt | nt  respectsBassTessitura] ifNone: [nil].	best == nil ifTrue: [^nil].	smallestInt := n intervalBetween: best.	1 to: l size do: 		[:i | 		testInt := n intervalBetween: (l at: i).		(testInt < smallestInt and: [(l at: i) respectsBassTessitura])			ifTrue:			 [best := l at: i.			  smallestInt := testInt]].	^best!containsLegalNote: n 	n respectsBassTessitura		ifFalse: [^false].	^(self upTriadNotes detect: [:each | each pitchClass = n pitchClass]					   ifNone: [nil]) notNil!downTriadNotes	"return all triad notes within 2 octaves in a particular order"	| o |	o := OrderedCollection new.	o add: self theLowOctave.	o add: self theLowFifth.	o  add: self theLowThird.	o add: self theTonic.	^o!triadDownNoteLeadingTo: n	"for the conflicting cases uses the priority given by  the ordering	of upAndDownTriadNotes "	^self downTriadNotes 		detect: [:each | 				(each isLeadingToneTo: n)				and: [each respectsBassTessitura]]		ifNone: [nil]!triadNoteLeadingTo: n	"for the conflicting cases uses two priority criteria: the proximity and 	the ordering given by triadNotesLeadingTo: "	"('A  maj7' asChordOct: 3) triadNoteLeadingTo: N D  @ 4"	| list |	list := self triadNotesLeadingTo: n.	list isEmpty ifTrue: [^nil].	list size = 1 ifTrue: [^list first].	(n isNearerTo: (list at: 2) than: list first)		ifTrue: [^(list at: 2)]		ifFalse: [^list first].!triadNotesLeadingTo: n	"answer the chord 'triad' notes  (extend to 7?) within an octave, 	 that are leading notes to the given note n"	"('A  maj7' asChordOct: 3) triadNotesLeadingTo: N D @ 4"	^self upAndDownTriadNotes select: 		[:each |		(each isLeadingToneTo: n) 			and: [each respectsBassTessitura]].!triadUpNoteLeadingTo: n	"for the conflicting cases uses the priority given by  the ordering	of upAndDownTriadNotes "	^self upTriadNotes 		detect: [:each | 				(each isLeadingToneTo: n)				and: [each respectsBassTessitura]]		ifNone: [nil]!upAndDownTriadNotes	"return all triad notes within 2 octaves in a particular order"	| o |	o := OrderedCollection new.	o add: self theOctave.	o  add: self theFifth.	o  add: self theThird.	o  add: self theTonic.	o add: self theLowOctave.	o add: self theLowFifth.	o  add: self theLowThird.	^o!upTriadNotes	"return all triad notes within 2 octaves in a particular order"	| o |	o := OrderedCollection new.	o add: self theOctave.	o  add: self theFifth.	o  add: self theThird.	o  add: self theTonic.	^o! !!Siren.OctaveDependentChord methodsFor: 'FP'!allPitchClasses	^notes collect: [:n | n pitchClass]! !!Siren.OctaveDependentChord class methodsFor: 'examples'!example	^N C majorTriad fondamental!example1	"self example1"	^(PitchClassChord newFromString: 'A  maj7') octave: 3!example2	^N C majorTriad fondamental! !!Siren.OctaveDependentChord class methodsFor: 'cation'!newWithValues: anArray 	^self new newWithValues: anArray!readFromFile	| n |	n := Dialog request: 'name of the file' initialAnswer: 'cc.chord'.	n isEmpty ifTrue: [^nil].	^self readFromFile: n!readFromFile: fileName 	| bos x |	bos := BinaryObjectStorage onOld: (Filename named: fileName) readStream.	[x := bos next]		valueNowOrOnUnwindDo: [bos close].	^x!root: r notes: n 	^(self new) root: r; notes: n! !!Siren.DataSet methodsFor: 'accessing'!addAlbum: alb	albums add: alb!addPlaylist: pls	playlists add: pls!addTrack: trk	tracks add: trk!albums	^albums!albums: aValue	albums := aValue!appVersion	^appVersion!appVersion: aValue	appVersion := aValue!artists	^artists!date	^date!date: aValue	date := aValue!features	^features!features: aValue	features := aValue!folder	^folder!folder: aValue	folder := aValue!majVersion	^majVersion!majVersion: aValue	majVersion := aValue!minVersion	^minVersion!minVersion: aValue	minVersion := aValue!persID	^persID!persID: aValue	persID := aValue!playlists	^playlists!playlists: aValue	playlists := aValue!root	^root isNil		ifTrue: [self]		ifFalse: [root]!tags	tags ifNil: [tags := IdentityDictionary new].	^tags!tracks	^tracks!tracks: aValue	tracks := aValue!tree	^tree! !!Siren.DataSet methodsFor: 'initialize-release'!free	"Setup instance"	tracks := nil.	playlists := nil.	albums := nil.	artists := nil.	tree := nil.!initialize	"Setup instance"	super initialize.	name := #none.	tracks := Dictionary new.	playlists := Dictionary new.	albums := Dictionary new.! !!Siren.DataSet methodsFor: 'printing'!printElement0: el on: aStream	"Format and print the receiver on the argument."	el hasSubNodes		ifFalse: [^aStream tab; nextPutAll: el class printString, ' ', el printString; cr].	aStream tab; nextPutAll: ' - ', el elements size printString.	el elements size > 0 		ifTrue: ["self halt"			1 to: (el elements size min: 24) do: 				[ :el2 | self printElement: el2 on: aStream]]"	tree tag type printOn: aStream. aStream cr."!printElement: el on: aStream	"Format and print the receiver on the argument."	el hasSubNodes		ifFalse: [^aStream tab; nextPutAll: el class printString, ' ', el printString; cr].	aStream tab; nextPutAll: ' - ', el elements size printString.	1 to: (el elements size min: 24) do: 				[ :in | self printElement: (el elements at: in) on: aStream]"	tree tag type printOn: aStream. aStream cr."!printElement: el on: aStream depth: dep	"Format and print the receiver on the argument."	| op |	dep > 3 ifTrue: [^self].	dep timesRepeat: [aStream tab].	el hasSubNodes		ifFalse: [aStream nextPutAll: el class printString, ' ', el printString; cr. ^self].	el isValue		ifTrue: [ op := el value]		ifFalse: [op := el elements].	aStream nextPutAll: ' - ', op size printString.	1 to: (op size min: 24) do: 				[ :in | self printElement: (op at: in) on: aStream depth: dep + 1]"	tree tag type printOn: aStream. aStream cr."!printOn0: aStream	"Format and print the receiver on the argument."	super printOn: aStream.	self tracks size printOn: aStream. aStream cr.	self albums size printOn: aStream. aStream cr.	self playlists size printOn: aStream. aStream cr.	tree elements size printOn: aStream. aStream cr.	tree elements do:		[ :el |		el hasSubNodes			ifTrue: [el size printOn: aStream. 				aStream nextPutAll: ' - ', el elements size printString; cr.				el elements size > 0 ifTrue: ["self halt"						el elements do: 						[ :el3 | el3 hasSubNodes							ifTrue: [aStream nextPutAll: ' : ', el3 elements size printString; cr]]]]			ifFalse: [el size printOn: aStream. 				aStream cr]]."	tree tag type printOn: aStream. aStream cr."!printOn: aStream	"Format and print the receiver on the argument."	super printOn: aStream.	aStream nextPutAll: tracks size printString, ' tracks'; cr.	aStream nextPutAll: playlists size printString, ' playlists'; cr."	self tracks size printOn: aStream. aStream cr.	self albums size printOn: aStream. aStream cr.	self playlists size printOn: aStream. aStream cr.	tree elements size printOn: aStream. aStream cr.	self printElement: tree on: aStream depth: 1"! !!Siren.DataSet methodsFor: 'cleaning'!fileNotFound	"Create a per-artist genre histogram"	"DataSet someInstance fileNotFound"	| tok tSiz count |	Transcript clear.	tok := 'file://localhost*'.	tSiz := tok size.	count := 1.	tracks valuesDo: 		[ :trk | | nam fnam dString rs byteA ws |		count := count + 1.		((count mod: 1000) = 0)			ifTrue: [Transcript show: count printString; cr].		nam := trk filename.		(tok match: nam) ifTrue:			[nam := nam copyFrom: tSiz to: nam size]."		nam := nam copyReplaceAll: '%20' with: ' '."		rs := nam readStream.		byteA := ByteArray new: nam size.		ws := byteA writeStream.		[rs atEnd] whileFalse:			[ | ch | 			ch := rs next.			ch = $%				ifTrue:   [ws nextPut: (Number readIntegerFrom: (rs next: 2) readStream radix: 16)]				ifFalse:  [ws nextPut: ch asInteger]].		dString := byteA asStringEncoding: #'UTF-8'.		nam := (CompositionStream on: dString readStream) contents.		('http*' match: nam) 			ifFalse: [fnam := Filename named: nam.				(fnam exists) ifFalse:					[Transcript show: nam; cr]]].	Transcript cr; show: 'done.'; cr.!genreHistogram	"Create a per-artist genre histogram"	"DataSet someInstance genreHistogram"	"PlayList allInstances do: [ :in | in properties ifNotNil: [in properties removeKey: #tag ifAbsent: []]]"	| tags |	Transcript show: 'Generate per-artist genre histograms'; cr.	(root at: #Artists) tracks associationsDo: 		[ :ass | 		ass value tracks associationsDo: 			[ :as2 |  | nam art |			nam := as2 key.			Transcript show: nam; cr.			art := as2 value.			tags := Bag new.			tags addAll: ((tracks select: [ :trk | trk artist == nam]) 								collect: [ :trk2 | trk2 genre]).			tags removeAllOccurrencesOf: #'' ifAbsent: [].			art at: #tags put: tags]].	Transcript cr; show: 'done.'; cr.!notInPlaylists	"Create a per-artist genre histogram"	"DataSet someInstance notInPlaylists"	"PlayList allInstances do: [ :in | in properties ifNotNil: [in properties removeKey: #tag ifAbsent: []]]"	| tgs |	Transcript show: 'Generate per-artist genre histograms'; cr.	(root at: #Artists) tracks associationsDo: 		[ :ass | 		ass value tracks associationsDo: 			[ :as2 |  | nam art |			nam := as2 key.			Transcript show: nam; cr.			art := as2 value.			tgs := Bag new.			tgs addAll: ((tracks select: [ :trk | trk artist == nam]) 								collect: [ :trk2 | trk2 genre]).			tgs removeAllOccurrencesOf: #'' ifAbsent: [].			art at: #tags put: tgs]].	Transcript cr; show: 'done.'; cr.!parseNames	"Create an hierarchical list of names"	"DataSet someInstance parseNames"	Transcript show: 'Generate name tree'; cr.	(root at: #Artists) tracks associationsDo: 		"A-Z list"		[ :ass |		ass value tracks associationsDo: 			"all artists"			[ :as2 |  | nam strList types |			nam := as2 key.			Transcript show: nam; cr.			strList := nam asString subStrings.			as2 value at: #names put: strList.			types := self parseTokens: strList.			as2 value at: #types put: types.]].	Transcript cr; show: 'done.'; cr.!parseTokens: strList	"Parse a list of strings into a list of token types"	" i.e., #(The Jesus & Mary Chain) -> #(#article #name #conj #name #name)"	| types dic |	types := OrderedCollection new: strList size.	dic := ((#article -> #(the an a ein eine u une)),		 (#conj -> #(with including featuring feat and &)),		  (#prep -> #(of )),			  (#punct -> #(. , / -))).	strList do: [ :tok | | ty |		ty := #name.		dic associationsDo: [ :ass |			(ass value includes: tok asSymbol) ifTrue: [ty := ass key]].		types addLast: ty].	^types! !!Siren.DataSet methodsFor: 'parsing XML'!addList: li to: di	"Add the given list to the dictionary"	"self addList: (playlists select: [ :it | it parent size == 0]) to: root."		li associationsDo:		[ :ass | | v chl |		v := ass value.		di addList: v.		chl := playlists select: [ :it | it parent asSymbol = v key].		chl isEmpty ifFalse:			[Transcript show: '	Found ', chl size printString, ' under ', v name; cr].		self addList: chl to: v].		"recurse"	li size > 0 ifTrue: [di size: li size]!groupAlbums	"Parse the dictionary into an album list"	"DataSet someInstance groupAlbums"	| top |	Transcript show: 'Group albums ', tracks size printString; cr."Get top-level nodes"	top := Set new.	top addAll: (tracks collect: [ :it | it album]).	albums := Dictionary new.	top do: [ :it | | li trx |		it isEmpty ifFalse:			[li := PlayList new name: it.			trx := tracks select: [ :it2 | it2 album = it].			trx isEmpty ifTrue: [self halt].			trx do: [ :tr |				li addTrack: tr].			albums at: it asSymbol put: li]]."	albums inspect"!groupArtists	"Parse the dictionary into an artist list"	"DataSet someInstance groupArtists"	"DataSet someInstance artists"	"(DataSet someInstance playlists do: [ :it | it key: it key asString asSymbol])"	"(DataSet someInstance playlists select: [ :it | it key == #'36556BEED87BEBA9' ])"	| top albs ar |	Transcript show: 'Group artists ', tracks size printString; cr."Get top-level nodes"	top := Set new.	top addAll: (tracks collect: [ :it | it artist]).	artists := PlayList new name: 'Artists'.	artists parent: root.	top do: [ :art | | li trx |		art isEmpty ifFalse:			[li := PlayList new name: art.			artists addList: li.			trx := tracks select: [ :it2 | it2 artist == art].			trx isEmpty ifTrue: [self halt].			albs := Set new.			albs addAll: (trx collect: [ :it | it album]).			albs do: [ :al | | alb atrx |				alb := PlayList new name: al.				li addTrack: alb.				atrx := trx select: [ :it2 | it2 album == al].				atrx do: [ :atr |					alb addTrack: atr]]]].	artists size: artists tracks size.	root removeListNamed: #Artists.	ar := PlayList new name: #Artists.	root addList: ar.	65 to: 90 do:		[ :in | | ch li li2 |		ch := in asCharacter.		Transcript show: '	Artists ', (String with: ch); cr.		li := PlayList new name: ch asSymbol.		li2 := artists tracks select: [ :pl | pl name first == ch].		li2 values do: [ :it | li addList: it].		ar addList: li.		ar size: ar tracks size].	artists := nil.!groupPlayLists	"Parse the dictionary into a play list"	"DataSet someInstance groupPlayLists"	"DataSet someInstance playlists"	"DataSet someInstance root"	"(DataSet someInstance playlists select: [ :it | '*Master*' match: it name]) "	"(DataSet someInstance playlists select: [ :it | it parent = '']) "	"(DataSet someInstance playlists select: [ :it | it size == 0]) size collect: [ :it | Transcript show: it name; cr]"	"(DataSet someInstance playlists do: [ :it | it key: it key asString asSymbol])"	"(DataSet someInstance playlists select: [ :it | it key == #'36556BEED87BEBA9' ])"	| top genres |	Transcript show: 'Group lists ', playlists size printString; cr."Get top-level nodes"	top := playlists select: [ :it | it parent size == 0].	root := PlayList new name: #Root.	root id: 0.	root key: 0.	genres := PlayList new name: #Genres.	root addList: genres.	self addList: top to: genres."	root inspect"!loadPlayLists	"Parse the dictionary into a play list"	"DataSet someInstance loadPlayLists"	"DataSet someInstance playlists"	"| ds di | di := Dictionary new.	ds := DataSet someInstance.	ds playlists associationsDo: [ :ass | di at: ass value key asSymbol put: ass value].	ds playlists: di"	| ind  lis |	lis := tree at: #Playlists.	Transcript show: 'Load lists ', lis size printString; cr.	playlists := Dictionary new.	ind := 1.	lis do:		[ :item | | plist |		plist := PlayList fromDictionary: item with: tracks.		playlists at: plist key asSymbol put: plist.		tracks do: [ :trk | trk addPlaylist: plist].		ind := ind + 1.		(ind \\ 1000 == 0) ifTrue: [Transcript show: ind printString; cr]].!loadTracks	"Parse the dictionary into a track list"	"DataSet someInstance loadTracks"	"DataSet someInstance tracks"	| trx ind  |	trx := tree at: #Tracks.	Transcript show: 'Load trax ', trx size printString; cr.	ind := 1.	trx associationsDo:		[ :ass | | ke trk |		ke := ass key.		trk := Track key: ke fromDictionary: ass value.		trk loadTags.			"read the file"		tracks at: ke asString asNumber put: trk.		ind := ind + 1.		(ind \\ 1000 == 0) ifTrue: [Transcript show: ind printString; cr]].!parseElement: el depth: dep index: indx	"Load XML elements into a data set"	"DataSet example1"	| k v dict oc ind |"Handle empty elements"	el isText ifTrue:		[(el text trimSeparators isEmpty) ifTrue: [^nil].		^el text asSymbol]."Handle dictionaries"	el tag type = 'dict'		ifTrue: [ind := indx.			dict := Dictionary new.			el elements do: [ :it | | ty |				(it isText and: [it text trimSeparators isEmpty]) ifFalse: [					ty := it tag type asSymbol .					((#key -> [k := it elements first text]),						(#integer -> [v := it elements first text asNumber]),						(#string -> [it elements isEmpty ifTrue: [v := ''] ifFalse: [v := it elements first text]]),						(#date -> [v := it elements first text]),						(#data -> [v := it elements first text]),						(#true -> [v := true]),						(#false -> [v := false]),						(#dict -> [v := self parseElement: it depth: dep + 1 index: ind.		"recurse"								ind := ind + 1.								(ind \\ 1000 == 0) ifTrue: [Transcript tab; 										show: dep printString, '  ', ind printString, '  ', 									k printString; cr]]),						(#array -> [v := self parseElement: it depth: dep + 1 index: ind.		"recurse"								ind := ind + 1.								(ind \\ 1000 == 0) ifTrue: [Transcript tab; 										show: dep printString, '  ', ind printString, '  ', 									k printString; cr]]))					case: ty					otherwise: [Transcript show: it tag type; cr.								self halt].					(k notNil) & (v notNil)						ifTrue: [ | k2 |							k2 := (k copyReplaceAll: ' ' with: '') asSymbol.							dict at: k2 put: v.						"	k2 == #TrackID								ifTrue: [Transcript tab; show: dep printString, '  ', ind printString, '  ', 									k printString, ' -> ', v printString; cr]. "							k := nil.  v := nil]]].			^dict].	el hasSubNodes ifFalse: [^el]."Handle arrays"	el elements size > 1		ifTrue: [oc := OrderedCollection new.			ind := indx.			el elements do: 				[ :el2 | | item |				item := self parseElement: el2 depth: dep + 1 index: ind.			"recurse"				item ifNotNil: [oc addLast: item.					ind := ind + 1.					(ind \\ 1000 == 0) ifTrue: [Transcript tab; 						show: dep printString, '  ', ind printString, '  '; cr]]].			^oc]!read: aFilename	"Load a data set"	"DataSet new read: '/Volumes/Content/iTunes/Library120412a.xml' "	"DataSet example1"	"DataSet someInstance tracks first"	Transcript cr; cr; show: 'Read DataSet ', aFilename; cr.	tree := XML.XMLParser processDocumentInFilename: aFilename					beforeScanDo: [:parser | parser validate: false].	Transcript show: 'Parse DataSet'; cr.	tree := self parseElement: tree root depth: 1 index: 1.	tree := tree first.	Transcript show: (tree at: #Tracks) size printString, ' tracks'; cr.	Transcript show: (tree at: #Playlists) size printString, ' playlists'; cr.	self loadTracks.	self loadPlayLists.	self groupPlayLists.	self groupArtists.	self groupAlbums.	tree := nil.	name := aFilename.	Transcript cr; show: 'Done'; cr.!readStrings: aFilename	"Load a data set"	"DataSet new read: '/Volumes/Content/iTunes/Library120412a.xml' "	| fil trk|	Transcript cr; cr; show: 'Read DataSet ', aFilename; cr."	trx := tree at: #Tracks."	fil := aFilename asFilename readStream.	fil upTo: Character cr.						"skip forst line"	[fil atEnd] whileFalse:		[trk := Track fromLine: (fil upTo: Character cr).		tracks at: trk id put: trk.].	Transcript show: tracks size printString, ' tracks'; cr.	name := aFilename.	Transcript cr; show: 'Done'; cr.! !!Siren.DataSet methodsFor: 'megatrax'!addRelationsFor: tok to: tag	"Find related tags and add parent/child relationships"	"DataSet defaultDataSet splitTags"	"DataSet defaultDataSet flushTags"	| other |"	Transcript show: tok, ' : ', tag name string; cr. "	(self tags includesKey: tok)		ifTrue:  [other := self tags at: tok.			(tag == other) ifTrue: [^self].			other addChild: tag.			tag addParent: other."			Transcript show: tok, ' : ', other name string; cr" ]		ifFalse: [other := Tag name: tok track: nil.			tags at: tok put: other.			other addChild: tag.			tag addParent: other."			Transcript show: tok, ' : ', tag name string; cr" ]!buildTagsTree	"Load the tags of the data set; re-load tags if reParse is true"	"DataSet defaultDataSet learnTags: false"	"DataSet defaultDataSet tags"	" | ta | 	ta := DataSet defaultDataSet tags.	Transcript clear.	1 to: 600 do: [ :ind | Transcript show: (ta at: ind) printString; cr]"	| tags2 cnt |	Transcript clear.	Transcript show: 'Processing DataSet ', name; cr."Collect labels"	Transcript show: 'Loading tags'; cr.	self tags do: 		[ :ta | | t2 |			t2 := tags detect: [ :tag | tag name == true									]					ifNone: [nil].	]!filterDegenerate	"Drop the vacuous tags"	"DataSet defaultDataSet filterDegenerate"	| tags1 tags2 |	tags1 := tags values.	tags1 removeAllSuchThat: 		[ :it | (((it tracks isEmpty) and: [it parents values isEmpty]) and: [it children values size == 1])].	tags2 := IdentityDictionary new.	tags1 do: [ :it | tags2 at: it name put: it].	Transcript crtab; show: tags size printString, ' tags'; cr.	tags := tags2.	Transcript tab; show: tags size printString, ' tags'; cr.!filterNumbers	"Drop the really short tokens and number-first tags"	"Transcript cr; tab; show: DataSet defaultDataSet tags size printString, ' tags'; cr.	DataSet defaultDataSet filterNumbers.	Transcript tab; show: DataSet defaultDataSet tags size printString, ' tags'; cr. "	"29896 to 29271"	| tags2 |	tags2 := IdentityDictionary new."Loop over tags"	self tags values do: 		[ :ta | | toks tk1 |		(ta name size > 2) ifTrue:"Scanner on tag"			[toks := Scanner new breakIntoTokens: ta name.			tk1 := toks first string.			(tk1 asNumber == 0) ifTrue:			"starts with a number: ignore"				[tags2 at: ta name put: ta]]].	tags := tags2.!fixAbbreviations	"Find truncated tags"	"DataSet defaultDataSet fixAbbreviations"	| tagL srch coll |"Loop over tags looking for matches"	tagL := self tags values.	tagL do: 		[ :ta |		(ta name size > 4) ifTrue:			[srch := ta name string, '*'.			coll := tagL select: [ :item | srch match: item name string].			(coll size > 1)				ifTrue: [Transcript cr; show: ta name string; crtab.					coll do:						[ :ma |						ma size ~= ta name size							ifTrue: [Transcript show: ma name string; tab]].					self halt					]]]!flushTags	"Reset the family dictionaries"	"DataSet defaultDataSet flushTags"	self tags values do: 		[ :ta | ta reinitialize]!isAlphaNumeric: char	"Check for AlphaNumeric or dash or dot"	char isAlphaNumeric ifTrue: [^true].	(#($. $-) includes: char) ifTrue: [^true].	^false!isSeparator: char	"Check for AlphaNumeric or dash or dot"	char isAlphaNumeric ifTrue: [^false].	(#($. $-) includes: char) ifTrue: [^false].	^true!learnTags: reParse	"Load the tags of the data set; re-load tags if reParse is true"	"DataSet defaultDataSet learnTags: false"	"DataSet defaultDataSet tags"	"DataSet defaultDataSet printTags: 600"	| tags2 cnt "tagVs" |	Transcript clear.	Transcript show: 'Processing DataSet ', name; cr."Parse tracks; empty tag list"	reParse ifTrue: [Transcript show: 'Parsing strings'; cr.		self tracks do: [ :tr | tr parseTags]].	tags := IdentityDictionary new.			"create tags dict""Collect labels"	Transcript show: 'Loading tags'; cr.	self tracks do: 		[ :tr | tr labels do: 			[ :lab | | ta |"Case-insensitive compare"			ta := tags at: lab ifAbsent: [nil].				"simple match here, clean up later"			ta isNil				ifTrue: [tags at: lab put: (Tag name: lab track: tr)]				ifFalse: [ta tracks add: tr]]]."Merge duplicates case insensitive"	Transcript show: 'Culling'; cr.	tags2 := IdentityDictionary new.	cnt := 0.	tags values do: [ :ts | | ta |		ta := tags values select: [ :tx | ts name value match: tx name value ignoreCase: true].		"match tag names"		(ta size = 1)			ifTrue: [tags2 at: ta first put: ts]			ifFalse: [ | t1 tn |				t1 := ta first."				Transcript show: t1 name string, ' - '."				(t1 == ts) ifTrue: 					[tags2 at: t1 name put: t1.					2 to: ta size do: [ :ind |						tn := ta at: ind."						Transcript show: tn name string, ' - '."						t1 tracks addAll: tn tracks]."				Transcript cr"				cnt := cnt + 1]]].	Transcript tab; show: cnt printString, ' duplicates'; cr.	Transcript tab; show: tags2 size printString, ' tags'; cr."Filter numbers and dead tags"	Transcript show: 'Filtering'; cr.	tags := tags2.	self filterNumbers.	Transcript tab; show: tags size printString, ' tags'; cr."Sort labels by frequency & Dump the top 300 to the Transcript""	Transcript show: 'Sorting'; cr.	tagVs := tags values asSortedCollection: [ :a :b | a tracks size > b tracks size]. 	1 to: 300 do: [ :ind | Transcript show: (tagVs at: ind) printString; cr]."	Transcript cr; show: 'Done'; cr.!printTags: howMany	"Dump some tags to the Transcript"	"DataSet defaultDataSet printTags: 600"	| tagVs | 	Transcript clear.	tagVs := DataSet defaultDataSet tags values asSortedCollection: [ :a :b | a tracks size > b tracks size]. 	1 to: 600 do: [ :ind | Transcript show: (tagVs at: ind) printString; cr]!scanTokens: toks in: tag	"Scan the token list in the tag"	"DataSet defaultDataSet splitTags"	| punct tk1 tk2 ind |"Ignore 1-token tags"	(toks size == 1)		ifTrue: [^self]."2 tokens: check len of 2"	(toks size == 2)		ifTrue: [tk1 := toks first string asSymbol.			tk2 := (toks at: 2) string asSymbol."			(tk1 size < 3) ifTrue: [self halt]."			"handle too-short 1st tag"			(tk2 size < 3)			"drop too-short 2nd tag"					ifTrue: [tag name: tk1]					 ifFalse: [self addRelationsFor: tk1 to: tag.							self addRelationsFor: tk2 to: tag].			^self]."3 or more tokens"	punct := 0.		"find longest list of words with no punct"	ind := 1.	[(punct == 0) and: [ind <= toks size]] whileTrue: 		[ | tz |		tz := (toks at: ind) string.		((tz size == 1) and: [self isSeparator: tz first]) ifTrue: [punct := ind].		ind := ind + 1]."if no punct, add all words"		(punct == 0) 			ifTrue: [self scanWords: toks from: 1 to: toks size in: tag]"Process the head"			ifFalse: [self scanWords: toks from: 1 to: punct - 1 in: tag."Scan the tail"					(punct == toks size) 						ifFalse: [self scanTokens: (toks copyFrom: punct + 1 to: toks size) in: tag]]!scanWords: tagList from: startI to: stopI in:tag	"Scan a set of tag tokens""Loop over tags"	startI to: stopI do: 		[ :ind | | tok |		tok := ''.		startI to: ind do: 			[ :in2 | | item |			item := tagList at: in2.			tok := tok, item.			self addRelationsFor: tok asSymbol to: tag.			(item size > 1)				ifTrue: [tok := tok, ' ']]]!splitTags	"Loop over the tags scanning them and building the parent/child tree"	"DataSet defaultDataSet splitTags"	"29778 to 94906 tags"	self flushTags.	Transcript tab; show: tags size printString, ' tags'; cr."Loop over tags"	self tags values do: 		[ :ta | | toks |"Scanner on tag"		toks := Scanner new scanTokens: ta name.		toks := toks collect: [ :item | item isSymbol ifTrue: [item] ifFalse: [item printString]].		self scanTokens: toks in: ta].	Transcript tab; show: tags size printString, ' tags'; cr! !!Siren.DataSet class methodsFor: 'examples'!example1	"Load an iTunes XML data set"	"DataSet example1"	"DataSet flushDataSet"	| db |	db := DataSet new: '/Volumes/Content/iTunes/Library120412b.xml'.	Transcript cr."	Transcript show: db printString; cr."	db inspect."| lis |lis := self tree elements last.Transcript cr; show: lis tag; cr.Transcript cr; show: lis elements size printString; cr.lis elements do: [ :el |Transcript cr; show: el  size printString]""	Transcript show: db tracks size printString; cr.	Transcript show: db albums size printString; cr.	Transcript show: db playlists size printString; cr.	Transcript show: db tree type.	db tree elements do:		[ :el |		Transcript show: el size printString; cr.		el size > 0 ifTrue: [el elements do: 			[ :el2 |			Transcript show: el2 size printString; cr]]]."!example2	"Load and process a MegaTrax data set"	"DataSet example2"	"DataSet defaultDataSet""	TagSetTool open "	DataSet flushDataSet.	DataSet new: '/Volumes/Content/Code/SndsLike/DataSets/MTrax/msongs-strings.txt'.	DataSet defaultDataSet learnTags: true.	"DataSet defaultDataSet learnTags: false"	DataSet defaultDataSet flushTags.	DataSet defaultDataSet splitTags.	DataSet defaultDataSet printTags: 600.! !!Siren.DataSet class methodsFor: 'class var accessing'!defaultDataSet	"DataSet defaultDataSet"	"DataSetTool open"	SongDataSet ifNil: [self new: self defaultDataSetName].	^SongDataSet!defaultDataSetName	"Answer an iTunes XML file"	^'/Volumes/Content/iTunes/Library120412b.xml'!flushDataSet	"DataSet flushDataSet"	SongDataSet ifNotNil: [SongDataSet release].	SongDataSet := nil!isSeparator: char	"Check for AlphaNumeric or dash or dot"	char isAlphaNumeric ifTrue: [^false].	(#($. $-) includes: char) ifTrue: [^false].	^true!tags	"DataSet tags"	"Tags := nil"	Tags ifNil: [Tags := self loadFiles: 'attributes.xml'].	^Tags! !!Siren.DataSet class methodsFor: 'xml import'!loadFiles: fname 	"Load the MegaTrax attributes files into a dict of identity sets"	"DataSet loadFiles: 'attributes.xml'"	| tree list dir taglist |	dir := '/Volumes/Content/Code/SndsLike/DataSets/MTrax/XML/'.	tree := XML.XMLParser processDocumentInFilename: dir , fname beforeScanDo: [:parser | parser validate: false].	list := tree children first elements select: [:el | el isBlankText not].	list := list collect: [:el | (el attributes at: 2) value].	taglist := Dictionary new.	list do: [ :fn | self loadList: fn in: dir to: taglist].	^taglist!loadList: fname in: dir to: taglist	"Load a MegaTrax list files into an identity set"	"DataSet loadFiles: 'attributes.xml'"	| streem list tok it |	tok := 'node label="'."	list := IdentitySet new."	list := OrderedCollection new."Open file"	streem := (dir , fname) asFilename readStream.	[streem atEnd] whileFalse: 					"read file"		[streem throughAll: tok.					"skip to token"		it := streem upTo: $".						"read to $""		Transcript show: it; cr."		list add: it "asLowercase asSymbol"].		"save lower-case symbol"	streem close."Add to dict"	taglist at: (fname copyFrom: 1 to: fname size - 4) asSymbol put: list! !!Siren.DataSet class methodsFor: 'instance creation'!new	^super new initialize!new: aFile	"Load a data set"	"DataSet new: '/Volumes/Content/iTunes/Library120412.xml' "	"DataSet new: '/Volumes/Content/Code/SndsLike/DataSets/MTrax/msongs-strings.txt' "	"DataSet someInstance"	"DataSet flushDataSet"	| inst dsname |	SongDataSet ifNotNil: [SongDataSet release. SongDataSet := nil].	inst := self new.	('*.xml' match: aFile) 		ifTrue: [inst read: aFile]		ifFalse: [inst readStrings: aFile].	dsname := Dialog request: 'Please edit data set name' initialAnswer: aFile.	dsname isEmpty ifFalse: [inst name: dsname].	SongDataSet := inst.	^inst! !!Siren.Cloud methodsFor: 'accessing'!density: theDensity	"set the density instance variable"	density := theDensity! !!Siren.Cloud methodsFor: 'playing'!eventList	"Make the cloud's events; assume that the receiver's pitch, loudness and 	durations are actually intervals"	| pattern number length start |	pattern := EventList new.	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	number truncated timesRepeat:		[pattern add: (MusicEvent 				dur: (length * 2) 	"legato"				pitch: self pitch value atRandom				ampl: self loudness value atRandom				voice: ((self voice == nil 						ifTrue: [nil] 						ifFalse: [self voice atRandom])))			at: start.		start := start + length].	^pattern!eventList0	"Make the cloud's events; assume that the receiver's pitch, loudness and 	durations are actually intervals"	| pattern rand number length start |	pattern := EventList new.	rand := Random new.	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	number truncated timesRepeat:		[pattern add: (MusicEvent 			dur: (length * 2 "+ (2000 * rand next) rounded")			pitch: ((self pitch value first) + 					((rand next * (self pitch value last - self pitch value first)) rounded))			ampl: ((self loudness value first) + 					((rand next * (self loudness value last - self loudness value first)) rounded))			voice: ((self voice == nil 						ifTrue: [nil] 						ifFalse: [(self voice first) + 					((rand next * (self voice last - self voice first)) rounded)])))			at: start.		start := start + length].	^pattern! !!Siren.Cloud class methodsFor: 'instance creation'!dur: aD pitch: aP ampl: anA	"return an initialized Cloud"	^self new duration: aD; 		pitch: aP; 		loudness: anA!dur: aD pitch: aP ampl: anA voice: aVoice	"return an initialized Cloud"	^self new duration: aD; 		pitch: aP; 		loudness: anA; 		voice: aVoice!dur: aD pitch: aP ampl: anA voice: aVoice density: aDe	"return an initialized Cloud"	^self new duration: aD; 		pitch: aP; 		loudness: anA; 		voice: aVoice; 		density: aDe!dur: aD voice: aVoice density: aDe	"return an initialized Cloud"	^self new duration: aD; 		voice: aVoice; 		density: aDe!fromDictionary: aDictionary	"Answer an initialized Cloud generated from the given property map dictionary."	"(Cloud fromDictionary: ((#duration -> 5000), 			(#pitch -> (48 to: 74)),			(#loudness -> (50 to: 100)), 			(#voice -> (1 to: 4)), 			(#density -> 25))) eventList edit"	| me |	me := self new.	aDictionary associationsDo: 		[ :ass |		me perform: ((ass key, ':') asSymbol) with: ass value].	^me! !!Siren.Cloud class methodsFor: 'examples'!dictionaryExample	"Answer an initialized Cloud generated from the given property map dictionary."	"Cloud dictionaryExample"	(Cloud fromDictionary: ((#duration -> 5000), 			(#pitch -> (48 to: 70)),			(#loudness -> (50 to: 100)), 			(#voice -> (1 to: 4)), 			(#density -> 15))) eventList edit!example1	"Create and edit a low 6 second stochastic cloud with 5 events per second"	"Cloud example1"	| c |	c := (Cloud  dur: 6		pitch: (48 to: 60)  		ampl: (80 to: 120) 		voice: (1 to: 4)		density: 5) eventList."	c edit "	c play"	c inspect"!randomExample	"Play a stochastic cloud with random properties."	"Cloud randomExample"	| rand pBase score |	rand := Random new.	pBase := 20 + (rand next * 60) rounded.	score := (Cloud  dur: (2 + (rand next * 6) asInteger)		pitch: (pBase to: (pBase + (rand next * 40)) rounded)  		ampl: (80 to: 120) 		voice: (1 to: 8)		density: (rand next * 20)) eventList.	score play.	(Delay forSeconds: 5) wait.	MIDIPort allNotesOff"	score inspect	score edit"!randomExample2	"Play a stochastic cloud with random properties."	"Cloud randomExample2"	| rand pBase score |	rand := Random new.	pBase := 20 + (rand next * 60) rounded.	score := (Cloud  dur: (3 + (rand next * 6))		pitch: (pBase to: (pBase + (rand next * 40)) rounded)  		ampl: (80 to: 120) 		voice: (1 to: 8)		density: (rand next * 20)) eventList.	score play.	MIDIPort allNotesOff"	score inspect	score edit"! !!Siren.HarmonicMinorScale methodsFor: 'Paleo'!costForPitch: n	(notes includes: n) ifTrue: [ ^ 0].	root majorSeventh = n ifTrue: [^ 0].	root majorSixth = n ifTrue: [^ 0].	(self allNotes includes: n) ifTrue: [^ 1].	^ 2!enharmonicScale	root = N C sharp ifTrue: [^ N D flat harmonicMinorScale].	root = N D sharp ifTrue: [^ N E flat harmonicMinorScale].	root = N F sharp ifTrue: [^ N G flat harmonicMinorScale].	root = N G sharp ifTrue: [^ N A flat harmonicMinorScale].	root = N A sharp ifTrue: [^ N B flat harmonicMinorScale].	root = N D flat ifTrue: [^ N C sharp harmonicMinorScale].	root = N E flat ifTrue: [^ N D sharp harmonicMinorScale].	root = N G flat ifTrue: [^ N F sharp harmonicMinorScale].	root = N A flat ifTrue: [^ N G sharp harmonicMinorScale].	root = N B flat ifTrue: [^ N A sharp harmonicMinorScale].	^ nil! !!Siren.HarmonicMinorScale class methodsFor: 'interval list'!allIntervals	^#(#unison #diminishedSecond #second #minorThird #majorThird #perfectFourth augmentedFourth #perfectFifth #minorSixth #majorSixth #minorSeventh #majorSeventh )!intervalList	^#(#unison #second #minorThird #perfectFourth #perfectFifth #minorSixth #majorSeventh )! !!Siren.AbstractOSCPacket methodsFor: 'accessing'!oscBytes	^oscBytes!oscSize	^oscBytes size! !!Siren.AbstractOSCPacket methodsFor: 'osc'!toOSCBytes: converter 	self subclassResponsibility.	^self! !!Siren.AbstractOSCPacket methodsFor: 'initialize-release'!init	| convertor |	convertor := OSCByteConvertor new.	self toOSCBytes: convertor.	oscBytes := convertor contents.	^self! !!Siren.OSCMessage methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'OSC: ', address, '  ', arguments printString.! !!Siren.OSCMessage methodsFor: 'osc'!addressToOSCBytes: convertor 	"Convert the address to the OSC format"	address toOSCBytes: convertor.	^self!argumentsToOSCBytes: convertor 	"Add the type tags, then the arguments"	arguments do: [:each | each toOSCBytes: convertor].	^self!toOSCBytes: converter 	"Convert myself to OSC format"	self addressToOSCBytes: converter.	arguments notEmpty ifTrue: [self argumentsToOSCBytes: converter].	^self!typesToOSC: converter	| index numPad |	arguments isEmpty ifTrue: [^self].	arguments do: [:each | each toOSCTypeOn: converter].	index := 1.	numPad := 4 - (converter position \\ 4).	"This isn't very ST -- should be numPad do:[converter nextPut: 0]"	[index <= numPad]		whileTrue: 			[converter nextPut: 0.			index := index + 1].	^self! !!Siren.OSCMessage methodsFor: 'initialize-release'!initAddress: t1 arguments: t2 	address := t1.	arguments := t2.	self init.	^self! !!Siren.OSCMessage class methodsFor: 'instance-creation'!for: addr	^self new initAddress: addr arguments: #()!for: addr with: args 	"Answer a TOM with the given address and arguments"	^self new initAddress: addr arguments: args! !!Siren.OSCMessage class methodsFor: 'examples'!example1	"OSCMessage example1"	^self for: '/example1' with: #(100)!example2	"OSCMessage example2"	^self for: '/example2' with: #('tester' 10.4)!example3	"OSCMessage example3"	^self for: '/example3' with: #(20 30 'blah')! !!Siren.Ostinato methodsFor: 'accessing'!events	^list events!list	^list!list: anEL	list := anEL!process: anBlockOrProc	process := anBlockOrProc! !!Siren.Ostinato methodsFor: 'playing'!play: numberOfTimes	"return an event list from the given number of times playing"	| time pattern |	time := 0 msec.	pattern := EventList newAnonymous.	numberOfTimes timesRepeat:		[pattern add: list at: time.		time := list duration + time].	pattern play!playAt: firstTime	"Play an ostinato until turned off."	| startTime rTime | 	startTime := firstTime.	rTime := Time microsecondClock.	playing := true.	voice := list voice == nil 		ifFalse: [list voice] 		ifTrue: [Voice default].	process := [[playing] whileTrue: 			[voice play: list at: startTime.			startTime := startTime + list duration.			(Delay untilMicroseconds: rTime + startTime - 500000) wait.		Transcript show: 'x '. ]] fork"At: 5"!playOn: aVoice at: firstTime	"play an ostinato until turned off."	| startTime | 	startTime := firstTime.	playing := true.	process := [[playing] whileTrue: 			[list playOn: aVoice at: startTime.			startTime := startTime + list duration.			(Delay untilMilliseconds: startTime - 500) wait]] forkAt: 5!stop	"stop a playing Ostinato."			playing := false."	self list stop"! !!Siren.Ostinato methodsFor: 'printing'!printOn: aStream	self name isNil ifFalse: [		aStream nextPutAll: 'Ostinato named: ', self name asString, ' on EventList: (']	ifTrue: [		aStream nextPutAll: 'Ostinato on EventList: ('].	aStream cr.	list printOn: aStream.	aStream nextPutAll: ') playing= ', playing printString; cr! !!Siren.Ostinato methodsFor: 'initializing'!initializeAnonymous	"set up a new Ostinato."	super initializeAnonymous.	playing := false.!initializeNamed: aName	"Set up a new Ostinato."	super initializeNamed: aName.	playing := false.! !!Siren.Ostinato class methodsFor: 'examples'!ostinatoExamples	"Create and edit some ostinati."	"Ostinato onList: (EventList named: #scale1)"	"Ostinato onList: (EventList named: #scale1) edit"	"Ostinato newNamed: #scaleO onList: (EventList named: #scale1)"	"(Ostinato named: #scaleO) play"	"(Ostinato named: #scaleO) playOn: 1 at: 0"	"(Ostinato named: #scaleO) stop"! !!Siren.Ostinato class methodsFor: 'instance creation'!named: aSymbol onList: anEL 	"create an Ostinato on the given EventList."	| me |	me := self new initializeNamed: aSymbol.	me list: anEL.	^me!named: aSymbol onList: anEL dur: theDur	"create an Ostinato on the given EventList."	| me |	me := self new initializeNamed: aSymbol.	me list: anEL.	me dur: theDur.	^me!newNamed: aSymbol onList: anEL 	"create an Ostinato on the given EventList."	| me |	me := self new initializeNamed: aSymbol.	me list: anEL.	^me!onList: anEL 	"create an Ostinato on the given EventList."	| me |	me := self new initializeAnonymous.	me list: anEL.	me events: anEL events.	^me!onList: anEL dur: theDur	"create an Ostinato on the given EventList."	| me |	me := self new initializeAnonymous.	me list: anEL.	me dur: theDur.	^me! !!Siren.Spectrum methodsFor: 'modes'!complex	"Set the receiver's instance variable 'magReal' to be #complex."	magReal := #complex!real	"Set the receiver's instance variable 'magReal' to be #real."	magReal := #real!setWindow: aSymbol	"Set the receiver's 'window'."	"#rectangular, #triangular"	window := aSymbol!window	"Answer the receiver's 'window'."	^window! !!Siren.Spectrum methodsFor: 'frames'!at: anIndex	"Answer the value at the given index (between 1 and self size)."	anIndex isSymbol		ifTrue: [^super at: anIndex].	^data at: anIndex!at: anIndex put: aValue	"Answer the value at the given index (between 0 and 1)."	anIndex isSymbol ifTrue: [^super at: anIndex put: aValue].	data at: anIndex put: aValue!frame: anIndex	"Answer the frame at the given index (between 1 and self size)."	^data at: anIndex!frame: anIndex do: aBlock	"Iterate over a single frame with the given block."	magReal == #real		ifTrue: [(data at: anIndex) do: aBlock]		ifFalse: [ | base |			base := anIndex * windowSize.			base to: base + windowSize do: aBlock]!frame: frm imagAt: frq	"Answer the given imag value in the given frame."	magReal == #complex		ifTrue: [^(data at: frm) at: frq + windowSize]!frame: frm imagAt: frq put: val	"Set the given imag value in the given frame."	magReal == #complex		ifTrue: [(data at: frm) at: frq + windowSize put: val]!frame: anIndex put: aValue	"Set the value at the given index (between 0 and 1)."	anIndex isSymbol ifTrue: [^super at: anIndex put: aValue].	data at: anIndex put: aValue!frame: frm realAt: frq	"Answer the requested real value from the given frame."	^(data at: frm) at: frq!frame: frm realAt: frq put: val	"Set the given real value in the given frame."	magReal == #complex		ifTrue: [(data at: frm) at: frq put: val]! !!Siren.Spectrum methodsFor: 'accessing'!D	"Answer the receiver's decimation factor."	^windowSize / stepSize!D: factor	"Set the receiver's decimation factor."	^stepSize := windowSize / factor!N	"Answer the receiver's 'windowSize'."	^windowSize!N: aNum	"Set the receiver's instance variable 'windowSize' to be aNum."	windowSize := aNum.!sound	"Answer the receiver's 'sound'."	^sound!sound: anObject	"Set the receiver's instance variable 'sound' to be anObject."	sound := anObject!stepSize	"Answer the receiver's 'stepSize'."	^stepSize!stepSize: anObject	"Set the receiver's instance variable 'stepSize' to be anObject."	stepSize := anObject!windowSize	"Answer the receiver's 'windowSize'."	^windowSize!windowSize: aNum	"Set the receiver's instance variable 'windowSize' to be aNum."	windowSize := aNum.! !!Siren.Spectrum methodsFor: 'computing'!compute	"Do the FFT and store the results into the receiver's data."	"Spectrum sweepExample"	"Spectrum fileExample"	| fft dSize min max samples spectrum |	dSize := (sound size / stepSize) truncated.		"# of windows"	data := Array new: dSize.						"array of arrays"	min := 1.0e30.  max := -1.0e30.	samples := UninterpretedBytes new: (windowSize * 4).		"FFT's private data"	samples gcCopyToHeap.	spectrum := UninterpretedBytes new: (windowSize * 4 + 1).	spectrum gcCopyToHeap.	fft := FFTWInterface new.						"set up the FFT"	[fft fftw_initialize: windowSize with: samples with: spectrum]		on: Error		do: [ :ex | self error: 'FFT not installed'].	Cursor execute showWhile:		[1 to: dSize do:			[ :winCount | | buffer slice |			buffer := self window: winCount.	"window the data buffer"			1 to: windowSize do:							"copy it to the FFT's input buffer"				[ :count | samples floatAt: (count - 1 * 4 + 1) put: (buffer at: count)].			fft fftw_forward_transform.				"do the FFT"			slice := Array new: (windowSize / 2).			magReal == #real				"pack data--real or complex"				ifFalse: [self error: 'Complex FFT not supported']				ifTrue: [1 to: windowSize / 2 do:	"copy the magnitude spectrum out"					[ :ind | | re im mag |						re := spectrum floatAt: (ind * 2 - 2 * 4 + 1).						im := spectrum floatAt: (ind * 2 - 1 * 4 + 1).						mag := ((re * re) + (im * im)) sqrt.						slice at: ind  put: mag.						min := mag min: min.						max := mag max: max].					data at: winCount put: slice]]].	self range: (min to: max)!compute0	"Do the FFT and store the results into the receiver's data."	"Display restoreAfter: [Spectrum sweepExample]"	"Display restoreAfter: [Spectrum fileExample]"	| fft dSize min max |	dSize := (sound size / stepSize) truncated.	data := Array new: dSize.		"array of arrays"	min := 1.0e30.  max := -1.0e30.	Cursor execute showWhile:		[1 to: dSize do:			[ :ind |			fft realData: (self window: ind).			fft transformForward: true.		"do fft"			magReal == #real				"pack data--real or complex"				ifTrue: [data at: ind put: fft realData]				ifFalse: [data at: ind put: 				"store complex spectrum as mag"					((1 to: windowSize) collect:						[ :i | ((fft realData at: i) squared 								+ (fft imagData at: i) squared) sqrt])].			(data at: ind) do:			"calc min/max"				[ :d | min := d min: min.					max := d max: max]]].	self range: (min to: max)!setData	"Create the receiver's data array for the right number of frames."	data := Array new: (sound size / stepSize) truncated.	domain := 0 to: data size!updateRange	"Iterate over the receier's data getting the RMS data range"	| min max off |	min := 1.0e30.  max := -1.0e30.	off := windowSize / 2.	magReal == #real ifTrue:		[data do: 			[ :fr | fr do: 				[ :d | min := d min: min.					max := d max: max]]].	magReal == #complex ifTrue:		[data do: 			[ :fr | 1 to: off do: 				[ :ind | | val |				val :=  ((fr at: ind) squared + (fr at: ind + off) squared) sqrt.					min := val min: min.					max := val max: max]]].	self range: (min to: max)!window: which	"Answer the real data array for the given window of the receiver's sound."	| dArray base sHalf  ind|	dArray := Array new: windowSize.	base := which - 1 * stepSize.		"which is 1-based"	window == #rectangular		ifTrue: [1 to: dArray size do:				[ :i | dArray at: i put: (sound floatSampleAt: (base + i))]].	window == #triangular		ifTrue: [sHalf := dArray size asFloat / 2.0.			1 to: sHalf do:				[ :i | dArray at: i put: ((sound floatSampleAt: (base + i)) * (i asFloat / sHalf))].			1 to: sHalf do:				[ :i | 				ind := i + sHalf.				dArray at: ind put: ((sound floatSampleAt: (base + ind)) * (1 - (i asFloat / sHalf )))]].	^dArray! !!Siren.Spectrum methodsFor: 'initialize-release'!initialize	"Set up the receiver."	super initialize.	window := " #rectangular " #triangular.	windowSize := 256.	stepSize := 1024."	fft := FFT new nu: (windowSize log: 2) truncated."	magReal := #real.			"mag, real, polar, or complex"! !!Siren.Spectrum methodsFor: 'printing'!display	"Display the receiver"	SpectrumView openOn: self!printOn: aStream	"Format and print the receiver on the argument."	aStream nextPutAll: self class name, ' on: '.	sound printOn: aStream.	aStream nextPutAll: (' window: ', windowSize printString, ' step: ', stepSize printString)! !!Siren.Spectrum methodsFor: 'time warp'!interpolateFrame: ind	"Answer a new frame interpolated for the given (floating-point) index."	| bas fra pre nex int |	bas := ind truncated max: 1.	fra := ind fractionPart.	pre := data at: bas.	fra < 0.05 ifTrue: [^pre].	bas = data size ifTrue: [^pre].	nex := data at: bas + 1.	int := pre class new: pre size.	1 to: pre size do:		[ :x | | v0 v1 |		v0 := pre at: x.		v1 := nex at: x.		int at: x put: (v0 + ((v1 - v0) * fra))].	^int!timewarpBy: fact	"Interpolate/decimate the receiver by the given (float or function) time factor."	| siz newD |	fact isNumber ifTrue:		[siz := (data size * fact) truncated.		newD := Array new: siz.		1 to: siz do:			[ :in |			newD at: in put: (self interpolateFrame: (in asFloat / fact))].		data := newD.		^self]				"else fact is a function"! !!Siren.Spectrum class methodsFor: 'examples'!fileExample	"Read a sound from disk and take its fft."	"Spectrum fileExample display"	| me |	me := self new initialize.	me sound: (SampledSound fromFile: (SirenUtility findFile: 'a.snd')).	me windowSize: 1024.	me stepSize: 512.	me real.	me compute.	^me!sweepExample	"Create a swept sine wave and take its fft."	"Spectrum sweepExample display"	| me |	me := self new initialize.	me sound: (SampledSound sweepDur: 1.0 rate: 44100 from: 20 to: 5000 chans: 1).	me windowSize: 1024.	me stepSize: 1024.	me real.	me compute.	^me! !!Siren.ChromaticInterval methodsFor: 'printing'!printOn: s 	s nextPutAll: 'Chromatic ' , semiTones printString! !!Siren.ChromaticInterval class methodsFor: 'creation'!semiTones: x 	"anInterval without type, only chromatic"	^self type: -1 semiTones: x! !!Siren.ChromaticInterval class methodsFor: 'examples'!examples"(N C octave: 3) transposeBySemiTones: 4  ->  E3"! !!Siren.PitchClassDoubleSharp methodsFor: 'testing'!isDoubleSharp	^true! !!Siren.PitchClassDoubleSharp methodsFor: 'printing'!printOn: s 	natural printOn: s.	s nextPutAll: '##'!storeOn: s 	"N C sharp sharp storeString"	s nextPutAll: 'N ' , self natural name , ' sharp sharp'! !!Siren.PitchClassDoubleSharp methodsFor: 'saving'!representBinaryOn: s	^MessageSend receiver: natural selector:  #doubleSharp! !!Siren.PitchClassDoubleSharp methodsFor: 'intervals'!alterate: note toReach: i 	| n |	n := natural alterate: note toReach: i.	^n sharp sharp!alterateBelow: note toReach: i 	| n |	n := natural alterateBelow: note toReach: i.	^n sharp sharp!closestEnharmonic	^self alterate: self following toReach: 0.!semiTonesToNatural	^-2! !!Siren.PitchClassDoubleSharp methodsFor: 'access'!flat	"la methode diese n'est pas definie et provoque donc une erreur"	^natural sharp!semiToneCount	^natural semiToneCount + 2!sharp	"Sorry, I have to do that (Cf. Bluesette) otherwise I can't 	compute possibleTonalities properly ..."	^nil! !!Siren.AnalysisList methodsFor: 'testing'!tonalitesCommunesAvec: l 	| o |	o := Set new.	self do: [:a | l do: [:al | al scale = a scale ifTrue: [o add: a scale]]]. 	^o!tonalitesCommunesAvec: l1 et: l2 	| o |	o := Set new.	self do: [:a | (l1 detect: [:al1 | al1 scale = a scale]			ifNone: [nil]) notNil ifTrue: [(l2 detect: [:al2 | al2 scale = a scale]				ifNone: [nil]) notNil ifTrue: [o add: a scale]]].	^o! !!Siren.AnalysisList class methodsFor: 'examples'!examples"	(FPChord newFromString: 'C  ') possibleTonalitiesInScaleClass:  MajorScale 	AnalysisList ({I de C MajorScale} {IV de G MajorScale} {V de F MajorScale} )"! !!Siren.FloatSound methodsFor: 'sample accessing'!intSampleAt: index	"Answer the sample at the given index as a scaled 16-bit integer."	^((self sampleAt: index) * 32767.0) rounded!intSampleAt: index put: aValue	"Put the given integer sample at the given index after scaling."	self sampleAt: index put: (aValue asFloat / 32767.0)! !!Siren.FloatSound methodsFor: 'accessing'!format	"Return the receiver's format--a symbol constant."	^#float32Bit!sampleSize	"Answer the size in bytes of the receiver's samples (4)."	^4! !!Siren.FloatSound methodsFor: 'private'!privateSampleAt: index	"Answer the sample at the given index."	^data floatAt: (index -1 * 4 + 1)!privateSampleAt: index put: aValue	"Stuff the given sample into the data array at the given index (no checking)."	data floatAt: (index -1 * 4 + 1) put: aValue asFloat! !!Siren.FloatSound class methodsFor: 'class constants'!formatSymbol	"Answer the symbolic code used for the format of the receiver's instances."	^#float32Bit!maxSample	"Answer the maximum value of the receiver class."	^1.0!minSample	"Answer the minimum value of the receiver class."	^-1.0! !!Siren.FloatSound class methodsFor: 'examples'!fileExample	"Answer a typical float sound read in from a file."	"SoundView openOn: FloatSound fileExample"	^FloatSound fromFile: 'snd/new/orchestra.f.snd'! !!Siren.EditorModel methodsFor: 'accessing'!copyBuffer	"Answer the receiver's copybuffer"	^copyBuffer!copyBuffer: anObject	"Set the receiver's copybuffer"	copyBuffer := anObject!select: sel	"Set the receiver's selection.""	sel == nil ifTrue: [Transcript show: 'clear'; cr]."	selections := sel.	self changed: #selection with: sel!selection	"Answer the receiver's selection."	^selections!view: aView	"Assign into the receiver's view instVar"	view := aView! !!Siren.DisplayListEditor methodsFor: 'editing'!doDisplay	"inspect button"	self changed!doEdit	"edit button"	self doInspect!doFile	"file i/o button"	Transcript show: 'No File.'; cr.!doInspect	"Inspect the editor (if shiftDown) or the model."	InputState default shiftDown		ifTrue: [self inspect]		ifFalse: [list inspect]!doZoom	"zoom button"! !!Siren.DisplayListEditor methodsFor: 'accessing'!displayList	"Answer the receiver's list."	^list!list	"Answer the receiver's list."	^list!list: aList	"Set the receiver's list, removing the dependency to the former list if necessary."	list == nil		ifFalse: [list removeDependent: self].	list := aList.	list addDependent: self!moveSelectionTo: newPoint	"Move the editor's selection to the new point in the list."	| oldOff |	selections hasItems		ifFalse: [oldOff := selections offset.			selections offset: newPoint.			self changed": #position with: (oldOff corner: newPoint)"]		ifTrue: [selections components do: [ : i | list remove: i].			selections offset: newPoint.			list add: selections.			self changed]! !!Siren.DisplayListEditor methodsFor: 'updating'!update: anAspect with: anArg from: aModel	"Echo the model's changes, assuming a view is a dependent of the receiver."	self changed: anAspect with: anArg! !!Siren.DisplayListEditor methodsFor: 'initialize-release'!release	"Remove the dependency to the list."	list removeDependent: self.	list release! !!Siren.DisplayListEditor class methodsFor: 'instance creation'!on: model	^self new list: model! !!Siren.EventListEditor methodsFor: 'initialize-release'!release	"Release the receiver's list."	eventList removeDependent: self.	list removeDependent: self.	list release! !!Siren.EventListEditor methodsFor: 'accessing'!ampl	"Answer the amplitude of the default event."	^defaultEvent == nil		ifTrue: [0]		ifFalse: [defaultEvent  loudness value]!ampl: newValue	"Set the amplitude of the default event."	defaultEvent == nil		ifTrue: [^self].	defaultEvent loudness: newValue asInteger.	self changed: #ampl!defaultEvent	"Answer the receiver's default event."	^defaultEvent == nil		ifTrue: [list defaultEventClass new]		ifFalse: [defaultEvent]!defaultEvent: anEvent	"Set the receiver's default event."	defaultEvent := anEvent!displayList	"Answer nil."	^nil!eventList	"Answer the receiver's subject eventList."	^eventList!eventList: anEL	"Set the given EventList as the receiver's model."	eventList := anEL.	defaultEvent := eventList defaultEventClass new.	anEL addDependent: self.	self changed: #list!items	"Answer the subject eventList's events."	^eventList events! !!Siren.EventListEditor methodsFor: 'links and groups'!group: events	"Group the event list argument within the receiver's list."	list group: events.	self changed: #events!link: anEvent with: anOtherEvent	"Set up a link between the two events or lists."	^self!select: anAorEL	"Add the given association to the list of selected items."	| mo |	anAorEL == nil		ifTrue: [^selections := nil].	mo := anAorEL isEvent		ifTrue: [anAorEL]		ifFalse: [anAorEL model].	mo hasItems		ifTrue: [selections := mo]		ifFalse: [selections == nil				ifTrue: [selections := EventList newNamed: EventList nextName ].			selections add: mo]! !!Siren.EventListEditor methodsFor: 'list access'!add: anAss	"Add the given EventAssociation to the model list."	list add: anAss.	self changed: #added.!doInspect	"Inspect the receiver's list."	InputState default shiftDown		ifTrue: [self inspect]		ifFalse: [list inspect]!eraseList	"Flush the receiver's list."	list empty.	self changed: #deleted.!play	"Play the receiver's eventList.""	Sensor leftShiftDown 		ifTrue: [self startStop]		ifFalse: [list play]"	eventList play!remove: anEvent	"Remove the given event from the receiver's list""	Transcript show: 'remove: ', anEvent printString; cr."	list remove: anEvent.	self changed: #deleted.!startStop	"If not playing, create ostinato and start; if playing, stop and release."	ostinato == nil		ifTrue: [ostinato := Ostinato onList: list.				[ostinato play]]		ifFalse: [ostinato stop.				ostinato := nil]! !!Siren.DisplayItem methodsFor: 'transforming'!asVisualComponent	"Answer an encapsulated version of the receiver which understands	VisualComponent protocol."	^TranslatingWrapper on: self!scaleBy: aPoint	"Translate the receiver's offset by the argument."	self extent: self extent * aPoint!scaledBy: aPoint	"Translate the receiver's offset by the argument."	^self copy extent: self extent * aPoint!translateBy: aPoint	"Translate the receiver's offset by the argument."	self offset: self offset + aPoint! !!Siren.DisplayItem methodsFor: 'accessing'!color	"Answer the receiver's display color."	^color!color: aVal	"Set the receiver's display color to the argument."	color := ((aVal isMemberOf: BlockClosure)		ifTrue: [aVal value]		ifFalse: [aVal])!container: aContainer	"Set the receiver's container to be aContainer."	container := aContainer.!extent	"Answer the extent of the receiver (dummy in this class)."	^1@1!extent: aPoint	"Ignored"!offset	"Answer the receiver's offset."	^offset!offset: aPoint	"Set the receiver's offset to the argument."	offset := aPoint! !!Siren.DisplayItem methodsFor: 'copying'!copy	"Answer a shallow copy of the receiver."	^self shallowCopy! !!Siren.DisplayItem methodsFor: 'testing'!isDisplayItem	"Answer whether the receiver is a kind of DisplayItem"	^true! !!Siren.DisplayItem methodsFor: 'displaying'!displayOn: aGraphicsContext	"Display the receiver on the argument."	self subclassResponsibility!displayPostScriptOn: aPostScriptContext	"Display the receiver on the argument in PostScript."	self subclassResponsibility! !!Siren.DisplayItem methodsFor: 'bounds accessing'!computePreferredBounds	"Answer the receiver's bounds--hack."	^self bounds!preferredBounds	"Answer the receiver's bounds--hack."	^self bounds!preferredExtent	^self preferredBounds extent! !!Siren.DisplayItem methodsFor: 'initialize-release'!initialize	"Initialize the instance variables of the receiver."	offset := 0@0! !!Siren.DisplayItem methodsFor: 'printing'!printCompleteOn: aStream depth: depth	"Print the receiver in the given Stream."	aStream cr.	depth timesRepeat: [aStream tab].	aStream nextPutAll: '(a ', self class name. 	model == nil ifFalse: [aStream nextPutAll: ' model: '. model printOn: aStream].	offset == nil ifFalse: [aStream nextPutAll: ' offset: '. offset printOn: aStream].	aStream nextPut: $).!printOn: aStream	"Print the receiver in the given Stream."	aStream nextPutAll: '(a ', self class name. 	model == nil ifFalse: [aStream nextPutAll: ' model: '. model printOn: aStream].	offset == nil ifFalse: [aStream nextPutAll: ' offset: '. offset printOn: aStream].	aStream nextPut: $); cr.! !!Siren.DisplayItem class methodsFor: 'instance creation'!model: aM offset: aPt	"Answer an instance of DisplayItem with the given instance variables."	^self new model: aM; offset: aPt!offset: aPt	"Answer an instance of DisplayItem with the given instance variables."	^self new offset: aPt! !!Siren.DisplayLine methodsFor: 'accessing'!corner: aPoint	"Set the corner of the receiver (offset + extent)."	offset == nil		ifFalse: [extent := aPoint - offset]."	end := (offset == nil			ifTrue: [aPoint]			ifFalse: [start + aPoint])."	^self!extent	"Answer the extent of the receiver."	^extent!extent: aPoint	"Set the extent of the receiver."	extent := aPoint"	end := (offset == nil			ifTrue: [aPoint]			ifFalse: [start + aPoint])"!width: aVal	width := aVal! !!Siren.DisplayLine methodsFor: 'printing'!printOn: aStream	"Print the receiver in the given Stream."	aStream nextPutAll: ' (a ', self class name. 	model == nil ifFalse: [aStream nextPutAll: ' model: '. model printOn: aStream].	offset == nil ifFalse: [aStream nextPutAll: ' offset: '. offset printOn: aStream].	extent == nil ifFalse: [aStream nextPutAll: ' extent: '. extent printOn: aStream]."	color == nil ifFalse: [aStream nextPutAll: ' color: '. color printOn: aStream]."	aStream nextPut: $); cr.! !!Siren.DisplayLine methodsFor: 'displaying'!displayOn: aGraphicsContext	"Display a line between startPoint and endPoint.""	Transcript show: start printString, '	', end printString; cr."	color == nil		ifFalse: [aGraphicsContext paint: color].	width == nil		ifFalse: [aGraphicsContext lineWidth: width].	aGraphicsContext displayLineFrom: offset to: (offset + extent)!displayPostScriptOn: aPostscriptContext	"Display the receiver on the argument as a PostScript item."	aPostscriptContext translate: offset.	aPostscriptContext rlineto: extent	.	aPostscriptContext translate: offset negated.! !!Siren.DisplayLine methodsFor: 'bounds accessing'!bounds	"Answer the receiver's bounds." 	^offset extent: ((extent x max: 1) @ (extent y max: 1))! !!Siren.DisplayLine class methodsFor: 'instance creation'!from: oPoint to: endPoint	"Answer an initialized instance."	^((self new) offset: oPoint) extent: (endPoint - oPoint)!offset: oPoint extent: ePoint		"Answer an initialized instance."	^((self new) offset: oPoint) extent: ePoint! !!Siren.Peal methodsFor: 'accessing'!at: index	"Answer the element in the base collection currently mapped into the index position."	^ base at: (self basicAt: index)!at: index put: object	^ self error: 'Can''t modify a peal by at:put:'!currentChange	"Answer the base as mapped by the current change."	^(1 to: self size) collect: [ :i  | self at: i ]!finished	"Answer is the peal has completed it's last change"	^ finished!setBase: baseSet	"Initialize the base set and everything else."	base := baseSet.	directions := Array new: self size withAll: 1.	position := 1.	1 to: self size do: [:i | self basicAt: i put: i].	finished := false.!size	"Redone here because SequencableCollection overrides it."	^ self basicSize! !!Siren.Peal methodsFor: 'playing'!eventList	| list |	list := EventList new.	self playOn: list durations: 125 meter: 125 at: 0.	^list!play	self eventList play!playOn0: out durations: dur meter: mtr at: start	"Play the receiver"	| time siz |	time := start.	siz := self size.	[finished] whileFalse:		[1 to: siz do: 			[ :i | out play: (self at: i) at: time dur: dur amp: 100. 				time := time + mtr ].		self change.		1 to: siz - 1 do: 			[ :i | out play: (self at: i) at: time dur: dur amp: 100. 				time := time + mtr ].		out play: (self at: siz ) at: time dur: dur + mtr amp: 100.  				time := time + mtr + mtr.		self change].	1 to: siz do: 			[ :i | out play: (self at: i) at: time dur: dur amp: 100. 				time := time + mtr ].!playOn: vox	self eventList playOn: vox!playOn: out durations: dur meter: mtr at: start	"Play the receiver"	| time siz |	time := start.	siz := self size.	[finished] whileFalse:		[1 to: siz do: 			[ :i | out add: time => ((self at: i) note, dur msec, 100 velocity). 				time := time + mtr].		self change.		1 to: siz - 1 do: 			[ :i | out add: time => ((self at: i) note, dur msec, 100 velocity). 				time := time + mtr].		out add: time => ((self at: siz) note, (dur + mtr) msec, 100 velocity).  				time := time + mtr + mtr.		self change].	1 to: siz do: 			[ :i | out add: time => ((self at: i) note, dur msec, 100 velocity). 				time := time + mtr].! !!Siren.Peal methodsFor: 'changing'!change	"Produce the next change in the peal"	self changeOrder: 1 bounds: (1 to: self size)! !!Siren.Peal methodsFor: 'private'!changeOrder: n bounds: range	"Produce the next change in the peal by moving the element n within the range.  If the element wants to move outside the range, alter it's direction and move the next element (recursively call this)."	| neighbor location |	location := self indexOfElement: n.	neighbor := location + (directions at: n).	(n = self size) ifTrue:		[(n = 1) ifFalse:			[self swap: location with: neighbor.			directions at: n-1 put: (directions at: n-1) negated].		finished := true.		^ self].	(range includes: neighbor) ifTrue:		[self swap: location with: neighbor]	ifFalse:		[directions at: n put: (directions at: n ) negated.		self changeOrder: n+1 bounds: (range copyWithout: location)]!indexOfElement: n	"Answer the index the anElement item  (i.e. the n-th item, not the item = to n) within the receiver."	1 to: self size do:		[:i | (self basicAt: i) = n ifTrue: [^ i]].	^ self error: 'An element does not exist in this peal'!swap: index1 with: index2	"We need to redefine this, since we redefined at: & at:put: to map trhrough the base collection"	| temp |	temp := self basicAt: index1.	self basicAt: index1 put: (self basicAt: index2).	self basicAt: index2 put: temp! !!Siren.Peal class methodsFor: 'examples'!pealExample1	"Play a simple bell peal"	"Peal pealExample1"	(Peal upon: #(60 62 64 65)) eventList edit.! !!Siren.Peal class methodsFor: 'instance creation'!new: size	"Create a new peal on the given size with 1..size as the base set."	| newPeal |	newPeal := self basicNew: size.	newPeal setBase: (1 to: size).	^ newPeal!upon: baseSet	"Create a new peal on the base set given"	| newPeal |	newPeal := self basicNew: baseSet size.	newPeal setBase: baseSet.	^ newPeal! !!Siren.FunctionEvent methodsFor: 'events'!playOn: aVoice at: aTime	"Play the receiver on the voice then."	aVoice isVoice		ifTrue: [aVoice playEvent: self at: aTime].	(SirenSession voices includesKey: aVoice)			ifTrue: [^(SirenSession voices at: aVoice) playEvent: self at: aTime].	aVoice isInteger			ifTrue: [Voice default playEvent: self at: aTime]! !!Siren.FunctionEvent methodsFor: 'accessing'!delta	^delta!delta: aValue	delta := aValue!function	^function!function: aFcn	function := aFcn.	self duration: aFcn duration.!interval	^interval!interval: aValue	interval := aValue!value	"Answer the receiver's data value"	| realIndex |	startedAt ifNil:		[index := 0.		startedAt := Time microsecondClock].	realTime		ifTrue: [realIndex := (Time microsecondClock - startedAt) / 1000000]		ifFalse: [realIndex := index].	^function atX: realIndex! !!Siren.FunctionEvent methodsFor: 'scheduling'!nextTime: now	"Answer the next time to reschedule me"	interval ifNotNil:		[^now + interval asUsec value].	delta ifNotNil:		[^now + (function nextXMoreThan: delta from: index)]!play	"Play the event list by passing it off to the event scheduler."	EventScheduler instance addClient: self in: 1 msec.	EventScheduler instance run!scheduleAt: aTime 	"Expand an eventList for the appointment scheduler."	| aVoice next |	aVoice := self voice.	startedAt ifNil:		[index := 0.		startedAt := Time microsecondClock].	aVoice isVoice		ifTrue: [aVoice playEvent: self at: aTime]		ifFalse: [(SirenSession voices includesKey: aVoice)			ifTrue: [(SirenSession voices at: aVoice) playEvent: self at: aTime]			ifFalse: [aVoice isInteger				ifTrue: [Voice default playEvent: self at: aTime]]].	next := self nextTime: aTime.	realTime		ifTrue: [((Time microsecondClock - startedAt) / 1000000) > function duration			ifTrue: [index := 0. ^nil]]		ifFalse: [index := index + 1.			index > function size				ifTrue: [index := 0. ^nil]].	^next			   "answer the time of the next appointment"! !!Siren.FunctionEvent class methodsFor: 'instance creation'!new	"Create and answer a new instance of me"	^super new initialize! !!Siren.DisplayRectangle methodsFor: 'displaying'!displayOn: aGraphicsContext	"Display a line between startPoint and endPoint.""	Transcript show: start printString, '	', end printString; cr."	color == nil		ifFalse: [aGraphicsContext paint: color].	(fill == nil or: [fill not])		ifFalse: [aGraphicsContext displayRectangle: (offset extent: extent)]		ifTrue: [aGraphicsContext displayRectangularBorder: (offset extent: extent)]!displayPostScriptOn: aPostscriptContext	"Display the receiver on the argument as a PostScript item."	aPostscriptContext translate: offset.	aPostscriptContext box: extent y width: extent x.	aPostscriptContext translate: offset negated.! !!Siren.DisplayRectangle methodsFor: 'accessing'!fill: aBoolean	"Set the receiver's filling Boolean."	fill := aBoolean!stroke: aNum	"Set the receiver's stroke line thickness."	stroke := aNum! !!Siren.DisplayRectangle class methodsFor: 'examples'!rectangleExample	"Open a display list view with randomly-placed random-color rectangles over the given extent."	"DisplayRectangle rectangleExample"	(DisplayList rectanglesX: 600 byY: 600) display! !!Siren.DisplayPolyline methodsFor: 'transforming'!scaledBy: aPoint	"Scale all the receiver's points by the argument; answer a copy."	|  newPts |	newPts := vertices collect: [ :pt | (pt * aPoint) truncated].	^self class offset: offset vertices: newPts! !!Siren.DisplayPolyline methodsFor: 'accessing'!bounds	"Answer the receiver's bounds." 	| ext |	ext := 0@0.	vertices do: [ :pt | ext := ext max: pt].	^offset extent: ext!extent	"Answer the receiver's extent." 	^self bounds extent!vertices: pointArray	"Set the receiver's vertices."	vertices := pointArray asArray! !!Siren.DisplayPolyline methodsFor: 'displaying'!displayOn: aGraphicsContext	"Stroke the receiver's edges on the supplied GraphicsContext."	| cachedLW |	color == nil		ifTrue: [aGraphicsContext paint: ColorValue black]		ifFalse: [aGraphicsContext paint: ColorValue black].	stroke == nil		ifFalse: [cachedLW := aGraphicsContext lineWidth.			aGraphicsContext lineWidth: stroke].	offset == nil		ifFalse: [aGraphicsContext translateBy: offset].	(fill == true)		ifFalse: [aGraphicsContext displayPolyline: vertices at: Point zero]		ifTrue: [aGraphicsContext displayPolygon: vertices at: Point zero].	offset == nil		ifFalse: [aGraphicsContext translateBy: offset negated].	stroke == nil		ifFalse: [aGraphicsContext lineWidth: cachedLW].! !!Siren.DisplayPolyline class methodsFor: 'examples'!polylineExample	"Open a display list view with randomly-placed random-color polylines over the given extent."	"DisplayPolyline polylineExample"	(DisplayList polylinesX: 600 byY: 600) display! !!Siren.DisplayPolyline class methodsFor: 'instance creation'!offset: offPt vertices: arrayOfPoints	"Answer a new DisplayPolyline with the arguments as its vertices."	^self basicNew offset: offPt; vertices: arrayOfPoints!vertices: arrayOfPoints	"Answer a new DisplayPolyline with the arguments as its vertices."	^self basicNew vertices: arrayOfPoints! !!Siren.EventListPanel methodsFor: 'accessing'!editorView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^editorView isNil		ifTrue:			[editorView := Siren.EventListDialog new]		ifFalse:			[editorView]!scoreView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^scoreView isNil		ifTrue:			[scoreView := ScoreView new]		ifFalse:			[scoreView]!textView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textView isNil		ifTrue:			[textView := Siren.EventListText new]		ifFalse:			[textView]! !!Siren.PitchClassNatural methodsFor: 'accessing'!flat	^flat!flat: value	flat := value!name	^name!name: x 	name := x!natural	^self!nom	^nom!nom: value	nom := value!sharp	^sharp!sharp: value	sharp := value! !!Siren.PitchClassNatural methodsFor: 'printing'!nameIs: aSymbol 	name = aSymbol ifTrue: [^true].	^nom = aSymbol!printOn: s 	s nextPutAll: (English			ifTrue: [name]			ifFalse: [nom])! !!Siren.PitchClassNatural methodsFor: 'saving'!representBinaryOn: s	^MessageSend receiver: self class selector:  name! !!Siren.PitchClassNatural methodsFor: 'intervals'!alterate: note toReach: i	"Join semitons to note in order to obtain the required number of semitones with self" 	| delta |	delta := (self  semiTonesWithNaturalNote: note) - i.	delta := ((delta + 6) \\ 12) -6.	delta = 0 ifTrue: [^note].	delta = 1 ifTrue: [^note flat].	delta = -1 ifTrue: [^note sharp].	delta = 2 ifTrue: [^note flat flat].	delta = -2 ifTrue: [^note sharp sharp].	delta = 3 ifTrue: [^note flat flat flat].	"to deal with cases like N B flat flat augmentedOctave"	delta = -3 ifTrue: [^note sharp sharp sharp].	^self error: 'illegal interval !!'!alterateBelow: note toReach: i	"Join semitons to note in order to obtain the required number of semitones with self" 	| delta |	delta := (self  semiTonesWithNaturalNoteBelow: note) - i.	delta := ((delta + 6) \\ 12) -6.	delta = 0 ifTrue: [^note].	delta = -1 ifTrue: [^note flat].	delta = 1 ifTrue: [^note sharp].	delta = -2 ifTrue: [^note flat flat].	delta = 2 ifTrue: [^note sharp sharp].	delta = -3 ifTrue: [^note flat flat flat].	"to deal with cases like N B flat flat augmentedOctave"	delta = 3 ifTrue: [^note sharp sharp sharp].	^self error: 'illegal interval !!'!closestEnharmonic	^self!semiTonesToNatural	^0!semiTonesWithNaturalNote: aNote 	"number of semitones between self and aNote"	| r |	r := aNote semiToneCount - semiToneCount.	"^r + 6 \\ 12 - 6"	^r \\ 12!semiTonesWithNaturalNoteBelow: aNote 	"number of semitones between aNote and self"	| r |	r :=  semiToneCount - aNote semiToneCount .	"^r + 6 \\ 12 - 6"	^r \\ 12! !!Siren.PitchClassNatural methodsFor: 'private-accessing'!following	^following!following: value	following := value!preceding	^preceding!preceding: value	preceding := value!semiToneCount	^semiToneCount!semiToneCount: s	semiToneCount := s! !!Siren.SoundView methodsFor: 'accessing'!bounds: aRectangle	"Set the receiver's bounds."	super bounds: aRectangle.	extent := aRectangle extent."	Transcript show: 'SndView size: ', extent printString; cr.""	self setPixmap.""	self invalidate"!markerColor	"Answer the color for selection markers."	^ColorValue blue!preferredBounds	"Answer the extent of the receiver's display object bounding box.""	Transcript show: (self model size / self step) printString; cr."	^self step = 0		ifTrue: [0@0 extent: (self model size @ 300)]		ifFalse: [0@0 extent: ((self model size / self step) @ 300)]!scale	"Return the vertical scale."	^ zoom y!scale: theScale	"Accept the argument, 'theScale', as the new instance variable 'scale'."	zoom y: theScale.!sound	"Answer the model's sound."	^model sound!sound: aSound	"Set the model's sound."	model sound: aSound.	model view: self."	step > 0		ifTrue: [width := (((aSound size / step) truncated) min: 16384) max: 512.		Transcript show: 'width: ', width printString; cr.		pixmap := Pixmap extent: (width @ 180)].	self redraw.	self changed: #text.	self changedPreferredBounds: nil."	self changed!step	"Return the horizontal sample-per-pixel scale"	^ zoom x!step: theStep	"Accept the argument, 'theStep', as the new instance variable 'step'."	zoom x: theStep.!text	"Answer the default display text for the receiver's sound."	| stream snd |	stream := WriteStream on: (String new: 64).	snd := self sound.	stream nextPutAll: 'rate: ', snd rate printString; cr.	stream nextPutAll: 'fmt: ', snd format; cr.	snd duration == nil		ifFalse: [stream nextPutAll: 'dur: ', 						((self sound duration asSec value printString) clipTo: 4); cr].	stream nextPutAll: 'samps: ', snd size rounded printString; cr.	((snd at: #comment) == nil)		ifFalse: [stream nextPutAll: 'cmnt: ', (snd at: #comment); cr].	^stream contents!viewExtent	"Answer the extent of the receiver's display object bounding box."	^extent! !!Siren.SoundView methodsFor: 'controller access'!defaultControllerClass	"Answer the default controller class for use with the receiver."	^SoundController! !!Siren.SoundView methodsFor: 'private'!scrollableExtent	"Answer the extent of the receiver's display object bounding box."	Transcript show: 'SndView scr extent: ', (self model size / zoom x) printString; cr.	^(self model size / zoom x) @ 1!visibleExtent	"Answer the extent of the receiver's clipping box."	Transcript show: 'SndView vis extent: ', 			((self bounds extent truncateTo: scrollOffset grid) max: scrollOffset grid) printString; cr.	^(self bounds extent truncateTo: scrollOffset grid) max: scrollOffset grid! !!Siren.SoundView methodsFor: 'displaying'!displayMarkersOn: aGC	"Show the selections (up to 2 markers) in the current sound"	| y1 blok srcX |	model == nil ifTrue: [^self].	aGC paint: self markerColor.	srcX := aGC clippingBounds left.	y1 := extent y.	model markers do: [ :sel |			self showMarkerAt: (self xForSample: sel)].	blok :=  [ :xVal | xVal ifNotNil: 					[Cursor caret displayOn: aGC 							at: (((self xForSample: xVal)- 8 + srcX)@ (y1 - 8))]].	blok value: model selection1.	blok value: model selection2.!displayOn: aGraphicsContext	"Display the receiver's sound on the argument"	self displayOnGC: aGraphicsContext.	self displayMarkersOn: aGraphicsContext"	pixmap == nil		ifFalse: [redrawn == nil				ifTrue: [self displayOnGC: pixmap graphicsContext].			pixmap displayOn: aGraphicsContext]		ifTrue: [self displayOnGC: aGraphicsContext]"!displayOnGC: aGC	"Show the receiver's sound on the GC."	| sound box centerY scaledScale setPoint value index oldPt ssize offsetIndex scaledStep |	redrawn := true.	box := aGC clippingBounds.	aGC paint: self backgroundColor.	aGC displayRectangle: box.	aGC paint: self foregroundColor.	centerY := extent y asFloat / 2.	model ifNil: [^self].	sound := self sound.	sound ifNil: [^self].	ssize := sound size.	scaledScale := (sound class maxSample / zoom y) asInteger.	scaledStep := zoom x asInteger.	scaledStep = 0 ifTrue: [scaledStep := sound size asFloat / box width]."Calculate the left-most sample and position"	setPoint := box left.	offsetIndex := setPoint * scaledStep + 1.	value := (sound sampleAt: (offsetIndex max: 1)) // scaledScale.	value := ((centerY - value) ) "min: box height - 1) max: 0".	oldPt := setPoint @ value truncated."Loop for the samples in the to-be-displayed region"	0 to: box width do:		[ :counter | | pt |		index := (counter * scaledStep) + offsetIndex.		index > ssize ifTrue: [^self]. 		value := (sound sampleAt: index) // scaledScale.		value := ((centerY - value) ) "min: box height - 1) max: 0".		pt := (setPoint + counter) @ (value asInteger).		aGC displayLineFrom: oldPt to: pt.		oldPt := pt]!displayPosition: pos	"Display the mouse pos in the corner of my display"	| gc srcpos scaledStep value time sound index box |	gc := self graphicsContext.	box := gc clippingBounds.	srcpos := box left + 4@12.	sound := self sound.	sound ifNil: [^self].	scaledStep := zoom x asInteger.	index := pos x * scaledStep.	value := sound sampleAt: index.	time := index asFloat / sound rate.	gc paint: DisplayListView backgroundColor.	gc displayRectangle: (srcpos - (0 @ 20) extent: 100@24).	gc paint: DisplayListView foregroundColor.	((time printString: 3), '@', value printString) displayOn: gc at: srcpos!invalidate	"Redisplay the receiver's sound"	redrawn := nil.	self displayOn: self graphicsContext.	super invalidate!redraw	"Redisplay the receiver's sound"	self invalidate! !!Siren.SoundView methodsFor: 'selection'!eraseMarkerAt: xValue	"take a mouse point and place a marker on the sound sample there""	| pGC p1 p2 box x |	x := xValue.	pGC := pixmap graphicsContext.	box := pGC clippingBounds.	p1 := x @ box top.	p2 := x @ box bottom.	pGC displayLineFrom: p1 to: p2.	pixmap displayOn: self graphicsContext."!selectBetween: startValue and: stopValue	"take a mouse region and place a marker on the sound sample there"	| pGC p1 p2 box |	(startValue = stopValue) ifTrue: [^self].	pGC := pixmap graphicsContext.	pGC paint: ColorValue lightGray.	box := pGC clippingBounds.	p1 := startValue @ box top + 4.	p2 := stopValue @ box bottom - 4.	pGC displayRectangularBorder: (p1 corner: p2).	pixmap displayOn: self graphicsContext!showMarkerAt: xValue	"take a mouse point and place a marker on the sound sample there"	| gc p1 p2 box theX |	theX := self graphicsContext clippingBounds left + xValue.	gc := self graphicsContext.	box := gc clippingBounds.	gc paint: ColorValue blue.	box := gc clippingBounds.	p1 := theX @ box top.	p2 := theX @ box bottom.	gc displayLineFrom: p1 to: p2! !!Siren.SoundView methodsFor: 'converting indeces'!sampleForX: xValue	"Answer the sample under the point with x = xValue."	^xValue - self class inset x * zoom x!xForSample: sample	"Answer the xValue of the sample with the given index."	^self step = 0		ifTrue: [sample + scrollOffset value x]		ifFalse: [sample / self step + scrollOffset value x]! !!Siren.SoundView methodsFor: 'initialize-release'!initialize	"Set up the proper default values for the receiver."	super initialize.	foregroundColor := ColorValue darkGray.	zoom := 30 @ 100.		"step @ scale""	pixmap := Pixmap extent: (3000@400).	extent := pixmap extent."! !!Siren.SoundView class methodsFor: 'examples'!example1	"Open a sound view on the example sound file."	"SoundView example1"	SoundView openOn: (SampledSound sweepExample)!example2	"Open a sound view on the a sound from a file."	"SoundView example2"	SoundView openOn: (SampledSound fromFile: 'kombination.snd')!exampleLong	"Open a sound view on the a sound from a file."	"SoundView exampleLong"	SoundView openOn: (SampledSound fromFile: 'FourMagicSentences.aiff')!exampleRamp	"Open a sound view on the a sound with a slow ramp."	"SoundView exampleRamp"	SoundView openOn: (SampledSound sawtoothDur: 2.0 rate: 22050 freq: 1 chans: 1)! !!Siren.SoundView class methodsFor: 'instance creation'!componentOnSound: aSound	"Answer a DLView for use as a component."	"SoundView openOn: (SampledSound fromFile: 'a.snd')"	| container me wrapper dled |	container := CompositePart new.	dled := SoundEditor new sound: aSound.	me := self on: dled.	wrapper := LookPreferences edgeDecorator on: me.	wrapper useHorizontalScrollBar; noMenuBar.	container add: wrapper in: (0@0 extent: 1.0@1.0).	^container!componentOnSoundNoFrills: aSound	"Answer a DLView for use as a component."	"SoundCanvas openOn: (SampledSound fromFile: 'a.snd')"	| container me dled |	container := CompositePart new.	dled := SoundEditor new sound: aSound.	me := self on: dled.	container add: me in: (0@0 extent: 1.0@1.0).	^container!openOn: aSound	"Take the sound as model and open a SoundView"	"SoundView openOn: (SampledSound fromFile: 'kombination.snd')"	| topView topWindow |	topView := (self soundViewOn: aSound) components first.	topWindow := (ScheduledWindow model: aSound			label: ('Sound View on: ', aSound name)			minimumSize: 500@300)			maximumSize: 1200@500.	topWindow component: topView.	topWindow icon: (Icon constantNamed: #systemBrowser).	topWindow openWithExtent: topWindow minimumSize!soundViewOn: aSound	"Take the sound as model and open a SoundView"	"SoundView openOn: (SampledSound fromFile: 'kombination.snd')"	"SoundView openOn: (SampledSound sweepExample)"	| topView me editor edgeDecorator |	topView := CompositePart new.	me := self new initialize.	editor := SoundEditor new sound: aSound.	me model: editor.	editor view: me."SoundView"	edgeDecorator := LookPreferences edgeDecorator on: me.	edgeDecorator noVerticalScrollBar; useHorizontalScrollBar; noMenuBar.	topView add: edgeDecorator			in: (LayoutFrame new leftFraction: 0; topFraction: 0; rightFraction: 1; bottomFraction: 1).	^topView! !!Siren.ConditionalDuration methodsFor: 'updating'!update: anAspect with: aValue	"Respond to a change in the receiver's model"	anAspect == #value		ifTrue: []! !!Siren.ConditionalDuration methodsFor: 'accessing'!valueAt: anArg	"Answer the result of passing the argument to the receiver's block."	^value value: anArg!wait	"Cycle the receiver until the argument fulfills the receiver's block."	^self waitUntil: []!waitUntil: anArg	"Cycle the receiver until the argument fulfills the receiver's block."	[value value: anArg value] 		whileFalse: ["Processor yield" (Delay forMilliseconds: 10) wait]! !!Siren.ConditionalDuration methodsFor: 'arithmetic'!* aValue	"Answer that it is an error to attempt arithmetic with this magnitude."	^self error: 'Arithmetic is undefined for this receiver.'!+ aDuration	"Answer the sum of the receiver and the argument--the composition of two blocks"	| block |	^aDuration class == self class 		ifTrue: [block _ aDuration value.			self class new value:					[ :a | (value value: a) and: [block value: a]]]		ifFalse: [block := aDuration value.			self class new value:					[ :a | (value value: a) and: [a > block]]]!- aValue	"Answer that it is an error to attempt arithmetic with this magnitude."	^self error: 'Arithmetic is undefined for this receiver.'!/ aValue	"Answer that it is an error to attempt arithmetic with this magnitude."	^self error: 'Arithmetic is undefined for this receiver.'! !!Siren.ConditionalDuration methodsFor: 'converting'!mostGeneral	"It is an error to try this here--we implement what's ok for CDs"	^self error: 'Arithmetic is not possible with conditional durations.'! !!Siren.ConditionalDuration methodsFor: 'private'!species	"Answer Duration."	^Duration! !!Siren.ConditionalDuration class methodsFor: 'instance creation'!on: aModel until: boolBlock	"Answer a new conditional duration whose value is the given block"	"ConditionalDuration until: [ :x | x > 5]"	| me |	me := ConditionalDuration value: boolBlock.	aModel addDependent: me!randomBetween: lo and: hi	"Answer a new conditional duration whose value is between lo and hi (given in seconds)"	| t val |	val := ((Random new nextFrom: lo to: hi) * 1000000) truncated.	t := Time microsecondClock.		^ConditionalDuration value: [ :x | Time microsecondClock > (t + val)].!until: boolBlock	"Answer a new conditional duration whose value is the given block"	"ConditionalDuration until: [ :x | x > 5]"	^ConditionalDuration value: boolBlock! !!Siren.ConditionalDuration class methodsFor: 'examples'!example	"Print a simple message to the transcript demonstrating the various types."	"ConditionalDuration example"	| t0 t me |	t0 := Time microsecondClock.		"get the time"					"make a duration 'until the argument is > 3000000'"	me := ConditionalDuration value: [ :x | x > 3000000].	Transcript cr; show: t0 printString; cr.					"use it to wait 3000000 usec."	me waitUntil: [Time microsecondClock - t0].	t := Time microsecondClock.		Transcript show: (t - t0) printString; cr.					"make a duration 'until 3 seconds from now'"	me := ConditionalDuration value: [ :x | Time microsecondClock > (t + 3000000)].					"wait it out."	me waitUntil: [].	t := Time microsecondClock.		Transcript show: (t - t0) printString; cr.	me inspect!exampleWithRands	"Demonstrate the random duration"	"ConditionalDuration exampleWithRands"	| t0 t me |	5 timesRepeat:		[me := ConditionalDuration randomBetween: 0.25 and: 0.75.		t0 := Time microsecondClock.		"get the time"		me wait.		t := Time microsecondClock.			Transcript show: ((t - t0) / 1000) truncated printString; cr.]! !!Siren.Signature methodsFor: 'tonality'!tonality	(sharps isEmpty not and: [flats isEmpty not])		ifTrue: [^self error: 'tonality is difficult to compute'].	(sharps isEmpty and: [flats isEmpty])		ifTrue: [^N C majorScale].	flats isEmpty ifTrue: [^self sharpsInRightOrder			ifTrue: [sharps last natural following majorScale]			ifFalse: [self error: 'tonality is difficult to compute']].	sharps isEmpty ifTrue: [^self flatsInRightOrder			ifTrue: [flats size = 1					ifTrue: [^N F majorScale]					ifFalse: [(flats at: flats size - 1) majorScale]]			ifFalse: [self error: 'tonality is difficult to compute']]! !!Siren.Signature methodsFor: 'printing'!printOn: s	s nextPutAll: sharps size printString,' sharps; ',flats size printString,' flats'!storeOn: s 	self isLegal ifTrue: [^s nextPutAll: 'Signature fromTonality: ' , self tonality root storeString , ' majorScale'].	s nextPutAll: 'Signature sharps: ' , sharps storeString , ' flats: ' , flats storeString! !!Siren.Signature methodsFor: 'testing'!flatsInRightOrder	| allFlats |	allFlats := PitchClass flatOrdering.	1 to: flats size do: [:i | (flats at: i) natural = (allFlats at: i) natural ifFalse: [^false]].	^true!isEmpty	^sharps isEmpty and: [flats isEmpty]!isLegal	^self flatsInRightOrder and: [self sharpsInRightOrder]!sharpsInRightOrder	| allSharps |	allSharps := PitchClass sharpOrdering.	1 to: sharps size do: [:i | (sharps at: i) natural = (allSharps at: i) natural ifFalse: [^false]].	^true! !!Siren.Signature methodsFor: 'access'!alterate: aNaturalNote	sharps do: [:s | s natural = aNaturalNote pitchClass ifTrue: [^aNaturalNote sharp]].	flats do: [:s | s natural = aNaturalNote pitchClass ifTrue: [^aNaturalNote flat]].	^aNaturalNote!flats	^flats!initialize	sharps := OrderedCollection new.	flats := OrderedCollection new!nbFlats: n	sharps := OrderedCollection new.	flats := PitchClass nFirstFlats: n.!nbSharps: n 	flats := OrderedCollection new.	sharps := PitchClass nFirstSharps: n!reOrderSharpsAndFlats	"attempts to reorder flats and sharps according to the natural order as found in 	PitchClass"	| allFlats allSharps |	allFlats := PitchClass flatOrdering.	allSharps := PitchClass sharpOrdering.	flats := (flats asSortedCollection: [:a :b | (allFlats indexOf: a natural)					<= (allFlats indexOf: b natural)]) asOrderedCollection.	sharps := (sharps asSortedCollection: [:a :b | (allSharps indexOf: a natural)					<= (allSharps indexOf: b natural)]) asOrderedCollection!sharps	^sharps!sharps: s flats: f 	"attempts to reorder flats and sharps according to the natural order as found in 	PitchClass"	sharps := s.	flats := f.	self reOrderSharpsAndFlats! !!Siren.Signature class methodsFor: 'creation'!choseSignature	"Signature choseSignature"	| choice s |	s := Signature new.	choice := Dialog 		choose: 'Choose a signature' 		fromList: #('no sharp/falt [C Major]' '1 sharp [G Major]' '2 sharps [D Major]' '3 sharps [A Major]' '4 sharps [E Major]' '5 sharps [B Major]' '6 sharps [F# Major]' '7 sharps [C# Major]' '1 flat [F Major]' '2 flats [Bb Major]' '3 flats [Eb Major]' '4 flats [Ab Major]' '5 flats [Dd Major]' '6 flats [Gg Major]' '7 flats [Cb Major]' ) 		values: (1 to: 15)		lines: 15		cancel: [nil] .	choice == nil ifTrue: [^s].	choice < 9		ifTrue: [s nbSharps: choice - 1]		ifFalse: [s nbFlats: choice - 8].	^s!fromTonality: aScale 	"Signature fromTonality: N E flat majorScale"	^self new sharps: aScale sharpNotesInSignature flats: aScale flatNotesInSignature!new^super new initialize!sharps: s flats: f	^self new sharps: s flats: f! !!Siren.Signature class methodsFor: 'examples'!example	^Signature choseSignature!example2	"Signature new tonality -> C MajorScale	(Signature new nbSharps: 4) tonality -> E MajorScale	 	(Signature new nbFlats: 3) tonality -> Eb MajorScale"!example3"	Signature fromTonality: N D majorScale	Signature fromTonality: N E flat majorScale"!example4	"Signatures may be created for illegal scales. However, method 	tonality yields an error for these scales: 		Signature fromTonality: N D minorScale -> 1 sharps; 1 flats 	Signature sharps: (Array with: N F sharp) flats: (Array with: (N E flat)) -> 1 sharps; 1 flats	(Signature fromTonality: N D minorScale) tonality -> error"! !!Siren.IntervalMagnitude methodsFor: 'accessing'!value: theValue	"Accept theValue, as the new instance variable 'value' -- perform  range-checking""	| range |	range := self class range.	range == nil		ifFalse: [((theValue < range first) or: [theValue > range last])			ifTrue: [self error: 'value out of range.']]."	value := theValue! !!Siren.IntervalMagnitude class methodsFor: 'class inst var access'!range	"Answer the class' range."	^range!range: anInterval	"Set the class' range."	range := anInterval! !!Siren.EventListTreeItem methodsFor: 'accessing'!children		^lists!hasChildren	^lists notEmpty! !!Siren.EventListTreeItem methodsFor: 'initialize-release'!lists: aCollection	lists := aCollection! !!Siren.SecondDuration methodsFor: 'process delay'!wait	"Delay for a time corresponding to the receiver"	"1.5 seconds wait"	(Delay forMicroseconds: self asUseconds value) wait! !!Siren.SecondDuration methodsFor: 'printing'!printOn: aStream	"Print the receiver on the argument as a MM declaration."	| valstr |	valstr := value printString.	valstr size > 6		ifTrue: [valstr := valstr copyFrom: 1 to: 5].	aStream nextPutAll: '(', valstr, self units, ')'!units	"Answer the units string of the receiver."	^' sec'! !!Siren.SecondDuration methodsFor: 'converting'!adaptToFloat	"Answer a float of seconds."	^self asSeconds value!asBeat	"Answer a RatioDuration."	^RatioDuration new value: (self asSec value)!asMS	"Answer a MSecondDuration."	^self asMsec!asMsec	"Answer a MSecondDuration."	^self asMseconds!asMseconds	"Answer a MSecondDuration."	^MSecondDuration new value: (value * 1000) truncated!asRatio	"Answer a RatioDuration."	^RatioDuration new value: (self asSec value asFloat)!asSec	"Answer a float of seconds."	^self asSeconds!asSeconds	"Answer a float of seconds."	^self!asUsec	"Answer a USecondDuration."	^self asUseconds!asUseconds	"Answer an int of micro seconds."	^USecondDuration new value: (value * 1000000) truncated! !!Siren.SecondDuration methodsFor: 'private'!mostGeneral	"Answer the receiver in seconds."	^self asSec!species	"Answer Duration."	^Duration! !!Siren.SecondDuration class methodsFor: '-- all --'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asSec! !!Siren.SHARCSample methodsFor: 'accessing'!addLast: newObject 	"Add newObject to the end of the receiver."	data addLast: newObject!ampl	"Answer the receiver's 'ampl'."	^ampl!ampl: anObject	"Set the receiver's instance variable 'ampl' to be anObject."	ampl := anObject!centroid	"Answer the receiver's 'centroid'."	^centroid!centroid: anObject	"Set the receiver's instance variable 'centroid' to be anObject."	centroid := anObject!key	"Answer the receiver's 'key'."	^key!key: anObject	"Set the receiver's instance variable 'key' to be anObject."	key := anObject!nHarm	"Answer the receiver's 'nHarm'."	^nHarm!nHarm: anObject	"Set the receiver's instance variable 'nHarm' to be anObject."	nHarm := anObject!name	"Answer the receiver's 'name'."	^name!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject!noPitch	"Answer the receiver's 'noPitch'."	^noPitch!noPitch: anObject	"Set the receiver's instance variable 'noPitch' to be anObject."	noPitch := anObject!pitch	"Answer the receiver's 'pitch'."	^pitch!pitch: anObject	"Set the receiver's instance variable 'pitch' to be anObject."	pitch := anObject!rePitch	"Answer the receiver's 'rePitch'."	^rePitch!rePitch: anObject	"Set the receiver's instance variable 'rePitch' to be anObject."	rePitch := anObject! !!Siren.SHARCSample methodsFor: 'arithmetic'!transformAmp: dBval	"Concert a minus-dB amplitude to an amplitude scale."	"SHARCSample someInstance transformAmp: -32.44"	^10 raisedTo: (dBval / 20)! !!Siren.SHARCSample methodsFor: 'converting'!asSumOfSines	"Answer a SOS-format description of the receiver."	"(Function from: (((SHARCInstrument fromDir: 'tuba') samples at: #c3) asWavetable: 512)) open"	"((SHARCInstrument fromDir: 'tuba') samples at: #c3) asSumOfSines"	| coll count |	coll := Array new: self size * 2.	count := 1.	1 to: self size do:		[ :hn | | ha |			"harmonic loop"		ha := self at: hn.		"get ampl/phase point"		coll at: count put: (self transformAmp: ha x).		coll at: (count + 1) put: (ha y).		count := count + 2].	^coll!asWavetable: len	"Answer a wavetable derived from the receiver."	"((SHARCInstrument orchestra at: #tuba) samples at: #c3) 			asWavetable: 512"	"(GraphMorph new data: (((SHARCInstrument orchestra at: #tuba) 			samples at: #c3) asWavetable: 360)) openInWorld"	| table sca |	table := Array new: len.				"result table"	sca := 32768.0 / ampl asFloat.		"ampl scale"	Cursor execute showWhile: [1 to: len do:		[ :sa | | va in |					"sample loop"		va := 0.0.						"samp value"										"scaled index"		in := (sa asFloat / len asFloat) * Float pi * 2.0.		1 to: self size do:			[ :hn | | ha ph |				"harmonic loop"			ha := self at: hn.			"get ampl/phase point"			ph := (in * hn) + ha y.		"actual phase"			va := va + (ph sin * (self transformAmp: ha x) * sca)].		table at: sa put: va]].	^table! !!Siren.SHARCSample methodsFor: 'initialize-release'!initialize	"Initialize the receiver for the given size."	self initialize: 64! !!Siren.SHARCSample class methodsFor: 'instance creation'!in: dirName descr: strm	"Read a sample's data from the given directory based on the given line from the contents file."	"SHARCInstrument loadOrchDir: 'sharc'"	"Format:		pitch key nHarm ampl noPitch rePitch      skip 5 fields       centroid		 c#2   24   152    2099   65.406   65.430 [ 2 25  1  5.440  1.353 ] 314.345 "	| inst pit nHarm fil nam istrm |	nam := dirName asFilename tail.	inst := self new initialize.	inst name: nam asSymbol.	strm skipSeparators.	pit := strm upToSeparator asSymbol.	strm skipSeparators.	inst pitch: pit.	inst key: (Number readFrom: strm).	strm skipSeparators.	((((strm atEnd) or: [inst name isNil]) or: [inst pitch isEmpty]) or: [inst noPitch = 0.0])		ifTrue: [^nil  "self error: 'Faulty SHARC data file'"]."	Transcript tab; show: 'Load sample from file ', dirName, Filename separatorString, 					nam, '_', pit, '.spect'; cr."	nHarm := Number readFrom: strm.	strm skipSeparators.	inst nHarm: nHarm.	inst ampl: (Number readFrom: strm).	strm skipSeparators.	inst noPitch: (Float readFrom: strm).	strm skipSeparators.	inst rePitch: (Float readFrom: strm).	strm skipSeparators.	5 timesRepeat:				"skip 5 fields"		[strm upToSeparator. strm skipSeparators].	inst centroid: (Float readFrom: strm).	fil := (dirName asFilename) filesMatching: ('*', pit, '.spect').	fil isEmpty ifTrue: [Transcript show: 'File not found: ', (fil asString); cr.			^inst].	fil := fil first asFilename.	fil exists ifFalse: [Transcript show: 'File not found: ', (fil asString); cr.			^inst].	istrm := fil readStream.	[istrm atEnd] whileFalse:		[ | amp pha |		istrm skipSeparators.		amp := Float readFrom: istrm.		istrm skipSeparators.		pha := Float readFrom: istrm.		inst addLast: (amp @ pha).	"harms saved as points: amp @ phase"		istrm skip: 1].	^inst! !!Siren.PlayList methodsFor: 'accessing'!addList: aValue	tracks isSequenceable		ifTrue: [tracks := Dictionary new "				self error: 'Adding trax & folders to the same playlist' " ].	tracks isNil		ifTrue: [tracks := Dictionary new].	tracks at: aValue name put: aValue.	aValue parent: self!addTrack: trk	tracks ifNil: [tracks := OrderedCollection new].	tracks addLast: trk!addTrack: aValue with: trax	| trk |	tracks ifNil: [tracks := OrderedCollection new].	trk := trax at: aValue "printString asSymbol" ifAbsent: [nil].	trk isNil		ifTrue: [self halt. tracks addLast: aValue]		ifFalse: [tracks addLast: trk]!all	^all!all: aValue	all := aValue!allArtists	"self allArtists"	| co se | 	co := OrderedCollection new. 	self allTracksInto: co.	se := Set new.	co do: [ :tr | se add: tr artist].	Transcript clear.	co := se asSortedCollection.	co do: [ :tr | Transcript show: tr asString; cr].	^co!allTracks	^self allTracksInto: OrderedCollection new.!allTracksInto: coll	" | co | co := OrderedCollection new. self allTracksInto: co. co"	tracks do:		[ :tr |		tr tracks isNil			ifTrue: [coll addLast: tr]			ifFalse: [tr allTracksInto: coll]]!asSymbol	"Hack"	^nil!at: nam	^tracks at: nam!id	^id!id: aValue	id := aValue!isEmpty	^false!key	^key!key: aValue	key := aValue!parent	^parent!parent: aValue	parent := aValue!removeListNamed: aSymbol	tracks isSequenceable		ifTrue: [tracks := Dictionary new "self error: 'Adding trax & folders to playlist'" ].	tracks isNil		ifTrue: [^nil].	tracks removeKey: aSymbol ifAbsent: []!size	^size!size: aValue	size := aValue!tracks	^tracks!tracks: aValue	tracks := aValue! !!Siren.PlayList methodsFor: 'printing'!fullName	"Full name with parents"	self parent isNil		ifTrue: [^self name].	self parent size = 0		ifTrue: [^self name].	self parent isSymbol		ifTrue: [^self parent asString, ' / ', self name].	^self parent fullName, ' / ', self name!printOn: aStream	aStream nextPutAll: self fullName.	self size ifNotNil: [aStream nextPutAll: '  --  ', self size printString]! !!Siren.PlayList class methodsFor: 'instance creation'!fromDictionary: dict with: trax	"Create a new playlist"	"Siren.PlayList fromDictionary: ()"	"Siren.PlayList name: 'te' id: 1 key: 123 parent: 234 items: #() all: true"	"DataSet someInstance loadPlayLists"	| inst trx |	inst := self new.	inst name: (dict at: #Name ifAbsent: ['']) .	inst id: (dict at: #PlaylistID ifAbsent: [0]).	inst key: (dict at: #PlaylistPersistentID ifAbsent: ['']) asSymbol.	inst parent: (dict at: #ParentPersistentID ifAbsent: ['']) asSymbol.	inst all: (dict at: #AllItems ifAbsent: [true]) .	trx := dict at: #PlaylistItems ifAbsent: [#()].	trx do: [ :it | inst addTrack: (it at: #TrackID) with: trax].	inst size: trx size.	^inst"		<dict>			<key>Name</key><string>Emil Gilels, Eugen Jochum; Berlin Philharmonic Orchestra</string>			<key>Playlist ID</key><integer>344239</integer>			<key>Playlist Persistent ID</key><string>47E554C8F42B81F9</string>			<key>Parent Persistent ID</key><string>9DCCFC04F85C8A5E</string>			<key>All Items</key><true/>			<key>Playlist Items</key>			<array>				<dict>					<key>Track ID</key><integer>86536</integer>				</dict>				<dict>					<key>Track ID</key><integer>86538</integer>				</dict>				<dict>					<key>Track ID</key><integer>86540</integer>				</dict>			</array>		</dict>"! !!Siren.LPCFrame methodsFor: 'accessing'!coefficients	^coefficients!coefficients: aValue	coefficients := aValue!err	^err!err: aValue	err := aValue!npoles	^npoles!npoles: aValue	npoles := aValue!pitch	^pitch!pitch: aValue	pitch := aValue!rmsO	^rmsO!rmsO: aValue	rmsO := aValue!rmsR	^rmsR!rmsR: aValue	rmsR := aValue!srate	^srate!srate: aValue	srate := aValue! !!Siren.LPCFrame methodsFor: 'printing'!printOn: aStream 	"Format and print the receiver on the argument."	aStream nextPutAll: ' LPC Frame ', (rmsR printString: 3), '  	', (rmsO printString: 3), '  	', 			(err printString: 4), '  	', (pitch printString: 4); cr! !!Siren.OSCPort methodsFor: 'accessing'!portNumber: newPortNum 	"Reset the receiver's UDP socket port number"	address port: newPortNum! !!Siren.OSCPort methodsFor: 'actions'!send: aMessage 	"Send something"	SirenUtility log: aMessage printString level: 1.	self critical: [socket sendTo: address buffer: aMessage oscBytes]! !!Siren.OSCPort methodsFor: 'initialize-release'!init: t1 	"Set up"	socket := SocketAccessor newUDP.	address := t1.	^self! !!Siren.OSCPort class methodsFor: 'examples'!demo	"OSCPort demo"	self sendStart.	self sendFreq.	self sendStop.	^self!demo2	"OSCPort demo2"	self scHost send: TypedOSCMessage start.	self scHost send: TypedOSCMessage changeFreq.	self scHost send: TypedOSCMessage scStop.	^self!sendFreq	"PSCPort sendFreq"	self localhost send: TypedOSCMessage changeFreq.	^self!sendStart	"OSCPort sendstop"	self localhost send: TypedOSCMessage start.	^self!sendStop	"Send a stop message"	self localhost send: TypedOSCMessage scStop.	^self! !!Siren.OSCPort class methodsFor: 'instance-creation'!cslHost	"Answer the default port for CSL"	^self to: (IPSocketAddress hostName: 'localhost' port: 54321)!default	"Answer the default instance"	^self to: (IPSocketAddress hostAddress: self defaultIP port: self defaultPort)!localhost	"Answer an OSC port on the local host"	^self to: (IPSocketAddress hostAddress: (ByteArray				with: 127				with: 0				with: 0				with: 1)			port: self defaultPort)!scHost	"Answer the default OSC server reference"	^self to: (IPSocketAddress hostAddress: (ByteArray				with: 192				with: 168				with: 61				with: 1)			port: self defaultSCOSCPort)!to: t1 	"Open a port on the given device"	^self new init: t1!to: ip port: port	"^an OSCPort with the given attributes"	"OSCPort to: #[127 0 0 1] port: 54321"	^self to: (IPSocketAddress hostAddress: ip port: port)!toHostName: t1 	"Answer an instance on the given host"	^self to: (IPSocketAddress hostName: t1 port: self defaultPort)!toHostName: aHostName portNumber: aPort 	"^an OSCPort 	Convenience method"	^self to: (IPSocketAddress hostName: aHostName port: aPort)!toLocalhostPortNumber: aPort 	"^an OSCPort 	Convenience method"	^self toHostName: 'localhost' port: aPort! !!Siren.OSCPort class methodsFor: 'defaults'!defaultIP	"Answer the class var default"	^SirenUtility defaultOSCHost!defaultIP: value	"Set the class var default"	SirenUtility defaultOSCHost: value!defaultPort	"Answer the class var default"	^SirenUtility defaultOSCPort!defaultPort: value	"Set the class var default"	SirenUtility defaultOSCPort: value!defaultSCOSCPort	"Answer the default port for OSC"	^57123! !!Siren.Swell methodsFor: 'initialize-release'!initialize	selector := #loudness! !!Siren.Swell class methodsFor: 'as yet unclassified'!example	"Swell example"	| roll decresc |	roll := ((Roll length: 2 rhythm: 100 note: 60) ampl: 80) eventList.	"100 msec = 10/sec"	decresc := Swell new function: (LinearFunction from: #((0 1) (1 0.5))); scale: 60.	decresc applyTo: roll.	roll play! !!Siren.SHARCInstrument methodsFor: 'accessing'!directory	"Answer the receiver's 'directory'."	^directory!directory: anObject	"Set the receiver's instance variable 'directory' to be anObject."	directory := anObject!name	"Answer the receiver's 'name'."	^name!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject!range	"Answer the receiver's 'range'."	^range!range: anObject	"Set the receiver's instance variable 'range' to be anObject."	range := anObject!sampleNamed: n	"Answer the receiver's sample by the given name."	^samples at: n ifAbsent: [nil]!sampleWithKey: k	"Answer the receiver's sample by the given name."	^samples detect: [ :s | s key = k] ifNone: [nil]!samples	"Answer the receiver's 'samples'."	^samples!samples: anObject	"Set the receiver's instance variable 'samples' to be anObject."	samples := anObject! !!Siren.SHARCInstrument methodsFor: 'converting'!asSpectrum	| sp n frIncr dat base |	n := 4096.		"default 'simulated' fft window size."	sp := Spectrum new real; sound: nil; windowSize: 4096;				stepSize: 4096; name: name;				folder: directory; setData.	frIncr := 44100 / n.	1 to: samples size do:		[ :ind | | sa |		dat := Array new: n.		sa := samples at: ind.			"get the sample"		base := sa rePitch / frIncr.		"base frequency of sample in bins"		sa do: 			[ :ind2 | | pt |			pt := sa at: ind2.			dat at: ind2 put: pt x].			"add up partials"		sp at: ind put: dat]! !!Siren.SHARCInstrument methodsFor: 'initialize-release'!initialize	samples := Dictionary new! !!Siren.SHARCInstrument class methodsFor: 'class constants'!loadOrchDir: dir	"SHARCInstrument loadOrchDir: 'sharc'"	"SHARCInstrument orchestra inspect"	| fullName instrs total |	fullName := SirenUtility findFile: dir.	Transcript cr; cr; show: 'Load SHARC database from dir ', fullName; cr.	SHARCOrchestra := Dictionary new.	instrs := fullName asFilename directoryNames.	instrs do: [ :subDir | | in | 		in := self fromDir: subDir asString.		SHARCOrchestra at: in name put: in].	total := SHARCOrchestra values inject: 0 into: 				[ :su :it | su + it samples size].	Transcript cr; show: 'Loaded ', SHARCOrchestra size printString,			' instruments, ', total printString, ' samples.'; cr.	^SHARCOrchestra!orchestra	"SHARCInstrument orchestra inspect"	^SHARCOrchestra! !!Siren.SHARCInstrument class methodsFor: 'instance creation'!fromDir: dirName 	"Answer a SHARC instrument group read from the CONTENTS file in the 	 given directory. The contents file describes a number of samples, each	 of which has a description file with its overtones."	"Contents file sample descr. line format		c2  24 152  2099   65.406   65.430  2 25  1  5.440  1.353  314.345 "	| inst strm pitches nam basename |	nam := SirenUtility findFile: dirName.	nam ifNil: [self error: 'Cannot find SHARC database'].	basename := dirName asFilename tail asString.	Transcript show: 'Load instrument ' , basename , ':  '.	strm := (nam , Filename separatorString , 'CONTENTS') asFilename readStream.	inst := self new initialize.	inst directory: dirName.	inst name: basename asSymbol.	[strm atEnd] whileFalse: 			[ | samp |			Cursor read showWhile: 					[samp := SHARCSample in: nam descr: strm].			samp ifNotNil: [inst samples at: samp pitch put: samp]].	strm close.	pitches := inst samples collect: [ :sa | sa key].	inst range: (pitches min to: pitches max).	Transcript show: inst samples size printString , ' samples.'; cr.	^inst! !!Siren.DisplayListSubcanvas methodsFor: 'aspects'!createDisplayListView	"Create and answer the receiver's display list view"	"DisplayListSubcanvas open"	displayList == nil		ifTrue: [displayList := DisplayList stringsX: 2000 byY: 2000].	componentPart == nil		ifTrue: [componentPart := DisplayListView componentOnList: displayList].	displayListView := componentPart components first component component.		"KLUDJ"	scroller := displayListView container.	^componentPart!hZoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^hZoom isNil		ifTrue:			[hZoom := 1 asValue]		ifFalse:			[hZoom]!setComponent: aComponent	"Set the receiver's component part"	componentPart := aComponent!setDisplayList: aDisplayList	"Set the receiver's display list"	displayList := aDisplayList!vZoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^vZoom isNil		ifTrue:			[vZoom := 1 asValue]		ifFalse:			[vZoom]! !!Siren.DisplayListSubcanvas methodsFor: 'actions'!nextPage	"This stub method was generated by UIDefiner"	^self!prevPage	"This stub method was generated by UIDefiner"	^self!zoomChanged	"Sent when the users moves the zoom sliders."	displayListView zoom: (hZoom value @ vZoom value).	scroller changed!zoomTo1	"Sent when the users presses the zoom-to-1 button."	hZoom value: 1.	vZoom value: 1.	self zoomChanged!zoomToLast	"This stub method was generated by UIDefiner"	^self! !!Siren.DisplayListSubcanvas class methodsFor: 'interface specs'!windowSpec	"Answer the user's favorite window layout"	^self windowSpecLeftBottom! !!Siren.DisplayListSubcanvas class methodsFor: 'instance creation'!onList: aDisplayList	| me |	me := self new.	me setDisplayList: aDisplayList.	me open!openOnList: aDisplayList	"DisplayListSubcanvas openOnList: (DisplayList rectanglesX: 6000 byY: 6000)"	"DisplayListSubcanvas openOnList: (DisplayList polylinesX: 2000 byY: 2000)"	| me |	me := self new.	me setDisplayList: aDisplayList.	self openOn: me! !!Siren.SymbolicLoudness methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a symbolic amplitude."	aStream nextPutAll: value!units	"Answer the units string of the receiver."	^' ampl'! !!Siren.SymbolicLoudness methodsFor: 'converting'!asDB	"Answer a dB loudness; ratio 1 = 0dB, ratio 0.5 = -6dB, etc."	"(#ff ampl) asDB"	^self asRatio asDB!asMIDI	"Answer a MIDIVelocity."	"(#pp ampl) asMIDI"		"pianissimo is MIDI velocity 24"	^MIDIVelocity new value:			((self class nameMap keyAtValue: value) last)!asRatio	"Answer a RatioLoudness."	"(#pp ampl) asRatio"		"pianissimo is 0.2"	^RatioLoudness new value:			(((self class nameMap keyAtValue: value) last / 120) asFloat)!asSymbol	"Answer a SymbolicLoudness."	^self!mostGeneral	"Answer the most numerically meaningful version of the receiver."	^self asRatio! !!Siren.SymbolicLoudness methodsFor: 'private'!species	"Answer Amplitude."	^Amplitude! !!Siren.SymbolicLoudness class methodsFor: 'class initialization'!initialize	"Set up the class dynamic mapping dictionary"	"SymbolicLoudness initialize"		NameMap := Dictionary new.	NameMap at: (1 to: 12) put: #ppp.	NameMap at: (12 to: 24) put: #pp.	NameMap at: (24 to: 38) put: #p.	NameMap at: (38 to: 50) put: #mp.	NameMap at: (50 to: 70) put: #mf.	NameMap at: (70 to: 85) put: #f.	NameMap at: (85 to: 100) put: #ff.	NameMap at: (100 to: 127) put: #fff.! !!Siren.SymbolicLoudness class methodsFor: 'instance creation'!fromMIDI: aValue	"Assuming value is a key velocity, answer a symbolic loudness name"	"(Amplitude value: 39) asSymbol"	| int |	int := NameMap keys detect: [ :range | range includes: aValue]				ifNone: [^self error: 'invalid Loudness range.'].	^(self new) value: (NameMap at: int)! !!Siren.SymbolicLoudness class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asDynamic! !!Siren.OSCByteConvertor methodsFor: 'initialize-release'!init	packetData := ByteArray new writeStream.	^self! !!Siren.OSCByteConvertor methodsFor: 'stream'!contents	^packetData contents!next: t1 put: t2 	^packetData next: t1 put: t2!nextPut: t1 	^packetData nextPut: t1!nextPutAll: t1 	^packetData nextPutAll: t1!nextPutType: char"	Transcript show: (String with: char); space."	^self nextPut: char asInteger!position	^packetData position! !!Siren.OSCByteConvertor class methodsFor: 'instance creation'!new	^super new init! !!Siren.SoundVoice methodsFor: 'events'!playEvent: t1 at: t2 	stream play: t1.	^self! !!Siren.SoundVoice class methodsFor: 'constant access'!default	^self on: SoundPort default! !!Siren.USecondDuration methodsFor: 'printing'!units	"Answer the units string of the receiver."	^' usec'! !!Siren.USecondDuration methodsFor: 'converting'!asMseconds	"Answer a MSecondDuration."	^MSecondDuration new value: (value / 1000) truncated!asSeconds	"Answer a float of seconds."	^SecondDuration new value: (value / 1000000) asFloat!asUseconds	"Answer a float of micro seconds."	^self! !!Siren.CmixVoice methodsFor: 'events'!endLine	stream nextPutAll: ');'; cr.	^self!playEvent: evt at: start 	"Play the given event"	| param newEv siz |	stream == nil ifTrue: [^self].	stream nextPutAll: parameterMap first.	newEv := 2.	siz := parameterMap size.	[newEv <= siz]		whileTrue: 			[(param := parameterMap at: newEv) isSymbol				ifTrue: [param == #start						ifTrue: [stream nextPutAll: start printString]						ifFalse: [stream nextPutAll: (evt perform: param) printString]]				ifFalse: [param isString						ifTrue: [stream nextPutAll: param]						ifFalse: [(param isMemberOf: BlockContext)								ifTrue: [stream nextPutAll: (param value: evt)]								ifFalse: [self error: 'unknown voice map item type.']]].			self space.			newEv := newEv + 1].	self endLine.	^self!space	stream nextPut: $,; space; tab.	^self!writeHeader	"Write out a CMix score file header."	stream nextPutAll: '/* cmix MINC data file created ' , Date today printString , ' */'; cr.	stream cr; nextPutAll: 'system("sfcreate -r 44100 -c 1 -i out.snd");'; cr.	stream nextPutAll: 'output("out.snd");			/* output sound file */'; cr.	stream nextPutAll: 'makegen(1, 10, 1024, 1)		/* f1 = sine wave */'; cr; cr.	^self! !!Siren.CmixVoice class methodsFor: 'examples'!randomExampleToFileAndEdit	"CmixVoice randomExampleToFileAndEdit"	self randomExampleToFileNamed: 'rand.m'.	^self!randomExampleToFileNamed: fnam 	"Create a random event list and store it on a file."	| evt strm list rand vox |	strm := (Filename named: fnam) writeStream.	rand := Random new."Create the event list and add a few additional properties"	(list := EventList randomExample: 64)		do: 			[ :ass | 			(evt := ass event) at: #pos put: rand next.			evt at: #prop1 put: (rand nextFrom: 320 to: 480).			evt at: #prop2 put: (rand nextIntFrom: 12000 to: 23000)]."Create a cmix voice and customize its parameter map."	(vox := CmixVoice newNamed: 'file:=two' onStream: strm) addMap: #pos.	vox addMap: [ :item | ((item at: #prop1) / 1000) printString].	vox addMap: #prop2."Play the list on the voice."	vox play: list.	strm close.	(Filename named: fnam) edit.	^self! !!Siren.CmixVoice class methodsFor: 'instance creation'!default	CmixVoice newNamed: 'fm' onStream: 'tmp.m' asFilename writeStream.	^self!defaultPMap	"CmixVoice randomExampleToFileAndEdit"	| map |	map := OrderedCollection new: 8.	map add: [ :ass :list | 'ins(', (ass key asSec value asFloat printString: 4)].	map add: [ :t2 | t2 duration asSec value asFloat printString: 4 ].	map add: [ :t3 | t3 loudness asDB positiveDB truncated printString].	^map! !!Siren.SelectionCloud methodsFor: 'playing'!eventList	"Make the cloud's events"	"assume that the receiver's pitch, loudness and durations are actually intervals"	| pattern rand number length start |	pattern := EventList new.	rand := Random new.	density isEvent		ifTrue: [^self eventListWithDensityFunction].	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	number truncated timesRepeat:		[ pattern add: (MusicEvent 			dur: (length * 2 "+ (2000 * rand next) rounded")			pitch: (self pitch value atRandom: rand)			ampl: (self loudness value atRandom: rand)			voice: (self voice atRandom: rand))			at: start.		start := start + length].	^pattern!eventListWithDensityFunction	"make the cloud's events"	"assume that the receiver's density is a function and that the voices are a selection set."	| dur pattern rand dens time playing ends snd |	pattern := EventList new.	rand := Random new.	time := 0.0. 		"msec"	playing := 0.	dens := density at: 0.	ends := SortedCollection new: (density range extent + 1) truncated."prime the generators"	playing := 1.	ends add: 0.0.							"time at first note end"	time := 0.0.	dur := duration asSec value."Step through the end times."	[time < dur] whileTrue:		[time := ends removeFirst.			"step to next end time"		playing := playing - 1.		dens := density at: (time / dur).		[dens > playing] whileTrue: 			[snd := self voice atRandom: rand.			pattern add: (MusicEvent dur: snd duration 								voice: snd 								ampl: (1.0 / dens)) at: time.			ends add: (time + snd duration asSec value).			playing := playing + 1]].	^pattern! !!Siren.SelectionCloud class methodsFor: 'examples'!example1	"Create a low 4 second cloud selecting pitch, amp and voice from value arrays."	"SelectionCloud example1"	(SelectionCloud  dur: 4  		pitch: #(32 40 48 50 52 55 57 )		ampl: #(80 80 120)		voice: #(1 2 3 4)		density: 8) eventList "edit" play "inspect"!exampleRand	"Edit a selection cloud with random properties."	"SelectionCloud exampleRand"	| rand pBase pArray aArray score |	rand := Random new.	pBase := 30 + (rand next * 40) rounded.	pArray := Array new: 2 + ((rand next * 4) rounded).	1 to: pArray size do: [:ind | pArray at: ind put: (pBase+(rand  next * 12) rounded)].	pBase := 20 + (rand next * 60) rounded.	aArray := Array new: 2 + ((rand next * 6) rounded).	1 to: aArray size do: [:ind | aArray at: ind put: (pBase+(rand  next * (120 - pBase)) rounded)].	score := (SelectionCloud  dur: (3 + (rand next * 4) rounded)		pitch: pArray		ampl: aArray		voice: (1 to: 8)		density: (3 + (rand next * 15) rounded)) eventList.	score edit."	score play.	(Delay forMilliseconds: (score duration + 1000)) wait"!randomExample	"Create a selection cloud with random properties."	"SelectionCloud randomExample"	| rand pBase pArray aArray score |	rand := Random new.	pBase := 20 + (rand next * 40) rounded.	pArray := Array new: 2 + ((rand next * 4) rounded).	1 to: pArray size do: [:ind | pArray at: ind put: (pBase+(rand  next * 12) rounded)].	pBase := 20 + (rand next * 60) rounded.	aArray := Array new: 2 + ((rand next * 6) rounded).	1 to: aArray size do: [:ind | aArray at: ind put: (pBase+(rand  next * (120 - pBase)) rounded)].	score := (SelectionCloud  dur: (3 + (rand next * 4) rounded)		pitch: pArray		ampl: aArray		voice: (1 to: 8)		density: (3 + (rand next * 15) rounded)) eventList.	score inspect."	score play.	(Delay forMilliseconds: (score duration + 1000)) wait"! !!Siren.DynamicSelectionCloud methodsFor: 'playing'!eventList	"make the dynamic selection cloud's events"	"assume that the receiver's pitch, loudness and durations are actually 2-D arrays"	| pattern rand number length start |	pattern := EventList new.	rand := Random new.	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	1 to: number do:		[ :counter |		pattern add: (MusicEvent 			dur: (length * 2 "+ (1000 * rand next) rounded")			pitch: ((rand next > (counter / number)) 					ifTrue: [ (self pitch value at: 1) atRandom: rand  ]					ifFalse: [ (self pitch value at: 2) atRandom: rand ])			ampl: (self loudness value atRandom: rand)			voice: (self voice atRandom: rand))			at: start.		start := start + length].	^pattern! !!Siren.DynamicSelectionCloud class methodsFor: 'examples'!example1	"Create a selection cloud that focuses onto a trill."	"DynamicSelectionCloud example1"	(DynamicSelectionCloud  dur: 4		pitch: #( #(36 38 40 43 45) #(53 54) )		ampl: #(80 80 120)		voice: #(1 3 5 7)		density: 16) eventList "edit" play "inspect"!example2	"Create a selection cloud that makes a transition from one triad to another"	"DynamicSelectionCloud example2"	(DynamicSelectionCloud dur: 4		pitch: #( #(60 62 64) #(72 74 76) )		ampl: #(80 80 120)		voice: #(1 3 5 7)		density: 12) eventList open "inspect"!randomExample	"Answer a dynamic selection cloud with random properties."	"DynamicSelectionCloud randomExample"	| rand pBase pArray1 pArray2 aArray1 score |	rand := Random new.	pBase := rand nextIntFrom: 42 to: 54.	pArray1 := Array new: (rand nextIntFrom: 2 to: 4).	1 to: pArray1 size do: 			[:ind | pArray1 at: ind put: (rand nextIntFrom: pBase to: pBase + 12)].	pBase := rand nextIntFrom: 60 to: 72.	pArray2 := Array new: (rand nextIntFrom: 4 to: 8).	1 to: pArray2 size do: 			[:ind | pArray2 at: ind put: (rand nextIntFrom: pBase to: pBase + 12)].	pBase := rand nextIntFrom: 40 to: 60.	aArray1 := Array new: (rand nextIntFrom: 2 to: 6).	1 to: aArray1 size do: 			[:ind | aArray1 at: ind put: (rand nextIntFrom: pBase to: pBase + 50)].	Transcript cr; show: 'DynSelCloud: ', pArray1 printString; cr; 			show: pArray2 printString; cr; cr.	score := (DynamicSelectionCloud  dur: 8		pitch: (Array with: pArray1 with: pArray2)		ampl: aArray1		voice: (1 to: 8)		density: (rand nextIntFrom: 5 to: 15)) eventList."	score inspect.""	score play.	(Delay forMilliseconds: (score duration + 1000)) wait"	score edit! !!Siren.ChromaticScale class methodsFor: 'interval list'!intervalList	^#(#unison #augmentedUnison #majorSecond #minorThird #majorThird #perfectFourth #augmentedFourth #perfectFifth #minorSixth #majorSixth #minorSeventh #majorSeventh )! !!Siren.TimeSequenceLayoutManager methodsFor: 'generating'!addItem: anAss atNode: aPath in: aDisplayList 	"Add the given item to the display list."	| path2 anE displayPoint item |	anE := anAss value.	anE hasItems		ifTrue: [^anE do:  			[ :i | 			path2 := aPath copy.			path2 addLast: anE.			self addItem: anAss key + i key => i value					atNode: path2					in: aDisplayList]].	displayPoint := self displayPointFor: anAss.	item := view itemFor: anAss.	item offset: displayPoint.	aDisplayList add: item atPath: aPath!displayPointFor: anAss 	"Answer the display point for the argument."	| dPoint |	dPoint := (anAss key asMS value - timeOffset / timeScale) asInteger.	(orientation == nil or: [orientation == #left])		ifTrue: [dPoint := dPoint @ 0]		ifFalse: [orientation == #top			ifTrue: [dPoint := 0 @ dPoint]].	^dPoint! !!Siren.TimeSequenceLayoutManager methodsFor: 'accessing'!timeOffset: aNumber	"Set the receiver's time offset."	timeOffset := aNumber!timeScale: aNumber	"Set the receiver's time scale."	timeScale := aNumber! !!Siren.PitchTimeLayoutManager methodsFor: 'generating'!displayPointFor: anAss	"Answer the display point for the argument."	| pch |	pch := anAss event pitch.	pch ifNil: [^((anAss key asMS value - timeOffset / timeScale) asInteger)		@ (60*pitchScale)].	^((anAss key asMS value - timeOffset / timeScale) asInteger)		@ ((60*pitchScale) 			- ((pch asMIDI value - pitchOffset) * pitchScale))! !!Siren.PitchTimeLayoutManager methodsFor: 'accessing'!pitchOffset: aNumber	"Set the receiver's pitch offset."	pitchOffset := aNumber!pitchScale: aNumber	"Set the receiver's pitch scale."	pitchScale := aNumber! !!Siren.PositionTimeLayoutManager methodsFor: 'generating'!displayPointFor: anAss	"Answer the display point for the argument."	^((anAss key asMS value - timeOffset / timeScale) asInteger)		@ ((anAss event position - pitchOffset) * pitchScale)! !!Siren.LPCSound methodsFor: 'smoothing'!smooth: data into: res	"filter the data"	"LPCEditor openOn: LPCSound someInstance"	| prev next this runningAvg thresh |	thresh := 0.3.	prev := data first pitch.							"prime the stored val;ues"	this := (data at: 2) pitch.	next := (data at: 3) pitch.	res at: 1 put: prev.	runningAvg := prev.	2 to: data size - 1 do:							"loop through the frames"		[ :i | | d1 d2 d3 |		d1 := (this - prev) abs / pchMax.			"get the scaled differences"		d2 := (next - this) abs / pchMax.		d3 := (next - prev) abs / pchMax.			"avg of prev/next"		Transcript show: d1 printString, ' - ', d2 printString, ' - ', d3 printString; tab.		((d1 < thresh) | (d2 < thresh))				"if this val is close to prev or to next"			ifTrue: [res at: i put: this.				Transcript tab; show: 'C1: ', runningAvg printString; cr.				runningAvg := (runningAvg + this) / 2.0]			ifFalse: [(d3 < thresh)					"else if prev close to next, but not to this"				ifTrue: [res at: i put: ((prev * next) / 2.0).					Transcript tab; show: 'C2: ', runningAvg printString; cr.					runningAvg := (runningAvg + (res at: i)) / 2.0]				ifFalse: [Transcript tab; show: 'C3: ', runningAvg printString; cr.					res at: i put: runningAvg]]	.	 "if we're lost"		prev := this.		this := next.		next := (data at: i + 1) pitch].	res at: nframes put: next!smoothAvg: data into: res	"filter the data"	"LPCEditor openOn: LPCSound someInstance"	| prev next this |	prev := data first pitch value.							"prime the stored val;ues"	this := (data at: 2) pitch value.	next := (data at: 3) pitch value.	res at: 1 put: prev.	2 to: data size - 1 do:							"loop through the frames"		[ :i | 		res at: i put: (prev + this + next) / 3.0.		 "avg of 3 values"		prev := this.		this := next.		next := (data at: i + 1) pitch value].	res at: data size put: next!smoothPitch	"filter the data"	"LPCEditor openOn: LPCSound someInstance"	| data smoothed smoothed2 |	data := Array new: frames size.	smoothed := Array new: frames size.	smoothed2 := Array new: frames size.	1 to: frames size do:		[ :i | data at: i put: ((frames at: i) pitch value)].	self smoothAvg: data into: smoothed.	self smoothAvg: smoothed into: smoothed2.	1 to: frames size do:		[ :i | (frames at: i) pitch: (smoothed2 at: i)].!smoothRunning: data into: res	"filter the data"	"LPCEditor openOn: LPCSound someInstance"	| prev next this runningAvg thresh verbose |	verbose := false.	thresh := 0.3.	prev := data first pitch value.							"prime the stored values"	this := (data at: 2) pitch value.	next := (data at: 3) pitch value.	res at: 1 put: prev.	runningAvg := prev.	2 to: data size - 1 do:									"loop through the frames"		[ :i | | d1 d2 d3 |		d1 := (this - prev) abs / pitchRange stop.			"get the scaled differences"		d2 := (next - this) abs / pitchRange stop.		d3 := (next - prev) abs / pitchRange stop.			"avg of prev/next"		verbose ifTrue: [Transcript show: d1 printString, ' - ', d2 printString, ' - ', d3 printString; tab].		((d1 < thresh) | (d2 < thresh))				"if this val is close to prev or to next"			ifTrue: [res at: i put: this.				verbose ifTrue: [Transcript tab; show: 'C1: ', runningAvg printString; cr].				runningAvg := (runningAvg + this) / 2.0]			ifFalse: [(d3 < thresh)					"else if prev close to next, but not to this"				ifTrue: [res at: i put: ((prev * next) / 2.0).					verbose ifTrue: [Transcript tab; show: 'C2: ', runningAvg printString; cr].					runningAvg := (runningAvg + (res at: i)) / 2.0]				ifFalse: [verbose ifTrue: [Transcript tab; show: 'C3: ', runningAvg printString; cr].					res at: i put: runningAvg]]	.	 "if we're lost"		prev := this.		this := next.		next := (data at: i + 1) pitch value].	res at: data size put: next!writePitch: howSmooth	"Replace the pitch values in the receiver's frames with a smoothed version selected by the argument."	| data smoothed smoothed2 |	data := Array new: frames size.	smoothed := Array new: frames size.	smoothed2 := Array new: frames size.	1 to: frames size do:			[ :i | data at: i put: ((frames at: i) pitch value)].	howSmooth == #running ifTrue: [self smoothRunning: data into: smoothed].	howSmooth == #smooth1 ifTrue: [self smoothAvg: data into: smoothed].	howSmooth == #smooth2 ifTrue: [self smoothAvg: data into: smoothed2.		self smoothAvg: smoothed2 into: smoothed].	1 to: frames size do:			[ :i | ((frames at: i) pitch: (smoothed at: i))].! !!Siren.LPCSound methodsFor: 'accessing'!addFrame: frame	frames addLast: frame!filename	^filename!filename: aValue	filename := aValue!filesize	^filesize!filesize: aValue	filesize := aValue!float: ind from: data 	"Answer the swapped float from the data at the index."	| index |	index := ind - 1 * 4 + 1.	UninterpretedBytes isBigEndian		ifFalse: [data swapLongAt: index].	^data floatAt: index!floatAt: ind put: value in: data 	"Store the swapped float into the data at the index."	| index |	index := ind - 1 * 4 + 1.	data floatAt: index put: value.	UninterpretedBytes isBigEndian		ifFalse: [data swapLongAt: index]!frameAt: ind put: frame	frames at: ind put: frame!frames	^frames!frames: aValue	frames := aValue!frate	^frate!frate: aValue	frate := aValue!long: ind from: data 	"Answer the swapped long int from the data at the index."	| index |	index := ind - 1 * 4 + 1.	UninterpretedBytes isBigEndian		ifFalse: [data swapLongAt: index]. 	^data longAt: index!longAt: ind put: value in: data 	"Store the swapped long int into the data at the index."	| index |	index := ind - 1 * 4 + 1.	data longAt: index put: value.	UninterpretedBytes isBigEndian		ifFalse: [data swapLongAt: index]!nframes	^nframes!nframes: aValue	nframes := aValue!npoles	^npoles!npoles: aValue	npoles := aValue!srate	^srate!srate: aValue	srate := aValue! !!Siren.LPCSound methodsFor: 'printing'!printOn: aStream 	"Format and print the receiver on the argument."	aStream nextPutAll: ' LPC Sound ', duration printString, ' ', frames size printString, ' frames '; cr!storeFile	"Store the receiver as a Csound format LPC file."	"LPCSound fromFile: '/Volumes/Content/Sound/3-IKnowGod/LPC/1.2a1.2.lpc'  "	"LPCSound someInstance storefile"	| strm newname |	newname := Dialog request: 'Store LPC data to file' initialAnswer: filename.	newname isEmpty ifTrue: [^self].	strm := newname asFilename writeStream binary.	self storeOn: strm.	strm close.!storeOn: aStream 	"Store the receiver on the argument as a Csound format LPC file."	"LPCSound fromFile: '/Volumes/Content/Sound/3-IKnowGod/LPC/1.2a1.2.lpc'  "	"LPCEditor open"	| cnt data fram |	data := UninterpretedBytes new: filesize.	self longAt: 1 put: 28 in: data.			"header size"	self longAt: 2 put: 2399 in: data.		"magic #"	self longAt: 3 put: npoles in: data.	self longAt: 4 put: nframes in: data.	self floatAt: 5 put: frate in: data.	self floatAt: 6 put: srate in: data.	self floatAt: 7 put: duration value in: data.	cnt := 8.	[1 to: frames size do:			" main write loop"		[ :i |		fram := frames at: i.		self floatAt: cnt      put: fram rmsR in: data.		self floatAt: cnt + 1 put: fram rmsO in: data.		self floatAt: cnt + 2 put: fram err in: data.		self floatAt: cnt + 3 put: fram pitch in: data.		cnt := cnt + 3.		1 to: npoles * 2 do:			[ :j | self floatAt: cnt + j put: (fram coefficients at: j) in: data].		cnt := cnt + (npoles * 2) + 1]] 			on: Error			do: [ :ignored | ].	aStream nextPutAll: data asByteArray! !!Siren.LPCSound methodsFor: 'statistics'!gatherStatistics	"Compute the max and min-non-0 pitch values for later."	| val pMax pMin rMax rMin reMax reMin |	pMax := frames first pitch.	pMin := frames first pitch.	rMax := frames first pitch.	rMin := frames first pitch.	reMax := frames first pitch.	reMin := frames first pitch.	2 to: frames size do:			" main read loop"		[ :i |		val := (frames at: i) pitch.		(val > pMax) ifTrue: [pMax := val].		((val < pMin) & (val > 0.0)) ifTrue: [pMin := val].		val := (frames at: i) rmsO.		(val > rMax) ifTrue: [rMax := val].		(val < rMin) ifTrue: [rMin := val].		val := (frames at: i) rmsR.		(val > reMax) ifTrue: [reMax := val].		(val < reMin) ifTrue: [reMin := val]].	pitchRange := pMin to: pMax.	rmsRange := rMin to: rMax.	residRange := reMin to: reMax.! !!Siren.LPCSound class methodsFor: 'instance creation'!fromFile: filename	"Read in an lpc sound from the given Csound format file."	"LPCSound fromFile: '1.2a1.2.lpc'  "	"LPCEditor openOn: LPCSound someInstance"	"LPCEditor openOn: (LPCSound fromFile: '1.2a1.2.lpc')"	"LPCSound instanceCount"	"LPCSound allInstances""	#define LP_MAGIC    999	#define LP_MAGIC2   2399                   /* pole file type */	#define LPBUFSIZ    4096           /* in lpanal */	#define MAXWINDIN   1000           /* for 10ms hops at 50 KC */	#define MAXPOLES    50	#define NDATA       4   /* number of data values stored with frame */	typedef struct {	        long    headersize, lpmagic, npoles, nvals;	        MYFLT   framrate, srate, duration;	        char    text[4];	} LPHEADER;      coef[0] = (MYFLT)rms2;		// resid rms      coef[1] = (MYFLT)rms1;		// orig rms	      coef[2] = (MYFLT)errn;		// err val      if (lpc.doPitch)					// pitch        coef[3] = getpch(csound, sigbuf);"	| rec inst hdrsiz magic npoles nvals frate srate dur cnt data fram |	inst := self new.	data := UninterpretedBytes from: (SirenUtility findFile: filename) asFilename contentsOfEntireFile.	hdrsiz := inst long: 1 from: data.	magic := inst long: 2 from: data.	npoles := inst long: 3 from: data.	nvals := inst long: 4 from: data.	frate := inst float: 5 from: data.	srate := inst float: 6 from: data.	dur := inst float: 7 from: data."end of header"	(hdrsiz = 28) ifFalse: [self error: 'bad file header size'].	(magic = 2399) ifFalse: [self error: 'bad file magic number'].	inst filename: filename.	inst filesize: data sizeInBytes.	inst npoles: npoles.	inst srate: srate.	inst frate: frate.	inst nframes: nvals.	inst duration: dur.	inst frames: (OrderedCollection new: nvals).	cnt := 8.	[1 to: nvals do:			" main read loop"		[ :i |		fram := LPCFrame new.		fram rmsR: (inst float: cnt from: data).		fram rmsO: (inst float: cnt + 1 from: data).		fram err: (inst float: cnt + 2 from: data).		fram pitch: (inst float: cnt + 3 from: data).		rec := Array new: npoles * 2.		cnt := cnt + 3.		1 to: npoles * 2 do:			[ :j | rec at: j put: (inst float: cnt + j from: data)].		fram coefficients: rec.		inst addFrame: fram.		cnt := cnt + (npoles * 2) + 1]]			on: Error			do: [ :ignored | ].	inst gatherStatistics.	^inst! !!Siren.RatioMagnitude methodsFor: 'accessing'!realValue	"Answer the receiver's value mapped to the receiver."	^value!value	"Answer the receiver's value mapped to the receiver."	^relative == nil		ifTrue: [value]		ifFalse: [self class new value: (relative value * value)]! !!Siren.RatioMagnitude methodsFor: 'converting'!asRatio	"Answer self."	^self!map	"Apply the receivers reference."	relative == nil		ifFalse: [value := value * relative value.				relative := nil]!relativeTo: aRelative	"Set the receivers reference."	relative := aRelative! !!Siren.RatioMagnitude class methodsFor: 'instance creation'!value: aValue relative: aMMagnitude	"Answer and instance with the argument as its value."	^(self new value: aValue) relativeTo: aMMagnitude! !!Siren.RatioLoudness methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a ratio."	aStream nextPutAll: "'a:'," value printString! !!Siren.RatioLoudness methodsFor: 'converting'!asDB	"Answer a dB loudness; ratio 1 = 0dB, ratio 0.5 = -6dB, etc."	"(RatioLoudness value: 0.25) asDB"	^DBLoudness new value: (20 * (value log))!asMIDI	"Answer a MIDI key velocity (0 to 127)"		^MIDIVelocity new value: ((value * 127.0) asInteger)!asSymbol	"Answer a symbolic dynamic."		^(self asMIDI) asSymbol! !!Siren.RatioLoudness methodsFor: 'private'!species	"Answer Amplitude."	^Amplitude! !!Siren.RatioLoudness class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asAmpl! !!Siren.DBLoudness methodsFor: 'converting'!asMIDI	"Answer a MIDI key velocity (0 to 127)"		^self asRatio asMIDI!asRatio	"Answer the receiver as a ratio between 0 and 1."	"-12 dB asRatio"	^RatioLoudness new value: (10 raisedTo: (value / 20))!positiveDB	"Answer the zero-based positive dB value of the receiver."	"90 dB = 32000"	"0 = 90		-6 = 80		-12 = 70"	^90 + (value / 0.6)! !!Siren.DBLoudness methodsFor: 'printing'!units	"Answer the units string of the receiver."	^' dB'! !!Siren.DBLoudness methodsFor: 'double dispatch'!differenceFromDynamic: aDyn	"Subtract the argument from the receiver after turning both into db."	^DBLoudness value: (self value - aDyn asDB value)!differenceFromVelocity: aDyn	"Subtract the argument from the receiver after turning both into db."	^DBLoudness value: (self value - aDyn asDB value)!productFromDynamic: aDyn	"Multiply the argument by the receiver after turning both into db."	^DBLoudness value: (self value * aDyn asDB value)!productFromVelocity: aDyn	"Multiply the argument by the receiver after turning both into db."	^DBLoudness value: (self value * aDyn asDB value)!quotientFromDynamic: aDyn	"Divide the argument by the receiver after turning both into db."	^DBLoudness value: (self value / aDyn asDB value)!quotientFromVelocity: aDyn	"Divide the argument by the receiver after turning both into db."	^DBLoudness value: (self value / aDyn asDB value)!sumFromDynamic: aDyn	"Add the argument to the receiver after turning both into db."	^DBLoudness value: (self value + aDyn asDB value)! !!Siren.DBLoudness methodsFor: 'private'!species	"Answer Amplitude."	^Amplitude! !!Siren.DBLoudness class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asDB! !!Siren.SoundEditor methodsFor: 'interaction'!copy	"Copy the current selection into the temporary copy buffer."	| selSnd |	selSnd := self selectedSound.	selSnd == nil		ifFalse: [copyBuffer := selSnd]!cut	"Cut out the current selection."	undoSound := sound.	sound := sound cutFrom: self selectionStart to: self selectionStop.	self changed.!file	"Save the receiver's sound to a file."	| name |	name := Dialog		request: 'Save copy buffer to:' 		initialAnswer: sound name.	name = '' ifTrue: [^nil].	copyBuffer == nil		ifTrue: [(SoundFile named: name) saveSound: self selectedSound]		ifFalse: [(SoundFile named: name) saveSound: copyBuffer].!newCopy	"Make a fresh copy of the receiver's model's sound."	self setModel: sound copy!play	"Play the receiver's sound"	((self selection1 ~~ nil) and: [self selection2 ~~ nil])		ifTrue: [SoundPort default playSamples: sound samples				rate: sound rate chans: sound channels 				from: (sound mapSampleIndex: self selection1) * sound sampleSize - 1				to: (sound mapSampleIndex: self selection2) * sound sampleSize - 1]		ifFalse: [changed 			ifTrue: [SoundPort default playSamples: sound samples					rate: sound rate chans: sound channels 					from: 1					to: sound samples sizeInBytes]			ifFalse: [sound play]]!playAll	"Play the receiver's sound"	sound play!playSelection	"Play the receiver's sound"	((self selection1 ~~ nil) and: [self selection2 ~~ nil])		ifTrue: [SoundPort default play: sound from: self selection1 to: self selection2]		ifFalse: [self playAll]!spawn	"Open a soundfile editor."	SoundView openOn: sound! !!Siren.SoundEditor methodsFor: 'accessing'!clearMarkers	"Flush the selection and markers"	markers := OrderedCollection new.	selections := Array new: 2.	self changed!list	^nil!mark: aSampleNumber	"Set the receiver's model"	markers == nil ifTrue: [markers := Dictionary new].	markers at: aSampleNumber printString asSymbol put: aSampleNumber!markChanged: aBoolean	"Set the flag to tell the receiver that the model's been changed."	changed := aBoolean!markers	"Answer the receiver's markers"	^markers!markers: aCollection	"Set the receiver's marker collection."	markers := aCollection!selection1	"Answer the receiver's primary selection."	selections isEmpty ifTrue: [^nil].	^selections at: 1!selection1: anInteger	"Set the receiver's primary selection."	selections at: 1 put: anInteger!selection2	"Answer the receiver's 2nd-ary selection."	selections isEmpty ifTrue: [^nil].	^selections at: 2!selection2: anInteger	"Set the receiver's secondary selection."	selections at: 2 put: anInteger!selectionStart	^self selection1 min: self selection2!selectionStop	^self selection1 max: self selection2!setModel: aModel	"Set the receiver's model."	self reinitialize.	super setModel: aModel.	self changed: #text!size	^sound size!sound	"Answer the receiver's model"	^sound!sound: aSound	"Set the receiver's model to be the given sound"	sound == nil ifFalse: [sound release]."	self reinitialize."	sound := aSound!view: aView	"Set the receiver's view to be the given view"	view := aView! !!Siren.SoundEditor methodsFor: 'initialize release'!initialize	"Set up the proper default values for the receiver."	markers := OrderedCollection new.	selections := Array new: 2.	changed := false!reinitialize	"Set up the proper default values for the receiver."	markers := OrderedCollection new.	selections := Array new: 2.	lastSelection := undoSound := copyBuffer := nil.	changed := false.	self changed! !!Siren.SoundEditor methodsFor: 'selection'!select: cursorX	"Take a mouse point and place a marker on the sound sample there."	|selection |	selection := (view sampleForX: cursorX).	view showMarkerAt: cursorX."	Transcript show: cursorX printString, ' --> ', selection printString; cr."	markers add: selection.	self selection1 == nil		ifTrue: [selections at: 1 put: selection]		ifFalse: [selections at: 2 put: selection]!selectedSound	"Answer a sound from the receiver view's selection."	| s |	((self selection1 == nil) or: [self selection2 == nil])		ifTrue: [^nil].	Cursor wait showWhile:		[s := sound fromSample: self selection1 toSample: self selection2].	^s!setSelection: aMarker	"Set the primary selection to be the given marker."	lastSelection = self selection2		ifFalse: [selections at: 2 put: aMarker.				lastSelection := aMarker]		ifTrue: [selections at: 1 put: aMarker.				lastSelection := aMarker].	((self selection1 == nil) or: [self selection2 == nil])		ifTrue: [^self].	self selection1 > self selection2		ifTrue: [ | temp |			temp := self selection1.			selections at: 1 put: self selection2.			selections at: 2 put: temp].	view invalidate! !!Siren.SoundEditor class methodsFor: 'instance creation'!new	"Answer an initialized instance."	^super new initialize! !!Siren.SoundController methodsFor: 'menu messages'!clearMarkers: ignored	"Flush the selection and markers"	model clearMarkers!copy	"copy the selected sound"	model copy!cut	"cut the selected segment out of the receiver's model sound"	model cut!doInspect	"Inspect the view."	model inspect!fadeIn	"Apply a ramp fade-in envelope to the receiver's sound."	| time |	time := Number readFrom: 		(ReadStream on: 			(Dialog request: 'Fade-in time' 					initialAnswer: '0.1')).	(time between: 0.001 and: 2.0) ifFalse: [^nil].	Cursor execute showWhile:		[model sound fadeInOver: time.		view redraw.		model markChanged: true]!fadeOut	"Apply a ramp fade-out envelope to the receiver's sound."	| time |	time := Number readFrom: 		(ReadStream on: 			(Dialog request: 'Fade-out time' 					initialAnswer: '0.1')).	(time between: 0.001 and: 2.0) ifFalse: [^nil].	Cursor execute showWhile:		[model sound fadeOutOver: time.		view redraw.		model markChanged: true]!file: ignored	"Open the file dialog"	model file!inspect: ignored	"Inspect the view."	model inspect!menu	^Menu		labelList: #(('play all' 'play selection') (copy cut paste) (accept cancel) (spawn inspect) 				('vertical scale' 'horizontal scale') ('fade in' 'fade out')(reset))		values: #(playAll playSelection copy cut paste 				accept cancel spawn doInspect				setVscale setHscale 				fadeIn fadeOut reset)!newCopy: ignored	"Make a fresh copy of the receiver's model's sound."	model newCopy!paste	"paste the selected sound into the model at the current selected marker"	model paste!play: ignored	"play the model"	model play!playAll	"play the model"	model play!playSelection	"play the model"	model playSelection!reset	"Clear the model's selections and markers"	model reinitialize!save	"Save a copy of the model to the disk."	model save!setHscale	"set the horizontal scale of the view"	| newStep |	newStep := Number readFrom: 		(ReadStream on: 			(Dialog request: 'New horizontal scale?' 					initialAnswer: view step printString)).	(newStep between: 1 and: 10000) ifFalse: [^nil].	view step: newStep.	view redraw!setVscale	"set the vertical scale of the view"	| newScale |	newScale := Number readFrom: 		(ReadStream on: 			(Dialog request: 'New vertical scale?'					initialAnswer: view scale printString)).	(newScale between: 1 and: 1000) ifFalse: [^nil].	view scale: newScale.	view redraw!spawn	"Edit a copy of the model."	model spawn! !!Siren.SoundController methodsFor: 'control defaults'!redButtonActivity	"set a marker with the red button"	| pt |	pt := self sensor cursorPoint.	self sensor waitNoButton.	pt y < 16		ifTrue: [^self selectMarkerAt: pt x].	model select: pt x!selectMarkerAt: x	"Select the marker at the given x value."	| markers sel |	markers := model markers.	sel := markers		detect: [ :m | ((view xForSample: m) - x) abs <= 8]		ifNone: [^nil].	model setSelection: sel! !!Siren.SoundController methodsFor: 'event driven'!exitEvent: anEvent 	"redraw the view to clear the position display."	super exitEvent: anEvent.	view invalidate!mouseMovedEvent: aMouseMovedEvent	view displayPosition: (self sensor cursorPointFor: aMouseMovedEvent)!redButtonPressedEvent: event	"set a marker with the red button"	| pt |	pt := event point.	self sensor waitNoButton.	pt y < 16		ifTrue: [^self selectMarkerAt: pt x].	model select: pt x! !!Siren.Duration class methodsFor: 'class constants'!color	"Answer the default color to display instances with."	^ColorValue red!initialize	"Set up the class inst var, a generality table."	"Duration initialize"	"Duration generalize: (100 msec) and: ((1/4) beat)"	"Duration generalize: (100 msec) and: (0.3 sec)"	generalityTable :=		((SecondDuration -> 80),		(RatioDuration -> 60),		(MSecondDuration -> 40),		(ConditionalDuration -> 0))!initializeGeneralities	"Set up the class inst var, a generality table."	"Duration initializeGeneralities"	"Duration generalize: (100 msec) and: ((1/4) beat)"	"Duration generalize: (100 msec) and: (0.3 sec)"	generalityTable :=		((SecondDuration -> 80),		(RatioDuration -> 60),		(MSecondDuration -> 40),		(ConditionalDuration -> 0))!mostGeneral	"Answer the most general-purpose duration--seconds"	^#asSec!propertyName	"Answer the receiver class's default property name."	^#duration:!relativeMember	"Answer the receiver class's species member used as a relative magnitude."	^RatioDuration!species	"Answer Duration."	^Duration! !!Siren.Duration class methodsFor: 'examples'!example	"Print a simple message to the transcript demonstrating the various types."	"Duration example"	| me |	me := Duration value: 1/4.	Transcript show: me printString; cr;		show: me asMS printString; cr.	me inspect! !!Siren.Duration class methodsFor: 'instance creation'!value: aValue	"Answer a new instance of a member of my species."	| number |	aValue species == Duration ifTrue: [^aValue].	(aValue isMemberOf: SmallInteger)		ifTrue: [aValue < 10			ifTrue: [^SecondDuration new value: aValue]			ifFalse: [^MSecondDuration new value: aValue]].	(aValue isKindOf: LimitedPrecisionReal)		ifTrue: [^SecondDuration new value: aValue].	(aValue isMemberOf: Fraction)		ifTrue: [^RatioDuration new value: aValue].	(aValue isKindOf: String)		ifTrue: [number := Number readFrom: (ReadStream on: aValue).			number = 0 ifTrue: [^self error: 'Unknown duration value.'].			^Duration value: number].	(aValue isMemberOf: BlockContext)		ifTrue: [^ConditionalDuration new value: aValue]."	^self error: 'Unknown duration type.'"	^aValue! !!Siren.EventAssociation methodsFor: 'comparing'!< anAssociation 	"Handle events, associations, and time/order sorting."	anAssociation isAssociation		ifFalse: [^value < anAssociation].	key ifNil:		[anAssociation key ifNil:			[^((key order) < (anAssociation order))]].	^key < anAssociation key!= anAssociation	"If the argument's not an association, compare it to the receiver's value, otherwise answer whether the receiver's key and value are both equal to the argument's."	(anAssociation isAssociation)		ifFalse: [^value = anAssociation].	key = anAssociation key		ifTrue: [^value = anAssociation value]		ifFalse: [^false]! !!Siren.EventAssociation methodsFor: 'accessing'!, anArgument	"Add the argument as a property of the receiver."	"((0 beat) => (1/16 beat,  'c3' pitch)),	  ((1/16 beat) => (1/16 beat, 'b2'  pitch))"	^EventList new add: self; add: anArgument!event	"Answer the receiver's event (value)."	^self value!start	"Answer the receiver's start (key)."	^self key!start: aTime	"Set the receiver's start (key)."	self key: (Duration value: aTime)!stop	"Answer the stop time of the event association."	^self start + self event duration!time	"Answer the receiver's start (key)."	^self key! !!Siren.EventAssociation methodsFor: 'printing'!printOn: aStream 	"Append to the argument, aStream, the two elements of the 	EventAssociation separated by a double-right arrow (=>)."	key printOn: aStream.	aStream nextPutAll: ' => '.	value printOn: aStream! !!Siren.SoundCanvas methodsFor: 'aspects'!container: ignored!hZoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^hZoom isNil		ifTrue:			[hZoom := 1 asValue]		ifFalse:			[hZoom]!preferredBounds	^soundView preferredBounds!setComponent: aComponent	"Set the receiver's component part"	componentPart := aComponent!vZoom	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^vZoom isNil		ifTrue:			[vZoom := 0.5 asValue]		ifFalse:			[vZoom]! !!Siren.SoundCanvas methodsFor: 'initialize'!createSoundView	"Create and answer the receiver's sound view"	"SoundCanvas open"	soundView := SoundView soundViewOn: SampledSound new."	componentPart == nil		ifTrue: [componentPart := DisplayListView componentOnList: displayList]."! !!Siren.SoundCanvas methodsFor: 'actions'!flushCoordinateCaches	"ignored"!zoomToZero	"This stub method was generated by UIDefiner"	^self! !!Siren.SirenUtility class methodsFor: 'class initialization'!initialize	"Edit these to taste for your installation."	"SirenUtility initialize. SirenSession initialize"	"SirenUtility dataDir"	"SirenSession eventLists"	"SirenUtility findFile: 'tuba'"	"See also system-dependent setup in SirenUtility>>playSoundFile"	| sirenDir |	DefaultMIDIIn := 1.			"Tune these to your setup"	DefaultMIDIOut := 2.	DefaultOSCHost := #[127 0 0 1].	DefaultOSCPort := 54321.	PortModel initialize.	Verbosity := 1.				"0 = pretty silent;								 1 = medium-verbose; 								 2 = full scheduler and interface logging"	LoggingStream = nil.			"logging output file"								"Look for Siren data and set search paths"	sirenDir := SirenUtility findDir: 'Siren_9.0' tryHard: true.	sirenDir ifNil: [self error: 'Cannot find Siren release folder'].	sirenDir := sirenDir, Filename separatorString.	ScoreDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Scores"	self addDir: 'Scores' to: ScoreDir.	self addDir: 'MIDI' to: ScoreDir.	SoundDir := OrderedCollection with: (sirenDir, 'Data') asSymbol.	"Sound files"	self addDir: 'Sound' to: SoundDir.	self addDir: 'Samples' to: SoundDir.	self addDir: 'SHARC/*' to: SoundDir.					"You can add using wildcards""	self addDir: 'Databases/*' to: SoundDir."				"STP-specific"	DataDir := OrderedCollection new.	DataDir addAll: ScoreDir.	DataDir addAll: SoundDir.	DataDir :=   DataDir asSet asOrderedCollection.	SirenSession initialize								"Session setup"!postLoad: aParcel	"Load the missing pieces and put up a dialog after loading the parcel"	| book text found |	Transcript show: 'Loading the MusicConstants from the web'; cr.	found := true.	['MusicConstants.st' asFilename fileIn] 		on: Error do: [ :ex | found := false].	found ifFalse: [	[('Siren7.5', Filename separatorString, 'MusicConstants.st') asFilename fileIn]		on: Error do: [ :ex | Transcript tab; show: 'Cannot find file Siren7.5/MusicConstants.st.'; cr]].	Transcript tab; show: 'done.'; cr.	found := true.	[(ListWorkBook new loadFromBoss: 'Siren7.5.Workbook.bos') open]		on: Error		do: [ :ex | found := false].	found ifFalse: [	[(ListWorkBook new loadFromBoss: 						('Siren7.5', Filename separatorString, 'Siren7.5_Workbook.bos')) open]		on: Error		do: [ :ex | Transcript tab; show: 'Cannot find file Siren7.5/Siren7.5.Workbook.bos.'; cr.			found := false]].	text := 'Welcome to Siren!!To use the package more fully, you should down-load the support files (Siren7.5.zip) from the Siren web site at http://FASTLabInc.com/Siren. These include an additional file-in of icons and constants (MusicConstants.st -- I just tried to file it in) as well as a documentation workbook (see below) as well as the external DLLCC files for using the sound and MIDI I/O facilities, and the CSL and Loris interfaces.To load the MusicConstants from the web,	''Siren7.5/MusicConstants.st'' asFilename fileIn.To load the Siren workbook from the web (in case you haven''t downloaded the Siren zip file), do this,	[(ListWorkBook new loadFromBoss: ''Siren7.5/Siren7.5.Workbook.bos'') open]Enjoy!!Stephen PopeSanta Barbara, May, 2007'.	book := ListWorkBook new		replaceAllTextPagesWith: (WorkspacePage 			labeled: (#installationWorkspace << #labels >> 'Siren Instructions')			on: (text asValue));		yourself.	book open! !!Siren.SirenUtility class methodsFor: 'scripts'!audiofileInsertsToUpdate: sql to: outN	"Convert an SQL insert to a delete"	"533937, '/SFX/Video objects/Gunshots and Explosions/Gunshots', 'X0027748_Heat - Gunshots_62.aiff', 'X' ); " | inp out ind path nam typ |inp := (Filename named: sql) readStream.out := (Filename named: outN) writeStream.Transcript clear.[inp atEnd] whileFalse:	[ind := inp upTo: $,.	inp upTo: $'.	path := inp upTo: $,.	inp skip: 2.	nam := inp upTo: $,.	inp skip: 2.	typ := inp upTo: $ .	inp upTo: Character cr.	out nextPutAll: 'update AudioFiles set Path = ''', path, ' File_name = ''', nam, ' Short_name = ''', typ, 		' where  Audio_file_id = ', ind, ';'; cr].inp close.out close."SirenUtility audiofileInsertsToUpdate: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/AudioFileInserts2.txt' 	to: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/AudioFileInserts2b.txt' "!collectGenreHistogramsStartingAt: ind	"Collect 100 genre histograms for the given seed song"	"SirenUtility collectGenreHistogramsStartingAt: '7080'" "Classical"	| arg reply strm coll dict |	arg := ind.	dict := IdentityDictionary new.	100 timesRepeat:		[reply := SirenUtility exploreRecommendationFor: arg.		SirenUtility genreHistogramOf: reply into: dict.		strm := (ReadStream on: reply).		strm upTo: Character cr.		arg := strm upTo: $ "space"]."Now sort and print the dict"	coll := OrderedCollection new.	dict keysAndValuesDo:		[ :k :v |		coll add: (v -> k)].	coll sort: [:a :b | a > b].	Transcript clear.	coll do: [ :it | Transcript show: it value asString, ' - ', it key printString; cr]!compareFileLists: sql and: files to: outN	"compare a file with the list of SQL records and the list of all files." | inp lin fnd nfnd out |inp := (Filename named: sql) readStream.out := (Filename named: outN) writeStream.Transcript clear.fnd := 0.nfnd := 0.[inp atEnd] whileFalse:	[lin := inp upTo: Character cr.	(Filename named: '/Volumes/Media/CoreDataSets', lin) exists		ifTrue: [fnd := fnd + 1]		ifFalse: [nfnd := nfnd + 1. 				out nextPutAll: lin; cr]].inp close.out close.Transcript show: 'Done'; crtab; show: fnd printString, ' found, '; crtab; show: nfnd printString, ' not found'; cr"SirenUtility compareFileLists: '/Volumes/Media/CoreDataSets/names.txt' 	and: '/Volumes/Media/CoreDataSets/list-all.txt'	to: '/Volumes/Media/CoreDataSets/missing-files.txt' "!convertAFInserts: fil	"make a delete out of an insert"	"INSERT INTO AudioFiles(Path, File_name, Short_name) VALUES ( '/Samples/Drums/BFD2/Audio/DW Collectors/Kick/Hit', 'S0051820_master01.wav', 'S' );"	| inp lin |	inp := (Filename named: fil) readStream.	Transcript clear.	[inp atEnd] whileFalse:		[lin := ReadStream on: (inp upTo: Character cr).		3 timesRepeat: [lin upTo: $, ].		lin skip: 2.		Transcript show: 'DELETE FROM AudioFiles where file_name like: ''%', (lin upTo: $'), ''''; cr]"SirenUtility convertAFInserts: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/AF_inserts.sql'"!convertEtDrScore: string	"make a delete out of an insert"	"convertEtDrScore:"	| inp lin tim nam sec times names tval |	inp := string asFilename readStream.	Transcript clear.	times := OrderedCollection new.	names := OrderedCollection new.	[inp atEnd] whileFalse:		[lin := ReadStream on: (inp upTo: Character cr).		(lin peek == $	) ifTrue: 			"if it starts with a tab"			[lin next.			tim := lin upTo: $	 "tab".		"read time"			tval := (tim copyFrom: 3 to: 4) asNumber.			tim first == $1 ifTrue: [tval := tval + 60].			3 timesRepeat: [lin upTo: $	 "tab"].		"skip to next"			nam := lin upToEnd.			times addLast: tval.			names addLast: (sec, '-', nam)."			Transcript show: tval printString, ' -> ', sec, '-', nam; cr"		] ifFalse: [sec := lin upTo: $  "space" ]].			Transcript cr; show: '{ '.	times do: [ :t | Transcript show: t printString, ', '].	Transcript show: '} '; cr; show: '{ '.	names do: [ :n | Transcript show: '"', n , '", '].	Transcript show: '} '; cr.	Transcript show: times size printString; cr."	times size timesRepeat: [ Transcript show: ""SirenUtility convertEtDrScore: '/Volumes/Content/Video/3 EternalDream/Doc/EtDr_score.txt' "!dropColumn1From: inFile to: outFile	"Filter columns out of a CSV file"	"SirenUtility dropColumn1From: '/Volumes/Content/Code/Python/SndsLike/FSongs3b.csv' 		to: '/Volumes/Content/Code/Python/SndsLike/FSongs3c.csv' "	| inp line out cnt |	inp := (Filename named: inFile) readStream.	out := (Filename named: outFile) writeStream.	Transcript clear.	cnt := 0.	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		line upTo: $,.		line skipSeparators.		out nextPutAll: line upToEnd; cr.		cnt := cnt + 1.		((cnt \\ 1000) = 0) ifTrue:			[Transcript show: cnt printString; cr]].	inp close.	out close.	Transcript show: 'Done: ', cnt printString, ' items copied.'; cr!dropColumnsFrom2: inFile to: outFile drop: drop	"Filter columns out of a CSV file"	"Keep genre in this example"	"SirenUtility dropColumnsFrom2: '/Volumes/Content/Code/Python/SndsLike/SSongs3.csv' 		to: '/Volumes/Content/Code/Python/SndsLike/SSongs3_b.csv' 		drop: #(version OID name file format comment title artist album year bit_rate frame_rate duration Dummy) "	"SirenUtility filterGenresFrom: '/Volumes/Content/Code/Python/SndsLike/S3Songs_b.csv' 			to: '/Volumes/Content/Code/Python/SndsLike/S3Songs_c.csv' 			keep: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-hist-keep.txt' "	| inp line tok cols out inds cnt fCnt lCnt |	inp := (Filename named: inFile) readStream.	out := (Filename named: outFile) writeStream.	Transcript clear."Read the first line to get the list of fields"	line := ReadStream on: (inp upTo: Character cr).	cols := OrderedCollection new.	[line atEnd] whileFalse:		[cols addLast: (line upTo: $,) asSymbol.		line skipSeparators]."Go through the list of fields to drop and make a list of indeces"	inds := OrderedCollection new.	1 to: cols size do:		[ :ind |		(drop includes: (cols at: ind))		ifTrue: [inds addLast: ind.			Transcript show: ind printString; space]]."Iterate over the lines dropping the fields"	Transcript cr.	lCnt := 0.	fCnt := 0.	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		cnt := 1.		[line atEnd] whileFalse:			[tok := (line upTo: $,).			line skipSeparators."Handle string tokens with embedded commas"			[(tok first == $") and: [tok last ~= $"]] whileTrue: [tok := tok, (line upTo: $,)].			(inds includes: cnt) ifFalse:"Remove quotes from numerical data"				[(tok size >= 3) ifTrue:					[ | ch |					ch := tok at: (tok size - 1).					(tok first == $ ) ifTrue: [tok := tok copyFrom: 2 to: tok size].					((tok first == $") and: [ch isDigit]) ifTrue: [tok := tok copyFrom: 2 to: tok size].					((tok last == $") and: [ch isDigit]) ifTrue: [tok := tok copyFrom: 1 to: tok size - 1].					(tok sameAs: 'None') ifTrue: [tok := 'NaN']]."Write out the included ones"				out nextPutAll: tok asString, ', ' ].			cnt := cnt + 1].		out nextPut: Character cr.		(fCnt = 0) ifTrue: [fCnt := cnt].		(fCnt = cnt) ifFalse: [Transcript show: 'Strange field count: ', cnt printString, ' ~= ', fCnt printString, 				' in line ', lCnt printString ; cr].		lCnt := lCnt + 1.		((lCnt \\ 1000) = 0) ifTrue:			[Transcript show: lCnt printString; cr]].	inp close.	out close.	Transcript show: 'Done: ', lCnt printString; cr."Here are the 424 fields of version 120712""version name file format labels title artist album year genre bit_rate frame_rate duration peakAvg peakVar peakVar2 peakDel peakDel2 rmsAvg rmsVar rmsVar2 rmsDel rmsDel2 lp_rmsAvg lp_rmsVar lp_rmsVar2 lp_rmsDel lp_rmsDel2 hp_rmsAvg hp_rmsVar hp_rmsVar2 hp_rmsDel hp_rmsDel2 dyn_rangeAvg dyn_rangeVar dyn_rangeVar2 dyn_rangeDel dyn_rangeDel2 stereoAvg stereoVar stereoVar2 stereoDel stereoDel2 chroMaxAvg chroMaxVar chroMaxVar2 chroMaxDel chroMaxDel2 chroWhtAvg chroWhtVar chroWhtVar2 chroWhtDel chroWhtDel2 spectCentAvg spectCentVar spectCentVar2 spectCentDel spectCentDel2 spectRollAvg spectRollVar spectRollVar2 spectRollDel spectRollDel2 spectSpreadAvg spectSpreadVar spectSpreadVar2 spectSpreadDel spectSpreadDel2 spectSkewAvg spectSkewVar spectSkewVar2 spectSkewDel spectSkewDel2 spectKurtAvg spectKurtVar spectKurtVar2 spectKurtDel spectKurtDel2 spectSlopeAvg spectSlopeVar spectSlopeVar2 spectSlopeDel spectSlopeDel2 spectVarAvg spectVarVar spectVarVar2 spectVarDel spectVarDel2 harmonicityAvg harmonicityVar harmonicityVar2 harmonicityDel harmonicityDel2 inharmonicityAvg inharmonicityVar inharmonicityVar2 inharmonicityDel inharmonicityDel2 harmonicCentAvg harmonicCentVar harmonicCentVar2 harmonicCentDel harmonicCentDel2 loud quiet decay held fp_gravity fp_bass fp_focus bh_lowpeakamp bh_midpeakamp bh_highpeakamp bh_lowpeakBPM bh_midpeakBPM bh_highpeakBPM bh_pdcentroid1 bh_pdcentroid2 bh_pdspread1 bh_pdspread2 bh_tempo beat_peaks beat_slope beat_weight beat_sum beat_height beat_hist_rat0 beat_hist_rat1 beat_hist_rat2 beat_hist_rat3 beat_max bands0Avg bands0Var bands0Var2 bands0Del bands0Del2 bands1Avg bands1Var bands1Var2 bands1Del bands1Del2 bands2Avg bands2Var bands2Var2 bands2Del bands2Del2 bands3Avg bands3Var bands3Var2 bands3Del bands3Del2 drums0Avg drums0Var drums0Var2 drums0Del drums0Del2 drums1Avg drums1Var drums1Var2 drums1Del drums1Del2 drums2Avg drums2Var drums2Var2 drums2Del drums2Del2 drums3Avg drums3Var drums3Var2 drums3Del drums3Del2 drums4Avg drums4Var drums4Var2 drums4Del drums4Del2 drums5Avg drums5Var drums5Var2 drums5Del drums5Del2 drums6Avg drums6Var drums6Var2 drums6Del drums6Del2 mfcc0Avg mfcc0Var mfcc0Var2 mfcc0Del mfcc0Del2 mfcc1Avg mfcc1Var mfcc1Var2 mfcc1Del mfcc1Del2 mfcc2Avg mfcc2Var mfcc2Var2 mfcc2Del mfcc2Del2 mfcc3Avg mfcc3Var mfcc3Var2 mfcc3Del mfcc3Del2 mfcc4Avg mfcc4Var mfcc4Var2 mfcc4Del mfcc4Del2 mfcc5Avg mfcc5Var mfcc5Var2 mfcc5Del mfcc5Del2 mfcc6Avg mfcc6Var mfcc6Var2 mfcc6Del mfcc6Del2 mfcc7Avg mfcc7Var mfcc7Var2 mfcc7Del mfcc7Del2 mfcc8Avg mfcc8Var mfcc8Var2 mfcc8Del mfcc8Del2 mfcc9Avg mfcc9Var mfcc9Var2 mfcc9Del mfcc9Del2 mfcc10Avg mfcc10Var mfcc10Var2 mfcc10Del mfcc10Del2 mfcc11Avg mfcc11Var mfcc11Var2 mfcc11Del mfcc11Del2 mfcc12Avg mfcc12Var mfcc12Var2 mfcc12Del mfcc12Del2 chromaW0 chromaW1 chromaW2 chromaW3 chromaW4 chromaW5 chromaI0 chromaI1 chromaI2 chromaI3 ssdBandMean1 ssdBandMean2 ssdBandMean3 ssdBandMean4 ssdBandMean5 ssdBandMean6 ssdBandMean7 ssdBandMean8 ssdBandMean9 ssdBandMean10 ssdBandMean11 ssdBandMean12 ssdBandMean13 ssdBandMean14 ssdBandMean15 ssdBandMean16 ssdBandMean17 ssdBandMean18 ssdBandMean19 ssdBandMean20 ssdBandMean21 ssdBandMean22 ssdBandMean23 ssdBandVar1 ssdBandVar2 ssdBandVar3 ssdBandVar4 ssdBandVar5 ssdBandVar6 ssdBandVar7 ssdBandVar8 ssdBandVar9 ssdBandVar10 ssdBandVar11 ssdBandVar12 ssdBandVar13 ssdBandVar14 ssdBandVar15 ssdBandVar16 ssdBandVar17 ssdBandVar18 ssdBandVar19 ssdBandVar20 ssdBandVar21 ssdBandVar22 ssdBandVar23 ssdBandSkew1 ssdBandSkew2 ssdBandSkew3 ssdBandSkew4 ssdBandSkew5 ssdBandSkew6 ssdBandSkew7 ssdBandSkew8 ssdBandSkew9 ssdBandSkew10 ssdBandSkew11 ssdBandSkew12 ssdBandSkew13 ssdBandSkew14 ssdBandSkew15 ssdBandSkew16 ssdBandSkew17 ssdBandSkew18 ssdBandSkew19 ssdBandSkew20 ssdBandSkew21 ssdBandSkew22 ssdBandSkew23 ssdBandKurt1 ssdBandKurt2 ssdBandKurt3 ssdBandKurt4 ssdBandKurt5 ssdBandKurt6 ssdBandKurt7 ssdBandKurt8 ssdBandKurt9 ssdBandKurt10 ssdBandKurt11 ssdBandKurt12 ssdBandKurt13 ssdBandKurt14 ssdBandKurt15 ssdBandKurt16 ssdBandKurt17 ssdBandKurt18 ssdBandKurt19 ssdBandKurt20 ssdBandKurt21 ssdBandKurt22 ssdBandKurt23 ssdBandMedian1 ssdBandMedian2 ssdBandMedian3 ssdBandMedian4 ssdBandMedian5 ssdBandMedian6 ssdBandMedian7 ssdBandMedian8 ssdBandMedian9 ssdBandMedian10 ssdBandMedian11 ssdBandMedian12 ssdBandMedian13 ssdBandMedian14 ssdBandMedian15 ssdBandMedian16 ssdBandMedian17 ssdBandMedian18 ssdBandMedian19 ssdBandMedian20 ssdBandMedian21 ssdBandMedian22 ssdBandMedian23 ssdBandMin1 ssdBandMin2 ssdBandMin3 ssdBandMin4 ssdBandMin5 ssdBandMin6 ssdBandMin7 ssdBandMin8 ssdBandMin9 ssdBandMin10 ssdBandMin11 ssdBandMin12 ssdBandMin13 ssdBandMin14 ssdBandMin15 ssdBandMin16 ssdBandMin17 ssdBandMin18 ssdBandMin19 ssdBandMin20 ssdBandMin21 ssdBandMin22 ssdBandMin23 ssdBandMax1 ssdBandMax2 ssdBandMax3 ssdBandMax4 ssdBandMax5 ssdBandMax6 ssdBandMax7 ssdBandMax8 ssdBandMax9 ssdBandMax10 ssdBandMax11 ssdBandMax12 ssdBandMax13 ssdBandMax14 ssdBandMax15 ssdBandMax16 ssdBandMax17 ssdBandMax18 ssdBandMax19 ssdBandMax20 ssdBandMax21 ssdBandMax22 ssdBandMax23 Dummy"!dropColumnsFrom: inFile to: outFile drop: drop	"Filter columns out of a CSV file"	| inp line tok cols out inds cnt fCnt lCnt |	inp := (Filename named: inFile) readStream.	out := (Filename named: outFile) writeStream.	Transcript clear."Read the first line to get the list of fields"	line := ReadStream on: (inp upTo: Character cr).	cols := OrderedCollection new.	[line atEnd] whileFalse:		[cols addLast: (line upTo: $,) asSymbol.		line skipSeparators]."Go through the list of fields to drop and make a list of indeces"	inds := OrderedCollection new.	1 to: cols size do:		[ :ind |		(drop includes: (cols at: ind))		ifTrue: [inds addLast: ind.			Transcript show: ind printString; space]		ifFalse: [out nextPutAll: (cols at: ind) asString, ', ']]."Iterate over the lines dropping the fields"	out nextPut: Character cr.	Transcript cr.	lCnt := 0.	fCnt := 0.	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		cnt := 1.		[line atEnd] whileFalse:			[tok := (line upTo: $,)."Handle string tokens with embedded commas"			[(tok first == $") and: [tok last ~= $"]] whileTrue: [tok := tok, (line upTo: $,)].			(inds includes: cnt) ifFalse:"Remove quotes from numerical data"				[(tok size > 3) ifTrue:					[ | ch |					ch := tok at: (tok size - 1).					((tok first == $") and: [ch isDigit]) ifTrue: [tok := tok copyFrom: 2 to: tok size].					((tok last == $") and: [ch isDigit]) ifTrue: [tok := tok copyFrom: 1 to: tok size - 1]]."Write out the included ones"				out nextPutAll: tok asString, ', ' ].			cnt := cnt + 1].		out nextPut: Character cr.		(fCnt = 0) ifTrue: [fCnt := cnt].		(fCnt = cnt) ifFalse: [Transcript show: 'Strange field count: ', cnt printString, ' ~= ', fCnt printString, 				' in line ', lCnt printString ; cr].		lCnt := lCnt + 1.		((lCnt \\ 1000) = 0) ifTrue:			[Transcript show: lCnt printString; cr]].	inp close.	out close.	Transcript show: 'Done: ', lCnt printString; cr."Keep genre in this example""SirenUtility dropColumnsFrom: '/Users/stp/Code/FMAK4/MM_Explore/MM_Explore/FSongsEMF4b.csv' 	to: '/Users/stp/Code/FMAK4/MM_Explore/MM_Explore/FSongsEMF4c.csv' 	drop: #(OID Version NumOnsets Tempo TemporalCentroid StereoWidth STrackBirths STrackDeaths LogAttackTime AttackSlope TemporalDelta DynamicRange2 TemporalSkewness TemporalKurtosis ChromaPeak Dummy Name Title Artist Album FYear BitRate FrameRate Duration AnalyzedOn FileFormat Genre SubGenre Genre1 Genre2 Genre1Weight Genre2Weight Instrument1 Instrument2 Instrument1Weight Instrument2Weight AvgFT WeightedFT TempoAvg TempoWeight TempoDistr TrackerConf SegmentConf SegmentWeight NumSegments VerseLength TypicalIndex SoloIndex FirstVerseStart TypicalStart SoloStart FadeIn FadeOut SoloCentroid SoloVariety SoloDynRange SoloTempo SoloRMS IgnoreMe Frame_id RealDuration PeakVar NumOnsetsVar TempoVar TemporalCentroidVar StereoWidthVar STrackBirthsVar STrackDeathsVar LogAttackTimeVar AttackSlopeVar TemporalDeltaVar DynamicRange2Var TemporalSkewnessVar TemporalKurtosisVar Normalized) ""For SFX - remove the BH & FP fields""OID Version NumOnsets Tempo TemporalCentroid StereoWidth STrackBirths STrackDeaths LogAttackTime AttackSlope TemporalDelta DynamicRange2 TemporalSkewness TemporalKurtosis ChromaPeak ChromaWeight Dummy Name Title Artist Album FYear BitRate FrameRate Duration AnalyzedOn FileFormat SubGenre Genre1 Genre2 Genre1Weight Genre2Weight Instrument1 Instrument2 Instrument1Weight Instrument2Weight AvgFT WeightedFT TempoAvg TempoWeight TempoDistr TrackerConf SegmentConf SegmentWeight NumSegments VerseLength TypicalIndex SoloIndex FirstVerseStart TypicalStart SoloStart FadeIn FadeOut QuietSections LoudSections SoloCentroid SoloVariety SoloDynRange SoloTempo SoloRMS LowPeakAmp LowPeakBPM MidPeakAmp MidPeakBPM HighPeakAmp HighPeakBPM LowMidRatio PeriodCentroid1 PeriodSpread1 PeriodCentroid2 PeriodSpread2 FP_gravity FP_bass FP_focus IgnoreMe Frame_id RealDuration PeakVar NumOnsetsVar TempoVar TemporalCentroidVar StereoWidthVar STrackBirthsVar STrackDeathsVar LogAttackTimeVar AttackSlopeVar TemporalDeltaVar DynamicRange2Var TemporalSkewnessVar TemporalKurtosisVar Normalized""This is all the fields""OID Version RMS Peak LPRMS HPRMS ZeroCrossings NumOnsets DynamicRange Tempo TemporalCentroid StereoWidth STrackBirths STrackDeaths LogAttackTime AttackSlope TemporalDelta DynamicRange2 TemporalSkewness TemporalKurtosis SpectralCentroid SpectralMCentroid SpectralSlope SpectralVariety SpectralFlux SpectralRolloff SpectralBandwidth SpectralSkewness SpectralKurtosis BassDynamicity ChromaPeak ChromaWeight SpectralBand1 SpectralBand2 SpectralBand3 SpectralBand4 SpectralBandMax DrumEnergyBand1 DrumEnergyBand2 DrumEnergyBand3 DrumEnergyBand4 DrumEnergyBand5 DrumEnergyBand6 VocalEnergyBand1 VocalEnergyBand2 VocalEnergyBand3 MFCCCoeff1 MFCCCoeff2 MFCCCoeff3 MFCCCoeff4 MFCCCoeff5 MFCCCoeff6 MFCCCoeff7 MFCCCoeff8 MFCCCoeff9 MFCCCoeff10 MFCCCoeff11 MFCCCoeff12 DeltaMFCC1 DeltaMFCC2 DeltaMFCC3 DeltaMFCC4 DeltaMFCC5 DeltaMFCC6 DeltaMFCC7 DeltaMFCC8 DeltaMFCC9 DeltaMFCC10 DeltaMFCC11 DeltaMFCC12 Dummy Name Title Artist Album FYear BitRate FrameRate Duration AnalyzedOn FileFormat Genre SubGenre Genre1 Genre2 Genre1Weight Genre2Weight Instrument1 Instrument2 Instrument1Weight Instrument2Weight AvgFT WeightedFT TempoAvg TempoWeight TempoDistr TrackerConf SegmentConf SegmentWeight NumSegments VerseLength TypicalIndex SoloIndex FirstVerseStart TypicalStart SoloStart FadeIn FadeOut QuietSections LoudSections SoloCentroid SoloVariety SoloDynRange SoloTempo SoloRMS LowPeakAmp LowPeakBPM MidPeakAmp MidPeakBPM HighPeakAmp HighPeakBPM LowMidRatio PeriodCentroid1 PeriodSpread1 PeriodCentroid2 PeriodSpread2 FP_gravity FP_bass FP_focus IgnoreMe Frame_id RealDuration RMSVar PeakVar LPRMSVar HPRMSVar ZeroCrossingsVar NumOnsetsVar DynamicRangeVar TempoVar TemporalCentroidVar StereoWidthVar STrackBirthsVar STrackDeathsVar LogAttackTimeVar AttackSlopeVar TemporalDeltaVar DynamicRange2Var TemporalSkewnessVar TemporalKurtosisVar SpectralCentroidVar SpectralMCentroidVar SpectralSlopeVar SpectralVarietyVar SpectralFluxVar SpectralRolloffVar SpectralBandwidthVar SpectralSkewnessVar SpectralKurtosisVar BassDynamicityVar ChromaPeakVar ChromaWeightVar SpectralBand1Var SpectralBand2Var SpectralBand3Var SpectralBand4Var SpectralBandMaxVar DrumEnergyBand1Var DrumEnergyBand2Var DrumEnergyBand3Var DrumEnergyBand4Var DrumEnergyBand5Var DrumEnergyBand6Var VocalEnergyBand1Var VocalEnergyBand2Var VocalEnergyBand3Var MFCCCoeff1Var MFCCCoeff2Var MFCCCoeff3Var MFCCCoeff4Var MFCCCoeff5Var MFCCCoeff6Var MFCCCoeff7Var MFCCCoeff8Var MFCCCoeff9Var MFCCCoeff10Var MFCCCoeff11Var MFCCCoeff12Var DeltaMFCC1Var DeltaMFCC2Var DeltaMFCC3Var DeltaMFCC4Var DeltaMFCC5Var DeltaMFCC6Var DeltaMFCC7Var DeltaMFCC8Var DeltaMFCC9Var DeltaMFCC10Var DeltaMFCC11Var DeltaMFCC12Var Normalized"!dropTo2ColumnsFrom: inFile to: outFile	"Filter columns of a TSV file: keep 1 & 3"	| inp line cols out cnt |	inp := (Filename named: inFile) readStream text.	out := (Filename named: outFile) writeStream text.	Transcript clear.	cnt := 0.	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		cols := OrderedCollection new: 64.		[line atEnd] whileFalse:			[cols addLast: (line upTo: $	 "tab").			line skipSeparators].		(cols size > 2) ifTrue: 			[out nextPutAll: 'Update FSongsAPM set TemporalCentroid = ',  (cols at: 1) asByteString, ' where NameToken = ''',  (cols at: 3) asByteString, ''';'; cr].			(cnt \\ 1000 = 999) ifTrue: [Transcript show: 'Done: ', (cnt + 1) printString; cr].			cnt := cnt + 1].	inp close.	out close.	Transcript show: 'Done: ', cnt printString; cr."SirenUtility dropTo2ColumnsFrom: '/Volumes/Content/Code/Python/SndsLike/SSongs.csv' 	to: '/Volumes/Content/Code/Python/SndsLike/SSongs2.csv' "!dropToNumColumnsFrom: inFile to: outFile	"Filter columns of a TSV file: keep 1 & 3"	| inp line out cnt tok |	inp := (Filename named: inFile) readStream text.	out := (Filename named: outFile) writeStream text.	Transcript clear.	cnt := 0.	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		line skipSeparators.		tok := line upTo: $	."tab"		out nextPutAll: tok; cr].	inp close.	out close.	Transcript show: 'Done: ', cnt printString; cr."SirenUtility dropToNumColumnsFrom: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-hist-top.txt' 	to: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-hist-top2.txt' "!exploreRecommendationFor: str	"Answer the genre histogram for the given recommender search"	| cmd proc reply connection |	connection := self pipeConnectionFor: '/Users/stp/Code/FMAK4/MM_Explore/MM_Explore_Beta7/MM_Explore'			arguments:  #('-Rdb' '/Users/stp/Desktop/MediaMined MusicEngine 1.0.426/OtherDataSets/SongDB_LMS.dat'					'-x' '/Users/stp/Code/FMAK4/MM_Explore/Configuration.txt'					'-s' str)			setProcessDescriptor: [:pd | proc := pd].	cmd := connection readStream.	[reply := cmd contents.	proc wait]		ensure: [cmd close].	^(reply copyReplaceAll: $' with: $_)"SirenUtility exploreRecommendationFor: '7080' "!featureNameDictionary	"Answer the dictionary of feature names and const values"	^((#RMS -> 0),	(#RMSVal -> 1),	(#Peak -> 2),	(#LPRMS -> 3),	(#HPRMS -> 4),	(#ZeroCrossings -> 5),	(#NumOnsets -> 6),	(#Tempo -> 7),	(#DynamicRange -> 8),	(#StereoWidth -> 9),	(#BassPitch -> 10),	(#BassNote -> 11),	(#BassStep -> 12),	(#BassDynamicity -> 13),	(#SpectralCentroid -> 14),	(#SpectralMCentroid -> 15),	(#SpectralSlope -> 16),	(#SpectralRolloff -> 17),	(#SpectralVariety -> 18),	(#SpectralFlux -> 19),	(#SpectralBandwidth -> 20),	(#SpectralSkewness -> 21),	(#SpectralKurtosis -> 22),	(#ChromaPeak -> 23),	(#ChromaWeight -> 24),	(#SpectralBand1 -> 25),	(#SpectralBand2 -> 26),	(#SpectralBand3 -> 27),	(#SpectralBand4 -> 28),	(#SpectralBandMax -> 29),	(#STrackBirths -> 30),	(#STrackDeaths -> 31),	(#DrumEnergyBand1 -> 32),	(#DrumEnergyBand2 -> 33),	(#DrumEnergyBand3 -> 34),	(#DrumEnergyBand4 -> 35),	(#DrumEnergyBand5 -> 36),	(#DrumEnergyBand6 -> 37),	(#VocalEnergyBand1 -> 38),	(#VocalEnergyBand2 -> 39),	(#VocalEnergyBand3 -> 40),	(#MFCCCoeff1 -> 41),	(#MFCCCoeff2 -> 42),	(#MFCCCoeff3 -> 43),	(#MFCCCoeff4 -> 44),	(#MFCCCoeff5 -> 45),	(#MFCCCoeff6 -> 46),	(#MFCCCoeff7 -> 47),	(#MFCCCoeff8 -> 48),	(#MFCCCoeff9 -> 49),	(#MFCCCoeff10 -> 50),	(#MFCCCoeff11 -> 51),	(#MFCCCoeff12 -> 52),	(#DeltaMFCC1 -> 53),	(#DeltaMFCC2 -> 54),	(#DeltaMFCC3 -> 55),	(#DeltaMFCC4 -> 56),	(#DeltaMFCC5 -> 57),	(#DeltaMFCC6 -> 58),	(#DeltaMFCC7 -> 59),	(#DeltaMFCC8 -> 60),	(#DeltaMFCC9 -> 61),	(#DeltaMFCC10 -> 62),	(#DeltaMFCC11 -> 63),	(#DeltaMFCC12 -> 64),	(#Duration -> 65),	(#SilenceRatio -> 66),	(#FYear -> 67),	(#BitRate -> 68),	(#FrameRate -> 69),	(#TempoAvg -> 70),	(#TempoWeight -> 71),	(#TempoDistr -> 72),	(#TrackerConf -> 73),	(#SegmentWeight -> 74),	(#SegmentConf -> 75),	(#NumSegments -> 76),	(#VerseLength -> 77),	(#FirstVerseStart -> 78),	(#SoloIndex -> 79),	(#TypicalIndex -> 80),	(#SoloStart -> 81),	(#TypicalStart -> 82),	(#QuietSections -> 83),	(#LoudSections -> 84),	(#FadeIn -> 85),	(#FadeOut -> 86),	(#SoloCentroid -> 87),	(#SoloVariety -> 88),	(#SoloDynRange -> 89),	(#SoloRMS -> 90),	(#SoloTempo -> 91),	(#LowPeakAmp -> 92),	(#LowPeakBPM -> 93),	(#MidPeakAmp -> 94),	(#MidPeakBPM -> 95),	(#HighPeakAmp -> 96),	(#HighPeakBPM -> 97),	(#LowMidRatio -> 98),	(#PeriodCentroid1 -> 99),	(#PeriodCentroid2 -> 100),	(#PeriodSpread1 -> 101),	(#PeriodSpread2 -> 102),	(#FP_gravity -> 103),	(#FP_bass -> 104),	(#FP_focus -> 105),	(#RMSVar -> 106),	(#RMSValVar -> 107),	(#PeakVar -> 108),	(#LPRMSVar -> 109),	(#HPRMSVar -> 110),	(#ZeroCrossingsVar -> 111),	(#NumOnsetsVar -> 112),	(#TempoVar -> 113),	(#DynamicRangeVar -> 114),	(#StereoWidthVar -> 115),	(#BassPitchVar -> 116),	(#BassNoteVar -> 117),	(#BassStepVar -> 118),	(#BassDynamicityVar -> 119),	(#SpectralCentroidVar -> 120),	(#SpectralMCentroidVar -> 121),	(#SpectralSlopeVar -> 122),	(#SpectralRolloffVar -> 123),	(#SpectralVarietyVar -> 124),	(#SpectralFluxVar -> 125),	(#SpectralBandwidthVar -> 126),	(#SpectralSkewnessVar -> 127),	(#SpectralKurtosisVar -> 128),	(#ChromaPeakVar -> 129),	(#ChromaWeightVar -> 130),	(#SpectralBand1Var -> 131),	(#SpectralBand2Var -> 132),	(#SpectralBand3Var -> 133),	(#SpectralBand4Var -> 134),	(#SpectralBandMaxVar -> 135),	(#STrackBirthsVar -> 136),	(#STrackDeathsVar -> 137),	(#DrumEnergyBand1Var -> 138),	(#DrumEnergyBand2Var -> 139),	(#DrumEnergyBand3Var -> 140),	(#DrumEnergyBand4Var -> 141),	(#DrumEnergyBand5Var -> 142),	(#DrumEnergyBand6Var -> 143),	(#VocalEnergyBand1Var -> 144),	(#VocalEnergyBand2Var -> 145),	(#VocalEnergyBand3Var -> 146),	(#MFCCCoeff1Var -> 147),	(#MFCCCoeff2Var -> 148),	(#MFCCCoeff3Var -> 149),	(#MFCCCoeff4Var -> 150),	(#MFCCCoeff5Var -> 151),	(#MFCCCoeff6Var -> 152),	(#MFCCCoeff7Var -> 153),	(#MFCCCoeff8Var -> 154),	(#MFCCCoeff9Var -> 155),	(#MFCCCoeff10Var -> 156),	(#MFCCCoeff11Var -> 157),	(#MFCCCoeff12Var -> 158),	(#DeltaMFCC1Var -> 159),	(#DeltaMFCC2Var -> 160),	(#DeltaMFCC3Var -> 161),	(#DeltaMFCC4Var -> 162),	(#DeltaMFCC5Var -> 163),	(#DeltaMFCC6Var -> 164),	(#DeltaMFCC7Var -> 165),	(#DeltaMFCC8Var -> 166),	(#DeltaMFCC9Var -> 167),	(#DeltaMFCC10Var -> 168),	(#DeltaMFCC11Var -> 169),	(#DeltaMFCC12Var -> 170))!fileBrokenNames: sql to: outN	"Go through the list of all files checking for the name prefix like L0000011_."	| inp lin fnd nfnd out ok |	inp := (Filename named: sql) readStream.	out := (Filename named: outN) writeStream.	Transcript clear.	fnd := 0.	nfnd := 0.	[inp atEnd] whileFalse:		[lin := inp upTo: Character cr.		ok := true.		('MXLS' includes: lin first) ifFalse: [ok := false].		2 to: 8 do:			[ :ind | (lin at: ind) isDigit ifFalse: [ok := false]].		((lin at: 9) == $_) ifFalse: [ok := false].		ok ifTrue: [fnd := fnd + 1]			ifFalse: [nfnd := nfnd + 1. 					out nextPutAll: lin; cr]].	inp close.	out close.	Transcript show: 'Done'; crtab; show: fnd printString, ' found, '; crtab; show: nfnd printString, ' not found'; cr"SirenUtility fileBrokenNames: '/Volumes/Media/CoreDataSets/names.txt' 	to: '/Volumes/Media/CoreDataSets/bad-file-names.txt' "!filterGenresFrom2: inFile to: outFile keep: keepFile	"Filter genre columns of a CSV file: keep the list - this version drops entries with no genre"	"SirenUtility filterGenresFrom2: '/Volumes/Content/Code/Python/SndsLike/FSongs2.csv' 			to: '/Volumes/Content/Code/Python/SndsLike/FSongs4.csv' 			keep: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-hist-keep.txt' "	| inp line out tok kep keeps rest cnt nam |	inp := (Filename named: inFile) readStream text.	kep := (Filename named: keepFile) readStream text.	out := (Filename named: outFile) writeStream text.	keeps := OrderedCollection new.	[kep atEnd] whileFalse:		[keeps addLast: (kep upTo: Character cr)].	kep close.	cnt := 0.	Transcript cr; show: 'Writing CSV data to ', outFile; cr.	inp upTo: Character cr.			"skip 1st line"	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		tok := line upTo: $,.		nam := tok copyFrom: 2 to: (tok size - 1).		rest := line upToEnd.		(keeps includes: nam)			ifTrue: [out nextPutAll: (keeps indexOf: nam) printString, ',', 					(rest copyFrom: 1 to: (rest size - 2)); cr.				cnt := cnt + 1.				((cnt \\ 100) = 0) ifTrue:					[Transcript show: cnt printString; cr]]].	inp close.	out close.	Transcript show: 'Done: ', cnt printString, ' items copied.'; cr!filterGenresFrom: inFile to: outFile keep: keepFile	"Filter genre columns of a CSV file: keep the list"	"SirenUtility filterGenresFrom: '/Volumes/Content/Code/Python/SndsLike/FSongs2.csv' 			to: '/Volumes/Content/Code/Python/SndsLike/FSongs3.csv' 			keep: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-hist-keep.txt' "	| inp line out tok kep keeps rest cnt nam |	inp := (Filename named: inFile) readStream text.	kep := (Filename named: keepFile) readStream text.	out := (Filename named: outFile) writeStream text.	keeps := OrderedCollection new.	[kep atEnd] whileFalse:		[keeps addLast: (kep upTo: Character cr)].	kep close.	cnt := 0.	Transcript cr; show: 'Writing CSV data to ', outFile; cr.	out nextPutAll: (inp upTo: Character cr); cr.		"copy 1st line"	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		tok := line upTo: $,.		nam := tok copyFrom: 2 to: (tok size - 1).		rest := line upToEnd.		(keeps includes: nam)			ifTrue: [out nextPutAll: tok, ',', rest; cr]			ifFalse: [out nextPutAll: '?,', rest; cr].		cnt := cnt + 1.		((cnt \\ 1000) = 0) ifTrue:			[Transcript show: cnt printString; cr]].	inp close.	out close.	Transcript show: 'Done: ', cnt printString, ' items copied.'; cr!genreHistogram2Of: str into: dict	"Answer the genre histogram for the given recommender search"	| inp genre |	inp := ReadStream on: str.	Transcript clear."Loop through the lines"	[inp atEnd] whileFalse:		[genre := (inp upTo: Character cr) .		(genre size > 0) ifTrue: 			[genre := genre asSymbol.			(dict includesKey: genre)				ifTrue: [dict at: genre put: ((dict at: genre) + 1)]				ifFalse: [dict at: genre put: 1]]]!genreHistogramFrom: fil	"Answer the genre histogram for the given recommender search"	"SirenUtility genreHistogramFrom: '/Users/stp/Code/FMAK4/MM_Explore/MM_Explore_Beta7/Stats3/Rock.out.txt' "	| inp genre coll dict |	inp := fil asFilename readStream.	dict := IdentityDictionary new.	Transcript clear."Loop through the lines"	[inp atEnd] whileFalse:		[genre := (inp upTo: Character cr) .		(genre size > 0) ifTrue: 			[genre := genre asSymbol.			(dict includesKey: genre)				ifTrue: [dict at: genre put: ((dict at: genre) + 1)]				ifFalse: [dict at: genre put: 1]]]."Now sort and print the dict"	coll := OrderedCollection new.	dict keysAndValuesDo:		[ :k :v |		coll add: (v -> k)].	coll sort: [:a :b | a > b].	Transcript clear.	coll do: [ :it | Transcript show: it value asString, ' - ', it key printString; cr]!genreHistogramOf: str	"Answer the genre histogram for the given recommender search"	| inp line dict coll genre |	inp := ReadStream on: str.	dict := IdentityDictionary new.	Transcript clear.	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr).		3 timesRepeat: [line upTo: $	 "tab"].		genre := (line upTo: $  "space") asSymbol.		(genre size = 0) ifTrue: [self halt]."		Transcript show: genre; cr."		(dict includesKey: genre)		ifTrue: [dict at: genre put: ((dict at: genre) + 1)]		ifFalse: [dict at: genre put: 1]].	coll := OrderedCollection new.	dict keysAndValuesDo:		[ :k :v |		coll add: (v -> k)].	coll sort: [:a :b | a > b].	coll do: [ :it | Transcript show: it value asString, ' - ', it key printString; cr]"SirenUtility genreHistogramOf: '7080   	Verano Porteno          	Karin Schaupp           	Classical           	   0.07116   	Dancing on the Plaza    	Karin Schaupp           	Classical           	  93.07058   	Fandango                	Karin Schaupp           	Classical           	 108.09442   	Dismantling Utopia      	Pat Metheny Group       	Jazz                	 109.014406  	Childrens Songs: S    	Manuel Barrueco         	Jazz                	 117.015076  	Capriccio No. 5         	Eliot Fisk              	Classical           	 126.023994  	Ninth Symphony: Seco    	Wendy Carlos            	Electronica/Dance   	 128.07918   	Odara                   	Caetano Veloso          	Latin               	 129.07102   	Choros No.1             	Karin Schaupp           	Classical           	 130.07132   	Fiesta                  	Karin Schaupp           	Classical           	 133.0'"!genreHistogramOf: str into: dict	"Answer the genre histogram for the given recommender search"	| inp line genre |	inp := ReadStream on: str.	Transcript clear."Loop through the lines"	[inp atEnd] whileFalse:		[line := ReadStream on: (inp upTo: Character cr)."skip 3 tabs and read the genre"		3 timesRepeat: [line upTo: $	 "tab"].		genre := (line upTo: $  "space") asSymbol.		(genre size = 0) ifTrue: [self halt]."		Transcript show: genre; cr."		(dict includesKey: genre)			ifTrue: [dict at: genre put: ((dict at: genre) + 1)]			ifFalse: [dict at: genre put: 1]].!insertAsTable: str	"turn SQL inserts into lists"	| inp line1 line2 |	inp := ReadStream on: str.	inp upTo: $( .	line1 := ReadStream on: (inp upTo: $) ).	inp upTo: $( .	line2 := ReadStream on: (inp upTo: $) ).	Transcript clear.	[line1 atEnd] whileFalse:		[line1 skipSeparators.		line2 skipSeparators.		Transcript show: (line1 upTo: $,), '	', (line2 upTo: $,); cr]"SirenUtility insertAsTable: 'INSERT INTO Frames (Version, Audio_file_id, RMS, Peak, LPRMS, HPRMS, ZeroCrossings, DynamicRange, TemporalCentroid, LogAttackTime, AttackSlope, StereoWidth, BassDynamicity, SpectralCentroid, SpectralMCentroid, SpectralSlope, SpectralRolloff, SpectralVariety, SpectralFlux, SpectralBandwidth, SpectralSkewness, SpectralKurtosis, ChromaPeak, ChromaWeight, SpectralBand1, SpectralBand2, SpectralBand3, SpectralBand4, SpectralBandMax, DrumEnergyBand1, DrumEnergyBand2, DrumEnergyBand3, DrumEnergyBand4, DrumEnergyBand5, DrumEnergyBand6, VocalEnergyBand1, VocalEnergyBand2, VocalEnergyBand3, MFCCCoeff1, MFCCCoeff2, MFCCCoeff3, MFCCCoeff4, MFCCCoeff5, MFCCCoeff6, MFCCCoeff7, MFCCCoeff8, MFCCCoeff9, MFCCCoeff10, MFCCCoeff11, MFCCCoeff12, DeltaMFCC1, DeltaMFCC2, DeltaMFCC3, DeltaMFCC4, DeltaMFCC5, DeltaMFCC6, DeltaMFCC7, DeltaMFCC8, DeltaMFCC9, DeltaMFCC10, DeltaMFCC11, DeltaMFCC12, RMSVar, PeakVar, LPRMSVar, HPRMSVar, ZeroCrossingsVar, DynamicRangeVar, TemporalCentroidVar, LogAttackTimeVar, AttackSlopeVar, StereoWidthVar, BassDynamicityVar, SpectralCentroidVar, SpectralMCentroidVar, SpectralSlopeVar, SpectralRolloffVar, SpectralVarietyVar, SpectralFluxVar, SpectralBandwidthVar, SpectralSkewnessVar, SpectralKurtosisVar, ChromaPeakVar, ChromaWeightVar, SpectralBand1Var, SpectralBand2Var, SpectralBand3Var, SpectralBand4Var, SpectralBandMaxVar, DrumEnergyBand1Var, DrumEnergyBand2Var, DrumEnergyBand3Var, DrumEnergyBand4Var, DrumEnergyBand5Var, DrumEnergyBand6Var, VocalEnergyBand1Var, VocalEnergyBand2Var, VocalEnergyBand3Var, MFCCCoeff1Var, MFCCCoeff2Var, MFCCCoeff3Var, MFCCCoeff4Var, MFCCCoeff5Var, MFCCCoeff6Var, MFCCCoeff7Var, MFCCCoeff8Var, MFCCCoeff9Var, MFCCCoeff10Var, MFCCCoeff11Var, MFCCCoeff12Var, DeltaMFCC1Var, DeltaMFCC2Var, DeltaMFCC3Var, DeltaMFCC4Var, DeltaMFCC5Var, DeltaMFCC6Var, DeltaMFCC7Var, DeltaMFCC8Var, DeltaMFCC9Var, DeltaMFCC10Var, DeltaMFCC11Var, DeltaMFCC12Var, Frame_start, Frame_duration) VALUES (327, 102815, 84.6937, 0.944061, 0.997586, 0.698285, 1.97647, 1.23656, -1e+30, -1e+30, -1e+30, 8.06462e-06, -1e+30, 207.052, 14.6044, 0.922097, 258.438, 0.000109031, 1028.56, 198.95, -1.00481, 1.00698, 1, 0.0758055, 0.855022, 0.956747, 0.893801, 0.780114, 0.582857, 0.000359365, 0.122933, 0.0411679, 0.0470418, 0.00654747, 0.000496737, 0.215513, 0.000549922, 0.000791321, -292.067, 38.6301, 23.5531, 8.3822, 14.6578, -3.47737, 8.73018, -3.87471, 5.51259, -6.40002, 4.14141, -6.91696, -15.2155, -1.02038, 3.99178, 1.39333, 0.945822, -0.0936216, 0.0253709, -0.341265, 0.0642555, 0.208289, 0.0154152, -0.124485, 0.909529, 0.134182, 0.00119386, 0.0412286, 0.0235294, 0.0657316, 0, 0, 0, 2.7435e-07, 0, 33.8001, 2.07019, 0.0103279, 15.7643, 0.0175433, 193.506, 33.3875, 0.00158737, 0.000541155, 0, 0.013379, 0.00134255, 0.00146159, 0.00596091, 0.014281, nan, 0.000289119, 0.0219297, 0.00580141, 0.0281595, 0.00325536, 0.000486839, 0.0696989, 0.00039616, 0.000421862, 25.0274, 8.72199, 1.64894, 1.4347, 0.579969, 1.83988, 0.66553, 0.679326, 0.247909, 0.541071, 0.230342, 0.406579, 15.2012, 4.99235, 4.08555, 1.48574, 1.26368, 1.00946, 0.326527, 0.861198, 2.24726, 0.642198, 0.713443, 0.226396, 0, 4.07159)'"!insertToDel2: sql to: outN	"Convert an SQL insert to a delete" | inp out ind |inp := (Filename named: sql) readStream.out := (Filename named: outN) writeStream.Transcript clear.[inp atEnd] whileFalse:	[inp skipThroughAll: 'VALUES'.	inp upTo: $,.	ind := inp upTo: $,.	inp upTo: Character cr.	out nextPutAll: 'Delete from Frames where Audio_file_id = ', ind, ';'; cr].inp close.out close."SirenUtility insertToDel2: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/FramesInserts_SFX.sql' 	to: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/FramesInserts_SFXd.sql' "!insertToDel: sql to: outN	"Convert an SQL insert to a delete"	"(0,470288,0,219.69,86.7227,"	"Delete from Frames where Audio_file_id = 470288" | inp out ind |inp := (Filename named: sql) readStream.out := (Filename named: outN) writeStream.Transcript clear.[inp atEnd] whileFalse:	[inp upTo: $,.	ind := inp upTo: $,.	inp upTo: Character cr.	out nextPutAll: 'Delete from Frames where Audio_file_id = ', ind, ';'; cr].inp close.out close."SirenUtility insertToDel: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/Frames_DB_110504z.txt' 	to: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/Frames_DB_110504x.txt' "!insertToUpdate: sql to: outN	"Convert an SQL insert to an update"	"1,'/Loops/Apple Loops_GarageBand','L0000003_Percussion Combo 06.wav','L',0);" | inp out ind "path nam sho set" pos1 pos2 lin |inp := (Filename named: sql) readStream.out := (Filename named: outN) writeStream.Transcript clear.[inp atEnd] whileFalse:	[ind := inp upTo: $,.	lin := inp upTo: Character cr.	pos1 := lin findString: ''',''' startingAt: 2 .	pos2 := lin findString: ''',''' startingAt: pos1 + 1 ."	nam := inp upTo: $,.	sho := inp upTo: $,.	set := inp upTo: $)."	out nextPutAll: 'UPDATE AudioFiles set Path = ', (lin copyFrom: 1 to: pos1), 		' File_name = ', (lin copyFrom: pos1 + 2 to: pos2), 		' Short_name = ', (lin copyFrom: pos2 + 2 to: pos2 + 3),		''' DataSet = 0 where Audio_file_id = ', ind, ';'; cr].inp close.out close."SirenUtility insertToUpdate: '/Volumes/Content/Databases/aria-tables/AudioFiles_DB_110427c.txt' 	to: '/Volumes/Content/Databases/aria-tables/AudioFiles_DB_110427d.txt' "!iso226Tables	"Interpolate the ISO 226 F-M tables to bark-scale frequencies"	"SirenUtility iso226Tables"	| ba f tf lu af af2 tf2 lu2 |	ba := #(50 150 250 350 450 570 700 840 1000 1170 1370 1600 1850 2150 2500 2900 		3400 4000 4800 5800 7000 8500 ).	f := #(20 25 31.5 40 50 63 80 100 125 160 200 250 315 400 500 630 800		1000 1250 1600 2000 2500 3150 4000 5000 6300 8000 10000 12500).	af := #(0.532 0.506 0.480 0.455 0.432 0.409 0.387 0.367 0.349 0.330 0.315      	0.301 0.288 0.276 0.267 0.259 0.253 0.250 0.246 0.244 0.243 0.243      	0.243 0.242 0.242 0.245 0.254 0.271 0.301).	lu := #(-31.6 -27.2 -23.0 -19.1 -15.9 -13.0 -10.3 -8.1 -6.2 -4.5 -3.1      	-2.0  -1.1  -0.4   0.0   0.3   0.5   0.0 -2.7 -4.1 -1.0  1.7       	2.5   1.2  -2.1  -7.1 -11.2 -10.7  -3.1).	tf := #(78.5  68.7  59.5  51.1  44.0  37.5  31.5  26.5  22.1  17.9  14.4       	11.4   8.6   6.2   4.4   3.0   2.2   2.4   3.5   1.7  -1.3  -4.2       	-6.0  -5.4  -1.5   6.0  12.6  13.9  12.3).	Transcript clear.	Transcript show: 'ba	', ba size printString; cr; show: 'f	', f size printString; cr; show: 'af	', af size printString; cr;		show: 'lu	', lu size printString; cr; show: 'tf	', tf size printString; cr.	af2 := OrderedCollection new.	lu2 := OrderedCollection new.	tf2 := OrderedCollection new.	ba do: [ :frq |		1 to: f size - 1 do: [ :cnt | | upper lower fract |			lower := f at: cnt.			upper := f at: cnt + 1.			((upper > frq) and: [lower <= frq]) ifTrue:				[fract := (frq - lower) / (upper - lower).				Transcript show: frq printString, '	', lower printString, '	', upper printString, '	', (cnt + fract) asFloat printString; cr.				lower := af at: cnt.				upper := af at: cnt + 1.				af2 addLast: (lower + ((upper - lower) * fract)).				lower := lu at: cnt.				upper := lu at: cnt + 1.				lu2 addLast: (lower + ((upper - lower) * fract)).				lower := tf at: cnt.				upper := tf at: cnt + 1.				tf2 addLast: (lower + ((upper - lower) * fract))]]].	Transcript show: af2 printString; cr.	Transcript show: lu2 printString; cr.	Transcript show: tf2 printString; cr.!ldaAsTable: ifile toks: tfile	"Translate a set of normalizer output messages to scales tables"	"SirenUtility ldaAsTable: '/Volumes/Content/Code/Python/SndsLike/DataSets/FASTLab/FSongs_LDA2.txt' 			toks: '/Volumes/Content/Code/Python/SndsLike/field_names.txt' "	| fil tok tokf toks lin ind map smap which |	fil := ifile asFilename readStream.	tokf := tfile asFilename readStream.	toks := OrderedCollection new.	[tokf atEnd] whileFalse: 		[toks addLast: (tokf upTo: $,)].	tokf close.	Transcript clear."Read file line-by-line"	3 timesRepeat: [fil upTo: Character cr].			"skip header"	[fil atEnd] whileFalse: 		[which := fil upTo: Character cr.		"skip index"		lin := ReadStream on: (fil upTo: Character cr).		ind := 1.		map := OrderedCollection new.		[lin atEnd] whileFalse: 			[tok := lin upTo: $ .			lin skipSeparators.			map add: ((toks at: ind) -> tok asNumber).			ind := ind + 1].		smap := map asSortedCollection: [ :a :b | a value abs > b value abs].			Transcript cr; show: which; cr.		1 to:30 do: [ :count | | ass |			ass := smap at: count.			Transcript show: ass key; tab; tab; show: ass value printString; cr].	].	fil close.!meLogData0: filNam	"Parse a log from Musicengine into 'WTF' statistics"	| inp cr tok key result dist num table |	inp := filNam asFilename readStream.	cr := String with: Character cr.	tok := cr, 'key '.	table := Dictionary new.	Transcript clear; show: ' '; cr; cr.	[inp atEnd] whileFalse: 		[inp skipThroughAll: tok.		key := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		result := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		dist := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		num := inp upTo: Character cr. inp skipSeparators.		num := num asNumber."		Transcript show: 'Res:  ', key printString, ' - ', result printString, ' - ', dist printString, ' - ', num printString, ' - '; cr."		key size > 0 ifTrue:			[(table includesKey: key)			ifFalse: [ | di | di := Dictionary new.				di at: dist put: (1 / num).				table at: key put: di]			ifTrue: [ | di | di := table at: key.				(di includesKey: dist)					ifFalse: [di at: dist put: (1 / num)]					ifTrue: [ | va | va := di at: dist.						di at: dist put: (va + (1 / num))]]]].	table associationsDo: [ :ass |		ass value associationsDo: [ :ass2 |			Transcript show: 'Res:  Song ', ass key, '   Dist ', ass2 key, '  =  ', ((1.0 - (ass2 value asFloat)) * 100) printString, '%'; cr]]" SirenUtility meLogData: '/Users/stp/Desktop/JL-MM_MEngine_Log.txt' "!meLogData2: filNam	"Parse a log from Musicengine into 'WTF' statistics"	"key 23310 res 21646 row 7 dist 0 num 20"	"SirenUtility meLogData2: '/Volumes/Content/Code/FMAK4/MM_Explore/MM_Explore/Stats5/MM_Explore_Log-old.txt' "	| inp cr tok key result "dist row" num table title |	inp := filNam asFilename readStream.	cr := String with: Character cr.	tok := cr, 'key '.	table := Dictionary new.	Transcript clear; cr; show: filNam; cr; cr.	[inp atEnd] whileFalse: 		[inp skipThroughAll: tok.		key := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		result := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		"row := "inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		"dist := "inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		num := inp upTo: Character cr. inp skipSeparators.		num := num asNumber.		inp upTo: Character cr. inp skipSeparators.		"skip DAT file name"		title := inp upTo: Character cr."		Transcript show: 'K:  ', key, ' Re: ', result, ' Ro: ', row,			' D: ', dist, ' N: ', num printString, ' - '; cr."		key size > 0 ifTrue:			[(table includesKey: key) ifFalse: 				[ | di | di := Dictionary new.				(key = result)					ifTrue:  [di at: title put: 0]					ifFalse:  [di at: title put: (1 / num)].				table at: key put: di]			ifTrue: [ | di va |				di := table at: key.				va := di at: title.				(key = result)					ifFalse:  [di at: title put: (va + (1 / num))]]]].	table associationsDo: [ :ass |		ass value associationsDo: [ :ass2 |			Transcript show: 'Song ', ass key, '  =  ', ((1.0 - (ass2 value asFloat)) * 100) printString, '% = ', ass2 key; cr]]!meLogData: filNam	"Parse a log from Musicengine into 'WTF' statistics"	"key 23310 res 21646 row 7 dist 0 num 20"	"SirenUtility meLogData: '/Users/stp/Code/FMAK4/MM_Explore/MM_Explore_Beta7/Stats/MM_MEngine_Log_SJ2.txt' "	| inp cr tok key result dist row num table |	inp := filNam asFilename readStream.	cr := String with: Character cr.	tok := cr, 'key '.	table := Dictionary new.	Transcript clear; cr; show: filNam; cr; cr.	[inp atEnd] whileFalse: 		[inp skipThroughAll: tok.		key := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		result := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		row := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		dist := inp upTo: $ . inp skipSeparators.		inp upTo: $ . inp skipSeparators.		num := inp upTo: Character cr. inp skipSeparators.		num := num asNumber."		Transcript show: 'K:  ', key, ' Re: ', result, ' Ro: ', row,			' D: ', dist, ' N: ', num printString, ' - '; cr."		key size > 0 ifTrue:			[(table includesKey: key)			ifFalse: [ | di | di := Dictionary new.				di at: dist put: (1 / num).				table at: key put: di]			ifTrue: [ | di | di := table at: key.				(di includesKey: dist)					ifFalse: [di at: dist put: (1 / num)]					ifTrue: [ | va | va := di at: dist.						di at: dist put: (va + (1 / num))]]]].	table associationsDo: [ :ass |		ass value associationsDo: [ :ass2 |			Transcript show: 'Res:  Song ', ass key, '   Dist ', ass2 key, '  =  ', ((1.0 - (ass2 value asFloat)) * 100) printString, '%'; cr]]!mergeLines: nams with: vals	"Go through the list of all files checking for the name prefix like L0000011_."	| inp in2 tok val dict |	inp := (Filename named: nams) readStream.	in2 := (Filename named: vals) readStream.	Transcript clear; cr; show: 'Name sort:'; cr.	dict := Dictionary new.	[inp atEnd] whileFalse:		[tok := inp upTo: Character cr.		val := in2 upTo: Character cr.		dict at: tok put: val].	inp close.	in2 close.	dict keys asSortedCollection do: [ :ke |		Transcript tab; show: ke, '		', (dict at: ke); cr].	Transcript cr; cr; show: 'Freq sort:'; cr.	(dict associations asSortedCollection: [:a :b | a value asNumber > b value asNumber]) do: [ :ass |		Transcript tab; show: ass key, '		', ass value; cr]."SirenUtility mergeLines: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-names.txt' 		with: '/Volumes/Content/Code/Python/SndsLike/Doc/genre-hist' "!pcaToConf2: argString	"Translate a set of PCA dimensions to a config file weighting"	| inp val nam op oc min max |	inp := ReadStream on: argString.	inp skipSeparators.	oc := OrderedCollection new: 80.	min := 1000.	max := 0.	[inp atEnd] whileFalse: 		[op := inp upTo: $ . inp skipSeparators.		val := (inp upTo: $ ) asNumber. inp skipSeparators.		nam := inp upTo: $ . inp skipSeparators.		(op size ~= 1) ifTrue: [self halt]."		((op at: 1) = $-) ifTrue: [val := 0 - val]."		(val > max) ifTrue: [max := val].		(val < min) ifTrue: [min := val].		oc add: (nam -> val)].	max := (max - min)."	min := 0 - min."	Transcript clear; show: 'Dist1Heading Distance1'; cr; cr; show: 'DistanceConfiguration {'; crtab.	oc do: [ :item |		Transcript show: item key, '	', (max - (item value - min)) printString; crtab].	Transcript show: '}'; cr; cr"SirenUtility pcaToConf2: ' - 0.299 DeltaMFCC4 - 0.299 MFCCCoeff4 - 0.283 SpectralBand4 - 0.251 SpectralBand3 + 0.215 DeltaMFCC11 + 0.215 MFCCCoeff11 - 0.199 SpectralSlope + 0.177 DeltaMFCC9 + 0.177 MFCCCoeff9 - 0.174 DeltaMFCC6 - 0.174 MFCCCoeff6 - 0.165 SpectralBand2 - 0.157 LPRMS + 0.143 DrumEnergyBand6 + 0.137 VocalEnergyBand2 - 0.132 SpectralBandwidthVar + 0.121 DrumEnergyBand6Var + 0.118 VocalEnergyBand2Var - 0.115 SpectralBandwidth + 0.114 DrumEnergyBand1 - 0.112 DeltaMFCC1 - 0.111 MFCCCoeff1 - 0.11 SpectralCentroidVar + 0.098 DrumEnergyBand1Var + 0.096 MFCCCoeff7 + 0.096 DeltaMFCC7 + 0.094 SpectralFluxVar + 0.093 MFCCCoeff12 + 0.093 DeltaMFCC12 - 0.092 ZeroCrossingsVar + 0.092 SpectralFlux - 0.09 DynamicRangeVar + 0.084 DrumEnergyBand2 - 0.083 DeltaMFCC1Var - 0.083 MFCCCoeff1Var + 0.075 DrumEnergyBand2Var + 0.071 SpectralBand3Var + 0.07  SpectralBand4Var + 0.069 SpectralVarietyVar - 0.068 DynamicRange + 0.068 DeltaMFCC10 + 0.068 MFCCCoeff10 - 0.067 SpectralRolloffVar - 0.067 MFCCCoeff3 - 0.067 DeltaMFCC3 - 0.065 Peak + 0.065 SpectralBandMax + 0.062 SpectralBandMaxVar - 0.061 DrumEnergyBand4Var - 0.061 SpectralMCentroidVar' "!pcaToConf3: argString	"Translate a set of PCA dimensions to a config file weighting"	| inp val nam op oc min max |	inp := ReadStream on: argString.	inp skipSeparators.	oc := OrderedCollection new: 80.	min := 1000.	max := 0.	[inp atEnd] whileFalse: 		[op := inp upTo: $ . inp skipSeparators.		val := (inp upTo: $ ) asNumber. inp skipSeparators.		nam := inp upTo: $ . inp skipSeparators.		(op size ~= 1) ifTrue: [self halt]."		((op at: 1) = $-) ifTrue: [val := 0 - val]."		(val > max) ifTrue: [max := val].		(val < min) ifTrue: [min := val].		oc add: (nam -> val)].	max := (max - min)."	min := 0 - min."	Transcript clear; show: 'Dist1Heading Distance1'; cr; cr; show: 'DistanceConfiguration {'; crtab.	oc do: [ :item |		Transcript show: item key, '	', item value printString; crtab].	Transcript show: '}'; cr; cr"SirenUtility pcaToConf3: ' - 0.329 SpectralSlope - 0.322 SpectralBandMax - 0.262 SpectralBand4 + 0.226 DrumEnergyBand1 + 0.212 DrumEnergyBand1Var - 0.188 MFCCCoeff4 + 0.172 MFCCCoeff12 - 0.168 SpectralBandwidthVar - 0.166 SpectralCentroidVar + 0.163 DrumEnergyBand2 + 0.158 SpectralBandMaxVar - 0.148 SpectralRolloffVar + 0.143 SpectralBand1 - 0.14 LPRMS + 0.131 DrumEnergyBand2Var - 0.129 SpectralRolloff - 0.127 SpectralBand3 + 0.123 MFCCCoeff9 - 0.122 DynamicRangeVar - 0.122 SpectralBandwidth - 0.12 SpectralCentroid - 0.12 MFCCCoeff6 + 0.109 DrumEnergyBand6Var - 0.106 DrumEnergyBand4 + 0.106 MFCCCoeff2 + 0.104 MFCCCoeff11 - 0.102 DynamicRange + 0.102 DrumEnergyBand5Var + 0.099 SpectralVariety + 0.098 DrumEnergyBand6 - 0.097 DrumEnergyBand4Var + 0.097 ChromaWeightVar - 0.095 SpectralKurtosisVar + 0.093 SpectralVarietyVar + 0.092 DrumEnergyBand5 - 0.089 SpectralBand2Var - 0.089 SpectralSlopeVar + 0.088 VocalEnergyBand2Var + 0.085 MFCCCoeff10 + 0.084 DeltaMFCC9Var + 0.083 VocalEnergyBand2 + 0.081 LPRMSVar - 0.075 SpectralSkewnessVar - 0.075 ZeroCrossingsVar - 0.071 HPRMSVar + 0.069 DeltaMFCC7 + 0.067 DeltaMFCC1 + 0.064 DeltaMFCC11Var + 0.063 DeltaMFCC2Var + 0.058 SpectralSkewness + 0.058 MFCCCoeff7 + 0.055 SpectralBand2 - 0.052 MFCCCoeff8 + 0.05 SpectralBand4Var + 0.049 DeltaMFCC9 + 0.049 SpectralFlux - 0.048 MFCCCoeff1Var - 0.045 SpectralBand1Var + 0.045 DeltaMFCC7Var + 0.044 DeltaMFCC11 + 0.044 ChromaPeakVar - 0.041 DrumEnergyBand3 - 0.041 DrumEnergyBand3Var + 0.038 HPRMS - 0.037 MFCCCoeff3 - 0.037 MFCCCoeff1 + 0.032 DeltaMFCC5 + 0.032 VocalEnergyBand3 - 0.032 ZeroCrossings - 0.031 DeltaMFCC6Var - 0.027 DeltaMFCC8 + 0.027 RMS - 0.027 MFCCCoeff7Var + 0.027 VocalEnergyBand3Var + 0.026 MFCCCoeff5 - 0.026 RMSVar + 0.024 DeltaMFCC12 - 0.022 DeltaMFCC12Var + 0.021 MFCCCoeff11Var + 0.021 DeltaMFCC1Var' "!pcaToConf4: file 	"Translate a set of PCA dimensions to a config file weighting"	"SirenUtility pcaToConf4: '/Volumes/Content/Code/FMAK4/MM_Explore/MM_Explore/FSongsEMF4-PCA.txt'"	| fil cnt inp val nam op oc min max |	fil := file asFilename readStream.	cnt := 0.	Transcript clear.	[fil atEnd]		whileFalse: 			[inp := ReadStream on: (fil upTo: Character cr).			inp skipSeparators.			oc := OrderedCollection new: 80.			min := 1000.			max := 0.			[inp atEnd]				whileFalse: 					[op := inp upTo: $ .					inp skipSeparators.					val := (inp upTo: $ ) asNumber.					inp skipSeparators.					nam := inp upTo: $ .					inp skipSeparators.					op size ~= 1 ifTrue: [self halt].					val > max ifTrue: ["		((op at: 1) = $-) ifTrue: [val := 0 - val]."						max := val].					val < min ifTrue: [min := val].					oc add: nam -> val].			max := max - min.	"	min := 0 - min."			cnt := cnt + 1.			Transcript show: 'Dist' , cnt printString , 'Heading Distance' , cnt printString; cr; cr; 				show: 'DistanceConfiguration {'; crtab.			oc do: [:item | Transcript show: item key , '	' , item value printString; crtab].			Transcript show: '}'; cr; cr]!pcaToConf4b: file 	"Translate a set of PCA dimensions to a config file weighting"	"SirenUtility pcaToConf4b: '/Volumes/Content/Code/FMAK4/MM_Explore/MM_Explore/FSongsEMF4-PCA.txt'"	| fil cnt inp val nam op oc min max names |	fil := file asFilename readStream.	cnt := 0.	names := self featureNameDictionary.	Transcript clear.	[fil atEnd]		whileFalse: 			[inp := ReadStream on: (fil upTo: Character cr).			inp skipSeparators.			oc := OrderedCollection new: 80.			min := 1000.			max := 0.			[inp atEnd]				whileFalse: 					[op := inp upTo: $ .					inp skipSeparators.					val := (inp upTo: $ ) asNumber.					inp skipSeparators.					nam := inp upTo: $ .					inp skipSeparators.					op size ~= 1 ifTrue: [self halt].					val > max ifTrue: ["		((op at: 1) = $-) ifTrue: [val := 0 - val]."						max := val].					val < min ifTrue: [min := val].					oc add: nam -> val].			max := max - min.	"	min := 0 - min."			cnt := cnt + 1.			Transcript show: 'DistanceConfiguration {'; crtab.			oc do: [:item | Transcript show: (names at: item key asSymbol) printString, '	' ,					item value printString; crtab].			Transcript show: '}'; cr; cr]!pcaToConf5: file 	"Translate a set of PCA dimensions to a config file weighting"	"SirenUtility pcaToConf5: '/Users/stp/Code/FMAK4/MM_Explore/lda_sfx5.txt'"	| fil cnt inp val coll ind |	fil := file asFilename readStream.	cnt := 1.	Transcript clear.	coll := OrderedCollection new.	inp := ReadStream on: (fil upTo: Character cr).	[inp atEnd] whileFalse: 		[coll addLast: (inp upTo: $,). inp skipSeparators].	[fil atEnd] whileFalse: 		[inp := ReadStream on: (fil upTo: Character cr).		Transcript show: 'Dist' , cnt printString , 'Heading Distance' , cnt printString; cr; cr; 				show: 'DistanceConfiguration {'; cr.		ind := 1.		[inp atEnd] whileFalse: 			[val := inp upTo: $,.			inp skipSeparators.			Transcript tab; show: (coll at: ind), '	', val; cr.			ind := ind + 1].			Transcript show: '}'; cr; cr.			cnt := cnt + 1].	fil close.!pcaToConf6: file 	"Translate a set of PCA/LDA dimensions to a config file weighting"	"SirenUtility pcaToConf6: '/Volumes/Content/Code/FMAK4/MM_Explore/MM_Explore/FSongsEMF4-PCA.txt'"	| fil cnt inp val coll ind names |	fil := file asFilename readStream.	cnt := 1.	Transcript clear.	coll := OrderedCollection new.	names := self featureNameDictionary."Read first line for feature names"	inp := ReadStream on: (fil upTo: Character cr).	[inp atEnd] whileFalse: 		[coll addLast: (inp upTo: $,). inp skipSeparators]."File loop"	[fil atEnd] whileFalse: 		[inp := ReadStream on: (fil upTo: Character cr).		Transcript show: 'Dist' , cnt printString , 'Heading Distance' , cnt printString; cr; cr; 				show: 'DistanceConfiguration {'; cr.		ind := 1."Line loop"		[inp atEnd] whileFalse: 			[val := inp upTo: $,.			inp skipSeparators.			Transcript tab; show: (names at: (coll at: ind) asSymbol) printString, '	', val; cr.			ind := ind + 1].			Transcript show: '}'; cr; cr.			cnt := cnt + 1].	fil close.!pcaToConf6: file title: title	"Translate a set of PCA/LDA dimensions to a config file weighting"	"SirenUtility pcaToConf6: '/Users/stp/Code/FMAK4/MM_Explore/MM_Explore/APM_Distances/lda_apm5_movement2'				title: 'Movement' "	| fil cnt inp val coll ind names |	fil := file asFilename readStream.	cnt := 1.	Transcript clear.	Transcript show: 'DistanceName ' , title; cr; cr.	coll := OrderedCollection new.	names := self featureNameDictionary."Read first line for feature names"	inp := ReadStream on: (fil upTo: Character cr).	[inp atEnd] whileFalse: 		[coll addLast: (inp upTo: $,). inp skipSeparators]."File loop"	[fil atEnd] whileFalse: 		[inp := ReadStream on: (fil upTo: Character cr).		Transcript show: '# ', title, ' Distance ' , cnt printString; cr; cr; 				show: 'DistanceConfiguration {'; cr.		ind := 1."Line loop"		[inp atEnd] whileFalse: 			[val := inp upTo: $,.			inp skipSeparators.			Transcript tab; show: (names at: (coll at: ind) asSymbol) printString, '	', val; cr.			ind := ind + 1].			Transcript show: '}'; cr; cr.			cnt := cnt + 1].	fil close!pcaToConf: argString	"Translate a set of PCA dimensions to a config file weighting"	| inp val nam op |	inp := ReadStream on: argString.	inp skipSeparators.	Transcript clear; show: 'Dist1Heading Distance1'; cr; cr; show: 'DistanceConfiguration {'; crtab.	[inp atEnd] whileFalse: 		[op := inp upTo: $ . inp skipSeparators.		val := inp upTo: $ . inp skipSeparators.		nam := inp upTo: $ . inp skipSeparators.		(op size ~= 1) ifTrue: [self halt].		((op at: 1) = $+) ifTrue: [Transcript show: nam, ' ', val; crtab].		((op at: 1) = $-) ifTrue: [Transcript show: nam, ' -', val; crtab]].	Transcript show: '}'; cr; cr"SirenUtility pcaToConf: ' - 0.299 DeltaMFCC4 - 0.299 MFCCCoeff4 - 0.283 SpectralBand4 - 0.251 SpectralBand3 + 0.215 DeltaMFCC11 + 0.215 MFCCCoeff11 - 0.199 SpectralSlope + 0.177 DeltaMFCC9 + 0.177 MFCCCoeff9 - 0.174 DeltaMFCC6 - 0.174 MFCCCoeff6 - 0.165 SpectralBand2 - 0.157 LPRMS + 0.143 DrumEnergyBand6 + 0.137 VocalEnergyBand2 - 0.132 SpectralBandwidthVar + 0.121 DrumEnergyBand6Var + 0.118 VocalEnergyBand2Var - 0.115 SpectralBandwidth + 0.114 DrumEnergyBand1 - 0.112 DeltaMFCC1 - 0.111 MFCCCoeff1 - 0.11 SpectralCentroidVar + 0.098 DrumEnergyBand1Var + 0.096 MFCCCoeff7 + 0.096 DeltaMFCC7 + 0.094 SpectralFluxVar + 0.093 MFCCCoeff12 + 0.093 DeltaMFCC12 - 0.092 ZeroCrossingsVar + 0.092 SpectralFlux - 0.09 DynamicRangeVar + 0.084 DrumEnergyBand2 - 0.083 DeltaMFCC1Var - 0.083 MFCCCoeff1Var + 0.075 DrumEnergyBand2Var + 0.071 SpectralBand3Var + 0.07  SpectralBand4Var + 0.069 SpectralVarietyVar - 0.068 DynamicRange + 0.068 DeltaMFCC10 + 0.068 MFCCCoeff10 - 0.067 SpectralRolloffVar - 0.067 MFCCCoeff3 - 0.067 DeltaMFCC3 - 0.065 Peak + 0.065 SpectralBandMax + 0.062 SpectralBandMaxVar - 0.061 DrumEnergyBand4Var - 0.061 SpectralMCentroidVar' "!printRatios	"Print ratios"	| line1 line2 |	line1 := ReadStream on: ''.	line2 := ReadStream on: ''.	Transcript clear.	[line1 atEnd]		whileFalse: 			[| n1 n2 n3 |			line1 skipSeparators.			line2 skipSeparators.			n1 := (line1 upTo: $,) asNumber.			n2 := (line2 upTo: $,) asNumber.			n1 > n2				ifTrue: [n3 := n1 / n2]				ifFalse: [n3 := n2 / n1].			n3 := n3 abs.			n3 < 1.0 ifTrue: [n3 := 1.0 / n3].			n3 < 1.2				ifTrue: [Transcript cr]				ifFalse: [Transcript show: n3 printString; cr]]!removeDblLines: sql to: outN	"Go through the list of all files checking for the name prefix like L0000011_."	| inp lin out |	inp := (Filename named: sql) readStream.	out := (Filename named: outN) writeStream.	[inp atEnd] whileFalse:		[lin := inp upTo: Character cr."		((lin size > 1) and: [(lin at: 1) = $C])			ifTrue: [self halt]."		('Cannot read file*' match: lin)			ifFalse: [out nextPutAll: lin; cr]].	inp close.	out close."SirenUtility removeDblLines: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/failed_abort.txt' 	to: '/Users/stp/Code/FMAK4/MM_Analyzer/DB_Pop1/failed_abort2.txt' "!renameFiles: fold 	"Create mv commands"	"Transcript clear.  SirenUtility renameFiles: '/Volumes/Content/iTunes/LMSMusic'"	| pos dir tail |	list := Filename filesMatching: (fold, '/*').	list do: 		[ :item | | fil |		fil := Filename named: item.		fil exists ifTrue:			[fil isDirectory				ifTrue: [Transcript show: '	Desc: ', item; cr.					SirenUtility renameFiles: item]				ifFalse: [pos := item lastIndexOf: $/ .					(((item at: pos + 1) == $M) 							and: [(item at: pos + 9) == $_]) 						ifTrue: [dir := item copyFrom: 1 to: pos.							tail := item copyFrom: pos + 10 to: item size."							Transcript show: 'mv ', item, '   ', dir, tail; cr."							Transcript show: tail; cr.							fil renameTo: (dir, tail)	]]]]!scrambleFileLines	"Read a file and write it with the lines in random order"	"SirenUtility scrambleFileLines"	| inp coll rnd out |	inp := (Filename named: '/Users/stp/Code/FMAK4/LaTiDo/LaTiDo_Beta5/song_list.txt') readStream.	coll := OrderedCollection new.	rnd := Random new.	out := (Filename named: '/Users/stp/Code/FMAK4/LaTiDo/LaTiDo_Beta5/song_list2.txt') writeStream.	[inp atEnd]		whileFalse: [coll addLast: (inp upTo: Character cr)].	Transcript show: 'scrambling ' , coll size printString , ' files'; cr.	[coll isEmpty]		whileFalse: 			[ | ind |			ind := (rnd next * coll size) truncated + 1.			out nextPutAll: (coll removeAtIndex: ind); cr].	out close.	inp close.	Transcript show: 'done'; cr!selectFileLines: inF to: outF base: bas every: ind	"Read a file and write it with the lines in random order"	"SirenUtility scrambleFileLines"	| inp out dir cnt lin |	inp := (Filename named: inF) readStream.	out := (Filename named: outF) writeStream.	dir := inF copyFrom: 1 to: (inF lastIndexOf: $/).	cnt := 0.	[inp atEnd] whileFalse: 		[lin := inp upTo: Character cr.		cnt := cnt + 1.		(cnt \\ ind = 0)			ifTrue: [ | dir2 |				dir2 := lin copyFrom: 1 to: (lin lastIndexOf: $/).				out nextPutAll: 'mkdir -p ', bas, '/', dir2; cr.				out nextPutAll: 'cp ', dir, lin, ' ', bas, '/', dir2; cr]].	out close.	inp close.	Transcript show: 'done'; cr" SirenUtility selectFileLines: '/Volumes/NewImagineDrive/song_list.txt' to: '/Volumes/NewImagineDrive/copy_songs.txt' 			base: '/Volumes/Media/New/APM' every: 10 "!sqlAsSanity2: fields from: table	"Create an SQL sanity test script"	"SELECT count(*) from Frames where RMS <= 0;	SELECT min(RMS), avg(RMS), max(RMS), stddev(RMS) FROM Frames WHERE RMS > 0; "	| strm |	Transcript clear.	strm := ReadStream on: fields.	[strm atEnd] whileFalse:		[ | fld |		fld := strm upTo: $ .		Transcript show: 'SELECT round(min(', fld, '), 4) as ', fld, ', round(avg(', fld, '), 4) as AVG, round(max(', fld, '), 4) as MAX, round(stddev(', fld, '), 4) as DEV FROM ', table, ';'; cr]"SirenUtility sqlAsSanity2: 'RMS Peak LPRMS HPRMS ZeroCrossings DynamicRange TemporalCentroid LogAttackTime AttackSlope StereoWidth BassDynamicity SpectralCentroid SpectralMCentroid SpectralSlope SpectralRolloff SpectralVariety SpectralFlux SpectralBandwidth SpectralSkewness SpectralKurtosis ChromaPeak ChromaWeight SpectralBand1 SpectralBand2 SpectralBand3 SpectralBand4 SpectralBandMax DrumEnergyBand1 DrumEnergyBand2 DrumEnergyBand3 DrumEnergyBand4 DrumEnergyBand5 DrumEnergyBand6 VocalEnergyBand1 VocalEnergyBand2 VocalEnergyBand3 MFCCCoeff1 MFCCCoeff2 MFCCCoeff3 MFCCCoeff4 MFCCCoeff5 MFCCCoeff6 MFCCCoeff7 MFCCCoeff8 MFCCCoeff9 MFCCCoeff10 MFCCCoeff11 MFCCCoeff12 DeltaMFCC1 DeltaMFCC2 DeltaMFCC3 DeltaMFCC4 DeltaMFCC5 DeltaMFCC6 DeltaMFCC7 DeltaMFCC8 DeltaMFCC9 DeltaMFCC10 DeltaMFCC11 DeltaMFCC12 LowPeakAmp LowPeakBPM MidPeakAmp MidPeakBPM HighPeakAmp HighPeakBPM LowMidRatio PeriodCentroid1 PeriodSpread1 PeriodCentroid2 PeriodSpread2 FP_gravity FP_bass FP_focus RMSVar PeakVar LPRMSVar HPRMSVar ZeroCrossingsVar DynamicRangeVar TemporalCentroidVar LogAttackTimeVar AttackSlopeVar StereoWidthVar BassDynamicityVar SpectralCentroidVar SpectralMCentroidVar SpectralSlopeVar SpectralRolloffVar SpectralVarietyVar SpectralFluxVar SpectralBandwidthVar SpectralSkewnessVar SpectralKurtosisVar ChromaPeakVar ChromaWeightVar SpectralBand1Var SpectralBand2Var SpectralBand3Var SpectralBand4Var SpectralBandMaxVar DrumEnergyBand1Var DrumEnergyBand2Var DrumEnergyBand3Var DrumEnergyBand4Var DrumEnergyBand5Var DrumEnergyBand6Var VocalEnergyBand1Var VocalEnergyBand2Var VocalEnergyBand3Var MFCCCoeff1Var MFCCCoeff2Var MFCCCoeff3Var MFCCCoeff4Var MFCCCoeff5Var MFCCCoeff6Var MFCCCoeff7Var MFCCCoeff8Var MFCCCoeff9Var MFCCCoeff10Var MFCCCoeff11Var MFCCCoeff12Var DeltaMFCC1Var DeltaMFCC2Var DeltaMFCC3Var DeltaMFCC4Var DeltaMFCC5Var DeltaMFCC6Var DeltaMFCC7Var DeltaMFCC8Var DeltaMFCC9Var DeltaMFCC10Var DeltaMFCC11Var DeltaMFCC12Var ' from: 'FSongsAPM'"!sqlAsSanity: fields from: table	"Create an SQL sanity test script"	"SELECT count(*) from Frames where RMS <= 0;	SELECT min(RMS), avg(RMS), max(RMS), stddev(RMS) FROM Frames WHERE RMS > 0; "	| strm |	Transcript clear.	strm := ReadStream on: fields.	[strm atEnd] whileFalse:		[ | fld |		fld := strm upTo: $ .		Transcript show: 'SELECT count(*) as ', fld, ' from ', table, ' where ', fld, ' < 0;'; cr;		show: 'SELECT round(min(', fld, '), 4) as MIN, round(avg(', fld, '), 4) as AVG, round(max(', fld, '), 4) as MAX, round(stddev(', fld, '), 4) as DEV FROM ', table, ' WHERE ', fld, ' > 0;'; cr]"SirenUtility sqlAsSanity: 'RMS Peak LPRMS HPRMS ZeroCrossings DynamicRange TemporalCentroid LogAttackTime AttackSlope StereoWidth BassDynamicity SpectralCentroid SpectralMCentroid SpectralSlope SpectralRolloff SpectralVariety SpectralFlux SpectralBandwidth SpectralSkewness SpectralKurtosis ChromaPeak ChromaWeight SpectralBand1 SpectralBand2 SpectralBand3 SpectralBand4 SpectralBandMax DrumEnergyBand1 DrumEnergyBand2 DrumEnergyBand3 DrumEnergyBand4 DrumEnergyBand5 DrumEnergyBand6 VocalEnergyBand1 VocalEnergyBand2 VocalEnergyBand3 MFCCCoeff1 MFCCCoeff2 MFCCCoeff3 MFCCCoeff4 MFCCCoeff5 MFCCCoeff6 MFCCCoeff7 MFCCCoeff8 MFCCCoeff9 MFCCCoeff10 MFCCCoeff11 MFCCCoeff12 DeltaMFCC1 DeltaMFCC2 DeltaMFCC3 DeltaMFCC4 DeltaMFCC5 DeltaMFCC6 DeltaMFCC7 DeltaMFCC8 DeltaMFCC9 DeltaMFCC10 DeltaMFCC11 DeltaMFCC12 LowPeakAmp LowPeakBPM MidPeakAmp MidPeakBPM HighPeakAmp HighPeakBPM LowMidRatio PeriodCentroid1 PeriodSpread1 PeriodCentroid2 PeriodSpread2 FP_gravity FP_bass FP_focus RMSVar PeakVar LPRMSVar HPRMSVar ZeroCrossingsVar DynamicRangeVar TemporalCentroidVar LogAttackTimeVar AttackSlopeVar StereoWidthVar BassDynamicityVar SpectralCentroidVar SpectralMCentroidVar SpectralSlopeVar SpectralRolloffVar SpectralVarietyVar SpectralFluxVar SpectralBandwidthVar SpectralSkewnessVar SpectralKurtosisVar ChromaPeakVar ChromaWeightVar SpectralBand1Var SpectralBand2Var SpectralBand3Var SpectralBand4Var SpectralBandMaxVar DrumEnergyBand1Var DrumEnergyBand2Var DrumEnergyBand3Var DrumEnergyBand4Var DrumEnergyBand5Var DrumEnergyBand6Var VocalEnergyBand1Var VocalEnergyBand2Var VocalEnergyBand3Var MFCCCoeff1Var MFCCCoeff2Var MFCCCoeff3Var MFCCCoeff4Var MFCCCoeff5Var MFCCCoeff6Var MFCCCoeff7Var MFCCCoeff8Var MFCCCoeff9Var MFCCCoeff10Var MFCCCoeff11Var MFCCCoeff12Var DeltaMFCC1Var DeltaMFCC2Var DeltaMFCC3Var DeltaMFCC4Var DeltaMFCC5Var DeltaMFCC6Var DeltaMFCC7Var DeltaMFCC8Var DeltaMFCC9Var DeltaMFCC10Var DeltaMFCC11Var DeltaMFCC12Var ' from: 'Frames1107a'"!sqlAsTable1: sql	"turn SQL inserts into lists"	| inp line1 line2 val |	inp := ReadStream on: sql.	inp upTo: $( .	line1 := ReadStream on: (inp upTo: $)).	inp upTo: $( .	line2 := ReadStream on: (inp upTo: $)).	Transcript clear.	[line1 atEnd] whileFalse:		[line1 skipSeparators.		line2 skipSeparators.		val := line2 upTo: $,.		((val size > 8) and: [(val first isDigit) or: [val first == $-]]) ifTrue: [val := val copyFrom: 1 to: 8].		Transcript show: (line1 upTo: $,), '	', val; cr]" [ SirenUtility sqlAsTable1: '' ] "!sqlAsTable2: str 	"turn SQL inserts into lists"	| inp line1 line2 line3 line4 line5 |	inp := ReadStream on: str.	line1 := ReadStream on: (inp upTo: Character cr).	line2 := ReadStream on: (inp upTo: Character cr).	line3 := ReadStream on: (inp upTo: Character cr).	line4 := ReadStream on: (inp upTo: Character cr).	line5 := ReadStream on: (inp upTo: Character cr).	Transcript clear.	"SirenUtility sqlAsTable2: ''	"	[line1 atEnd]		whileFalse: 			[Transcript show: (line1 upTo: $,)					, '	' , (line2 upTo: $,) , '	' , (line3 upTo: $,) , '	' , (line4 upTo: $,) , '	' , (line5 upTo: $,); cr.			line1 skipSeparators.			line2 skipSeparators.			line3 skipSeparators.			line4 skipSeparators.			line5 skipSeparators]!sqlAsTable3: str	"turn SQL record print-outs into lists"	| inp line1 line2 |	inp := ReadStream on: str.	line1 := ReadStream on: (inp upTo: Character cr).	line2 := ReadStream on: (inp upTo: Character cr).	line1 skip: 1.	line2 skip: 1.	Transcript clear.	[line1 atEnd] whileFalse:		[ | tag val |		tag := line1 upTo: $|.		[tag first = $ ] whileTrue: [tag := tag copyFrom: 2 to: tag size].		[tag last = $ ] whileTrue: [tag := tag copyFrom: 1 to: tag size - 1].		val := line2 upTo: $|.		[(val size > 0) and: [val first = $ ]] whileTrue: [val := val copyFrom: 2 to: val size].		[(val size > 0) and: [val last = $ ]] whileTrue: [val := val copyFrom: 1 to: val size - 1].		Transcript show: tag, '	', val; cr.		line1 skipSeparators.		line2 skipSeparators]"SirenUtility sqlAsTable3: '| OID   | Version | File                                                                                                                | Name                      | Title                | Artist            | Album               | Year | Bit_Rate | Frame_Rate | Duration | RealDuration | Format | Genre       | Labels | peakAvg  | peakVar  | peakDel       | peakDel2        | rmsAvg  | rmsVar  | rmsDel    | rmsDel2     | lp_rmsAvg | lp_rmsVar | lp_rmsDel   | lp_rmsDel2    | hp_rmsAvg | hp_rmsVar | hp_rmsDel  | hp_rmsDel2      | dyn_rangeAvg | dyn_rangeVar | dyn_rangeDel        | dyn_rangeDel2 | stereoAvg | stereoVar | stereoDel   | stereoDel2   | spectCentAvg | spectCentVar | spectCentDel | spectCentDel2 | spectRollAvg | spectRollVar | spectRollDel | spectRollDel2 | spectSpreadAvg | spectSpreadVar | spectSpreadDel | spectSpreadDel2 | spectSkewAvg | spectSkewVar | spectSkewDel | spectSkewDel2 | spectKurtAvg | spectKurtVar | spectKurtDel | spectKurtDel2 | spectSlopeAvg | spectSlopeVar | spectSlopeDel | spectSlopeDel2 | spectVarAvg | spectVarVar | spectVarDel | spectVarDel2 | bands0Avg  | bands0Var | bands0Del      | bands0Del2       | bands1Avg | bands1Var | bands1Del      | bands1Del2      | bands2Avg | bands2Var | bands2Del      | bands2Del2      | bands3Avg | bands3Var | bands3Del       | bands3Del2       | drums0Avg  | drums0Var  | drums0Del       | drums0Del2       | drums1Avg  | drums1Var | drums1Del      | drums1Del2       | drums2Avg | drums2Var | drums2Del      | drums2Del2      | drums3Avg  | drums3Var | drums3Del      | drums3Del2      | drums4Avg | drums4Var | drums4Del      | drums4Del2    | drums5Avg  | drums5Var | drums5Del       | drums5Del2       | drums6Avg  | drums6Var | drums6Del      | drums6Del2       | mfcc0Avg | mfcc0Var | mfcc0Del  | mfcc0Del2   | mfcc1Avg | mfcc1Var | mfcc1Del   | mfcc1Del2   | mfcc2Avg | mfcc2Var | mfcc2Del  | mfcc2Del2  | mfcc3Avg | mfcc3Var | mfcc3Del   | mfcc3Del2    | mfcc4Avg | mfcc4Var | mfcc4Del  | mfcc4Del2    | mfcc5Avg | mfcc5Var | mfcc5Del    | mfcc5Del2  | mfcc6Avg | mfcc6Var | mfcc6Del  | mfcc6Del2    | mfcc7Avg | mfcc7Var | mfcc7Del  | mfcc7Del2     | mfcc8Avg | mfcc8Var | mfcc8Del   | mfcc8Del2    | mfcc9Avg | mfcc9Var | mfcc9Del   | mfcc9Del2    | mfcc10Avg | mfcc10Var | mfcc10Del  | mfcc10Del2   | mfcc11Avg | mfcc11Var | mfcc11Del   | mfcc11Del2  | mfcc12Avg | mfcc12Var | mfcc12Del  | mfcc12Del2   | chroMaxAvg | chroMaxVar | chroMaxDel  | chroMaxDel2 | chroWhtAvg | chroWhtVar | chroWhtDel   | chroWhtDel2  | chromaW0 | chromaW1 | chromaW2 | chromaW3 | chromaW4 | chromaW5 | chromaI0 | chromaI1 | chromaI2 | chromaI3 | bh_lowpeakamp | bh_midpeakamp | bh_highpeakamp | bh_lowpeakBPM | bh_midpeakBPM | bh_highpeakBPM | bh_pdcentroid1 | bh_pdcentroid2 | bh_pdspread1 | bh_pdspread2 | bh_tempo | fp_gravity | fp_bass | fp_focus | quiet    | loud     | Normalized | Dummy || 17423 |  120606 | /Volumes/Content/Sound/FASTLab/Rock/Alternative/The White Stripes/Get Behind Me Satan/09 - Passive Manipulation.mp3 | 09 - Passive Manipulation | Passive Manipulation | The White Stripes | Get Behind Me Satan | 2005 |      192 |      44100 |       35 |         NULL | mp3    | Alternative | NULL   | 0.192291 | 0.116928 | 0.00000222394 | -0.000000776818 | 67.9935 | 6.36435 | 0.0269291 | -0.00303174 |  0.847879 |  0.059893 | 0.000519927 | -0.0000306582 |  0.876554 | 0.0486395 | 0.00043811 | -0.000000947992 |      1.43161 |     0.911636 | -0.0000000000783756 |             0 |   1.04191 | 0.0227366 | 0.000730619 | 0.0000300477 |      912.902 |       665.86 |     0.712529 |     0.0348412 |       1893.6 |      1693.18 |      1.10427 |    -0.0424718 |        55.8735 |         26.712 |      0.0607197 |      0.00351417 |      3.11733 |      1.00431 |   0.00180198 |  0.0000255831 |      551.413 |      931.738 |     0.459566 |     0.0366734 |     -0.192111 |      0.241438 |  -0.000423905 |  -0.0000153122 |     15.3483 |     13.9327 | 0.000269049 | -0.000202881 | 0.00405654 | 0.0115113 | 0.000000157337 | -0.0000000762126 | 0.0285801 | 0.0605365 | 0.000000825425 | -0.000000614326 | 0.0441162 | 0.0326995 | 0.000000136991 | -0.000000111565 | 0.0117488 | 0.0100603 | 0.0000000856726 | -0.0000000657855 | 0.00266336 | 0.00387538 | 0.0000000849702 | -0.0000000782795 | 0.00414807 | 0.0313553 | 0.000000114193 | -0.0000000977018 | 0.0121219 | 0.0315659 | 0.000000217175 | -0.000000337324 | 0.00498537 | 0.0101859 | 0.000000147585 | -0.000000335092 | 0.0442431 | 0.0385287 | 0.000000475968 | 0.00000021425 | 0.00850986 | 0.0160413 | 0.0000000855441 | -0.0000000690647 | 0.00792804 | 0.0138176 | 0.000000110215 | -0.0000000398989 | -158.182 |  19.9903 | -0.169205 | -0.00790593 | -16.6639 |  7.20077 | -0.0275972 | -0.00308902 |  45.3643 |  5.54171 | 0.0431115 | 0.00199847 | -29.8003 |  4.85354 | -0.0207538 | -0.000289898 |  15.0912 |  3.15155 | 0.0142022 | -0.000696169 | -2.28955 |  2.66135 | 0.000860066 | 0.00119418 | -9.26957 |  2.68688 | -0.004614 | -0.000324289 |  11.2376 |  2.63934 | 0.0111536 | -0.0000819382 | -14.6686 |   1.7228 | -0.0102186 | 0.0000827001 |  7.60839 |  1.70503 | 0.00517882 | -0.000946577 |   -2.2558 |   1.66157 | -0.0033257 | -0.000625911 |  -5.80585 |   1.46011 | -0.00633996 | -0.00139861 |   6.00967 |   1.36157 | 0.00554991 | -0.000205676 |     5.2906 |    2.99216 | 0.000657462 |           0 |    17.4494 |     9.4196 | 0.0000814388 | -0.000381717 |  15.9596 |  14.5038 |  13.9974 |  12.6361 |  12.4857 |  12.4006 |        4 |        5 |        3 |        4 |       1187.56 |       774.676 |          700.7 |            84 |           111 |         152.25 |        0.47378 |       0.525235 |     0.307083 |     0.284018 |       83 |    11.7904 | 1176.07 | 0.266031 | 0.188034 | 0.361604 |          0 |  NULL |'"!sqlAsTable4: sql	"turn SQL inserts into lists"	| inp line1 line2 |	inp := ReadStream on: sql.	line1 := ReadStream on: (inp upTo: Character cr).	line2 := ReadStream on: (inp upTo: Character cr).	Transcript clear.	[line1 atEnd] whileFalse:		[line1 skipSeparators.		line2 skipSeparators.		Transcript show: (line1 upTo: $|), '	', (line2 upTo: $|); cr]"SirenUtility sqlAsTable4: '| OID | Version | RMS     | Peak | LPRMS    | HPRMS    | ZeroCrossings | NumOnsets | DynamicRange | Tempo | TemporalCentroid | StereoWidth | STrackBirths | STrackDeaths | LogAttackTime | AttackSlope | TemporalDelta | DynamicRange2 | TemporalSkewness | TemporalKurtosis | SpectralCentroid | SpectralMCentroid | SpectralSlope | SpectralVariety | SpectralFlux | SpectralRolloff | SpectralBandwidth | SpectralSkewness | SpectralKurtosis | BassDynamicity | ChromaPeak | ChromaWeight | SpectralBand1 | SpectralBand2 | SpectralBand3 | SpectralBand4 | SpectralBandMax | DrumEnergyBand1 | DrumEnergyBand2 | DrumEnergyBand3 | DrumEnergyBand4 | DrumEnergyBand5 | DrumEnergyBand6 | VocalEnergyBand1 | VocalEnergyBand2 | VocalEnergyBand3 | MFCCCoeff1 | MFCCCoeff2 | MFCCCoeff3 | MFCCCoeff4 | MFCCCoeff5 | MFCCCoeff6 | MFCCCoeff7 | MFCCCoeff8 | MFCCCoeff9 | MFCCCoeff10 | MFCCCoeff11 | MFCCCoeff12 | DeltaMFCC1 | DeltaMFCC2 | DeltaMFCC3 | DeltaMFCC4 | DeltaMFCC5 | DeltaMFCC6  | DeltaMFCC7 | DeltaMFCC8 | DeltaMFCC9 | DeltaMFCC10 | DeltaMFCC11 | DeltaMFCC12 | Dummy | Name                                                                                    | Title              | Artist  | Album          | FYear | BitRate | FrameRate | Duration | AnalyzedOn          | FileFormat | genre | SubGenre | Genre1 | Genre2 | Genre1Weight | Genre2Weight | Instrument1 | Instrument2 | Instrument1Weight | Instrument2Weight | AvgFT | WeightedFT | TempoAvg | TempoWeight | TempoDistr | TrackerConf | SegmentConf | SegmentWeight | NumSegments | VerseLength | TypicalIndex | SoloIndex | FirstVerseStart | TypicalStart | SoloStart | FadeIn | FadeOut | QuietSections | LoudSections | SoloCentroid | SoloVariety | SoloDynRange | SoloTempo | SoloRMS | LowPeakAmp | LowPeakBPM | MidPeakAmp | MidPeakBPM | HighPeakAmp | HighPeakBPM | LowMidRatio | PeriodCentroid1 | PeriodSpread1 | PeriodCentroid2 | PeriodSpread2 | FP_gravity | FP_bass | FP_focus | IgnoreMe | Frame_id | RealDuration | RMSVar  | PeakVar | LPRMSVar  | HPRMSVar  | ZeroCrossingsVar | NumOnsetsVar | DynamicRangeVar | TempoVar | TemporalCentroidVar | StereoWidthVar | STrackBirthsVar | STrackDeathsVar | LogAttackTimeVar | AttackSlopeVar | TemporalDeltaVar | DynamicRange2Var | TemporalSkewnessVar | TemporalKurtosisVar | SpectralCentroidVar | SpectralMCentroidVar | SpectralSlopeVar | SpectralVarietyVar | SpectralFluxVar | SpectralRolloffVar | SpectralBandwidthVar | SpectralSkewnessVar | SpectralKurtosisVar | BassDynamicityVar | ChromaPeakVar | ChromaWeightVar | SpectralBand1Var | SpectralBand2Var | SpectralBand3Var | SpectralBand4Var | SpectralBandMaxVar | DrumEnergyBand1Var | DrumEnergyBand2Var | DrumEnergyBand3Var | DrumEnergyBand4Var | DrumEnergyBand5Var | DrumEnergyBand6Var | VocalEnergyBand1Var | VocalEnergyBand2Var | VocalEnergyBand3Var | MFCCCoeff1Var | MFCCCoeff2Var | MFCCCoeff3Var | MFCCCoeff4Var | MFCCCoeff5Var | MFCCCoeff6Var | MFCCCoeff7Var | MFCCCoeff8Var | MFCCCoeff9Var | MFCCCoeff10Var | MFCCCoeff11Var | MFCCCoeff12Var | DeltaMFCC1Var | DeltaMFCC2Var | DeltaMFCC3Var | DeltaMFCC4Var | DeltaMFCC5Var | DeltaMFCC6Var | DeltaMFCC7Var | DeltaMFCC8Var | DeltaMFCC9Var | DeltaMFCC10Var | DeltaMFCC11Var | DeltaMFCC12Var | Normalized | NameToken | NameHash ||   7 |     401 | 84.0758 |    1 | 0.985711 | 0.911627 |       35.2401 |      NULL |      1.44974 |  NULL |             NULL |   0.0275899 |         NULL |         NULL |          NULL |        NULL |          NULL |          NULL |             NULL |             NULL |          2543.71 |           36.2414 |      0.949313 |         41.1234 |      411.234 |          4411.1 |           2445.45 |          -1.0037 |          1.00933 |        0.77805 |    4.72762 |    0.0994907 |      0.460558 |      0.682761 |      0.560796 |      0.254011 |         1.68034 |       0.0125302 |       0.0234091 |       0.0429922 |        0.154923 |       0.0672378 |        0.274716 |         0.287072 |         0.361746 |         0.151492 |   -156.403 |    30.1007 |    -9.1536 |    4.26657 |    2.49706 |    1.54698 |     2.1409 |   -2.54895 |    5.28766 |    -3.90333 |     7.20927 |     -6.8558 |   -1.41547 |   -0.32091 |   0.162287 | -0.0371563 |   0.122429 | -0.0020153 |  0.0390949 | -0.0208084 | -0.0373697 |     0.14992 |   -0.252382 |   -0.869272 |     0 | /Volumes/Content/Imagine/likeZEBRA/00048a18cf612aa76a34d9586abd694a-192k.mp3 | A Gentleman Caller | Cursive | The Ugly Organ |  2003 |     192 |     44100 |  198.687 | 2012-02-06 11:48:22 | NULL       |       | NULL     |        |        |            0 |            0 |             |             |                 0 |                 0 |  NULL |       NULL |       75 |     4.82022 |          0 |        NULL |        NULL |           0.2 |           7 |     14.2791 |         NULL |      NULL |            NULL |      15.3721 |   29.6512 |    0.1 |       1 |      0.227273 |     0.459596 |      1.01222 |    0.978416 |     0.998257 |  0.999205 | 1.01675 |    2115.94 |         76 |    1879.54 |      101.5 |     2425.09 |       152.5 |    0.748768 |        0.509922 |      0.322213 |        0.561144 |      0.289624 |    12.9884 | 889.571 |  0.24823 |        0 |     NULL |         NULL | 4.71803 |       0 | 0.0189726 | 0.0462158 |          18.3732 |         NULL |        0.288789 |     NULL |                NULL |      0.0313974 |            NULL |            NULL |             NULL |           NULL |             NULL |             NULL |                NULL |                NULL |             916.158 |              5.04453 |         0.737833 |            37.6228 |         376.204 |            2156.71 |              884.775 |                   0 |          0.00276028 |                 0 |       2.78317 |       0.0826722 |         0.477139 |         0.638193 |         0.182613 |         0.133611 |           0.838511 |          0.0141522 |          0.0546544 |          0.0610459 |          0.0827348 |          0.0390911 |           0.084203 |            0.136754 |           0.0900187 |           0.0547591 |             0 |        5.4759 |         6.177 |       3.79211 |       3.72598 |       2.28716 |       2.22553 |       1.83518 |       1.52066 |        1.41427 |        1.40663 |              0 |       8.52226 |       3.55717 |       2.96468 |       2.75269 |        2.4559 |       2.05688 |       1.67187 |       1.35652 |        1.1467 |        1.08005 |        1.15847 |        1.25469 |          0 | NULL      |     NULL |'"!sqlAsTable5: str	"turn SQL inserts into lists" | inp line1 line2 |inp := ReadStream on: str.line1 := ReadStream on: (inp upTo: Character cr).line2 := ReadStream on: (inp upTo: Character cr).Transcript clear.[line1 atEnd] whileFalse:	[Transcript show: (line1 upTo: $|), '	', (line2 upTo: $|); cr.	line1 skipSeparators.	line2 skipSeparators]"SirenUtility sqlAsTable5: 'OID | Version | RMS      | Peak     | LPRMS    | HPRMS    | ZeroCrossings | NumOnsets | DynamicRange | Tempo | TemporalCentroid | StereoWidth | STrackBirths | STrackDeaths | LogAttackTime | AttackSlope | TemporalDelta | DynamicRange2 | TemporalSkewness | TemporalKurtosis | SpectralCentroid | SpectralMCentroid | SpectralSlope | SpectralVariety | SpectralFlux | SpectralRolloff | SpectralBandwidth | SpectralSkewness | SpectralKurtosis | BassDynamicity | ChromaPeak | ChromaWeight | SpectralBand1 | SpectralBand2 | SpectralBand3 | SpectralBand4 | SpectralBandMax | DrumEnergyBand1 | DrumEnergyBand2 | DrumEnergyBand3 | DrumEnergyBand4 | DrumEnergyBand5 | DrumEnergyBand6 | VocalEnergyBand1 | VocalEnergyBand2 | VocalEnergyBand3 | MFCCCoeff1 | MFCCCoeff2 | MFCCCoeff3 | MFCCCoeff4 | MFCCCoeff5 | MFCCCoeff6 | MFCCCoeff7 | MFCCCoeff8 | MFCCCoeff9 | MFCCCoeff10 | MFCCCoeff11 | MFCCCoeff12 | DeltaMFCC1 | DeltaMFCC2 | DeltaMFCC3 | DeltaMFCC4 | DeltaMFCC5 | DeltaMFCC6 | DeltaMFCC7 | DeltaMFCC8 | DeltaMFCC9 | DeltaMFCC10 | DeltaMFCC11 | DeltaMFCC12 | Dummy | Name                                                                         | Title                                                            | Artist                           | Album                          | FYear | BitRate | FrameRate | Duration | AnalyzedOn          | FileFormat | Genre                | SubGenre | Genre1 | Genre2 | Genre1Weight | Genre2Weight | Instrument1 | Instrument2 | Instrument1Weight | Instrument2Weight | AvgFT | WeightedFT | TempoAvg | TempoWeight | TempoDistr | TrackerConf | SegmentConf | SegmentWeight | NumSegments | VerseLength | TypicalIndex | SoloIndex | FirstVerseStart | TypicalStart | SoloStart | FadeIn  | FadeOut | QuietSections | LoudSections | SoloCentroid | SoloVariety | SoloDynRange | SoloTempo | SoloRMS  | LowPeakAmp | LowPeakBPM | MidPeakAmp | MidPeakBPM | HighPeakAmp | HighPeakBPM | LowMidRatio | PeriodCentroid1 | PeriodSpread1 | PeriodCentroid2 | PeriodSpread2 | FP_gravity | FP_bass  | FP_focus | IgnoreMe | Frame_id | RealDuration | RMSVar   | PeakVar | LPRMSVar | HPRMSVar | ZeroCrossingsVar | NumOnsetsVar | DynamicRangeVar | TempoVar | TemporalCentroidVar | StereoWidthVar | STrackBirthsVar | STrackDeathsVar | LogAttackTimeVar | AttackSlopeVar | TemporalDeltaVar | DynamicRange2Var | TemporalSkewnessVar | TemporalKurtosisVar | SpectralCentroidVar | SpectralMCentroidVar | SpectralSlopeVar | SpectralVarietyVar | SpectralFluxVar | SpectralRolloffVar | SpectralBandwidthVar | SpectralSkewnessVar | SpectralKurtosisVar | BassDynamicityVar | ChromaPeakVar | ChromaWeightVar | SpectralBand1Var | SpectralBand2Var | SpectralBand3Var | SpectralBand4Var | SpectralBandMaxVar | DrumEnergyBand1Var | DrumEnergyBand2Var | DrumEnergyBand3Var | DrumEnergyBand4Var | DrumEnergyBand5Var | DrumEnergyBand6Var | VocalEnergyBand1Var | VocalEnergyBand2Var | VocalEnergyBand3Var | MFCCCoeff1Var | MFCCCoeff2Var | MFCCCoeff3Var | MFCCCoeff4Var | MFCCCoeff5Var | MFCCCoeff6Var | MFCCCoeff7Var | MFCCCoeff8Var | MFCCCoeff9Var | MFCCCoeff10Var | MFCCCoeff11Var | MFCCCoeff12Var | DeltaMFCC1Var | DeltaMFCC2Var | DeltaMFCC3Var | DeltaMFCC4Var | DeltaMFCC5Var | DeltaMFCC6Var | DeltaMFCC7Var | DeltaMFCC8Var | DeltaMFCC9Var | DeltaMFCC10Var | DeltaMFCC11Var | DeltaMFCC12Var | Normalized | NameToken          | NameHash |117 |    NULL | -1.83717 | -3.90253 | -4.08645 | 0.785797 |     -0.793643 |      NULL |     -2.50231 |   142 |             NULL |    -1.11733 |         NULL |         NULL |          NULL |        NULL |          NULL |          NULL |             NULL |             NULL |         -2.80726 |          -1.97672 |      0.839651 |        -1.06561 |     -2.03585 |        -1.21814 |          -2.80614 |        0.0361157 |        0.0665514 |        2.51223 |    3.06326 |      1.23933 |     -0.405384 |     -0.152297 |     -0.156569 |     -0.187089 |        -2.23537 |       -0.889843 |        -2.08139 |        -3.79159 |       -0.460359 |         6.17459 |         3.19844 |         0.266324 |          1.76117 |         -3.23064 |   -2.24078 |    4.87082 |   -4.26584 |   -4.96812 |   0.917358 |   -4.30851 |    -2.8051 |   -4.95841 |   -1.28653 |    -2.29132 |    0.243058 |    -1.84485 |    2.93851 |  -0.734525 |  -0.615343 |    1.04836 |   -2.59857 |  -0.351315 |   0.756947 |   0.147634 |    2.03962 |    0.895794 |    -2.58086 |    0.330826 |     0 | /Volumes/APM_DataSet/Content/SON/SCD/wav/SON_SCD_0065/SON_SCD_0065_01501.wav | Emotion 15 - with great expression | Human EMOTIONS - ROMANCE | Sonoton Recorded Music Library |     0 |       0 |         0 |  2.24273 | 2011-08-13 15:45:04 | NULL       | ATMOSPHERES PEACEFUL | NULL     |        |        |            0 |            0 | Strings     |             |                 0 |                 0 |  NULL |       NULL |      142 |     1.67326 |          0 |        NULL |        NULL |      -2.19587 |           3 |   -0.938632 |         NULL |      NULL |            NULL |     -1.40177 |   -1.3122 | 7.41176 | 2.06976 |       2.70217 |       3.7466 |     -4.00987 |     7.25745 |     0.618955 |   2.53414 | -6.43671 |   -2.23654 |   -2.67692 |   -1.27333 |    3.68575 |    -1.70656 |     2.09562 |    -5.83788 |      -0.0403466 |    -0.0376683 |        0.288977 |      0.643274 |  -0.494681 | -3.11423 |  5.01688 |        0 |     NULL |          147 | -0.48327 |       0 | 0.467474 |  1.35661 |         -2.06447 |         NULL |        -3.51508 |     NULL |                NULL |      -0.518306 |            NULL |            NULL |             NULL |           NULL |             NULL |             NULL |                NULL |                NULL |            -2.96269 |              4.33998 |        0.0222154 |           -1.13263 |       -0.326599 |           0.092265 |             -2.95931 |             1.13189 |            0.370121 |                 0 |       4.25886 |         6.26155 |          0.26138 |        -0.234169 |        -0.254173 |        -0.265407 |          -0.112271 |           -1.15201 |           -2.15888 |            -3.7721 |            3.35442 |            6.45882 |            2.13194 |            0.810697 |             4.94452 |            -1.80374 |       -2.7001 |     -0.657421 |       2.87821 |      -1.49955 |      -2.54399 |       1.35592 |      0.969165 |      0.903667 |       1.22003 |         -1.952 |       -0.85463 |      -0.399615 |      -2.56504 |      -1.57809 |        -2.668 |      -3.65277 |     -0.802104 |     -0.445918 |      0.367635 |      -3.05127 |      -2.38813 |       -5.59726 |      -0.822447 |       -5.71447 |          1 | SON_SCD_0065_01501 |     NULL |'"!sqlAsTable: sql	"turn SQL inserts into lists"	| inp line1 line2 val |	inp := ReadStream on: sql.	line1 := ReadStream on: (inp upTo: Character cr).	line2 := ReadStream on: (inp upTo: Character cr).	Transcript clear.	[line1 atEnd] whileFalse:		[line1 skipSeparators.		line2 skipSeparators.		val := line2 upTo: $,.		((val first isDigit) and: [val size > 8]) ifTrue: [val := val copyFrom: 1 to: 8].		Transcript show: (line1 upTo: $,), '	', val; cr]" [ SirenUtility sqlAsTable: '' ] "!timingsTable: file 	"Read a list of timing summaries and summarize"	"SirenUtility timingsTable: '/Volumes/Content/Code/Python/SndsLike/Doc/timing2.txt'"	"Timing table (msec)	Start-up           0.0	Pre-proc          18.5	Load            6039.5	Setup              4.5	Analysis        1834.5	Stage2             0.0	Fl_Patt         2919.0	Bt_Hist         7079.8	Chroma             0.4	Stats              0.8	DB save          217.8	Clean-up           0.6	Total          18115.9"	| fil inp tok val dat count lin iCount inds nam tot |	fil := file asFilename readStream.	dat := Dictionary new.	inds := Dictionary new.	count := 0.	iCount := 1."Read file line-by-line"	[fil atEnd] whileFalse: 		[lin := fil upTo: Character cr.		(lin includes: Character tab)			" if it's a label line"			ifFalse: [count := count + 1. iCount := 1]			ifTrue: [inp := ReadStream on: lin.				inp skipSeparators.				tok := (inp upTo: Character space) asSymbol.				inp skipSeparators.				val := inp upToEnd asNumber.				inds at: iCount put: tok.				iCount := iCount + 1.				(dat includesKey: tok)					ifFalse: [dat at: tok put: val]					ifTrue: [dat at: tok put: (val + (dat at: tok))]]].	fil close.	tot := ((dat at: #Total)  / 1000.0)."self halt."	Transcript clear; cr; show: 'Timing Averages'; cr; cr.	inds keysDo: [ :k |		nam := inds at: k.		val := ((dat at: nam) asFloat / tot) asInteger.		Transcript show: nam asString, '		', val printString; cr].	Transcript cr; cr."	Transcript show: 'Sorted by %'; cr; cr.	inds := dat associations asSortedCollection: [ :a :b | a value > b value].	inds do:		[  :ass |		nam := ass key.		val := (((dat at: nam) / count) / tot) asInteger.		Transcript show: nam asString, '		', val printString; cr]"!weightsToScale: file 	"Translate a set of normalizer output messages to scales tables"	"SirenUtility weightsToScale: '/Volumes/Content/Code/FMAK4/MM_Explore/MM_Explore/weightsAPM.txt'"	"--                  RMS  min:        1.529  avg:       76.687  max:       87.629  var:       78.935  dev:        8.885"	| fil inp tok avg dev names avgCmd devCmd |	fil := file asFilename readStream.	names := self featureNameDictionary.	avgCmd := WriteStream on: (String new: 1024).	devCmd := WriteStream on: (String new: 1024).	avgCmd nextPutAll: 'AverageWeights {'; cr.	devCmd nextPutAll: 'StdDevWeights {'; cr."Read file line-by-line"	[fil atEnd] whileFalse: 		[inp := ReadStream on: (fil upTo: Character cr).		inp skip: 2.		inp skipSeparators.		tok := inp upTo: $ .		Transcript show: tok; cr.		inp throughAll: 'avg:'.		inp skipSeparators.		avg := inp upTo: $ .		inp throughAll: 'dev:'.		inp skipSeparators.		dev := inp upToEnd.		avgCmd tab; nextPutAll: ((names at: tok asSymbol) printString, ' ', avg); cr.		devCmd tab; nextPutAll: ((names at: tok asSymbol) printString, ' ', dev); cr.].	inp close.	avgCmd nextPutAll: '}'; cr.	devCmd nextPutAll: '}'; cr.	Transcript clear; show: avgCmd contents; cr; show: devCmd contents.! !!Siren.SirenUtility class methodsFor: 'utilities'!categoryList	"Answer the class categories for all of CSL"	^#( 'Music-Models-Representation'		'Music-Models-Implementation'		'Music-Events'		'Music-EventGenerators'		'Music-EventModifiers'		'Music-Functions'		'Music-PitchClasses'		'Music-PitchScales'		'Music-Sound'		'Music-Support'		'Music-DBase'		'MusicIO-Voices'		'MusicIO-MIDI'		'MusicIO-OSC'		'MusicIO-Sound'		'MusicIO-External'		'MusicUI-DisplayLists'		'MusicUI-DisplayListViews'		'MusicUI-Layout'		'MusicUI-Editors'		'MusicUI-Functions'		'MusicUI-Sound'		'MusicApps-CSL'		'MusicApps-Loris'		'MusicApps-LPC'		'MusicApps-SHARC'	)!fileoutCategories	"Create the source directory of old-fashioned ST80 file-outs (for Squeak users)"	"SirenUtility fileoutCategories"	| folder file |	folder := Dialog request: 'File out into' initialAnswer: 'Sources'.	folder isEmpty ifTrue: [^nil].	folder asFilename exists ifFalse: [folder asFilename makeDirectory].	folder := folder, Filename separatorString.	self categoryList do:		[ :cat |		file := SourceCodeStream write: (folder, cat, '.st') encoding: #Source.		[Siren organization fileOutCategorySource: cat on: file]			ensure: [file close]]!playSoundFile: nam	"Play a sound file using UNIX shell and libsndfile's play program"	"Edit this to your platform's method, which might use a SoundPort or a simple shell command"	"Sound playFile: 'a.snd' "	| fullName |	fullName := SirenUtility findFile: nam.	fullName ifNil: [self error: 'File not found'].	Transcript show: 'Playing snd file ', nam, '...'; cr.	UnixProcess cshOne: ('/usr/local/bin/sndfile-play ', fullName)!writeSirenManual	"Create the big book"	"SirenUtility writeSirenManual"	"Siren organization listAtCategoryNamed: #'Music-Events'""	| mw classes |	mw := ManualWriter new.	classes := OrderedCollection new: 512.	self categoryList do:		[ :cat |		classes addAll: (Siren organization superclassOrder: cat)].	mw classList: classes.	mw methodBody value: false.	mw doReport"!writeSirenManualToHTML: folder	"Create the doxygen-style manual in an HTML folder"	"SirenUtility writeSirenManualToHTML: 'Manual'"	| mw index classes fn book |	mw := nil. "ManualWriter new."	mw methodBody value: false.	index := WriteStream on: (String new: 2048).	book := TextStream on: (String new: 2048).	classes := OrderedCollection new: 512.	fn := Filename named: folder.	fn exists		ifTrue: [fn isDirectory			ifFalse: [self error: 'File exists']]		ifFalse: [fn makeDirectory].	index nextPutAll: '<HTML><HEAD><TITLE>The Siren 7.5 Reference Manual</TITLE></HEAD><BODY BGCOLOR="#ffffcc"><H2>The Siren 7.5 Reference Manual</H2><font size=+1><UL><a href=#cat><LI>Classes listed by category</A><a href=#alpha><LI>Classes listed alphabetically</A><a href="SirenReferenceManual.html"><LI>The entire manual in one file</A></UL></font><a name="cat">'; cr.	book emphasis: #(#large #bold); nextPutAll: 'The Siren 7.5 Reference Manual'; emphasis: nil; cr.	self categoryList do:		[ :cat | | catClasses |		index cr; nextPutAll: '<H4>', cat asString, '</H4><UL>'; cr.		book cr; nextPutAll: '<H2>', cat asString, '</H2><HR>'; cr.		catClasses := Siren organization superclassOrder: cat.		classes addAll: (catClasses collect: [ :each | each name]).		catClasses do:			[ :theClass | | text |			index cr; nextPutAll: '<LI><A HREF="', theClass name, '.html">', theClass name, '</A>'.			mw classList: (Array with: theClass).			text := mw reportText.			book cr; nextPutAllText: text, '<HR>'; cr.			"Smalltalk.Heeg.HtmlWriter write: text				into: (folder, Filename separatorString, theClass name, '.html')"].		index cr; nextPutAll: '</UL><P><HR>'; cr].	index cr; nextPutAll: '<a name="alpha"><H3>Classes Listed Alphabetically</H3><UL>'; cr.	classes asSortedCollection do:		[ :theClass |			index cr; nextPutAll: '<LI><A HREF="', theClass asString, '.html">', theClass asString, '</A>'].	index cr; nextPutAll: '</UL><HR><br></BODY></HTML>'; cr.	((Filename named: (folder, Filename separatorString, 'index.html')) writeStream) 			nextPutAll: index contents; close.	"Smalltalk.Heeg.HtmlWriter write: book contents				into: (folder, Filename separatorString, 'SirenReferenceManual.html')."! !!Siren.SirenUtility class methodsFor: 'class var accessing'!dataDir	"Answer the class's default data storage directory."	^DataDir!defaultMIDIIn	"Answer the class's default MIDI input device."	^DefaultMIDIIn!defaultMIDIIn: num	"Set the class's default MIDI input device."	DefaultMIDIIn :=  num!defaultMIDIOut	"Answer the class's default MIDI output device."	^DefaultMIDIOut!defaultMIDIOut: num	"Set the class's default MIDI output device."	DefaultMIDIOut := num!defaultOSCHost	"Answer the class's default OSC host IP."	^DefaultOSCHost!defaultOSCHost: ip	"Set the class's default OSC host IP."	DefaultOSCHost := ip!defaultOSCPort	"Answer the class's default OSC port #."	^DefaultOSCPort!defaultOSCPort: num	"Set the class's default OSC port #."	DefaultOSCPort := num!scoreDir	"Answer the class's default score storage directory."	^ScoreDir!soundDir	"Answer the class's default sound storage directory."	^SoundDir! !!Siren.SirenUtility class methodsFor: 'example access'!formNamed: key	"Answer the given item from the global music constants."	"(SirenUtility formNamed: #altoClef) display"	^(DisplayListView constants at: #forms) at: key!musicConstants	"Answer the global music constants (mostly icons)."	"SirenUtility musicConstants inspect"	^DisplayListView constants! !!Siren.SirenUtility class methodsFor: 'logging'!log: theMessage	"Log the given string to the Transcript (or otgher output stream) if the system verbosity is >= the given verbosity level"	"SirenUtility log: 'hello there' level: 2"	LoggingStream		ifNil: [Transcript show: theMessage; cr]		ifNotNil: [LoggingStream nextPutAll: theMessage; cr].!log: theMessage level: verbosityInt	"Log the given string to the Transcript (or otgher output stream) if the system verbosity is >= the given verbosity level"	"SirenUtility log: 'hello there' level: 2"	Verbosity > verbosityInt		ifTrue: [self log: theMessage]!verbosity	"Answer the class's default verbosity, 0/1/2."	"(SirenUtility verbosity > 0)"	"(SirenUtility verbosity > 1)"	^Verbosity!verbosity: aNum	"Set the class's default verbosity, 0/1/2."	Verbosity := aNum! !!Siren.SirenUtility class methodsFor: 'file support'!addDir: dir to: list	"Try to locate the requested directory and, if found, add it to the given list"	"SirenSession initialize"	| theDir sDir |	(dir includes: $*) 		ifTrue: [ | base |			base := dir copyUpTo: $*.			(base last == Filename separator) ifTrue: 				[base := base copyFrom: 1 to: base size - 1 ].			theDir := SirenUtility findDir: base tryHard: true.			theDir ifNotNil: [self addDir: theDir to: list.				((Filename named: theDir) filesMatching: '*') do: 					[ :newD | 					(Filename named: newD) isDirectory						ifTrue: [self addDir: newD to: list]]]]		ifFalse: [theDir := SirenUtility findDir: dir tryHard: true.			theDir ifNil: [^self].			sDir := theDir asSymbol.			(list includes: sDir)				ifFalse: [list add: sDir]]!createS7: aFullPathName	"Create an s7 folder and copy any files with the same name  into it"	"SirenUtility createS7: (SirenUtility dataDir first, Filename separatorString, 'testing')"	"SirenUtility nextName: 'testing' type: 'aiff' "	"| strm |	strm := (SirenUtility nextName: 'testing' type: 'aiff' ) asFilename writeStream.	strm nextPut: $..	strm close."	| froot fnam list |	froot := Filename named: aFullPathName.	fnam := Filename named: aFullPathName, '.s7'.	fnam exists ifTrue: [fnam isDirectory		ifTrue: [Transcript show: aFullPathName, ' exists.'; cr. ^nil]		ifFalse: [Transcript show: aFullPathName, ' exists as a regular file!!'; cr. ^nil]].	list := froot filesMatching: '*'.	fnam makeDirectory.	list do: [ :fil |		(Filename named: fil) renameTo: (aFullPathName, '.s7', Filename separatorString, 									(Filename named: fil) tail)]!findDir: dir	"Try to locate the requested directory either locally or globally"	"SirenUtility findDir: 'Data' tryHard: false"	"SirenUtility findDir: 'Frameworks' tryHard: true"	^self findDir: dir tryHard: false!findDir: dir tryHard: aggressive	"Try to locate the requested directory either locally or globally"	"SirenUtility findDir: 'Data' tryHard: false"	"SirenUtility findDir: 'Frameworks' tryHard: true"	"SirenUtility findDir: '3-Credo' tryHard: true"	| fsep home |	dir asFilename existsSafely ifTrue: [^dir].								"if local"	fsep := Filename separatorString.	(fsep, dir) asFilename existsSafely ifTrue: [^(fsep, dir)].				"if at /X"	home := SystemUtils getEnvironmentVariable: 'HOME'.	(home, fsep, dir) asFilename existsSafely ifTrue: [^(home, fsep, dir)].	"if in $HOME"	(Filename filesMatching: '*')										"if in *"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	DataDir do: [ :dDir | | fnd |		((dir findString: dDir asString startingAt: 1) = 0)			ifTrue: [fnd := self findFile: dir in: dDir.				fnd isEmpty ifFalse: [^fnd]]].	aggressive ifFalse: [^nil].	(Filename filesMatching: home, fsep, '*')								"if in ~/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: fsep, 'Smalltalk', fsep, '*')					"if in /Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	(Filename filesMatching: home, fsep, 'Smalltalk', fsep, '*')				"if in ~/Smalltalk/*"		do: [ :each | ((each, fsep, dir) asFilename existsSafely)				ifTrue: [^(each, fsep, dir)]].	^nil!findFile: fil	"Try to locate the requested file in the data directories, being smart about s7 files"	"SirenUtility findFile: 'b.snd'"	"SirenUtility findFile: '1.1a.aiff'"	| nam ans base s7 |	fil asFilename exists ifTrue: [^fil asFilename asAbsoluteFilename asString].	DataDir isString		ifTrue: [nam := (DataDir, Filename separatorString, fil).			nam asFilename exists ifTrue: [^nam]]		ifFalse: [DataDir do:			[ :dir |			ans := self findFile: fil in: dir.			ans isEmpty ifFalse: [^ans]]].	((fil findString: '.s7' startingAt: 1) = 0) ifFalse: [^nil].	(fil includes: $.) ifTrue:									"if not found, look for an s7 folder"		[base := fil asFilename base asString.		s7 := base, 's7'.		s7 := self findFile: s7.		s7 ifNotNil:			[nam := (s7, Filename separatorString, fil).			nam asFilename exists ifTrue: [^nam]].		base := base copyFrom: 1 to: base size - 1.		"try again removing the next-to-last suffix"		s7 := base asFilename base asString, 's7'.		s7 := self findFile: s7.		s7 ifNotNil:			[nam := (s7, Filename separatorString, fil).			nam asFilename exists ifTrue: [^nam]]].	^nil!findFile: fil in: theDir	"Try to locate the requested file in the given directory, being smart about s7 files"	"SirenUtility findFile: 'b.snd'"	"SirenUtility findFile: '1.1a.aiff'"	"SirenUtility findFile: '1.2a1.aiff'"	| nam ans |	(theDir includes: $*)		ifFalse: [nam := (theDir, Filename separatorString, fil).			nam asFilename exists				ifTrue: [^nam asFilename asAbsoluteFilename asString].			(Filename filesMatching: (theDir, Filename separatorString, '*.s7')) do:				[ :dir2 |				nam := (theDir, Filename separatorString, fil).				nam asFilename exists					ifTrue: [^nam asFilename asAbsoluteFilename asString]]]		ifTrue: [(Filename filesMatching: theDir) do:			[ :dir2 |			(dir2 asFilename tail = fil) ifTrue: [^dir2].			dir2 asFilename isDirectory				ifTrue: [ans := self findFile: fil in: dir2.						ans isEmpty ifFalse: [^ans]]]].	^''!findFiles: ext	"Answer all of the files in the user's data folders with the given filename extension"	"SirenUtility findFiles: 'au'"	"SirenUtility findFiles: 'mid'"	| coll |	coll := Set new.	DataDir do:		[ :dir | self findFiles: ext in: dir into: coll].	^coll asOrderedCollection!findFiles: ext in: theDir into: coll	"Add the files with the given name extension to the given collection"	"SirenUtility findFiles: 'au' into: OrderedCollection new"	"SirenUtility findFiles: 'mid' into: OrderedCollection new"	(theDir includes: $*)			ifFalse: [(Filename filesMatching: (theDir, Filename separatorString, '*')) do:				[ :dir2 | | dex |				dex := dir2 asFilename extension.				dex ifNotNil: [(('*', ext, '*') match: dex ignoreCase: true)						ifTrue: [coll add: dir2 asSymbol]]]]			ifTrue: [(Filename filesMatching: theDir) do:				[ :dir2 |				dir2 asFilename isDirectory					ifTrue: [self findFiles: ext in: dir2 into: coll]]].	^coll!listS7: aName	"List the contents of the requested s7 file"	"SirenUtility listS7: '1.2a1'"	| fobj fnam |	fnam := (SirenUtility findFile: (aName, '.s7')).	fnam isEmpty ifTrue: [^#()].	fobj := Filename named: fnam.	^fobj filesMatching: '*'!nextName: aName type: extension	"Answer the next free name with the given extension in the given s7 folder"	"SirenUtility createS7: (SirenUtility dataDir first, Filename separatorString, 'testing')"	"SirenUtility nextName: 'testing' type: 'aiff'"	| fnam base list ind |	fnam := (SirenUtility findFile: (aName, '.s7')).	fnam isEmpty ifTrue: [^nil].	ind := '_1.'.	base := Filename named: fnam.	list := (base filesMatching: ('*.', extension)).	list isEmpty		ifFalse: [list := list asSortedCollection last.			((list includes: $_) and: [list includes: $.])				ifTrue: [ind := (list copyFrom: (list lastIndexOf: $_) + 1 to: (list lastIndexOf: $.) - 1) asNumber.					ind := '_', (ind + 1) printString, '.']].	^(base asString, Filename separatorString, aName, ind, extension)! !!Siren.FunctionView methodsFor: 'private'!setModel: aModel	"Set the receiver's model to be aModel"	super setModel: aModel.	models at: 1 put: aModel!source unavailable! !!Siren.FunctionView methodsFor: 'accessing'!aScale	"Answer the receiver's 'aScale'."	^aScale!aScale: anObject	"Set the receiver's instance variable 'aScale' to be anObject."	aScale := anObject!colors	"Answer the receiver's color array."	^colors!colors: anArrayOfSize4	"Set the receiver's color array to the argument."	colors := anArrayOfSize4!displayExtent	"Answer the receiver's visual extent."	^hRange@vRange!dontNormalize: aNumber	normalize at: aNumber put: false.!hRange	"Answer the receiver's 'hRange'."	^hRange!hRange: aNumber	"Set the receiver's horizontal extent to aNumber."	hRange := aNumber!lineWidth: aNumber	"Set the receiver's line width to the argument."	lineWidth := aNumber!model	"Answer the fisrt element from receiver's array of models."	^models at: 1!modelAt: anIndex	"Answer the receiver's model at the given index."	^models at: anIndex!modelAt: anIndex put: aFunction	"Set the receiver's model at the given index to the given function."	models at: anIndex put: aFunction.	controller model: aFunction.	anIndex == 1		ifTrue: [self model: aFunction]!models	"Answer the receiver's first model."	^models!models: anArray	"Set the receiver's array of models to the argument."	models := anArray.	self model: (anArray at: 1)!normalize: aNumber	normalize at: aNumber put: true.!normalizeArray: arrayOfBooleans	"Set the receiver's array of normalization switches."	normalize := arrayOfBooleans!vRange	"Answer the receiver's 'vRange'."	^vRange!vRange: aNumber	"Set the receiver's vertical extent to aNumber."	vRange := aNumber! !!Siren.FunctionView methodsFor: 'controller access'!bounds: aRectangle	"Set the receiver's bounds."	super bounds: aRectangle.	vRange := aRectangle height - 8.	aScale := vRange.	hRange := aRectangle width - 8.	self setPixmap."	self invalidate"!defaultControllerClass	^FunctionController! !!Siren.FunctionView methodsFor: 'displaying'!displayGridsOn: gc	"Display the gridding for the receiver on its cached form."	gc paint: DisplayListView backgroundColor.	gc displayRectangle: pixmap bounds.	gc paint: DisplayListView foregroundColor.	gc paint: ColorValue gray.	0 to: hRange by: 32 do:		[ :xVal |		gc displayLineFrom: (xVal @ 0) to: (xVal @ vRange)].	0 to: vRange by: 32 do:		[ :yVal |		gc displayLineFrom: (0 @ yVal) to: (hRange @ yVal)]!displayOn: aGraphicsContext"	Transcript show: 'FcnView size: ', hRange printString, ' @ ', vRange printString; cr."	cache ifFalse: [aGraphicsContext paint: backgroundColor.				aGraphicsContext displayRectangle: aGraphicsContext clippingBounds].	self class inset == nil		ifFalse: [aGraphicsContext translateBy: self class inset].	self displayOnImage.	pixmap displayOn: aGraphicsContext.	self class inset == nil		ifFalse: [aGraphicsContext translateBy: self class inset negated].!displayOnImage	"Display the receiver view on its cached form."	"FunctionView example"	| gc oldPt mod |	gc := pixmap graphicsContext.	self displayGridsOn: gc.	gc lineWidth: lineWidth.	1 to: models size do:		[ :k |		(mod := models at: k) == nil			ifFalse: [ | rng rmin rmax dom dmin dmax hScale vScale |				gc paint: (colors at: k).				rng := mod range.				rmin := rng first.				rmax := rng stop "- rmin".				rmax = rmin ifTrue: [^self].				(normalize at: k)					ifTrue: [vScale := aScale / (rmax - rmin)]		"auto-scale"					ifFalse: [vScale := aScale].						"no auto-scale"				dom := mod domain.				dmin := dom first.				dmax := dom stop "- dmin".				dmax = dmin					ifTrue: [hScale := hRange]					ifFalse: [hScale := hRange asFloat / (dmax - dmin)].				oldPt := 0@(vRange - ((mod at: (0 + dmin)) - rmin * vScale)) truncated.				1 to: hRange do:					[ :i | | val |					val := mod at: ((i asFloat/hScale) + dmin) asFloat.					val := vRange - ((val - rmin) * vScale ) truncated.					gc displayLineFrom: oldPt to: i@val.					oldPt := i@val]]]!updateBetween: p1 and: p2 with: color on: gc	"Display the receiver on its cached form."	"FunctionView example"	| x1 x2 y1 y2 ins |	ins := self class inset x.	x1 := (p1 x + ins) truncated. y1 := (vRange - p1 y + ins) truncated.	x2 := (p2 x + ins) truncated. y2 := (vRange - p2 y + ins) truncated.	gc paint: color.	gc displayLineFrom: (x1@y1) to: (x2@y2).! !!Siren.FunctionView methodsFor: 'initialize-release'!initialize	"Initialize the receiver's instance variables for cacheing the pixmap during display."	super initialize.	vRange := 256.	hRange := 512.	aScale := 256.	models := Array new:4.	colors := Array with: (DisplayListView foregroundColor)				with: ColorValue red				with: ColorValue cyan				with: ColorValue green.	normalize := #(false false false false).	lineWidth := LineWidth.!initializeCacheSized: x by: y	"Initialize the receiver's instance variables for cacheing the pixmap during display."	self initialize.	vRange := y.	hRange := x.	aScale := y!initializeCacheing	"Initialize the receiver's instance variables for cacheing the pixmap during display."	self initialize.	vRange := 256.	hRange := 512.	aScale := 256!initializeCacheingSmall	"Initialize the receiver's instance variables for cacheing the pixmap during display."	self initialize.	vRange := 192.	hRange := 384.	aScale := 192!setPixmap	"Reset the receiver's pixmap display cache after changing its size."	pixmap := Pixmap extent: (hRange+1)@(vRange+1).	pixmap background: DisplayListView backgroundColor! !!Siren.FunctionView class methodsFor: 'examples'!example	"FunctionView example"	FunctionView multiFunctionExample!expSegExample	"Demonstrate an ExpSeg function with different weights."	"FunctionView expSegExample"	FunctionView onFunction: (ExponentialFunction from: #((0 0 3) (0.3 1 5) (0.6 0.3 0) (1 0)))!fileExample	"Read an extracted envelope as floating-point data from a file."	"FunctionView fileExample"	FunctionView onFunctions: (Function fromFile: 'G1.2a1.env') normalize: #(false true true false)!linSegExample	"FunctionView linSegExample"	FunctionView onFunction: (LinearFunction from: #((0 0) (0.15 1.0) (0.25 0.75) (0.75 0.5) (1 0)))!multiFunctionExample	"Open a function editor on 4 different functions."	"FunctionView multiFunctionExample"	FunctionView 		onFunctions: (Array with: (LinearFunction from: #((0 0) (0.12 1) (0.17 0.74) 				(0.35 0.5) (0.9 0.4) (1 0) )) 			with: (FourierSummation from: #((1 0.5 0)  (3 0.15 0)  (5 0.1 0)  (7 0.075 0)  (9 0.055 0)  (11 0.05 0)))			with: (ExponentialFunction from: #((0 0 5) (0.05 1 -5) (0.2 0.25 -1) (1 0))) 			with: (SplineFunction from: #((0 0.5) (0.3 0.6) (0.7 0.5) (0.85 0.7) (1 0.6))))			withColors: self defaultColors		normalize: #(false true false false) 	x: 512 y: 256!smallFileExample	"Read an extracted envelope as floating-point data from a file."	"FunctionView smallFileExample"	FunctionView smallOnFunction: (Function readFloatsFrom: 'snd/yy/ec/syl/y2.env')"	FunctionView smallOnFunction: (Function readFloatsFrom: 'snd/yy/ec/syl/y2.2.env')"!smallMultiFunctionExample	"Open a function editor on 4 different functions."	"FunctionView smallMultiFunctionExample"	 	FunctionView onFunctions: (Array 			with: (LinearFunction from: #((0 0) (0.12 1) (0.17 0.74) 					(0.35 0.5) (0.9 0.4) (1 0)))			with: (LinearFunction from: #((0 0.1) (0.3 0.5) (0.7 0.3) (1 0)))			with: (ExponentialFunction from: #((0 0 5) (0.05 1 -5) (0.2 0.25 -1) (1 0)))			with: (SplineFunction default))		withColors: self defaultColors		x: 384 y: 192! !!Siren.FunctionView class methodsFor: 'constant access'!defaultColors	"Answer the default color array for the 4 functions."	^Array with: ColorValue blue with: ColorValue red				with: ColorValue cyan with: ColorValue green!inset	"Answer the default display inset."	^6@6!lineWidth	"Answer the default line width for fnuction plots."	^LineWidth!lineWidth: anInteger	"Set the default line width for fnuction plots."	"FunctionView lineWidth: 1"	LineWidth := anInteger! !!Siren.FunctionView class methodsFor: 'class initialization'!initialize	"Set up the defaults"	"FunctionView initialize"	"FunctionView lineWidth: 1"	LineWidth :=  2! !!Siren.FunctionView class methodsFor: 'instance creation'!componentOnFunction: function color: color normalize: normal x: x y: y	| container me wrapper |	container := CompositePart new.	me := self new initialize.	me initializeCacheSized: x by: y.	me hRange: x; vRange: y; aScale: y; setPixmap.	me models: (Array with: function with: nil with: nil with: nil) .	me colors: (Array with: color with: nil with: nil with: nil).	me normalizeArray: (Array with: normal with: false with: false with: false).	wrapper := LookPreferences edgeDecorator on: me.	wrapper noVerticalScrollBar.	container add: wrapper borderedIn: (0@0 extent: 1@1).	^container!componentOnFunctions: functionArray withColors: colorArray normalize: normArray x: x y: y	| container me wrapper |	container := CompositePart new.	me := self new initialize.	me initializeCacheSized: x by: y.	me hRange: x; vRange: y; aScale: y; setPixmap.	me models: functionArray.	me colors: colorArray.	me normalizeArray: normArray.	wrapper := LookPreferences edgeDecorator on: me.	wrapper noVerticalScrollBar.	container add: wrapper borderedIn: (0@0 extent: 1@1).	^container!componentOnFunctions: functionArray withColors: colorArray x: x y: y	| container me wrapper |	container := CompositePart new.	me := self new initialize.	me initializeCacheSized: x by: y.	me hRange: x; vRange: y; aScale: y; setPixmap.	me models: functionArray.	me colors: colorArray.	wrapper := LookPreferences edgeDecorator on: me.	wrapper noVerticalScrollBar.	container add: wrapper borderedIn: (0@0 extent: 1@1).	^container!onFunction: function	"FunctionView example"	"FunctionView onFunction: (Function randomOfSize: 512 from: 0.1 to: 0.9) normalize: true"	^function range size > 1		ifTrue: [self onFunctions: (Array with: function with: nil with: nil with: nil)			withColors: self defaultColors			normalize: #(true false false false) 			x: 512 y: 256]		ifFalse: [self onFunctions: (Array with: function with: nil with: nil with: nil)			withColors: self defaultColors			normalize: #(false false false false) 			x: 512 y: 256]!onFunction: function normalize: norm	"FunctionView example"	self onFunctions: (Array with: function with: nil with: nil with: nil) 		withColors: self defaultColors 		normalize: (Array with: norm with: false with: false with: false) 		x: 512 y: 256!onFunction: function x: x y: y	"FunctionView onFunction: (LinearFunction from: #((0@0) (0.1@1.0)								(0.15@0.75) (0.75@0.5) (1@0))) 		x: 256 y: 128"	^function range size > 1		ifTrue: [self onFunctions: (Array with: function with: nil with: nil with: nil)			withColors: self defaultColors			normalize: #(true false false false) 			x: x y: y]		ifFalse: [self onFunctions: (Array with: function with: nil with: nil with: nil)			withColors: self defaultColors			normalize: #(false false false false) 			x: x y: y]!onFunctions: functionArray	"FunctionView onFunctions: (Array 			with: (LinearFunction from: #((0@0) (0.15@1.0) (0.25@0.75) (0.75@0.5) (1@0))) 			with: (LinearFunction from: #((0@0.1) (0.3@0.7) (0.7@0.45) (1@0))) 			with: (LinearFunction from: #((0@0) (0.05@1) (0.2@0.35) (1@0))) 			with: (LinearFunction from: #((0@0.2) (0.6@0.3) (1@0.3))))"	^self onFunctions: functionArray		withColors: self defaultColors		normalize: #(true true true true) 		x: 512 y: 256!onFunctions: functionArray normalize: normArray	"FunctionView onFunctions: (Array 			with: (LinearFunction from: #((0@0) (0.15@1.0) (0.25@0.75) (0.75@0.5) (1@0))) 			with: (LinearFunction from: #((0@0.1) (0.3@0.7) (0.7@0.45) (1@0))) 			with: (LinearFunction from: #((0@0) (0.05@1) (0.2@0.35) (1@0))) 			with: (LinearFunction from: #((0@0.2) (0.6@0.3) (1@0.3))))"	^self onFunctions: functionArray		withColors: self defaultColors		normalize: normArray		x: 512 y: 256!onFunctions: functionArray withColors: colorArray normalize: normArray x: x y: y	"FunctionView onFunctions: (Array 			with: (LinearFunction from: #((0@0) (0.15@1.0) (0.25@0.75) (0.75@0.5) (1@0))) 			with: (LinearFunction from: #((0@0.1) (0.3@0.7) (0.7@0.45) (1@0))) 			with: (LinearFunction from: #((0@0) (0.05@1) (0.2@0.35) (1@0))) 			with: (LinearFunction from: #((0@0.2) (0.6@0.3) (1@0.3))))		withColors: (Array with: ColorValue blue with: ColorValue red				with: ColorValue cyan with: ColorValue green)		normalize: #(false false false false)		x: 512 y: 256"	| window container me wrapper |	window := ScheduledWindow new.	window label: 'Function Editor'.	window minimumSize: (x*1.05+22) truncated @(y+20).	window maximumSize: (x*1.05+22) truncated @(y+20).	container := CompositePart new.	me := self new initialize.	me initializeCacheSized: x by: y.	me hRange: x; vRange: y; aScale: y; setPixmap.	me models: functionArray.	me colors: colorArray.	me normalizeArray: normArray.	wrapper := LookPreferences edgeDecorator on: me.	wrapper noVerticalScrollBar.	container add: wrapper borderedIn: (0@0 extent: 1@1).	window component: container.		window open!onFunctions: functionArray withColors: colorArray x: x y: y	"FunctionView onFunctions: (Array 			with: (LinearFunction from: #((0@0) (0.15@1.0) (0.25@0.75) (0.75@0.5) (1@0))) 			with: (LinearFunction from: #((0@0.1) (0.3@0.7) (0.7@0.45) (1@0))) 			with: (LinearFunction from: #((0@0) (0.05@1) (0.2@0.35) (1@0))) 			with: (LinearFunction from: #((0@0.2) (0.6@0.3) (1@0.3))))		withColors: (Array with: ColorValue blue with: ColorValue red				with: ColorValue cyan with: ColorValue green)		x: 512 y: 256"	self onFunctions: functionArray		withColors: colorArray		normalize: #(true true true true) 		x: x y: y!onFunctions: functionArray x: x y: y	"FunctionView onFunctions: (Array 			with: (LinearFunction from: #((0@0) (0.15@1.0) (0.25@0.75) (0.75@0.5) (1@0))) 			with: (LinearFunction from: #((0@0.1) (0.3@0.7) (0.7@0.45) (1@0))) 			with: (LinearFunction from: #((0@0) (0.05@1) (0.2@0.35) (1@0))) 			with: (LinearFunction from: #((0@0.2) (0.6@0.3) (1@0.3))))		x: 512 y: 256"	^self onFunctions: functionArray		withColors: self defaultColors		x: x y: y!openOn: function	^self onFunction: function!smallOnFunction: function	"FunctionView example"	^self onFunctions: (Array with: function with: nil with: nil with: nil)			x: 384 y: 192! !!Siren.SuperColliderVoice methodsFor: 'events'!endLine	"Put the proper command terminator on the receiver's stream."	stream nextPutAll: ' ],'; cr!space	"Put the proper field separator on the receiver's stream."	stream space; nextPut: $,; space; tab!writeFooter	"Write a notelist file footer on the receiver's stream.""	stream skip: -2."	stream nextPutAll: '];'; cr!writeHeader	"Write a SuperCollider notelist file header on the receiver's stream."	header ifNotNil: 		[^stream nextPutAll: header].	stream nextPutAll: '// SC2 Score for rotating bell clusters; generated on ',		Date today printString, ' at ',  Time now printString, '// Instrument format [ delT, \panner, \fname, dur, att, dec, ampl, angVel ]score = #['! !!Siren.SuperColliderVoice class methodsFor: 'examples'!randomExampleToFileAndEdit	"SuperColliderVoice randomExampleToFileAndEdit"	self randomExampleToFileNamed: 'rand.sc'.	^self!randomExampleToFileNamed: fnam 	"Create a random event list and store it on a file."	"SuperColliderVoice randomExampleToFileAndEdit"	| evt strm list rand vox |	strm := (Filename named: fnam) writeStream.	rand := Random new."Create the event list and add a few additional properties"	(list := EventList randomExample: 64)		do: [ :ass | 			evt := ass event.			evt at: #attack put: (rand nextFrom: 0.001 to: 0.03).			evt at: #decay put: (rand nextFrom: 0.2 to: 0.3).			evt at: #index put: (rand nextFrom: 0.2 to: 2.3).			evt at: #decay put: (rand nextFrom: 0.2 to: 0.3)]."Create a SuperCollider voice and customize its parameter map."	vox := SuperColliderVoice newNamed: '1' onStream: strm."Play the list on the voice."	vox play: list.	strm close.	(Filename named: fnam) edit.	^self! !!Siren.SuperColliderVoice class methodsFor: 'instance creation'!defaultPMap	"Answer up the parameter map for the default instance."	"Instrument format		[ delT, 'fm', fname, dur, att, dec, ampl, index ] "	| map |	map := OrderedCollection new: 8.	map add: [ :ass :li | '	[ ', ((li nextTimeFor: ass) asSec value asFloat printString: 6)].	map add: '\fm'.	map add: [ :e | e duration asSec value asFloat printString: 4].	map add: [ :e | e attack value printString: 4].	map add: [ :e | e decay value printString: 4].	map add: [ :e | e ampl value asFloat printString: 4].	map add: [ :e | e index printString: 4].	^map!pMapForPanner	"Answer up the parameter map for the default instance."	"Instrument format		[ delT, 'panner', fname, dur, att, dec, ampl, angVel ] "	| map |	map := OrderedCollection new: 8.	map add: [ :ass :li | '	[ ', (li nextTimeFor: ass) asSec value 										printString: 5].	map add: '\panner'.	map add: [ :e | '\', e partial].	map add: [ :e | e duration asSec value printString].	map add: [ :e | e attack value printString].	map add: [ :e | e decay value printString].	map add: [ :e | e ampl value printString truncateTo: 6].	map add: [ :e | e angularVelocity printString truncateTo: 6].	^map! !!Siren.PortAudioInterface methodsFor: 'accessing'!cbProcess	^cbProcess!cbProcess: aValue	cbProcess := aValue!ioSemaphore	^ioSemaphore!ioSemaphore: aValue	ioSemaphore := aValue! !!Siren.PortAudioInterface class methodsFor: 'class initialization'!const: flag		^PA_Constants at: flag!initialize	"Set up the class constants dictionary (PortAudio 19)"	"PortAudioInterface initialize" 	"PortAudioInterface const: #lin16Bit"	"#define paFloat32        ((PaSampleFormat) 0x00000001)	#define paInt32          ((PaSampleFormat) 0x00000002)	#define paInt24          ((PaSampleFormat) 0x00000004) 	#define paInt16          ((PaSampleFormat) 0x00000008)	#define paInt8           ((PaSampleFormat) 0x00000010)	#define paUInt8          ((PaSampleFormat) 0x00000020)	"	PA_Constants := IdentityDictionary new.	PA_Constants at: #paFloat32 put: 1.	PA_Constants at: #float32 put: 1.	PA_Constants at: #paInt32 put: 2.	PA_Constants at: #int32 put: 2.	PA_Constants at: #paInt24 put: 4.	PA_Constants at: #int24 put: 4.	PA_Constants at: #paInt16 put: 8.	PA_Constants at: #lin16Bit put: 8.	PA_Constants at: #paInt8 put: 16.	PA_Constants at: #int8 put: 16.! !!Siren.PortAudioInterface class methodsFor: 'examples'!example0	"Demonstrate using the PortAudioInterface with the simple interface"	"PortAudioInterface example0"	| pa val |	pa := PortAudioInterface new."Initialize PA"	val := pa pa_initialize.	Transcript cr; show: 'PA_init returned: ', val printString; cr."Get IO data"		Transcript show: pa pa_num_in printString, ' in ', 			pa pa_num_out printString, ' out ',			pa pa_in_rate printString, ' Hz i ',			pa pa_out_rate printString, ' Hz o '; cr.	val := pa pa_terminate.	Transcript show: 'PA_close returned: ', val printString; cr.!example2	"Demonstrate using the PortAudioInterface with the non-semaphore-signalling interface"	"PortAudioInterface example2"	| pa val bufFrames oChans |	bufFrames := 1024.	oChans := 2.	pa := PortAudioInterface new."Initialize PA"	val := pa pa_initialize.	Transcript cr; show: 'PA_init returned: ', val printString; cr."Open PA"	val := pa pa_open_p: 1 with: oChans	 	"device, I/O channels"				with: (self const: #paInt16) 	"sample format"				with: 44100 					"sample rate"				with: bufFrames. 				"frames per buffer"	Transcript show: 'PA_open returned: ', val printString; cr."START"	1 wait.	val := pa pa_start.	Transcript cr; show: 'PA_start returned: ', val printString; cr."wait"	1 wait."STOP, close, ..."	val := pa pa_stop.	Transcript show: 'PA_stop returned: ', val printString; cr.	val := pa pa_close.	Transcript show: 'PA_close returned: ', val printString; cr.! !!Siren.RatioDuration methodsFor: 'double dispatching'!quotientFromInteger: numerator	"Answer a MM whose value is the argument over the receiver's value."	"1/4 beat"	^self species relativeMember value: (numerator / value)! !!Siren.RatioDuration methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a fractional duration."	aStream nextPutAll: "'d:'," value printString!units	"Answer the units string of the receiver."	^' beat'! !!Siren.RatioDuration methodsFor: 'converting'!asMS	"Answer a MSecondDuration."	^relative == nil		ifTrue: [MSecondDuration new value: ((value * 1000) truncated)]		ifFalse: [MSecondDuration new value:					((value * 1000 * (relative asRatio value)) truncated)]!asMsec	"Answer a MSecondDuration."	^relative == nil		ifTrue: [MSecondDuration new value: ((value * 1000) truncated)]		ifFalse: [MSecondDuration new value:					((value * 1000 * (relative asRatio value)) truncated)]!asSec	"Answer a SecondDuration."	^relative == nil		ifTrue: [SecondDuration new value: value asFloat]		ifFalse: [SecondDuration new value:					(value asFloat * (relative asRatio value))]!asUsec	"Answer a USecondDuration."	^self asUseconds!asUseconds	"Answer a USecondDuration."	^relative == nil		ifTrue: [USecondDuration new value: ((value * 1000000) truncated)]		ifFalse: [USecondDuration new value:					((value * 1000000 * (relative asRatio value)) truncated)]!mostGeneral	"Answer the most numerically meaningful version of the receiver."	^self asSec! !!Siren.RatioDuration methodsFor: 'private'!species	"Answer Duration."	^Duration! !!Siren.RatioDuration class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asBeat! !!Siren.NeapolitanMinor class methodsFor: 'interval list'!intervalList	"tire de McLaughlin et le Mahavishnu Orchestra"	^#(#unison #minorSecond #minorThird #perfectFourth #perfectFifth #minorSixth #majorSeventh )! !!Siren.ExtDynamicSelectionCloud methodsFor: 'playing'!eventList	"make the dynamic selection cloud's events"	"assume that the receiver's 'pitch' is a list of associations like		(0 -> pitch-set)		(1 -> pitch-set) ..."	| pattern rand length start to from howMany pList |	pattern := EventList new.	rand := Random new.	length := (1 / density) asFloat.	start := 0.	pList := self pitch value.	to := pList at: 1.	2 to: pList size do:		[ :which | | set1 set2 |		from := to.		to := pList at: which.		set1 := from value.		set2 := to value.		howMany := ((to key - from key) * density)."		Transcript show: start printString, ' -> ', howMany printString, 						' from ', set1 printString, ' & ', set2 printString; cr."		1 to: howMany do:			[ :count |			pattern add: (MusicEvent 				dur: length				pitch: ((rand next > (count / howMany)) 					ifTrue: [set1 atRandom: rand]					ifFalse: [set2 atRandom: rand])				ampl: self loudness				voice: self voice)				at: start.			start := start + length]].	^pattern! !!Siren.ExtDynamicSelectionCloud methodsFor: 'accessing'!list: aList	"Set the receiver's list"	list := aList! !!Siren.ExtDynamicSelectionCloud class methodsFor: 'examples'!chordExample	"Answer a dynamic selection cloud that plays chords from a scale."	"ExtDynamicSelectionCloud chordExample"	"Create cloud from a set like		(0 -> chord) (1 -> chord) ..."		| score chords list |	chords := ((NeapolitanMinor root: N do) generateChordsPoly: 5 inOctave: 3) scrambled.	list :=  OrderedCollection new.	1 to: 7 do:		[ :ind |		ind even ifTrue: [list add: ((ind - 1) * 3 -> ((chords at: ind) collect: [ :no | no + 24]))]			ifFalse: [list add: ((ind - 1) * 3 -> (chords at: ind))]].	score := (self dur: 8		pitch: list		ampl: 60		voice: nil		density: 10) eventList.	score eventsDo: [ :ev |		ev inst: '/i1/pn'.		ev modIndex: 2.0.		ev ratio: 1.02.		ev pos: 0.0]."	score edit"	score voice: (OSCVoice map: #pMapForCSLSimpleFM).	score play! !!Siren.SoundFile methodsFor: 'read/write'!readSamples	"Read samples from the file into the sample buffer."	| data |	index ifNil: [self error: 'Cannot operate on unopened file'].	(position = 0) ifFalse: 		[Interface lsf_seek: index with: 0 with: (LibSndFileInterface const: #SEEK_SET)].	(sampleFormat == #lin16Bit)		ifFalse: [self error: 'Sound file format ', sampleFormat, ' not imlpemented...'].	sound isNil 		ifTrue: [data := (WordArray new: size * channels) copyToHeapAsSigned: #malloc:.				data beGarbageCollectable]		ifFalse: [sound samples isPointer			ifTrue: [data := sound samples]			ifFalse: [data := sound samples copyToHeapAsSigned: #malloc:.					data beGarbageCollectable]].	Interface lsf_read_Isamples: index with: data with: (size * channels).	sound ifNil:		[sound := SampledSound named: name size: size rate: rate channels: channels 						format: sampleFormat data: data].	sound samplesInMemory: channels * size.	sound at: #fileIndex put: index.!readSamples: sndClass 	"Read samples from the file into the sample buffer."	| data |	index ifNil: [self error: 'Cannot operate on unopened file'].	position = 0 ifFalse: [Interface lsf_seek: index with: 0						with: (LibSndFileInterface const: #SEEK_SET)].	sampleFormat == #lin16Bit ifFalse: [self error: 'other file formats not imlpemented...'].	sound isNil		ifTrue: 			[data := (WordArray new: size * channels) copyToHeapAsSigned: #malloc:.			data beGarbageCollectable]		ifFalse: [sound samples isPointer				ifTrue: [data := sound samples]				ifFalse: [data := sound samples copyToHeapAsSigned: #malloc:.					data beGarbageCollectable]].	Interface lsf_read_Isamples: index with: data with: size * channels.	sound ifNil: [sound := sndClass named: name size: size rate: rate 				channels: channels format: sampleFormat data: data].	sound samplesInMemory: channels * size!saveSound: snd	"Write samples from the given sound to the receiver file."	"(SampledSound sweepDur: 5.0 rate: 44100 from: 50 to: 1000 chans: 1) 				scaleBy: 0.1; storeOnFileNamed: 'sweep.aiff'"	| type which data howMany |	(snd format == #lin16Bit)		ifFalse: [self error: 'other file formats not imlpemented...'].	('*.aiff' match: name)		ifTrue: [type := LibSndFileInterface const: #LSF_FORMAT_AIFF].	('*.wav' match: name)		ifTrue: [type := LibSndFileInterface const: #LSF_FORMAT_WAV].	('*.snd' match: name)		ifTrue: [type := LibSndFileInterface const: #LSF_FORMAT_AU].	('*.sf' match: name)		ifTrue: [type := LibSndFileInterface const: #LSF_FORMAT_IRCAM].	type ifNil: [self error: 'Can''t determine sound file format.'].	data := snd data gcCopyToHeap.	which := Interface lsf_create: name 				with: (LibSndFileInterface const: #LSFM_WRITE) 				with: (type bitOr: (LibSndFileInterface const: #LSF_FORMAT_PCM_16))				with: snd rate with: snd channels.	howMany := Interface lsf_write_Isamples: which with: data with: (snd size * snd channels).	Transcript show: 'Wrote ', howMany printString, ' samples to sound file ', name; cr.	Interface lsf_close: which.! !!Siren.SoundFile methodsFor: 'accessing'!channels	"Answer the instance variable 'channels'."	^channels!channels: theChannels	"Accept the argument, 'theChannels', as the new instance variable 'channels'."	channels := theChannels.!fileFormat	^fileFormat!fileFormat: aValue	fileFormat := aValue!format	^fileFormat!mode: theMode	"Set the receiver's mode to #read or #write"	mode := theMode!name	"Answer the instance variable 'name'."	^name!name: theFileName	"Accept the argument, 'theFileName', as the new instance variable 'name'."	name := theFileName.!rate	"Return the instance variable 'rate'."	^ rate!rate: aRate	"Set the instance variable 'rate'."	rate := aRate!sampleFormat	^sampleFormat!sampleFormat: aValue	sampleFormat := aValue!samples	"Return the instance variable 'samples'."	^sound samples!size	"Answer the number of sample frames in the file."	^size!size: aNumber	"Set the number of sample frames in the file."	^size := aNumber!sizeInSamples	"Answer the number of sample frames in the file."	^size * channels!sound	"Answer the instance variable 'sound'."	^sound!sound: theSound	"Accept the argument, 'theSound', as the new instance variable 'sound'."	sound := theSound! !!Siren.SoundFile methodsFor: 'printing'!printOn: aStream 	"Format and print the receiver on the argument."	aStream nextPutAll: self class name, 		' named ', self name printString, 		' rate: ', self rate printString,		' channels: ', self channels printString,		' size: ', size printString; cr.! !!Siren.SoundFile methodsFor: 'initialize-release'!close	"Close the receiver's file."	index ifNil: [^self].	Interface lsf_close: index.!initialize	"Set up the instance variables of a default sound file."	self propCheck.	Interface ifNil: [Interface := LibSndFileInterface new].	index := nil.	position := 0.!open	"Open the named file and read the header"	self openForReading.!openForReading	"Open the named file and read the header"	| compFormat |	mode := #read.	index := Interface lsf_open: name with: (LibSndFileInterface const: #LSFM_READ).	(index < 0) ifTrue: [^nil "self error: 'Cannot open soundfile'"].	compFormat := Interface lsf_get_format: index.	fileFormat := FileFormats at: (compFormat bitAnd: 16rFFF000)					ifAbsent: [#LSF_FORMAT_UNKNOWN].	sampleFormat := SampleFormats at: (compFormat bitAnd: 16r1F)					ifAbsent: [#LSF_FORMAT_UNKNOWN].	rate := Interface lsf_get_rate: index.	channels := Interface lsf_get_channels: index.	size := Interface lsf_get_frames: index.! !!Siren.SoundFile class methodsFor: 'class initialization'!initialize	"Set up the file format and sample format dictionaries to interface with libsndfile."	"SoundFile initialize"	LibSndFileInterface initialize.	FileFormats := (((LibSndFileInterface const: #LSF_FORMAT_WAV) -> #riff),		((LibSndFileInterface const: #LSF_FORMAT_AIFF) -> #aiff),		((LibSndFileInterface const: #LSF_FORMAT_AU) -> #au),		((LibSndFileInterface const: #LSF_FORMAT_IRCAM) -> #bicsf),		((LibSndFileInterface const: #LSF_FORMAT_RAW) -> #raw)).	SampleFormats := (((LibSndFileInterface const: #LSF_FORMAT_PCM_S8) -> #lin8bit),		((LibSndFileInterface const: #LSF_FORMAT_PCM_16) -> #lin16Bit),		((LibSndFileInterface const: #LSF_FORMAT_PCM_24) -> #lin24Bit),		((LibSndFileInterface const: #LSF_FORMAT_PCM_32) -> #lin32Bit),		((LibSndFileInterface const: #LSF_FORMAT_FLOAT) -> #float32),		((LibSndFileInterface const: #LSF_FORMAT_DOUBLE) -> #float64),		((LibSndFileInterface const: #LSF_FORMAT_ULAW) -> #mulaw8)	).! !!Siren.SoundFile class methodsFor: 'instance creation'!named: nameString	"Open the given file (EBICSF, SPARC, or NeXT soundfile format)"	"SoundFile named: 'b.snd'"	| me fullName |	me := self new initialize.	fullName := SirenUtility findFile: nameString.	fullName isNil		ifTrue: [me name: nameString]		ifFalse: [me name: fullName].	^me!openFileNamed: nameString	"Open the given file (EBICSF, SPARC, AIFF, or NeXT soundfile format)"	"SoundFile openFileNamed: 'b.snd'"	| me |	me := self new initialize.	me name: (SirenUtility findFile: nameString).	me openForReading.	^me!readFileNamed: nameString	"Open the given file (EBICSF, SPARC, or NeXT soundfile format)"	"SoundFile readFileNamed: 'b.snd'"	"Sound fromFile: 'kombination.snd'"	| theName me |	theName := SirenUtility findFile: nameString.	theName ifNil: [^nil].	theName isEmpty ifTrue: [^nil].	me := self new initialize.	me name: theName.	me openForReading.	(me sizeInSamples > 1000000) 		ifTrue: [(Dialog confirm: 'SoundFile has ' , me sizeInSamples printString, 					' samples; Load it anyway?')			ifFalse: [^me]].	[me readSamples]		on: Error		do: [ :ex | "ignore" ].	^me!readFileNamed: nameString  answer: theClass	"Open the given file (EBICSF, SPARC, or NeXT soundfile format)"	"SoundFile readFileNamed: 'moon.snd'"	| me |	me := self new initialize.	me name: nameString.	me openForReading.	(me sizeInSamples > 1000000) 		ifTrue: [(Dialog confirm: 'SoundFile "', nameString, '" has ' , 				me samples printString, ' samples.Load it anyway?')			ifFalse: [^me]].	me readSamples: theClass.	me close.	^me!releaseFileIndex: index	"Free the given sound file index"	Interface lsf_close: index! !!ZPoint methodsFor: 'testing'!= aPoint	^super = aPoint and: [z = aPoint z]!hash	^super hash bitXor: z hash!isZero	^super isZero and: [z isZero]! !!ZPoint methodsFor: 'arithmetic'!* aZPointOrNumber 	"only works if the argument is a ZPoint or Number"	| scalePoint |	scalePoint := (aZPointOrNumber isMemberOf: ZPoint)				ifTrue: [aZPointOrNumber]				ifFalse: [ZPoint						x: aZPointOrNumber						y: aZPointOrNumber						z: aZPointOrNumber].	^ZPoint		x: x * scalePoint x		y: y * scalePoint y		z: z * scalePoint z!+ aZPointOrNumber 	"Answer a new ZPoint that is the sum of the receiver and delta 	(which is a ZPoint  	or Number)."	| deltaPoint |	deltaPoint := (aZPointOrNumber isMemberOf: ZPoint)				ifTrue: [aZPointOrNumber]				ifFalse: [ZPoint						x: aZPointOrNumber						y: aZPointOrNumber						z: aZPointOrNumber].	^ZPoint		x: x + deltaPoint x		y: y + deltaPoint y		z: z + deltaPoint z!- aZPointOrNumber 	"Answer a new ZPoint that is the sum of the receiver and delta 	(which is a ZPoint  	or Number)."	| deltaPoint |	deltaPoint := (aZPointOrNumber isMemberOf: ZPoint)				ifTrue: [aZPointOrNumber]				ifFalse: [ZPoint						x: aZPointOrNumber						y: aZPointOrNumber						z: aZPointOrNumber].	^ZPoint		x: x - deltaPoint x		y: y - deltaPoint y		z: z - deltaPoint z!/ aZPointOrNumber 	"only works if the argument is a ZPoint or Number"	| scalePoint |	scalePoint := (aZPointOrNumber isMemberOf: ZPoint)				ifTrue: [aZPointOrNumber]				ifFalse: [ZPoint						x: aZPointOrNumber						y: aZPointOrNumber						z: aZPointOrNumber].	^ZPoint		x: x / scalePoint x		y: y / scalePoint y		z: z / scalePoint z!rounded	^self class basicNew		setX: x rounded		setY: y rounded		setZ: z rounded! !!ZPoint methodsFor: 'accessing'!z	^z!z: aNumber	z := aNumber! !!ZPoint methodsFor: 'private'!convertToFloats	x := x asFloat.	y := y asFloat.	z := z asFloat!setX: xValue setY: yValue setZ: zValue	x := xValue.	y := yValue.	z := zValue! !!ZPoint methodsFor: 'point functions'!dotProduct: aZPoint	| temp |	temp := self * aZPoint.	^temp x abs + temp y abs + temp z abs! !!ZPoint methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' @ '.	z printOn: aStream!storeOn: aStream	"copied & modified from class Point"	aStream nextPut: $(;	nextPutAll: self species name;	nextPutAll: ' x: ';	store: x;	nextPutAll: ' y: ';	store: y;	nextPutAll: ' z: ';	store: z;	nextPut: $).! !!ZPoint methodsFor: 'converting'!asPoint	^x@y! !!ZPoint class methodsFor: 'instance creation'!x: xValue y: yValue z: zValue	^self basicNew setX: xValue setY: yValue setZ: zValue! !!Siren.PortMidiInterface class methodsFor: 'examples'!example1	"Demonstrate using the PortMidiInterface"	"PortMidiInterface example1"	"PortMidiInterface unloadLibraries"	| pm val in out cnt nam dir |	pm := PortMidiInterface new."Initialize PM"	val := pm pm_initialize.	Transcript cr; show: 'PM_init returned: ', val printString; cr.	in := pm pm_default_input_device.	Transcript tab; show: 'pm_default_input_device returned: ', in printString; cr.	out := pm pm_default_output_device.	Transcript tab; show: 'pm_default_output_device returned: ', out printString; cr.	cnt := pm pm_count_devices.	Transcript show: 'pm_count_devices returned: ', cnt printString; cr.	1 to: cnt do: [ :ind |		nam := pm pm_get_name: ind.		dir := pm pm_dev_dir: ind.		Transcript tab; show: ind printString, ' = ', nam copyCStringFromHeap, '  (', dir printString, ')'; cr]."Open PM device for output"	out < 0 ifTrue: [Transcript show: 'No devices found; done'. ^self].	val := pm pm_open: out with: 0.	Transcript show: 'PM_open returned: ', val printString; cr."Test plays a note"	Transcript show: 'PM_test...'; cr.	pm pm_test."Close & terminate"	val := pm pm_close: out.	Transcript show: 'PM_close returned: ', val printString; cr.	val := pm pm_terminate.	Transcript show: 'PM_terminate returned: ', val printString; cr.!testMIDI	"Demonstrate using the PortMidiInterface to call the test note function in the driver"	"PortMidiInterface testMIDI"	"PortMidiInterface unloadLibraries"	| pm val |	pm := PortMidiInterface new.	val := pm pm_initialize.	Transcript cr; show: 'PM_init returned: ', val printString; cr.	val := pm pm_open: MIDIVoice defaultOutInterface with: 0.	Transcript show: 'PM_open returned: ', val printString; cr.	pm pm_test.			"call the test code in the driver"	val := pm pm_close: val.	Transcript show: 'PM_close returned: ', val printString; cr.	val := pm pm_terminate.	Transcript show: 'PM_terminate returned: ', val printString; cr.!testMIDI2	"Demonstrate using the PortMidiInterface to play a note on/off cmd pair"	"PortMidiInterface testMIDI2"	"PortMidiInterface unloadLibraries"	| pm val which |	pm := PortMidiInterface new."Init"	val := pm pm_initialize.	Transcript cr; show: 'PM_init returned: ', val printString; cr."Open"	which := pm pm_open: MIDIVoice defaultOutInterface with: 0.	Transcript show: 'PM_open returned: ', which printString; cr."Send note on"	pm pm_write_data3: which "MIDIVoice defaultOutInterface" with: 144 with: 48 with: 120.	1 wait."Send note off"	pm pm_write_data3: which "MIDIVoice defaultOutInterface" with: 128 with: 48 with: 120.	1 wait."Close"	val := pm pm_close: which.	Transcript show: 'PM_close returned: ', val printString; cr."Terminate"	val := pm pm_terminate.	Transcript show: 'PM_terminate returned: ', val printString; cr.! !!Siren.Roll methodsFor: 'accessing'!duration	"compute and answer the duration"	^duration == nil 		ifFalse: [duration]		ifTrue: [number * noteDuration]! !!Siren.Roll methodsFor: 'initialize'!length: aLength rhythm: aDuration note: aNote	"make a new roll of the specified length..."	delta := aDuration.	noteDuration := aDuration.	number := aLength / aDuration.	self pitch: (Pitch value: aNote).	^self!number: aNumber rhythm: aDuration note: aNote	"make a new roll with the specified number of notes..."	delta := aDuration.	number := aNumber.	noteDuration := aDuration.	self pitch: (Pitch value: aNote).	^self! !!Siren.Roll methodsFor: 'playing'!eventList	"return an eventList for me"	| newList |	newList := EventList newAnonymous.	0 to: number do:		[ :count |			newList add: (self defaultEventClass 					dur: noteDuration pitch: self pitch ampl: self loudness) 				at: (delta * count) ].	^newList! !!Siren.Roll class methodsFor: 'examples'!rollExample	"Create and edit/play a few rolls."	"((Roll length: 2 rhythm: 100 note: 48) ampl: 100) eventList"	"((Roll length: 2 rhythm: 100 note: 48) ampl: 100) eventList edit"	((Roll length: 2 rhythm: 50 note: 60) ampl: 80) eventList play."	MIDIPort allNotesOff."! !!Siren.Roll class methodsFor: 'instance creation'!length: aNumber rhythm: aDuration note: aNote	"return a new roll of the specified length..."	^self new length: aNumber rhythm: aDuration note: aNote!number: aNumber rhythm: aDuration note: aNote	"return a new roll with the specified number of events..."	^self new number: aNumber rhythm: aDuration note: aNote! !!Siren.ExponentialFunction methodsFor: 'accessing'!at: anIndex	"Answer the value at the given index in my range--do exponential interpolation such 	that if f(x, i) is the i-th function value in the transition from breakpoint v[J] to 	v[J+1], then:		f(x) = v[J] + (v[J+1] - v[J])*(1 - exp(i*x[J]/(N-1)))/(1 - exp(x[J]))	for 0 <= i < N, where N is the number of function points between t[J] and the next 	horizontal value, and x is the exponential weight whereby x = 0 will yield a 	straight line, x < 0 will yield an exponential transition, and x > 0 will yield a 	logarithmic transition."	| weight interp xVal count x1 x2 y1 y2 val |	xVal := data first x.	count := 1.	[xVal < anIndex] whileTrue:		[count := count + 1.		count > data size			ifTrue: [val := data last x].		xVal := (data at: count) x].	xVal = anIndex 		ifTrue: [val := (data at: count) y]		ifFalse: [x1 := (data at: (count - 1)) x.			x2 := (data at: count) x.			y1 := (data at: (count - 1)) y.			y2 := (data at: count) y.			weight := (data at: count - 1) z.			interp := (anIndex - x1) / (x2 - x1).			weight == 0		"special case for linear interpolation"				ifTrue: [val := y1 + (interp * (y2 - y1))].			val := y1 + ((y2 - y1) * ((1 - (interp * weight) exp) / (1 - weight exp)))].	^(val * scale) + offset!pointAt: index	"Answer the given value in the receiver's breakpoint collection as a 2-D point."	| pt |	pt := data at: index.	^pt x @ pt y! !!Siren.ExponentialFunction methodsFor: 'printing'!printOn: aStream	"Format and print the receiver on the argument."	| pt |	data size > 16		ifTrue: [^super printOn: aStream].	aStream nextPutAll: self class name, ' from: '.	aStream nextPut: $#; nextPut: $(.	1 to: data size do: 			[ :i |			pt := data at: i.			aStream nextPut: $(.			pt x printOn: aStream.			aStream space.			pt y printOn: aStream.			aStream space.			(pt respondsTo: #z)				ifTrue: [pt z printOn: aStream].			aStream nextPut: $); space].			aStream nextPut: $)! !!Siren.ExponentialFunction class methodsFor: 'examples'!expADSRViewExample	"Make an exp seg and open a view on its form."	"ExponentialFunction expsegViewExample"	FunctionView onFunction: 		(ExponentialFunction from: #((0 0 -5) (0.2 1 -3) (0.8 0.5 -2) (1 0)))!expASRViewExample	"Make an exp seg and open a view on its form."	"ExponentialFunction expASRViewExample"	FunctionView onFunction: 		(ExponentialFunction from: #((0 0 -3) (0.3 0.9 0) (0.7 0.9 -3) (1 0)))!expsegViewExample	"Make an exp seg and open a view on its form."	"ExponentialFunction expsegViewExample"	FunctionView onFunction: 		(ExponentialFunction from: #((0 0 -3) (0.2 1 -5) (0.6 0.5 -1) (1 0)))! !!Siren.ExponentialFunction class methodsFor: 'instance creation'!a: att d: dec s: sus r: rel	"Answer an ADSR envelope."	"(ExponentialFunction a: 0.06 d: 0.06 s: 0.4 r: 0.4) edit"	| susT arr |	susT := 1.0 - (att + dec).	arr := Array new: 5.	arr at: 1 put: (0 @ 0 @ 3).	arr at: 2 put: (att @  1 @ -3).	arr at: 3 put: ((att + dec) @ sus @ -2).	arr at: 4 put: (susT @ sus @ -2).	arr at: 5 put: (1 @ 0).	^self from: arr!default	"Answer a default instance of the receiver class."	"ExponentialFunction default edit"	^self from: #((0 0 3 ) (0.08 1.0 -3) (0.2 0.5 -1) (1 0 0))!from: anArrayOfPoints	"Answer a function with the given points."	"ExponentialFunction from: #((0 0 5) (0.5 1 5) (1 0))"	| me |	me := self ofSize: anArrayOfPoints size.	anArrayOfPoints first isPoint		ifTrue: [anArrayOfPoints do: 			[ :aZPoint |  me add: aZPoint]]		ifFalse: [anArrayOfPoints do: 			[ :anArray |  me add: (anArray first @ (anArray at: 2) @ anArray last)]].	me updateRange.	^me! !!Siren.DisplayString methodsFor: 'accessing'!bounds	"Answer a rectangle that circumscribes the receiver."	^offset extent: self extent!extent	"Answer a rectangle that circumscribes the receiver."	^font == nil		ifFalse: [((TextMeasurer forFont: font)				measureString: string				fromCharacterIndex: 1				to: string size) @ font height]		ifTrue: [(string size * 12) @ 12]!font	"Answer the receiver's font."	^font!font: aFont	"Set the receiver's font."	font := aFont!string	"Answer the receiver's string."	^string!string: aString	"Set the receiver's string."	string := aString! !!Siren.DisplayString methodsFor: 'printing'!printOn: aStream	"comment stating purpose of message"	aStream nextPutAll: ' (a ', self class name, ' offset: '.	offset printOn: aStream.	aStream nextPutAll: ' string: '.	string printOn: aStream."	color == nil		ifFalse: [aStream nextPutAll: ' color: '. color printOn: aStream]."	aStream nextPut: $); cr.! !!Siren.DisplayString methodsFor: 'displaying'!displayOn: aGraphicsContext	"display the receiver on the argument.""	Transcript show: (aGraphicsContext translation  + offset) printString; space."	font == nil		ifFalse: [aGraphicsContext font: font].	color == nil		ifFalse: [aGraphicsContext paint: color].	aGraphicsContext displayString: string at: (offset + (0@14))!displayPostScriptOn: aPostscriptContext	"Display the receiver on the argument as a PostScript item."	aPostscriptContext translate: offset.	aPostscriptContext show: string.	aPostscriptContext translate: offset negated.! !!Siren.DisplayString methodsFor: 'initialize-release'!initialize	"Initialize the instance variables of the receiver."	super initialize.	font := Screen default defaultFontPolicy findFont: FontDescription default.! !!Siren.DisplayString class methodsFor: 'examples'!stringExample	"Open a display list view with randomly-placed random-color strings over the given extent."	"DisplayString stringExample"	(DisplayList stringsX: 600 byY: 600) display! !!Siren.DisplayString class methodsFor: 'instance creation'!new	"Answer a new initialized instance."	^super new initialize!string: aString	"Answer a new instance with the argument as its string."	^self new string: aString!string: aString offset: oPoint	"Answer a new instance with the arguments as its string and offset point."	^self new string: aString; offset: oPoint! !!Siren.HungarianMinor class methodsFor: 'interval list'!intervalList	"tire de McLaughlin et le Mahavischnu Orchestra"	^#(#unison #second #minorThird #augmentedFourth #perfectFifth #minorSixth #majorSeventh )! !!Siren.HungarianMinor class methodsFor: 'examples'!exemple	"	(HungarianMinor root: N do) notes ->   #(Do Re Mib Fa# Sol Lab Si )	(HungarianMinor root: N do) generateChordsPoly: 4->  OrderedCollection (Do #min #maj7  Re #dim5 7  Mib #aug5 #maj7  Fa# #dim5 #dim7  Sol #maj7  Lab #maj7  Si #min #dim7  )	(FPChord newFromString: 'D min ') possibleTonalitiesInScaleClass: self ->ListeDAnalyses ({I de Re HungarianMinor} {VII de Mib HungarianMinor} )"! !!Siren.Trill methodsFor: 'playing'!eventList	"return an eventList for me"	| newList |	newList := EventList newAnonymous.	0 to: number do:		[ :count |			newList add: (self defaultEventClass 					dur: noteDuration 					pitch: (self pitch value at: ((count \\ self pitch value size) + 1)) 					ampl: self loudness) 				at: (delta * count) ].	^newList! !!Siren.Trill class methodsFor: 'instance creation'!length: aNumber rhythm: aDuration note: aNote	"return a new roll of the specified length..."	^self new length: aNumber rhythm: aDuration note: aNote!length: aNumber rhythm: aDuration notes: aNote	"return a new trill of the specified length..."	^self new length: aNumber rhythm: aDuration note: aNote! !!Siren.FFTWInterface class methodsFor: 'examples'!example	"Demonstrate using the FFTWInterface by taking the FFT of a sawtooth wave"	"FFTWInterface example"	| fft size val samples spectrum incr "e scale" mag signalFcn spectFcn |	size :=  1024."Create a sawtooth"	samples := UninterpretedBytes new: (size * 4).	val := -0.8.	incr := 0.02.	1 to: size do:							[ :ind |		samples floatAt: (ind - 1 * 4 + 1) put: val.		val := val + incr.		(val > 0.8) ifTrue: [val := val - 1.6]].	samples gcCopyToHeap.	spectrum := UninterpretedBytes new: (size * 4 + 1).	spectrum gcCopyToHeap."Initialize"	fft := FFTWInterface new.				"set up the FFT"	val := fft fftw_initialize: size with: samples with: spectrum.	Transcript cr; show: 'FFTW_init returned: ', val printString; cr."Do the FFT"	fft fftw_forward_transform."Now get the magnitude spectrum"	signalFcn := Function ofSize: size / 2.	spectFcn := Function ofSize: size / 2."	e := 2.71828183.	scale := 0.11512925."	1 to: size by: 2 do:		[ :ind | | re im |		re := spectrum floatAt: (ind - 1 * 4 + 1).		im := spectrum floatAt: (ind * 4 + 1).		mag := ((re * re) + (im * im)) sqrt."		spectFcn add: (e raisedTo: (mag * scale))"		"amp = exp(a * 0.11512925)"		spectFcn add: mag.		signalFcn add: ((samples floatAt: (ind - 1 * 4 + 1)) / 4.0)].	FunctionView lineWidth: 1.	InputState default shiftDown		ifFalse: [FunctionView onFunctions: (Array with: signalFcn with: spectFcn) 					normalize: #(false true true true) ]		ifTrue: [spectFcn edit]! !!Siren.IndentedListLayoutManager methodsFor: 'generating'!displayPositionFor1: aPath	"Answer the display position of the element at the given path."	| pt |	length == nil ifTrue: [length := 0].	pt := (orientation == #left or: [orientation == nil])		ifFalse: [(length * xStep) @ (aPath size * yStep)]		ifTrue: [(aPath size * xStep) @ (length * yStep)].	Transcript show: aPath printString, ' ', pt printString; cr.	^pt!displayPositionFor: aPath	"Answer the display position of the element at the given path."	length == nil ifTrue: [length := 0].	^(orientation == #left or: [orientation == nil])		ifFalse: [(length * xStep) @ (aPath size * yStep)]		ifTrue: [(aPath size * xStep) @ (length * yStep)]! !!Siren.IndentedListLayoutManager class methodsFor: 'examples'!colorListExample	"IndentedListLayoutManager colorListExample"	| acc me |	acc := STreeAccessor subject: MusicMagnitude			terminalQuery: [ :c | c subclasses size = 0]			childAccessor: #sortedSubclasses			itemGenerator: [ :c | (DisplayString new)									model: c;									string: c name;									color: [c color]].	me := (self new) accessor: acc; xStep: 16; yStep: 16.	^me displayList display!listExample	"IndentedListLayoutManager listExample display"	"DisplayListView classListExample"	| acc me |	acc := STreeAccessor subject: Magnitude			terminalQuery: [ :c | c subclasses size = 0]			childAccessor: #sortedSubclasses			itemGenerator: [ :c | (DisplayString new)									model: c;									string: c name;									color: ColorValue darkGray].	me := (self new) accessor: acc; xStep: 16; yStep: 16.	^me displayList! !!Siren.SEventQueue methodsFor: 'accessing'!add: eventAss	"Add the given eventAssociation to the receiver in the right place."	^self add: eventAss loop: false!add: eventAss loop: aBool	"Add the given eventAssociation to the receiver in the right place."	| key which |	key := eventAss key usec value.	which := self locateSlotFor: key.	which key: key.	which value: eventAss value.	which loop: aBool!asOrderedCollection	"Answer a copy of the receiver's items"	| list |	list := OrderedCollection new.	self do: [ :item | list addLast: item value name].	^list!detect: aBlock	"Walk the list looking"	| item |	self isEmpty ifTrue: [^nil].	item := first.		[(aBlock value: item) ifTrue: [^item]. 		item := item next.		item notNil] whileTrue.	^nil!do: aBlock	"Refer to the comment in Collection|do:."	| item |	self isEmpty ifTrue: [^nil].	item := first.		[aBlock value: item. 		item := item next.		item notNil] whileTrue.!includes: sought	^(self detect: [ :item | item ==  sought]) notNil!isEmpty	^first isNil!itemNamed: theName	"Answer a copy of the receiver's items"	self do: [ :item | (item value name == theName) ifTrue: [^item]].	^nil!ready: now	"Answer whether there's an event ready within 5000 usec of the given time"	first ifNil: [^false].	first start ifNil: [^false]."	Transcript show: (now - first start) printString; cr.""	^(now - first start) abs < 1000"	^(now - first start) > 1000!removeAllSuchThat: aBlock 	"Remove each element for which aBlock evaluates to true. "	| item prev next |	self isEmpty ifTrue: [^nil].	item := first.	[item isNil]		whileFalse: [(aBlock value: item)			ifFalse: [item := item next]			ifTrue: [prev := item previous.				prev ifNotNil: [prev next: item next].				next := item next.				next ifNotNil: [next previous: prev].				((item == first) and: [next isNil])					ifTrue: [first := nil].				item := next]]!removeFirst	"Remove and answer the first item from the list."	| item |	first ifNil: [last := nil. ^nil].	item := first.	first := first next.	^item!size	"Answer how many elements the receiver contains."	| item tally |	self isEmpty		ifTrue: [^0].	tally := 0.	item := first.	[(item := item next) notNil] whileTrue: [tally := tally + 1].	^ tally! !!Siren.SEventQueue methodsFor: 'printing'!printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	aStream print: self class; nextPutAll: ' ('.	aStream nextPutAll: first printString, ' - ', last printString.	aStream nextPut: $)! !!Siren.SEventQueue methodsFor: 'private'!locateSlotFor: start	"Find the proper slot for inserting a new event with the given start time."	| new item |	new := self class nextRecord.		"get a record from the class's pool"	new ifNil: [self error: 'No scheduler slots available'].	((first isNil) or: [first start isNil])		ifTrue: [first := new.			last := nil.			^new].	first start >= start					"If it's before the first scheduled event, prepend."		ifTrue: [first previous: new.			new next: first.			last ifNil: [last := first].			first := new.			^new].	last ifNil:							"if it's after the first and only entry"		[first next: new.		new previous: first.		last := new.		^new].	last start <= start					"If it's after the last scheduled event, append."		ifTrue: [last next: new.			new previous: last.			last := new.			^new].	item := first.						"Else do linear search and then insert."	[item key < start]		whileTrue: [item := item next].	item previous next: new.	new previous: item previous.	item previous: new.	new next: item.	^new! !!Siren.SEventQueue class methodsFor: 'record pool'!initialize	"Set up the class's record pool"	"SEventQueue initialize"	| poolSize |	poolSize := 32.	CurrentRecord := 1.	RecordPool := Array new: poolSize.	1 to: poolSize do:		[ :count |		RecordPool at: count put: ScheduleRecord new].!nextRecord	"Set up the class's record pool"	"SEventQueue initialize"	"SEventQueue nextRecord"	| rec looped |	looped := false.		[CurrentRecord := (CurrentRecord + 1).		CurrentRecord > RecordPool size			ifTrue: [looped ifTrue: [^nil].				CurrentRecord := 1.				looped :=  true].		rec := RecordPool at: CurrentRecord.		rec key isNil]	whileFalse.	^rec! !!Siren.LPCEditor methodsFor: 'aspects'!showPitch	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showPitch isNil		ifTrue:			[showPitch := true asValue]		ifFalse:			[showPitch]!showRMS	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showRMS isNil		ifTrue:			[showRMS := true asValue]		ifFalse:			[showRMS]!showResid	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showResid isNil		ifTrue:			[showResid := true asValue]		ifFalse:			[showResid]!showRunning	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showRunning isNil		ifTrue:			[showRunning := true asValue]		ifFalse:			[showRunning]!showSmoothed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showSmoothed isNil		ifTrue:			[showSmoothed := true asValue]		ifFalse:			[showSmoothed]!showSmoothed2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showSmoothed2 isNil		ifTrue:			[showSmoothed2 := true asValue]		ifFalse:			[showSmoothed2]! !!Siren.LPCEditor methodsFor: 'actions'!closeWindow	"close view"	^self closeRequest!overwritePitch	"Store the smoothed pitch into the model sound"	| which sel |	which := (Menu labelArray: #(running smooth1 smooth2)) startUp.	which == 0 ifTrue: [^self].	sel := #(running smooth1 smooth2) at: which.	sound writePitch: sel.	self redraw!redraw	"Redisplay"	builder namedComponents do: [:t1 | t1 invalidate].!save	"Store the model data to a new file."	sound storeFile! !!Siren.LPCEditor methodsFor: 'interface opening'!postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder componentAt: #View1) widget model: sound		"and plug it in"!sound: aSound	sound := aSound!theLPCView	^LPCView new editor: self! !!Siren.LPCEditor class methodsFor: 'interface opening'!openOn: snd	"LPCEditor openOn: LPCSound someInstance."	| inst |	inst := self new.	inst sound: snd.	self openOn: inst withSpec: #windowSpec! !!Siren.ListOfNotes methodsFor: 'recognition'!asTriad	"recognizes the list as a triad, if possible. relies en enharmonic spelling"	"detecte la quinte puis la tonique puis la tierce"	| pc   allInt fifth root third triade |	self size < 3 ifTrue: [^nil].	pc := self collect: [:n | n pitchClass].	fifth := pc detect: [:p| 		allInt := (1 to: pc size) collect: [:i | (pc at: i) intervalBetween: p].		fifth := allInt detect: [:int| int = MusicalInterval perfectFifth] ifNone: [nil].		fifth notNil]			 ifNone: [nil].	fifth isNil ifTrue: [^nil].	root := fifth perfectFourth.	third := pc detect: [:p | p natural == root majorThird natural] ifNone: [^nil].	triade := Array with: root with: third with: fifth.	pc do: [:p| (triade includes: p) ifFalse: [^nil]].	^Triad new root: root; notes: self; type: (((root intervalBetween: third) = MusicalInterval majorThird) ifTrue: [#major] ifFalse: [#minor])! !!Siren.ListOfNotes methodsFor: 'queries'!barycenter	| x |	self isEmpty ifTrue: [^nil].	x := 0.	self do: [:n | x := x + n midiPitch].	^OctaveDependentNote fromMidiPitch: (x // self size) "rounded"!highest	| highest |	self isEmpty ifTrue: [^nil].	highest := self first.	self do: [:n | n midiPitch > highest midiPitch ifTrue: [highest := n]].	^highest!lowest	| lowest |	self isEmpty ifTrue: [^nil].	lowest := self first.	self do: [:n | n midiPitch < lowest midiPitch ifTrue: [lowest := n]].	^lowest! !!Siren.ListOfNotes methodsFor: 'ciphering'!cipherIn: aScale 	"works only for triads for the time being. Uses the French notation"	"(ListOfNotes from: (Array with: (N G @ 2) with: (N C @ 3) with: (N E @ 4)))	cipherIn: nil"	|  lowest degres   |	lowest := self lowest.	degres := self collect: [:x| lowest intervalTypeBetween: x].	"third := (l detect: [:x| (lowest intervalTypeBetween: x) = 3].	fourth := 	fifth := 	sixth := "	^degres! !!Siren.ListOfNotes methodsFor: 'accessing'!identityIndexOf: x 	"yields the index found with a == test instead of the usual ="	^self identityIndexOf: x ifAbsent: [0]!nextIdentityIndexOf: anElement from: startIndex to: stopIndex 	"Answer the next index of anElement within the receiver between startIndex 	and stopIndex. 	If the receiver does not contain anElement, answer nil"	startIndex to: stopIndex do: [:i | (self at: i)			== anElement ifTrue: [^i]].	^nil! !!Siren.ListOfNotes class methodsFor: 'creation'!from: aList	^ self withAll: aList! !!Siren.ListOfNotes class methodsFor: 'examples'!example	"(ListOfNotes from: (Array with: (N C octave: 2) with: (N D octave: 3) with: (N D octave: 4)))barycenter -> C#3"! !!Siren.DiatonicInterval methodsFor: 'computing notes'!bottomIfTopIs: aNote 	"yields the note making the interval self with aNote"	^ascending		ifTrue: [aNote preceding]		ifFalse: [aNote following]!topIfBottomIs: aNote 	"yields the note making the interval self with aNote"	^ascending ifFalse: [aNote preceding]		ifTrue: [aNote following]! !!Siren.DiatonicInterval methodsFor: 'initialize'!initialize	ascending := true! !!Siren.DiatonicInterval methodsFor: 'printing'!printOn: s 	s nextPutAll: 'Diatonic interval '! !!Siren.DiatonicInterval methodsFor: 'private'!ascending: t 	ascending := t! !!Siren.DiatonicInterval class methodsFor: 'creation'!ascending	^DiatonicInterval new ascending: true!descending	^DiatonicInterval new ascending: false!new	^super new initialize! !!Siren.PitchClassDoubleFlat methodsFor: 'testing'!isDoubleFlat	^true! !!Siren.PitchClassDoubleFlat methodsFor: 'printing'!printOn: s 	natural printOn: s.	s nextPutAll: 'bb'!storeOn: s 	"N C flat flat storeString"	s nextPutAll: 'N ' , self natural name, ' flat flat'! !!Siren.PitchClassDoubleFlat methodsFor: 'saving'!representBinaryOn: s	^MessageSend receiver: natural selector:  #doubleFlat! !!Siren.PitchClassDoubleFlat methodsFor: 'intervals'!alterate: note toReach: i 	| n |	n := natural alterate: note toReach: i.	^n flat flat!alterateBelow: note toReach: i 	| n |	n := natural alterateBelow: note toReach: i.	^n flat flat!closestEnharmonic	^self alterate: self preceding toReach: 0.!semiTonesToNatural	^2! !!Siren.PitchClassDoubleFlat methodsFor: 'access'!flat	"Sorry, I have to do that (Cf. Bluesette) otherwise I can't 	compute possibleTonalities properly ..."	^nil!semiToneCount	^natural semiToneCount - 2!sharp	"Methode flat is not defined. 	Exemple C flat diminishedSeventh.."	^natural flat! !!Siren.Tag methodsFor: 'accessing'!addChild: aTag	children at: aTag name put: aTag!addParent: aTag	parents at: aTag name put: aTag!addSibling: aTag	siblings at: aTag name put: aTag!children	^children!isTag	^true!name	^name!name: aValue	name := aValue!parents	^parents!siblings	^siblings!tracks	tracks ifNil: [tracks := OrderedCollection new].	^tracks!tracks: aValue	tracks := aValue! !!Siren.Tag methodsFor: 'printing'!printOn: aStream	"Format and print the receiver on the argument."	aStream nextPutAll: name value, ' - ', self tracks size printString, ' tracks'.! !!Siren.Tag methodsFor: 'initialize-release'!initialize	"Setup instance"	parents := IdentityDictionary new.	children := IdentityDictionary new.	siblings := IdentityDictionary new.!reinitialize	"Setup instance"	parents := IdentityDictionary new.	children := IdentityDictionary new.	siblings := IdentityDictionary new.! !!Siren.Tag class methodsFor: 'instance creation'!name: nam track: tr	"Create and return a new Tag"	| inst |	inst := self new initialize.	inst name: nam.	tr ifNotNil: [inst tracks addFirst: tr].	^inst! !!Siren.DisplayList methodsFor: 'accessing'!color	^ColorValue black!flatten	"Answer a copy of the receiver with its hierarchy flattened."	| new |	new := DisplayList new.	components do:		[ :item |		item hasItems			ifTrue: [ | subnew |				subnew := item flatten components.				subnew do: [ :subitem |					new add: (subitem translateBy: item offset)]]			ifFalse: [new add: item]].	^new!itemWithin: dist of: point	"Answer the list of items whose boundingBoxes are entirely within the given rectangle."	components do: 		[ :comp |		comp hasItems			ifTrue: [ | item |				(item := comp itemWithin: dist of: (point - self offset)) == nil					ifFalse: [^item]]			ifFalse: [((comp bounds expandedBy: dist) containsPoint: point)					ifTrue: [^comp]]].	^nil!itemsFromX: x1 toX: x2	"Answer the list of items whose offsets are within the given X range."	| dList |	dList := DisplayList new.	components do: 		[ :i |		i hasItems			ifTrue:				[ | tList |				tList := i itemsFromX: x1 + i offset x 							toX: x2 + i offset x.				tList isEmpty ifFalse: [dList add: tList at: i offset]]			ifFalse:				[(i offset x between: x1 and: x2) ifTrue: [dList add: i]]].	^dList!itemsIntersecting: rect	"Answer the list of items whose boundingBoxes intersect the given rectangle. 	Clip them to the box's border if necessary."	| dList dList2 |	dList := DisplayList new.	components do: 		[ :i |		i hasItems			ifTrue: [dList2 := i itemsIntersecting: (rect translateBy: self offset).				dList2 == nil					ifFalse: [dList add: (dList2 offset: i offset)]]			ifFalse: [(((i boundingBox) translateBy: self offset) 								intersects: rect)					ifTrue: [dList add: (i clipTo: (rect translateBy: ((0@0) - self offset)))]]].	^(dList components isEmpty)		ifTrue: [nil]		ifFalse: [(dList components size = 1)			ifTrue: [dList components first]			ifFalse: [dList]]!itemsWithin: rect	"Answer the list of items whose boundingBoxes are entirely within the given rectangle."	| dList movedRect |	movedRect := rect moveBy: self offset negated.	dList := DisplayList new.	components do: 		[ :comp |		comp hasItems			ifTrue: [ | items |				items := comp itemsWithin: movedRect.				items == nil ifFalse: [dList add: items]]			ifFalse: [(movedRect contains: comp bounds) 					ifTrue: [dList add: comp]]].	(dList components isEmpty)		ifTrue: [^nil]		ifFalse: [(dList components size = 1)			ifTrue: [ | first |				first := dList components first.				first hasItems					ifTrue: [first container: nil].				^first copy translateBy: self offset]			ifFalse: [^dList translateBy: self offset]]!itemsWithin: dist of: point	"Answer the list of items whose boundingBoxes are entirely within the given rectangle."	| dList |	dList := DisplayList new.	components do: 		[ :comp |		comp hasItems			ifTrue: [dList add: 					(comp itemsWithin: dist of: (point - self offset))]			ifFalse: [((comp bounds expandBy: dist) containsPoint: point)					ifTrue: [dList add: comp]]].	^(dList components isEmpty)		ifTrue: [nil]		ifFalse: [(dList components size = 1)			ifTrue: [dList components first]			ifFalse: [dList]]!modelsFromX: x1 toX: x2	"Answer the list of model-space-items whose offsets are within the given X range."	| dList |	dList := DisplayList new.	components do: 		[ :i |		((i offset x >= x1) and: [i offset x <= x2])				ifTrue: [dList add: i]].	^dList collect: [ :i | i model]!nodeAt: aPath	"Answer the element described by the collection of items in the argument."	| next path2 |	components isEmpty ifTrue: [^nil].	next := components			detect: [ :i | 					i "component" model == aPath first]			ifNone: [nil].	next == nil		ifFalse: [aPath size = 1			ifTrue: [^next]			ifFalse: [path2 := aPath copy.				path2 removeFirst.				^next nodeAt: path2]]		ifTrue: [^nil]!nodeFor: aModel	"Answer the element whose model is the argument."	components isEmpty ifTrue: [^nil].	^components			detect: [ :i | 					i model == aModel]			ifNone: [nil].!offset	"Answer the receiver's offset."	^offset == nil		ifTrue: [0@0]		ifFalse: [offset]!offset: aPoint	"Set the receiver's offset."	offset := aPoint!wrapperClass	"Raise an error."	self error: 'I don''t use Wrappers!!'! !!Siren.DisplayList methodsFor: 'testing'!hasItems	"Answer whether or not the receiver has items or components."	^true!isEmpty	"Amswer whether the receiver has any items."	^components isEmpty! !!Siren.DisplayList methodsFor: 'transforming'!scaledBy: aPoint	"Scale the receiver's offset by the argument."	| newMe |	newMe := self class new.	self do:		[ :item |		newMe add: (item scaledBy: aPoint) at: item offset * aPoint].	^newMe!translateBy: aPoint	"Translate the receiver's offset by the argument."	self offset: self offset + aPoint! !!Siren.DisplayList methodsFor: 'displaying'!display	"Open a DisplayListView on the receiver."	self computePreferredBounds.	^DisplayListSubcanvas openOnList:  self!displayNonCached	"Open a DisplayListView on the receiver."	^DisplayListView openNonCached: self!displayOn: aGraphicsContext	"Display each of the receiver's components."	| clipBox |	clipBox := aGraphicsContext clippingBounds.	offset ifNotNil: [aGraphicsContext translateBy: offset].	components do:		[ :c | (c intersects: clipBox)			ifTrue: [c displayOn: aGraphicsContext]].	offset ifNotNil: [aGraphicsContext translateBy: offset negated].!displayPostScriptOn: aPostscriptContext	"Display each of the receiver's components."	offset == nil		ifFalse: [aPostscriptContext translate: offset].	1 to: components size do:		[ :i | (components at: i) displayPostScriptOn: aPostscriptContext].	offset == nil		ifFalse: [aPostscriptContext translateBy: offset negated].! !!Siren.DisplayList methodsFor: 'bounds accessing'!bounds	"Compute the receiver's preferredBounds"	| preferredBounds |self halt.	components isEmpty		ifTrue: [preferredBounds := (0@0) extent: (0@0)]		ifFalse: [preferredBounds := components first computePreferredBounds].	1 to: components size do:		[:i |		preferredBounds := preferredBounds merge: (components at: i) computePreferredBounds].	preferredBounds origin < (0@0)		ifTrue: [preferredBounds := preferredBounds 				translatedBy: preferredBounds origin negated].	offset == nil		ifTrue: [preferredBounds := preferredBounds expandedBy: (64@64)]		ifFalse: [preferredBounds := (preferredBounds translatedBy: offset) expandedBy: (64@64)].	preferredExtent := preferredBounds extent.	^preferredBounds!computePreferredBounds	"Compute the receiver's preferredBounds"	| preferredBounds |	components isEmpty		ifTrue: [preferredBounds := (0@0) extent: (0@0)]		ifFalse: [preferredBounds := components first computePreferredBounds].	1 to: components size do:		[:i |		preferredBounds := preferredBounds merge: (components at: i) computePreferredBounds].	preferredBounds origin < (0@0)		ifTrue: [preferredBounds := preferredBounds 				translatedBy: preferredBounds origin negated].	offset == nil		ifTrue: [preferredBounds := preferredBounds expandedBy: (64@64)]		ifFalse: [preferredBounds := (preferredBounds translatedBy: offset) expandedBy: (64@64)].	preferredExtent := preferredBounds extent.	^preferredBounds!extent	"Answer the extent of the receiver."	^self computePreferredBounds extent!preferredBounds	"Compute the receiver's preferredBounds"	| preferredBounds |	components isEmpty		ifTrue: [preferredBounds := (0@0) extent: (0@0)]		ifFalse: [preferredBounds := components first computePreferredBounds].	1 to: components size do:		[:i |		preferredBounds := preferredBounds merge: (components at: i) computePreferredBounds].	preferredBounds origin < (0@0)		ifTrue: [preferredBounds := preferredBounds 				translatedBy: preferredBounds origin negated].	offset == nil		ifTrue: [preferredBounds := preferredBounds expandedBy: (64@64)]		ifFalse: [preferredBounds := (preferredBounds translatedBy: offset) expandedBy: (64@64)].	preferredExtent := preferredBounds extent.	^preferredBounds! !!Siren.DisplayList methodsFor: 'enumerating'!do: aBlock	"Iterate the argument block over the receiver's components."	components do: aBlock! !!Siren.DisplayList methodsFor: 'printing'!printCompleteOn: aStream depth: depth	"Descend the hierarchy printing on the stream."	aStream cr.	depth timesRepeat: [aStream tab].	aStream nextPutAll: '(a DisplayList '.	offset == nil		ifFalse: [aStream nextPutAll: ' offset: ', offset printString]."	model == nil		ifFalse: [aStream nextPutAll: ' model: ', model printString]."	components == nil		ifFalse: [components do: 			[ :e | 			e printCompleteOn: aStream depth: depth + 1]].	aStream nextPut: $)!printCompletePostScriptOn: aStream depth: depth	"Descend the hierarchy printing on the stream."	aStream cr.	depth timesRepeat: [aStream tab].	aStream nextPutAll: '(a DisplayList '.	offset == nil		ifFalse: [aStream nextPutAll: ' offset: ', offset printString]."	model == nil		ifFalse: [aStream nextPutAll: ' model: ', model printString]."	components == nil		ifFalse: [components do: 			[ :e | 			e printCompleteOn: aStream depth: depth + 1]].	aStream nextPut: $)!printOn: aStream	"Print the receiver on the argument using the recursive method."	^InputState default shiftDown 		ifTrue: [super printOn: aStream]		ifFalse: [self printCompleteOn: aStream depth: 0]!printPostScriptOn: aStream	"Print the receiver on the argument using the recursive method."	^self printCompletePostScriptOn: aStream depth: 0! !!Siren.DisplayList methodsFor: 'adding-removing'!add: aVisualComponent	"Add the argument to the receiver."	^self addComponent: aVisualComponent!add: aVisualComponent at: aPoint	"Add aVisualComponent to the receiver's components with its offset set to aPoint."	aVisualComponent offset: aPoint.	self add: aVisualComponent!add: anItem atPath: aPath	"Add the first argument at the node described by the second."	| node |	(aPath == nil or: [aPath isEmpty])		ifTrue: [^self add: anItem].	node := self nodeAt: aPath.	node == nil		ifTrue: [self addComponent: anItem]		ifFalse: [node addComponent: anItem]!addAll: aCollection	"Add the argument to the receiver."	aCollection do: [ :item | self add: item]!addComponent: aVisualComponent	"Add the argument to the receiver."	components addLast: aVisualComponent.	aVisualComponent container: self!addWrapper: aVisualWrapper	"Raise an error."	self error: 'I don''t use Wrappers!!'! !!Siren.DisplayList class methodsFor: 'examples'!exampleHierarchical	"Create and answer a large display list with a lines, strings, and visuals."	"DisplayList exampleHierarchical display"	| dl1 dl2 dl3 dl4 dl5 dl6 rand size |	size := 100.	dl1 := DisplayList new.	dl2 := DisplayList new.	dl3 := DisplayList new.	dl4 := DisplayList new.	dl5 := DisplayList new.	dl6 := DisplayList new.	rand := Random new.	10 timesRepeat:		[ | pt |		pt := (rand next * size) rounded @ ((rand next * size) rounded).		dl1 add: ((DisplayString string: (pt printString) 				offset: pt) color: (ColorValue random: rand))].	10 timesRepeat:		[ | x y w h |		x := (rand next * size) rounded.		y := (rand next * size) rounded.		w := (rand next * size) rounded.		h :=  (rand next * size) rounded.		dl2 add: ((DisplayRectangle offset: (x@y) extent: (w@h))				color: (ColorValue random: rand); fill: true)].	10 timesRepeat:		[ | x y w h |		x := (rand next * size) rounded.		y := (rand next * size) rounded.		w := (rand next * size) rounded.		h :=  (rand next * size) rounded.		dl3 add: ((DisplayRectangle offset: (x@y) extent: (w@h))				color: (ColorValue random: rand); fill: true)].	10 timesRepeat:		[ | pt |		pt := (rand next * size) rounded @ ((rand next * size) rounded).		dl4 add: ((DisplayString string: (pt printString) 				offset: pt) color: (ColorValue random: rand))].	dl1 computePreferredBounds.	dl2 computePreferredBounds.	dl3 computePreferredBounds.	dl4 computePreferredBounds.	dl5 add: dl1;		add: dl2 at: (250@0);		add: dl3 at: (0@250); 		add: dl4 at: (250@250).	dl5 computePreferredBounds.	dl6 add: dl5 at: (50@50).	dl6 computePreferredBounds.	^dl6!gridExample	"Create and answer a large display list with lines and strings."	"DisplayList gridExample display"	"DisplayListView example"	| dList rand ext step |	ext := 2000.	step := 50.	dList := DisplayList new.	0 to: (ext/step) do:		[ :i |		dList add: ((DisplayLine offset: (i*step)@0 extent: 0@ext) color: ColorValue random).		dList add: ((DisplayLine offset: 0@(i*step) extent: ext@0) color: ColorValue random)].	rand := Random new.	1 to: 200 do:		[ :i | | pt |		pt := (rand next * ext) rounded @ ((rand next * ext) rounded).		dList add: ((DisplayString string: (pt printString) offset: pt)color: ColorValue random)].	^dList!gridExampleX: x byY: y	"Create and answer a large display list with lines and strings."	"(DisplayList gridExampleX: 3000 byY: 500) display"	"DisplayListView example"	| dList rand step |	step := 50.	dList := DisplayList new.	0 to: (x/step) do:		[ :i |		dList add: (DisplayLine offset: (i*step)@0 extent: 0@y)].	0 to: (y/step) do:		[ :i |		dList add: (DisplayLine offset: 0@(i*step) extent: x@0)].	rand := Random new.	1 to: (x * y / 20000) do:		[ :i | | pt |		pt := (rand next * x) rounded @ ((rand next * y) rounded).		dList add: (DisplayString string: (pt printString) offset: pt)].	^dList!polylineExample	"Answer a display list with randomly-placed random-color polylines over the given extent."	"DisplayList polylineExample"	(DisplayList polylinesX: 600 byY: 600 items: 100) display!polylineExampleHuge	"Answer a display list with randomly-placed random-color polylines over the given (very large) extent."	"DisplayList polylineExampleHuge"	(DisplayList polylinesX: 6000 byY: 6000 items: 10000) display!polylinesX: x byY: y	"Answer a display list with randomly-placed random-color polylines over the given extent."	"(DisplayList polylinesX: 600 byY: 600) display"	| dList rand inset scale x0 y0 size pointArray |	inset := 16.	scale := 128.	dList := DisplayList new.	rand := Random new.	x0 := rand nextIntFrom: inset to: x-inset.	y0 := rand nextIntFrom: inset to: y-inset.	((x/20) + (y/20)) timesRepeat:		[size := rand nextIntFrom: 3 to: 7.		pointArray := Array new: size.		pointArray at: 1 put: (0@0).		pointArray at: size put: (0@0).		x0 := y0 := 0.		2 to: size-1 do: [ :i |			x0 := x0 + (rand nextIntFrom: scale negated to: scale).			y0 := y0 + (rand nextIntFrom: scale negated to: scale).			pointArray at: i put: (x0 @ y0)].		dList add: ((DisplayPolyline				offset: ((rand nextIntFrom: inset to: x-inset)						@(rand nextIntFrom: inset to: y-inset)))				color: ColorValue random;				vertices: pointArray)].	^dList!polylinesX: x byY: y items: num	"Answer a display list with randomly-placed random-color polylines over the given extent."	"(DisplayList polylinesX: 600 byY: 600 items: 1000) display"	| dList rand inset scale x0 y0 size pointArray |	inset := 16.	scale := 128.	dList := DisplayList new.	rand := Random new.	x0 := rand nextIntFrom: inset to: x-inset.	y0 := rand nextIntFrom: inset to: y-inset.	num timesRepeat:		[size := rand nextIntFrom: 3 to: 7.		pointArray := Array new: size.		pointArray at: 1 put: (0@0).		pointArray at: size put: (0@0).		x0 := y0 := 0.		2 to: size-1 do: [ :i |			x0 := x0 + (rand nextIntFrom: scale negated to: scale).			y0 := y0 + (rand nextIntFrom: scale negated to: scale).			pointArray at: i put: (x0 @ y0)].		dList add: ((DisplayPolyline				offset: ((rand nextIntFrom: inset to: x-inset)						@(rand nextIntFrom: inset to: y-inset)))				color: ColorValue random;				vertices: pointArray)].	^dList!postScriptExample	"Create and answer a large display list with a lines, strings, and visuals."	"DisplayList postScriptExample"	"NOT WORKING"	| dList psRenderer file |	dList := (DisplayList stringsX: 600 byY: 900) "DisplayList example2".	file := 'temp.ps' asFilename writeStream.	psRenderer := PostScriptPrinter new.	psRenderer file: file; start: nil."	psRenderer scale: 10@10."	dList displayPostScriptOn: psRenderer.	psRenderer endNoPrint: nil. 		"this prints it.""	'temp.ps' asFilename edit."!randomExample	"Create and answer a large display list with a lines, strings, and visuals."	"DisplayList randomExample display"	| dList rand ext num |	ext := 3000.	dList := DisplayList new.	rand := Random new.	num := 500.	num timesRepeat:		[ | x y w h |					"add rectangles"		x := (rand next * ext) rounded.		y := (rand next * ext) rounded.		w := (rand next * ext/30) rounded.		h :=  (rand next * ext/30) rounded.		dList add: ((DisplayRectangle				offset: (x@y)				extent: (w@h))				color: ColorValue random; fill: true)].	num timesRepeat:		[ | pt1 pt2 |					"add lines"		pt1 := (rand next * ext) rounded @ ((rand next * ext) rounded).		pt2 := (rand next * ext) rounded @ ((rand next * ext) rounded).		dList add: ((DisplayLine offset: pt2 extent: (pt1 - pt2))				color: ColorValue random)].	num timesRepeat:		[ | pt |						"add strings"		pt := (rand next * ext) rounded @ ((rand next * ext) rounded).		dList add: ((DisplayString string: (pt printString) 				offset: pt) color: ColorValue random)].	num timesRepeat:		[ | pt coll |					"add visuals"		coll := Cursor allInstances.		pt := (rand next * ext) rounded @ ((rand next * ext) rounded).		dList add: ((DisplayVisual visual: (coll atRandom asOpaqueImage figure) 				offset: pt) color: ColorValue random)].	^dList!rectangleExample	"Answer a display list with randomly-placed random-color rectangles over the given extent."	"DisplayList rectangleExample"	(DisplayList rectanglesX: 2000 byY: 2000) display!rectanglesX: x byY: y	"Answer a display list with randomly-placed random-color rectangles over the given extent."	"(DisplayList rectanglesX: 600 byY: 600) display"	| dList rand x0 y0 x1 y1 scale w h |	dList := DisplayList new.	rand := Random new.	scale := 0.	x0 := x - (scale * 2).	y0 := y - (scale * 2).	((x/10) + (y/10)) timesRepeat:		[x1 := scale + (rand next * x0) rounded.		y1 := scale + (rand next * y0) rounded.		w := ((rand next * 0.5 * (x / 20) abs) rounded).		h :=  ((rand next * 0.5 * (y / 20) abs) rounded).		dList add: ((DisplayRectangle				offset: (x1@y1)				extent: (w@h))				color: ColorValue random; fill: true)].	^dList!stringExample	"Open a display list view with randomly-placed random-color strings over the given extent."	"DisplayList stringExample"	(DisplayList stringsX: 4000 byY: 4000) display!stringsX: x byY: y	"Answer a display list with randomly-placed random-color strings over the given extent."	"(DisplayList stringsX: 600 byY: 600) display"	| dList rand inset |	inset := 16.	dList := DisplayList new.	rand := Random new.	((x/5) + (y/5)) timesRepeat:		[ | pos |		pos := (rand nextIntFrom: inset to: x - inset) @ (rand nextIntFrom: inset to: y - inset).		dList add: ((DisplayString				string: pos printString				offset: pos)				color: ColorValue random)].	^dList!visualsX: x byY: y	"Answer a display list with randomly-placed random-color visuals over the given extent."	"(DisplayList visualsX: 600 byY: 600) display"	| dList rand inset |	inset := 16.	dList := DisplayList new.	rand := Random new.	((x/10) + (y/10)) timesRepeat:		[dList add: ((DisplayVisual				visual: (rand nextIntFrom: 10 to: 100000) printString asParagraph				offset: ((rand nextIntFrom: inset to: x-inset)						@(rand nextIntFrom: inset to: y-inset)))				color: ColorValue random)].	^dList! !!Siren.CsoundVoice methodsFor: 'events'!writeFooter	stream cr; nextPutAll: 'end'; cr; cr.	^self!writeHeader	stream nextPutAll: ';; csound score file created ', Date today printString; cr.	stream cr; nextPutAll: 'f1 0 1024 10 1'; cr.	stream cr.	^self! !!Siren.CsoundVoice class methodsFor: 'examples'!randomExampleToFileAndEdit	"CsoundVoice randomExampleToFileAndEdit"	self randomExampleToFileNamed: 'rand.sco'.	^self!randomExampleToFileNamed: fnam 	"Create a random event list and store it on a file."	"CsoundVoice randomExampleToFileAndEdit"	| evt strm list rand vox |	strm := (Filename named: fnam) writeStream.	rand := Random new."Create the event list and add a few additional properties"	(list := EventList randomExample: 64)		do: [ :ass | 			(evt := ass event) at: #pos put: rand next.			evt at: #prop1 put: (rand nextFrom: 320 to: 480).			evt at: #prop2 put: (rand nextIntFrom: 12000 to: 23000)]."Create a csounc voice and customize its parameter map."	(vox := CsoundVoice newNamed: '1' onStream: strm) addMap: #pos.	vox addMap: [ :item | ((item at: #prop1) / 1000) printString: 4].	vox addMap: #prop2."Play the list on the voice."	vox play: list.	strm close.	(Filename named: fnam) edit.	^self! !!Siren.CsoundVoice class methodsFor: 'instance creation'!defaultPMap	| map |	(map := OrderedCollection new: 8) add: [:t2 | 'i' , (t2 voice == nil				ifTrue: [1]				ifFalse: [t2 voice]) printString].	map add: #start.	map add: [ :t3 | t3 duration asSec value asFloat printString: 4].	map add: [ :t4 | t4 loudness asDB positiveDB printString: 4].	^map! !!Siren.PseudoMinorScale class methodsFor: 'interval list'!intervalList	^#(#unison #second #minorThird #perfectFourth #perfectFifth #majorSixth #majorSeventh )! !!Siren.DynamicCloud methodsFor: 'playing'!eventList	"make the cloud's events--assume that the receiver's pitch, loudness and durations are actually ARRAYS of two intervals (for the start and end ranges)"	| pattern rand number length start percent pRange p1 p2 p3 p4 		amplRange a1 a2 a3 a4 v1 v2 v3 v4 vRange |	pattern := EventList new.	rand := Random new.	number := duration asSeconds value asFloat * density.	length := (1000 / density) rounded.	start := 0.	(self pitch value isMemberOf: Array)		ifTrue: [pRange := self pitch value first.			p1 := self pitch value first first.			p2 := self pitch value first last.			p3 := self pitch value last first - p1.			p4 := self pitch value last last - p2]		ifFalse: [pRange := self pitch value].	(self loudness value isMemberOf: Array)		ifTrue: [amplRange := self loudness value first.			a1 := self loudness value first first.			a2 := self loudness value first last.			a3 := self loudness value last first - a1.			a4 := self loudness value last last - a2]		ifFalse: [amplRange := self loudness value].	(self voice isMemberOf: Array)		ifTrue: [vRange := self voice first.			v1 := self voice first first.			v2 := self voice first last.			v3 := self voice last first - v1.			v4 := self voice last last - v2]		ifFalse: [vRange := self voice].	1 to: number truncated do:		[ :count |		pattern add: (MusicEvent 			dur: (length * 2 + (length * rand next) rounded)			pitch: ((pRange first rounded) + 					((rand next * (pRange last - pRange first)) rounded))			ampl: ((amplRange first rounded) + 					((rand next * (amplRange last - amplRange first)) rounded))			voice: (self voice == nil 						ifTrue: [nil] 						ifFalse: [(vRange first rounded) + 					((rand next * (vRange last - vRange first)) rounded)]))			at: start.		start := start + length.	percent := count / number.	(self pitch value isMemberOf: Array)		ifTrue: [pRange := p1 + (p3 * percent) to: p2 + (p4 * percent)].	(self loudness value isMemberOf: Array)		ifTrue: [amplRange := a1 + (a3 * percent) to: a2 + (a4 * percent)].	(self voice isMemberOf: Array)		ifTrue: [vRange := v1 + (v3 * percent) to: v2 + (v4 * percent)]].	^pattern! !!Siren.DynamicCloud class methodsFor: 'examples'!crescendoExample	"Create and play an 8-second cloud that goes from soft to loud on the same pitch."	"DynamicCloud crescendoExample"	(DynamicCloud  dur: 6  		pitch: (40 to: 40)		ampl: #((20 to: 30) (80 to: 100))		voice: (1 to: 1)		density: 20) eventList 	"edit" 	play.  MIDIPort allNotesOffIn: 8	"inspect"!example1	"Edit a 6-second cloud that goes from low to high and soft to loud."	"DynamicCloud example1"	(DynamicCloud  dur: 6  		pitch: #((30 to: 44) (50 to: 50))		ampl: #((20 to: 40) (90 to: 120))		voice: (1 to: 4)		density: 20) eventList "edit" play "inspect"!example4	"Edit a 6 second cloud that focuses on its center"	"DynamicCloud example4"	(DynamicCloud  dur: 6  		pitch: #((30 to: 64) (40 to: 40))		ampl: #((20 to: 40) (90 to: 120))		voice: (1 to: 8)		density: 10) eventList edit!focusExample	"Create a 6-second cloud that focuses on its center."	"DynamicCloud focusExample"	(DynamicCloud  dur: 6  		pitch: #((60 to: 84) (68 to: 68))		ampl: #((20 to: 20) (90 to: 100))		voice: (1 to: 8)		density: 10) eventList edit "play" "inspect"!randomExample	"Create a dynamic second cloud with random properties."	"DynamicCloud randomExample edit"	| rand |	rand := Random new.	^DynamicCloud  dur: (rand nextIntFrom: 3 to: 8)  		pitch: (Array with: ((rand nextIntFrom: 24 to: 48) 					to: (rand nextIntFrom: 24 to: 54))				with: ((rand nextIntFrom: 48 to: 60)					to: (rand nextIntFrom: 60 to: 72)))		ampl: (Array with: ((rand nextIntFrom: 24 to: 36)					to: (rand nextIntFrom: 36 to: 48))				with: ((rand nextIntFrom: 72 to: 88)					to: (rand nextIntFrom: 80 to: 112)))		voice: (1 to: 4)		density: (rand nextIntFrom: 4 to: 16)! !!Siren.MelodicMinorScale methodsFor: 'Paleo'!costForPitch: n	(notes includes: n) ifTrue: [ ^ 0].	root majorSeventh = n ifTrue: [^ 0].	root majorSixth = n ifTrue: [^ 0].	(self allNotes includes: n) ifTrue: [^ 1].	^ 2!enharmonicScale	root = N C sharp ifTrue: [^ N D flat melodicMinorScale].	root = N D sharp ifTrue: [^ N E flat melodicMinorScale].	root = N F sharp ifTrue: [^ N G flat melodicMinorScale].	root = N G sharp ifTrue: [^ N A flat melodicMinorScale].	root = N A sharp ifTrue: [^ N B flat melodicMinorScale].	root = N D flat ifTrue: [^ N C sharp melodicMinorScale].	root = N E flat ifTrue: [^ N D sharp melodicMinorScale].	root = N G flat ifTrue: [^ N F sharp melodicMinorScale].	root = N A flat ifTrue: [^ N G sharp melodicMinorScale].	root = N B flat ifTrue: [^ N A sharp melodicMinorScale].	^ nil! !!Siren.MelodicMinorScale class methodsFor: 'interval list'!allIntervals	^#(#unison #diminishedSecond #second #minorThird #majorThird #perfectFourth augmentedFourth #perfectFifth #minorSixth #majorSixth #minorSeventh #majorSeventh )!intervalList	^#(#unison #second #minorThird #perfectFourth #perfectFifth #majorSixth #majorSeventh )! !!Siren.IndentedTreeLayoutManager methodsFor: 'generating'!addItem: aModelNode atNode: aPath under: parentPoint in: aDisplayList	"Add the given item to the display list."	|  displayPoint item path2 displayList2 |	displayPoint := (self displayPositionFor: aPath) + (parentPoint x@0).	length := length + 1.	item := treeAccessor itemFor: aModelNode.	item offset: displayPoint.	(treeAccessor isTerminal: aModelNode)		ifFalse: [displayList2 := DisplayList new.			displayList2 model: aModelNode.			(treeAccessor childrenOf: aModelNode) do: [ :i | 				path2 := aPath copy.				path2 addLast: aModelNode.				self addItem: i					atNode: path2					under: item bounds rightCenter					in: displayList2].			displayList2 add: item.			aDisplayList add: displayList2 atPath: aPath.			parentPoint = (0@0)				ifFalse: [aDisplayList add:						((DisplayLine new)							offset: item bounds leftCenter + (-2@4);							corner: parentPoint + (2@4); color: ColorValue black)					atPath: aPath]]				ifTrue: [aDisplayList add: item atPath: aPath.					aDisplayList add:							((DisplayLine new)								offset: item bounds leftCenter + (-2@4);								corner: parentPoint + (2@4); color: ColorValue black)						atPath: aPath]!generateDisplayList	"Generate and answer the receiver's display list."	list := DisplayList new.	self addItem: treeAccessor subject			atNode: (OrderedCollection new)			under: 0@0			in: list.	^list! !!Siren.IndentedTreeLayoutManager class methodsFor: 'examples'!listExample	"IndentedTreeLayoutManager listExample display"	"DisplayListView classTreeExample"	| acc me |	acc := STreeAccessor subject: "View" Magnitude			terminalQuery: [ :c | c subclasses size = 0]			childAccessor: #sortedSubclasses			itemGenerator: [ :c | (DisplayString new)							model: c; 							string: c name; 							color: ColorValue black].	me := (self new) accessor: acc; xStep: 4; yStep: 12.	^me displayList! !!Siren.MusicalDescendingInterval methodsFor: 'computing notes'!bottomIfTopIs: aNote 	"yields the note for which I am the interval self"self halt.	^super topIfBottomIs: aNote!topIfBottomIs: aNote 	"yields the note for which I am the interval self"	^super bottomIfTopIs: aNote! !!Siren.MusicalDescendingInterval methodsFor: 'testing'!isAscending	^false!isDescending	^true! !!Siren.MusicalDescendingInterval methodsFor: 'mutations'!ascending	^MusicalInterval type: type semiTones: semiTones!descending	^self! !!Siren.MusicalDescendingInterval class methodsFor: 'examples'!example"(N C octave: 3) intervalBetween: (N D octave: 2) descending Minor seventh(N B flat octave: 3) intervalBetween: (N B flat flat octave: 2) descending augmented octave"! !!Siren.MIDIVoice methodsFor: 'events'!play: anEventList	"Expand the list and play it now."	anEventList voice: self.	^anEventList play!playEvent: anEvent at: aTime	"Send the given Event to the instrument."	^aTime isNil		ifTrue: [instrument play: anEvent at: Time microsecondClock]		ifFalse: [instrument play: anEvent at: aTime usec value]! !!Siren.MIDIVoice methodsFor: 'accessing'!number	"Answer my channel or icon number"	| n |	n := Number readFrom: (ReadStream on: (name)).	n = 0 ifTrue: [^self channel].	^n! !!Siren.MIDIVoice methodsFor: 'initialize-release'!close	"Close the stream, device, or whatever."	instrument close!initialize	"Set up a MIDIVoice's time counter."	super initialize.	currentTime := nil!reset	"Reset my time."		currentTime := nil! !!Siren.MIDIVoice class methodsFor: 'examples'!randomExample	"Play some random notes on a voice on a device on a port."	"MIDIVoice randomExample"	| events voice |	events := (EventList randomExample: 80 		from: ((#duration: -> (20 to: 80)), (#pitch: -> (48 to: 80)),				(#ampl: -> (84 to: 124)))).	voice := MIDIVoice default.	events playOn: voice!scaleExample	"Play a scale on a voice on a device on a port to the Apple MIDI Mgr."	"MIDIVoice scaleExample"	"MIDIPort allNotesOff"	| voice device port scale |	port := MIDIPort default.	port open.	device := MIDIDevice on: port.	voice := MIDIVoice on: device.	scale := EventList scaleFrom: 24 to: 100 in: 4.0."	scale eventsDo: [ :e | e duration: (e duration * 3)]."	voice play: scale!voiceInspect	"MIDIVoice voiceInspect"	(MIDIVoice on: (MIDIDevice on: (MIDIPort default))) inspect! !!Siren.MIDIVoice class methodsFor: 'class initialization'!defaultOutInterface	"Answer the class's default interface # (use external device list to get the right value)."	"MIDIVoice defaultOutInterface"	^SirenUtility defaultMIDIOut!flushDefault	"Reset the class's default instance."	"MIDIVoice flushDefault"	singleton := nil!initialize	"Reset the class's default instance."	"MIDIVoice initialize"	singleton := nil.	useSingleton := false.! !!Siren.MIDIVoice class methodsFor: 'instance creation'!default	"Answer the default MIDIVoice."	"MIDIVoice default"	useSingleton		ifTrue: [singleton ifNil: [singleton := MIDIVoice on: (MIDIDevice on: MIDIPort default)].			^singleton]		ifFalse: [^MIDIVoice on: (MIDIDevice on: MIDIPort default)]!named: aName onDevice: aMidiDevice channel: aChannel	"set up a MidiVoice on the given device and channel"	"MIDIVoice named: 'xxx' onDevice: (MIDIDevice on: 1) channel: 1"	| me |	me := self new initializeNamed: aName.	me instrument add: (aChannel -> aMidiDevice).	^me!new	"Cache the latest instance."	^self default!on: aMidiDevice	"Answer up a MidiVoice on the given device."	"MIDIVoice on: (MIDIDevice on: (MIDIPort default openOutput))"	| me |	me := self basicNew initialize.	me instrument: aMidiDevice.	^me!on: aMidiDevice channel: aChannel	"set up a MidiVoice on the given device and channel"	"MidiVoice onDevice: (MidiFB01 newOn: 1) channel: 1"	| me |	me := self new initializeNamed: aChannel.	me instrument add: (aChannel -> aMidiDevice).	^me! !!Siren.EventListFileViewer methodsFor: 'actions'!editFile	"Edit the selected sound file"	| score |	score := EventList fromFile: self selectedFilename asString.	score ifNotNil: [^score edit].	Dialog warn: 'Cannot read score from file'!loadFile	"Load the selected file into the SirenSession"	| nam |	nam := self selectedFilename asString.	SirenSession eventList: nam put: (EventList fromFile: nam)!playFile	"Play the selected sound file"	(EventList fromFile: self selectedFilename asString) play! !!Siren.EventListFileViewer methodsFor: 'accessing'!printBlurbFor: aFilename on: stream	self		print: (#Path << #labels >> 'Path') value: [aFilename asString] on: stream;		print: (#Size << #labels >> 'Size') value: [aFilename fileSize printString] on: stream;		print: (#LastModified << #labels >> 'Last modified') 				value: [self timestampStringAt: #modified in: aFilename dates] on: stream! !!Siren.EventListFileViewer class methodsFor: 'accessing'!isInterestedInFile: aFilename	('*.ev' match: aFilename tail) ifTrue: [^true].	('*.sm' match: aFilename tail) ifTrue: [^true].	('*.mid' match: aFilename tail) ifTrue: [^true].	('*.midi' match: aFilename tail) ifTrue: [^true].	^false!tabLabel	^(#FileInformation << #labels >> 'Score File') asString! !!Siren.DisplayVisual methodsFor: 'accessing'!bounds	"Answer the visual's bounds translated by the receiver's translation."	^offset == nil		ifTrue: [visual bounds]		ifFalse: [visual bounds translatedBy: offset]!visual	"Answer the receiver's visual."	^visual!visual: aVisual	"Set the receiver's visual."	visual := aVisual."	aVisual palette == nil		ifTrue: [aVisual palette: MappedPalette colorDefault]"! !!Siren.DisplayVisual methodsFor: 'printing'!printOn: aStream	"Print the receiver in the given Stream."	aStream nextPutAll: '(a ', self class name. 	model == nil ifFalse: [aStream nextPutAll: ' model: '. model printOn: aStream].	visual == nil ifFalse: [aStream nextPutAll: ' visual: '. visual printOn: aStream].	offset == nil ifFalse: [aStream nextPutAll: ' offset: '. offset printOn: aStream].	aStream nextPut: $); cr.!storeOn: aStream	"Print the receiver in the given Stream."	aStream nextPutAll: '('; store: self class. 	visual == nil ifFalse: [aStream nextPutAll: ' visual: '. visual storeOn: aStream].	offset == nil ifFalse: [aStream nextPutAll: ' offset: '. offset printOn: aStream].	aStream nextPut: $)! !!Siren.DisplayVisual methodsFor: 'displaying'!displayOn: aGraphicsContext	"Display the receiver's visual on the given graphics context."	color == nil		ifFalse: [aGraphicsContext paint: color].	aGraphicsContext translateBy: offset.	visual displayOn: aGraphicsContext.	aGraphicsContext translateBy: offset negated.!displayPostScriptOn: aPostscriptContext	"Display the receiver on the argument as a PostScript item."	aPostscriptContext translate: offset.	aPostscriptContext imageWidth: visual width 			height: visual height 			bits: visual bits.	aPostscriptContext translate: offset negated! !!Siren.DisplayVisual class methodsFor: 'instance creation'!model: aM visual: aV offset: aPt	"Answer an instance of DisplayItem with the given instance variables."	^self new model: aM; visual: aV; offset: aPt!visual: aV	"Answer an instance of DisplayItem with the given instance variables."	^(super new initialize) visual: aV!visual: aV offset: aPt	"Answer an instance of DisplayItem with the given instance variables."	^(super new initialize) visual: aV; offset: aPt!visual: aV origin: aPt	"Answer an instance of DisplayItem with the given instance variables."	^(super new initialize) visual: aV; offset: aPt! !!Siren.DisplayVisual class methodsFor: 'examples'!convertMusicConstants	"Convert all the forms to opaque forms"	"DisplayVisual convertMusicConstants. DisplayVisual displayMusicConstants"	| all |	all := DisplayListView constants.	all keysAndValuesDo: [ :key :group |		Transcript show: key printString; cr.		(group isMemberOf: Dictionary)			ifTrue: [group keysAndValuesDo:				[ :str :item | | newI |				(item isKindOf: DisplayVisual)					ifTrue: [newI := item.						item visual: (OpaqueImage figure: item visual 							shape: (item visual convertToCoverageWithOpaquePixel: 1))]					ifFalse: [(item isMemberOf: Depth1Image)							ifTrue: [newI := OpaqueImage figure: item 												shape: (item convertToCoverageWithOpaquePixel: 1)]].				group at: str put: newI]].		((group isMemberOf: Array) or: [(group isMemberOf: OrderedCollection)])			ifTrue: [group do:					[ :item |					(item isMemberOf: OpaqueImage)						ifFalse: [item visual: (OpaqueImage figure: item visual 								shape: (item visual convertToCoverageWithOpaquePixel: 1))]]]]!displayMusicConstants	"Draw a nice table of the hierarchical image dictionary."	"DisplayVisual displayMusicConstants"	| win xstep y i ystep comp |	win := ScheduledWindow model: nil label: 'MusicConstants' 			minimumSize: 700@750.	comp := CompositePart new.	xstep := 64.	ystep := 48.	y := 0.	DisplayListView constants keysAndValuesDo: [ :title :dict |		i := 0.		comp add: (DisplayString string: title) at: (xstep@y).		y := y + (ystep/2).		dict keysAndValuesDo:			[ :str :item |			comp add: (DisplayString string: (str respondsToArithmetic 					ifTrue: [str printString] ifFalse: [str "clipTo: 6"]))			 at: ((i*xstep+8)@y).			comp add: item at: ((i*xstep+8)@(y+(ystep/2))).			i := i + 1.			i = 14 ifTrue: [i := 0. y := y + (ystep * 1.5)]].		y := y + ystep + 24].	win component: (BoundedWrapper on: comp).	win open!storeMusicConstants	"Write out all the forms to opaque forms"	"DisplayVisual storeMusicConstants"	| fil all |	fil := 'MusicConstants.st' asFilename writeStream.	all := DisplayListView constants.	all keysAndValuesDo: [ :key :group |		Transcript show: key printString; cr.		(group isMemberOf: Dictionary)			ifTrue: [fil cr; nextPutAll: 'Siren.DisplayListView constants at: ', key printString,						 ' put: IdentityDictionary new.'; cr.					group keysAndValuesDo:					[ :str :item | 					fil cr; nextPutAll: '(Siren.DisplayListView constants at: ', key printString, 						') at: ''', str, ''' asSymbol put: '.					item storeOn: fil.					fil nextPut: $!! ]].		((group isMemberOf: Array) or: [(group isMemberOf: OrderedCollection)])			ifTrue: [fil cr; nextPutAll: 'Siren.DisplayListView constants at: ', key printString,						 ' put: OrderedCollection new.'; cr.				group do:					[ :item |					fil cr; nextPutAll: '(Siren.DisplayListView constants at: ', key printString, ') add: '.					item storeOn: fil.					fil nextPut: $!! ]]].	fil close!visualExample	"Open a display list view with randomly-placed random-color visuals over the given extent."	"DisplayVisual visualExample"	(DisplayList visualsX: 600 byY: 600) display! !!Siren.GapSound methodsFor: 'accessing'!allocateData	"no-op"	^self!cutFrom: startSample to: stopSample	"Cut the designated section from the receiver."	| realStart realStop |	realStart := self mapSampleIndex: startSample.	realStop := self mapSampleIndex: stopSample.	cutList == nil		ifTrue: [cutList := SortedCollection new].	cutList add: realStart.	cutList add: realStop.	self size: (self size - (stopSample - startSample)).	^self!samples	^source samples! !!Siren.GapSound methodsFor: 'testing'!hasGaps	"Answer whether the receiver has any gaps."	^true! !!Siren.GapSound methodsFor: 'private'!mapSampleIndex: index	"Map the given sample index according to the cut list (i.e., deleted sections) of the receiver."	| mappedIndex |	((cutList == nil) or: [cutList size < 2])		ifTrue: [^index - firstIndex].	mappedIndex := index.	mappedIndex < cutList first		ifTrue: [^mappedIndex].	1 to: cutList size by: 2 do:		[ :cutIndex |		mappedIndex := mappedIndex - 				((cutList at: cutIndex) - (cutList at: cutIndex + 1)).		(((cutIndex + 1) = cutList size) or: 				[mappedIndex < (cutList at: cutIndex + 2)])			ifTrue: [^mappedIndex]].		^mappedIndex - firstIndex.! !!Siren.GapSound class methodsFor: 'instance creation'!on: source cutFrom: start to: stop	"Answer a CompositeSound derived from the argument missing the given range."	"GapSound exampleView"	| me |	me := self new initialize.	me source: source.	me samplesInMemory: source samplesInMemory.	me data: source data.	me cutFrom: start to: stop.	^me! !!Siren.GapSound class methodsFor: 'examples'!exampleView	"Open a sound view on a ramp with a chunk cut out of it."	"GapSound exampleView"	SoundView openOn: ((SampledSound rampDur: 1.0 rate: 16000 chans: 1) 			cutFrom: 1000 to: 10000)! !!Siren.RatioPitch methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a ratio."	aStream nextPutAll: "'p:'," value printString! !!Siren.RatioPitch methodsFor: 'converting'!asFracMIDI	"return a RatioPitch as a fractional MIDINote."	^self asHertz asFracMIDI.!asFracSymbol	"Assuming value is a ratio, answer a symbolic note name"	^SymbolicPitch fromFracMIDI: (self asFracMIDI)!asHertz	"Answer a HertzPitch."	^relative == nil		ifTrue: [HertzPitch new value: (value * 261.623)]		ifFalse: [HertzPitch new value:					(value * (relative asHertz value))]!asMIDI	"return a RatioPitch as a MIDINote (rounded)."	^self asHertz asMIDI.!asSymbol	"Assuming value is a ratio, answer a symbolic note name"	^SymbolicPitch fromMIDI: (self asMIDI)!mostGeneral	"Answer the most numerically meaningful version of the receiver."	^self asHertz! !!Siren.RatioPitch methodsFor: 'private'!species	"Answer Pitch."	^Pitch! !!Siren.RatioPitch class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asStep! !!Siren.DataSetTool methodsFor: 'actions'!inspect	self tree selection ifNotNil: [self tree selection inspect]! !!Siren.DataSetTool methodsFor: 'interface opening'!childrenFor: aNode	"tracks"		aNode isEmpty ifTrue: [^#()].	aNode tracks ifNil: [^#()].	^aNode tracks isSequenceable		ifTrue: [aNode tracks]		ifFalse: [aNode tracks values asSortedCollection]!postOpenWith: aBuilder	super postOpenWith: aBuilder.	self tree list:		(TreeModel 			on: Siren.DataSet defaultDataSet "tags" root			displayRoot: false			childrenWith: [ :node | self childrenFor: node]).	self tree selectionIndexHolder		onChangeSend: #nodeSelected to: self"self halt."! !!Siren.DataSetTool methodsFor: 'notifications'!nodeSelected	self tree selectionIndexHolder ifNil: [^self].	self tree selection ifNil: [^self]."	self tree selection inspect.""	self tree selection open"! !!Siren.DataSetTool methodsFor: 'aspects'!childrenOf: anXMLNodeself halt.	^[anXMLNode children reject: [:some | some isText]]		on: Error		do: [:ex | ex return: #()]!tree	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tree isNil		ifTrue:			[tree := MultiSelectionInTree new]		ifFalse:			[tree]! !!Siren.TagSetTool methodsFor: 'aspects'!childrenOf: aNode	^aNode children! !!Siren.TagSetTool methodsFor: 'notifications'!nodeSelected	self tree selectionIndexHolder ifNil: [^self].	self tree selection ifNil: [^self]."	self tree selection inspect.""	self tree selection open"! !!Siren.TagSetTool methodsFor: 'interface opening'!childrenFor: aNode	"children"	^aNode isCollection		ifTrue: [aNode values]		ifFalse: [aNode children values]!postOpenWith: aBuilder	super postOpenWith: aBuilder.	self tree list:		(TreeModel 			on: Siren.DataSet defaultDataSet tags			displayRoot: false			childrenWith: [ :node | self childrenFor: node]).	self tree selectionIndexHolder		onChangeSend: #nodeSelected to: self"self halt."! !!Siren.OSCBundle methodsFor: 'initialize-release'!init: aCollection 	self init: aCollection time: Timestamp now!init: aCollection time: aTime 	"Initialize the receiver."	messages := aCollection.	time := aTime.	self init! !!Siren.OSCBundle methodsFor: 'osc'!timeTagToOSCBytes: aConvertor 	"Store a time thingy into the given convertor"	time isNil 		ifTrue: 			[8 timesRepeat: [aConvertor nextPut: 0].			^self].	(self class asSecondsSince1900: time) toOSCBytes: aConvertor.	(self class asNTPMilliseconds: time) toOSCBytes: aConvertor!toOSCBytes: aConvertor 	"^self"	'#bundle' toOSCBytes: aConvertor.	self timeTagToOSCBytes: aConvertor.	messages		do: 			[:aMessage | 			aMessage oscSize toOSCBytes: aConvertor.			aConvertor nextPutAll: aMessage oscBytes]! !!Siren.OSCBundle class methodsFor: 'examples'!example1	"Simple example"	^self 		with: (Array with: OSCMessage scRun with: OSCMessage scIncreaseVolume)!example2	^self with: (Array with: self example1 with: OSCMessage scDecreaseVolume)! !!Siren.OSCBundle class methodsFor: 'class initialization'!initialize	"Initialize the values of the shared variables."	"OSCBundle initialize"	MillisecScale = 4295000.	MillisecToNTP:= ((2 raisedTo: 32) / 1000).	SecsInAYear:= 60 * 60 * 24 * 365! !!Siren.OSCBundle class methodsFor: 'support'!asNTPMilliseconds: aTimestamp 	"Convert aTimestamp to the OSC representation of the same"	| msec |	msec := aTimestamp millisecond * MillisecToNTP. "((2 raisedTo: 32) / 1000)"	^msec asInteger!asSecondsSince1900: aTimestamp 	"Convert aTimestamp to seconds since 1900"	| sec |	"Gets us the number of seconds since Jan 1. 1901"	sec := aTimestamp asSeconds.	"sec := sec + SecsInAYear."	"Convert that to be GMT-based"	sec := TimeZone default convertLocalSecondsToGMT: sec.	"Add one year worth of seconds"	^sec + SecsInAYear. "(60 * 60 * 24 * 365)"!timestampToOSC: aTimestamp 	"Convert aTimestamp to the OSC representation of the same"	| sec msec |	sec := self asSecondsSince1900: aTimestamp.	msec := self asNTPMilliseconds: aTimestamp.	^(sec bitShift: 32) bitOr: msec! !!Siren.OSCBundle class methodsFor: 'instance creation'!with: aCollection	^self with: aCollection at: Timestamp now!with: aCollection at: aTimestamp	^self new init: aCollection time: aTimestamp! !!Siren.SirenSession methodsFor: 'accessing'!objectFor: identifier	"Find the object that corresponds to the given ID"	| obj |	identifier ifNil: [^nil].	(loadedSounds includes: identifier)		ifTrue: [^SirenSession soundNamed: identifier].	(loadedLists includes: identifier)		ifTrue: [^SirenSession eventListNamed: identifier].	obj := EventScheduler timers itemNamed: identifier.	obj ifNotNil: [^obj].	obj := EventScheduler clients itemNamed: identifier.	obj ifNotNil: [^obj].	^nil!selectedObject	"Select an item in the list"	| it obj |	it := self selectedObjectName.	it ifNil: [^nil].	obj := self objectFor: it.	obj ifNotNil: [^obj].	^nil!selectedObjectName	"Select an item in the list"	| si it |	si := scheduleListText selectionIndexHolder value.	si = 0 ifTrue: [^nil].	it := scheduleList list at: si.	it ifNil: [^nil].	^it!transport	"it's me"	^self! !!Siren.SirenSession methodsFor: 'actions--change'!chBlockSize	"Respond to a selection in the block size menu"	SoundPort blockSize: blockSize value."	Transcript show: 'Sound IO block size set to ', SoundPort blockSize printString; cr"!chInChans	"Respond to a selection in the input channel menu"	SoundPort in: inChannels value."	Transcript show: 'Sound IO # input channels set to ', SoundPort inChannels printString; cr"!chListSelection	"Respond to a selection in the main list menu"	transport value: self selectedObject."	Transcript show: 'Select: ', transport value printString; cr."!chOSCAddr	"Respond to a selection in the OSC address field"	| str addr port |	str := oscAddress value.	(str includes: $:)		ifFalse: [self error: 'Broken OSC address format'].	addr := str copyUpTo: $:.	port := str copyAfter: $:.	addr first isDigit			"if the IP is an address like '127.0.0.1' "		ifTrue: [addr := IPSocketAddress stringToBytes: addr]		ifFalse: [addr := IPSocketAddress hostAddressByName: str].	OSCPort defaultIP: addr.	OSCPort defaultPort: port asNumber.	Transcript show: 'OSC address set to ', str; cr!chOutChans	"Respond to a selection in the output channel menu"	SoundPort out value."	Transcript show: 'Sound IO # output channels set to ', SoundPort out printString; cr"!chSRate	"Respond to a selection in the sampleRate menu"	SoundPort sampleRate: sampleRate value."	Transcript show: 'Sound IO sample rate set to ', SoundPort sampleRate printString; cr"!chVerbosity	"Respond to a selection in the verbosity menu"	SirenUtility verbosity: verbosity value.	Transcript show: 'Global verbosity set to ', SirenUtility verbosity printString; cr.	self changed: #verbosity!chVoiceClass	"Respond to a selection in the voice class menu"	Voice setDefault: defaultVoiceClass value.	Transcript show: 'Default IO voice class set to ', defaultVoiceClass value; cr!newEventList	"Respond to a selection in the score menu"	| sco |	sco := eventList value.	sco ifNil: [^nil].	sco isString ifFalse: [sco := sco name].	sco isEmpty ifTrue: [self halt].	Transcript show: 'Score ', sco, ' selected'; cr.	loadedLists add: sco.	self updateScheduleList!newMIDIPort	"Respond to a selection in the MIDI port menu"	Transcript show: 'MIDI port set to ', (MIDIPort devices at: midiPort value) name; cr.!newSound	"Respond to a selection in the sound menu"	| snd |	snd := sound value.	snd ifNil: [^nil].	snd isString ifFalse: [snd := snd name].	snd isEmpty ifTrue: [self error: 'Sound not found'. "snd := snd name"].	Transcript show: 'Sound ', snd, ' selected'; cr.	loadedSounds add: snd.	self updateScheduleList.!newSoundPort	"Respond to a selection in the sound port menu"	Transcript show: 'Sound port set to ', 			(SoundPort concreteClass devices at: soundPort value) name; cr.!newTimer	"Respond to a selection in the timer menu"	Transcript show: 'Timer  ', timer value printString, ' selected'; cr.!newVoice	"Respond to a selection in the sound port menu"	Transcript show: 'Voice set to ', voice value printString; cr.! !!Siren.SirenSession methodsFor: 'resources'!addItemsFrom: aDict to: aMenu path: aPath	"Add items from the given dictionary to a hierarchical menu"	| fils dirs |	aDict isEmpty		ifTrue: [^Menu labelArray: #('Empty')].	fils := OrderedCollection new: aDict size.	dirs := OrderedCollection new: aDict size.	aDict associationsDo: 		[ :ass | | key val |			key := ass key.			val := ass value.			(val isKindOf: Dictionary)			"kludj"				ifTrue: [dirs add: key]				ifFalse: [fils add: key]].	dirs isEmpty		ifFalse: [dirs do:							"recurse through sub-dicts creating submenus"			[ :sub | | child |			aMenu beginSubMenuLabeled: sub. 			(sub == #/)				ifTrue: [child := aPath, sub]				ifFalse: [child := aPath, sub, '/'].			self addItemsFrom: (aDict at: sub) to: aMenu path: child.			aMenu endSubMenu]].	fils do:		[ :it | aMenu add: (it -> (aPath, it)"(aDict at: it)")].!listMenu	"Answer the event list menu"	| devs mb |	devs := SirenSession eventLists.	devs isEmpty		ifTrue: [^Menu labelArray: #('No scores')].	mb := MenuBuilder new.	self addItemsFrom: devs to: mb path: ''.	^mb menuHolder!soundMenu	"Answer the hierarchical sound menu"	| devs mb |	devs := SirenSession sounds.	devs isEmpty		ifTrue: [^Menu labelArray: #('No sounds')].	mb := MenuBuilder new.	self addItemsFrom: devs to: mb path: ''.	^mb menuHolder!timerMenu	"Answer the timer list menu"	| devs labels |	devs := EventScheduler timers.	devs isEmpty		ifTrue: [^Menu labelArray: #('No timers')].	labels := Array new: devs size.	1 to: devs size do: 		[ :ind | labels at: ind put: (devs at: ind) name].	^Menu labelArray: labels! !!Siren.SirenSession methodsFor: 'actions--transport'!forward	"This stub method was generated by UIDefiner"	^self!play	"Play the selection"	transport value		ifNil: [Transcript show: 'Nothing to play'; cr]		ifNotNil: [^transport value play]!record	"This stub method was generated by UIDefiner"	^self!rewind	"This stub method was generated by UIDefiner"	^self!stop	"Stop the selection"	| obj | 	transport value ifNotNil: [^transport value stop].	obj := self selectedObject.	obj ifNotNil: [^obj stop].	EventScheduler instance run: false! !!Siren.SirenSession methodsFor: 'initialize release'!initialize	"Set up the defaults values."	"self open"	interfaceParams := SoundPort concreteClass properties.	interfaceParams isEmpty ifTrue: [interfaceParams := #(0 0 0 0)].	inChannels := interfaceParams first asValue.	outChannels := (interfaceParams at: 2) asValue.	sampleRate := (interfaceParams at: 3) asValue.	blockSize := SoundPort concreteClass blockSize asValue.	defaultVoiceClass := #MIDIVoice asValue.	transport := nil asValue.	scheduleList := SelectionInList new.	scheduleListText := SelectionInList new.	clock := String new asValue.	loadedSounds := OrderedCollection new.	loadedLists := OrderedCollection new.	verbosity := SirenUtility verbosity asValue.	oscAddress := (SirenUtility defaultOSCHost printIP, ':', SirenUtility defaultOSCPort printString) asValue.	(EventScheduler instance dependents includes: self)		ifFalse: [EventScheduler instance addDependent: self]!release	super release.	(EventScheduler instance dependents includes: self)		ifTrue: [EventScheduler instance removeDependent: self].	loadedSounds := OrderedCollection new.	loadedLists := OrderedCollection new.	ObjectMemory compactingGC.! !!Siren.SirenSession methodsFor: 'actions'!allOff	"Turn off anything that's playing"	self stopSound.	self stopMIDI.	self resetSound.	EventScheduler resetClock.!cleanUp	self stopSound.	self stopMIDI.	MIDIPort cleanUp.	self resetSound.	SirenExternalInterface unload.	EventScheduler resetClock."	Siren.CSL.IO release.	Siren.CSL.CSL freeModule.	Siren.Loris.Loris freeModule."	ObjectMemory globalGarbageCollect!configureMIDI	| sel dev devices |	MIDIPort concreteClass devices ifNil: [MIDIPort testOpenClose].	sel := (Menu labelArray: #('pick input port' 'pick output port')) startUp.	sel = 0 ifTrue: [^self].	sel = 1 ifTrue: [devices := MIDIPort concreteClass devices select: [ :item | item out = 1]].	sel = 2 ifTrue: [devices := MIDIPort concreteClass devices select: [ :item | item out = 0]].	dev := (Menu labelArray: (devices collect: [ :item | item name])) startUp.	dev = 0 ifTrue: [^self].	sel = 1 ifTrue: [Transcript show: 'Default MIDI input device set to ', ((devices at: dev) name); cr.			dev := (devices at: dev) port.			SirenUtility defaultMIDIIn: dev.			MIDIPort concreteClass in: dev].	sel = 2 ifTrue: [Transcript show: 'Default MIDI output device set to ', ((devices at: dev) name); cr.			dev := (devices at: dev) port.			SirenUtility defaultMIDIOut: dev.			MIDIPort concreteClass out: dev].!freeLists	SirenSession flushTempEventLists.	SirenSession initializeSounds.	ObjectMemory globalGarbageCollect!inspectSession	self inspect!loadAll	"SirenSession initialize. SirenSession loadDemoData"	"EventScheduler interrupt; flush"	"EventScheduler release""Create some timers""	EventScheduler addTimer: 0.0 interval: 2.0.	EventScheduler addTimer: 1.0 interval: 2.0.	EventScheduler  run."	SirenSession initialize. SirenSession loadDemoData!openSirenUtility	SirenSession openUtility!openTransport	"Open a transport control"	^self class openTransport!resetSound	"Reset the parameters of the sound port"	SoundPort initialize.	blockSize value: SoundPort blockSize.	inChannels value: SoundPort in.	outChannels value: SoundPort out.	sampleRate value: SoundPort sampleRate.!stopMIDI	"Turn off MIDI"	EventScheduler interrupt.	EventScheduler flush.	[MIDIPort default allNotesOff]		on: Error		do: [ :ex | Transcript show: 'Midi not installed'; cr].!stopSound	"Stop the sound player if it's active"	| port |	port := SoundPort defaultOrNil.	port ifNotNil: [port stop; close]! !!Siren.SirenSession methodsFor: 'interface opening'!postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	defaultVoiceClass onChangeSend: #chVoiceClass to: self.	blockSize onChangeSend: #chBlockSize to: self.	inChannels onChangeSend: #chInChans to: self.	outChannels onChangeSend: #chOutChans to: self.	sampleRate onChangeSend: #chSRate to: self.	oscAddress onChangeSend: #chOSCAddr to: self.	verbosity onChangeSend: #chVerbosity to: self.	scheduleListText selectionHolder onChangeSend: #chListSelection to: self.	self soundPort onChangeSend: #newSoundPort to: self.	self sound onChangeSend: #newSound to: self.	self voice onChangeSend: #newVoice to: self.	self midiPort onChangeSend: #newMIDIPort to: self.	self eventList onChangeSend: #newEventList to: self.	self timer onChangeSend: #newTimer to: self.! !!Siren.SirenSession methodsFor: 'aspects'!blockSize	^blockSize!clock	^clock!defaultVoiceClass	^defaultVoiceClass!eventList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^eventList isNil		ifTrue:			[eventList := nil asValue]		ifFalse:			[eventList]!inChannels	^inChannels!midiPort	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^midiPort isNil		ifTrue:			[midiPort := nil asValue]		ifFalse:			[midiPort]!oscAddress	"Answer the formatted OSC IP address + port"	^oscAddress!outChannels	^outChannels!sampleRate	^sampleRate!scheduleList	"Answer the scheduler's list"	^scheduleList!scheduleListText	"Answer the scheduler's list"	^scheduleListText!scheduleListText0	"Answer the scheduler's list"	^SelectionInList new list: (self scheduleList list collect:		[ :item | | obj |		obj := self objectFor: item.		obj ifNotNil: [(obj isActive ifTrue: [' X	'] ifFalse: ['	']), item]])!sound	^sound isNil		ifTrue:			[sound := nil asValue]		ifFalse:			[sound]!soundPort	^soundPort isNil		ifTrue:			[soundPort := nil asValue]		ifFalse:			[soundPort]!timer	"Answer the timer"	^timer isNil		ifTrue: [timer := nil asValue]		ifFalse: [timer]!updateClock	"Answer the clock display"	clock value: ((EventScheduler clock asFloat / 1000000.0) printString: 5).	self changed: #clock.!updateScheduleList	"Build the transport view's list"	| list textList |	list := OrderedCollection new.	list addAll: EventScheduler timers asOrderedCollection."	list addAll: EventScheduler clients asOrderedCollection."	list addAll: loadedSounds.	list addAll: loadedLists.	self scheduleList list: list.	self changed: #scheduleList.	textList := OrderedCollection new.	list do:		[ :item | | obj |		obj := self objectFor: item.		obj ifNotNil: [textList add: (obj isActive					ifTrue: [' X	']					ifFalse: ['	']), 				item]].	self scheduleListText list: textList.	self changed: #scheduleListText.!updateTimer	"Answer the timer display"	timer value: ((Time millisecondClockValue asFloat / 1000.0) printString: 6).	self changed: #timer.!verbosity	"Answer the verbosity level 0, 1, or 2"	^verbosity!verbosityLabel	"Answer the verbosity level 0, 1, or 2"	^'Verbosity: ', verbosity printString!voice	^voice isNil		ifTrue: [voice := nil asValue]		ifFalse: [voice]! !!Siren.SirenSession methodsFor: 'actions--tests'!testMIDI	| lis sel |	sel := (SirenSession midiTestMenu) startUp.	sel ifNil: [^self].	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testInput].	sel == 2 ifTrue: [^MIDIPort testInputStop].	sel == 3 ifTrue: [^MIDIPort testANote].	sel == 4 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	lis := EventList newAnonymous.	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (90 to: 110))			voice: #((1)(1))			density: 8) eventList).		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (68 to: 90))			ampl: #((80 to: 100) (60 to: 120))			voice: #((1)(1))			density: 9) eventList)].	lis eventsDo: [ :ev | ev voice: nil].	lis playOn: MIDIVoice default!testMIDIin	MIDIPort testInput!testMIDIout	"Unused - see testMIDI"	| lis sel | self halt.	sel := (Menu labelArray: #('single note' 'scale' 'dense chaos')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^MIDIPort testANote].	sel == 2 ifTrue: [^(EventList scaleFrom: 48 to: 72 in: 1.5) playOn: MIDIVoice default].	lis := EventList newAnonymous. 	1 timesRepeat: 		[lis addAll: ((DynamicCloud  dur: 6  			pitch: #((50 to: 64) (78 to: 80))			ampl: #((60 to: 80) (90 to: 110))			voice: #((0) (0))			density: 8) eventList) .		lis addAll: ((DynamicCloud  dur: 6  			pitch: #((22 to: 48) (38 to: 40))			ampl: #((80 to: 100) (60 to: 120))			voice: #((0) (0))			density: 9) eventList)].	lis playOn: MIDIVoice default!testOSCout	| sel |	sel := (Menu labelArray: #('CSL FM example' 'MIDI example')) startUp.	sel == 0 ifTrue: [^self].	sel == 1 ifTrue: [^OSCVoice fmExample1].		^OSCVoice midiScaleExample!testSndFileIn	"Run the default sound file test"	LibSndFileInterface example1: 'unbelichtet.aiff'!testSoundIn	"This stub method was generated by UIDefiner"	^self!testSoundOut	"Play a sound"	PortAudioPort playSweep! !!Siren.SirenSession methodsFor: 'updating'!executeAutoSave	^self!update: anAspectSymbol with: aParameter from: aSender	"Catch an update"	(anAspectSymbol == #timer)		ifTrue: [^self updateClock				"^Transcript show: 'timer update'; cr"].	(anAspectSymbol == #event)		ifTrue: [^self updateClock 				"^Transcript show: 'event update'; cr"].	(anAspectSymbol == #running)		ifTrue: [^Transcript show: 'status update: ', aParameter printString; cr].	(anAspectSymbol == #appointments)		ifTrue: [^self "updateScheduleList "				"^Transcript show: 'clients update'; cr"].	Transcript show: 'other update: ', anAspectSymbol printString; cr! !!Siren.SirenSession methodsFor: 'actions--menu'!deleteItem	"Remove an item from the list"	| it |	it := scheduleList selection.	it ifNil: [^self].	Transcript show: 'Remove ', it; cr.	(loadedSounds includes: it)			"if snd"		ifTrue: [loadedSounds remove: it]		ifFalse: [(loadedLists includes: it)			"if sco"			ifTrue: [loadedLists remove: it]			ifFalse: [(EventScheduler timers includes: it)			"if timer"				ifTrue: [EventScheduler removeTimerNamed: it]				ifFalse: [(EventScheduler clients includes: it)			"if client"					ifTrue: [EventScheduler removeClientNamed: it]					ifFalse: [Transcript show: '		not found '; cr]]]].	scheduleList list remove: it.	self changed: #scheduleList!playItem	"Remove an item from the list"	| it obj |	it := self selectedObjectName.	it ifNil: [^self].	obj := nil.	Transcript show: 'Play ', it; cr.	(loadedSounds includes: it)		ifTrue: [obj := SirenSession soundNamed: it]		ifFalse: [(loadedLists includes: it)			ifTrue: [obj := SirenSession eventListNamed: it]			ifFalse: [(EventScheduler timers includes: it)				ifTrue: [obj := EventScheduler timerNamed: it]				ifFalse: [(EventScheduler clients includes: it)					ifTrue: [obj := EventScheduler clientNamed: it]					ifFalse: [Transcript show: '		not found '; cr]]]].	obj ifNil: [Transcript show: 'Play: object not found'; cr. ^nil].	obj play.	transport value: obj.	self changed: #transport!spawnItem	"Remove an item from the list"	| it obj |	it := self selectedObjectName.	it ifNil: [^self].	obj := nil.	Transcript show: 'Play ', it; cr.	(loadedSounds includes: it)		ifTrue: [obj := SirenSession soundNamed: it]		ifFalse: [(loadedLists includes: it)			ifTrue: [obj := SirenSession eventListNamed: it]			ifFalse: [(EventScheduler timers includes: it)				ifTrue: [obj := EventScheduler timerNamed: it]				ifFalse: [(EventScheduler clients includes: it)					ifTrue: [obj := EventScheduler clientNamed: it]					ifFalse: [Transcript show: '		not found '; cr]]]].	obj ifNil: [Transcript show: 'Play: object not found'; cr. ^nil].	obj open.	transport value: obj.	self changed: #transport!zeroTimer	EventScheduler instance resetClock! !!Siren.SirenSession class methodsFor: 'resources'!midiPortMenu	"Answer the midi port menu"	"SirenSession midiPortMenu startUp"	| devs labels |	devs := MIDIPort concreteClass devices.	devs isEmpty		ifTrue: [^Menu labelArray: #('No MIDI')].	labels := OrderedCollection new: devs size.	devs do: 		[ :item | (item out == 0)			ifTrue: [labels add: item name, '  (out)']			ifFalse: [labels add: item name, '  (in)']].	^Menu labelArray: labels asArray!soundPortMenu	"Answer the sound port menu"	| devs labels |	devs := SoundPort concreteClass devices.	devs isEmpty		ifTrue: [^Menu labelArray: #('No sound IO')].	labels := Array new: devs size.	1 to: devs size do: 		[ :ind | labels at: ind put: (devs at: ind) name].	^Menu labelArray: labels! !!Siren.SirenSession class methodsFor: 'class initialization'!flushTempEventLists	"Flush the class's temporary event list dictionary."	"SirenSession flushTempEventLists"	EventLists at: #Temp put: Dictionary new.	ObjectMemory compactingGC!initialize	"Edit these to taste for your installation."	"SirenSession initialize"	"SirenSession instanceCount"	"SirenSession someInstance"	"SirenSession refresh"	self initializeEventLists.						"Flush cache dictionaries"	self initializeSounds.	self initializeVoices.	self release.	singleton := nil.	useSingleton := true.	ObjectMemory compactingGC.	(ObjectMemory dependents includes: self)		ifFalse:	[ObjectMemory addDependent: self].!initializeEventLists	"Flush the class's event list dictionary."	"SirenSession initializeEventLists"	EventLists := Dictionary new.	EventLists at: #Temp put: Dictionary new.	ObjectMemory compactingGC!initializeSounds	"Empty the class's sound dictionary."	Sounds := Dictionary new.	ObjectMemory compactingGC!initializeVoices	"SirenSession initializeVoices"	Voices := Dictionary new.!update: anAspect with: arguments from: anObject	"You can put code here to be done before or after a snapshot 		(i.e., do you want to store events lists and sounds in the image or not)"	"anAspect == #aboutToSnapshot		ifTrue: [Siren.CSL.IO release]	"	"never store an IO object across snapshots"! !!Siren.SirenSession class methodsFor: 'interface opening'!open	"Open the ApplicationModel's user interface."	"SirenSession open"	^self openOn: self new withSpec: #utilWindowSpec!openTransport	"Open the ApplicationModel's user interface."	"SirenSession openTransport"	^self openOn: self new withSpec: #transportWindowSpec!openUtility	"Open the ApplicationModel's user interface."	"SirenSession openUtility"	^self openOn: self new withSpec: #utilWindowSpec! !!Siren.SirenSession class methodsFor: 'class var accessing'!atVoice: nam put: vox	"Add to the class's voice dictionary."	^Voices at: nam put: vox!eventList: aName	"Get the event list at the given (possibly hierarchical) name in the shared dictionary"	"SirenSession eventListNamed: 'aa/bb/cc' "	| sco |	sco := self dataAt: aName in: EventLists.	sco ifNotNil: [^sco].	sco := SirenUtility findFile: (aName asFilename tail).	sco ifNotNil: [^EventList fromFile: sco].	^nil!eventList: aName put: anEventList	"Store the give n event list in the shared dictionary; handle hierarchical names"	"SirenSession eventList: 'aa/bb/cc' put: EventList new"	"SirenSession eventListNamed: 'aa/bb/cc'"	^self data: aName in: EventLists put: anEventList!eventListNamed: aName	"Get the event list at the given (possibly hierarchical) name in the shared dictionary"	"SirenSession eventListNamed: 'aa/bb/cc' "	| sco |	sco := self dataAt: aName in: EventLists.	sco ifNotNil: [^sco].	sco := SirenUtility findFile: (aName asFilename tail).	sco ifNotNil: [^EventList fromFile: sco].	^nil!eventLists	"Answer the class's event list dictionary."	^EventLists!schedule	"Answer the 'global' scheduler."	"Siren schedule"	EventScheduler instance!sound: aName	"Get the event list at the given (possibly hierarchical) name in the shared dictionary"	"SirenSession sound: 'aa/bb/cc' "	| snd |	snd := self dataAt: aName in: Sounds.	snd ifNotNil: [^snd].	snd := (aName asFilename tail).	snd := SirenUtility findFile: snd.	snd ifNotNil: [^Sound fromFile: snd].	^nil!sound: aName put: aSound	"Store the give n event list in the shared dictionary; handle hierarchical names"	"SirenSession sound: 'Tests/sawtooth' put: SampledSound sawtooth"	"SirenSession sound: 'Tests/sawtooth' put: nil"	^self data: aName in: Sounds put: aSound!soundNamed: aName	"Get the event list at the given (possibly hierarchical) name in the shared dictionary"	"SirenSession soundNamed: 'aa/bb/cc' "	| snd |	snd := self dataAt: aName in: Sounds.	snd ifNotNil: [^snd].	snd := (aName asFilename tail).	snd := SirenUtility findFile: snd.	snd ifNotNil: [^Sound fromFile: snd].	^nil!sounds	"Answer the class's sound dictionary."	^Sounds!voice: aName put: vox	"Add to the class's voice dictionary."	^self data: aName in: Voices put: vox!voiceNamed: aName	"Add to the class's voice dictionary."	^self dataAt: aName in: Voices!voices	"Answer the class's voice dictionary."	^Voices! !!Siren.SirenSession class methodsFor: 'data load/store'!data: aName in: theDict put: anItem	"Store the given item (sound or event list) in the shared dictionary; 		handle hierarchical names"	"SirenSession eventList: 'aa/bb/cc' put: EventList new"	"SirenSession eventList: 'aa/bb/cc'"	| path dict |	(aName includes: Filename separator)		ifFalse: [(theDict includesKey: #Temp)				ifFalse: [theDict at: #Temp put: IdentityDictionary new].			^(theDict at: #Temp) at: aName asSymbol put: anItem]."If given a hierarchical-style name, descend into the dictionary"	path := aName asFilename components.	dict := theDict.	1 to: path size - 1 do:		[ :ind | | lev |		lev := (path at: ind) asSymbol.		(dict includesKey: lev)			ifFalse: [dict at: lev put: IdentityDictionary new].		dict := dict at: lev].	dict at: path last asSymbol put: anItem.!dataAt: aName in: theDict	"Get the event list at the given (possibly hierarchical) name in the shared dictionary"	"SirenSession eventList: 'aa/bb/cc' "	| path dict |	(aName includes: Filename separator)		ifFalse: [(theDict includesKey: #Temp)				ifFalse: [^nil].			^(theDict at: #Temp) at: aName ifAbsent: [nil]].	path := aName asFilename components.	dict := theDict.	1 to: path size do:		[ :ind | | lev |		lev := (path at: ind) asSymbol.		(dict includesKey: lev)			ifFalse: [^nil].		dict := dict at: lev].	^dict!loadDemoData	"Load a few scores and sounds for demos"	"Customize this to load your personal session data."	"SirenSession initialize."	"SirenSession loadDemoData"	"EventScheduler interrupt; flush"	"EventScheduler release"	| snd list item |"Load some sounds"	list := SirenUtility findFiles: 'au'.	(Dialog confirm: 'Should I load ', list size printString, ' AU files?')	ifTrue: [list do: 		[ :each | item := SampledSound fromFile: each.		item ifNotNil: [self sound: ('AU', Filename separatorString, each) asSymbol put: item]]].	list := SirenUtility findFiles: 'snd'.	(Dialog confirm: 'Should I load ', list size printString, ' SND files?')	ifTrue: [list do: 		[ :each | item := SampledSound fromFile: each.		item ifNotNil: [self sound: ('SND', Filename separatorString, each) asSymbol put: item]]].	list := SirenUtility findFiles: 'aif'.	(Dialog confirm: 'Should I load ', list size printString, ' AIFF files?')	ifTrue: [list do: 		[ :each | item := SampledSound fromFile: each.		item ifNotNil: [self sound: ('AIFF', Filename separatorString, each) asSymbol put: item]]].	list := SirenUtility findFiles: 'wav'.	(Dialog confirm: 'Should I load ', list size printString, ' WAV files?')	ifTrue: [list do: 		[ :each | item := SampledSound fromFile: each.		item ifNotNil: [self sound: ('WAV', Filename separatorString, each) asSymbol put: item]]]."Load some MIDI"	list := SirenUtility findFiles: 'mid'.	(Dialog confirm: 'Should I load ', list size printString, ' MIDI files?')	ifTrue: [list do: 		[ :each | item := EventList fromFile: each.		item ifNotNil: [self eventList: ('MIDI', Filename separatorString, each) asSymbol put: item]]]."Load some noteLists"	list := SirenUtility findFiles: 'ev'.	(Dialog confirm: 'Should I load ', list size printString, ' EV files?')	ifTrue: [list do: 		[ :each | item := EventList fromFile: each.		((item notNil) and: [item events size > 0])			ifTrue: [self eventList: ('EV', Filename separatorString, each) asSymbol put: item]]]."Create some test sounds"	snd := SampledSound sineDur: 1 rate: 44100 freq: 80 chans: 1.	SirenSession sound: 'Tests/sine' put: snd.	SirenSession sound: 'Tests/silence' put: snd.	SirenSession sound: 'Tests/pink' put: snd.	SirenSession sound: 'Sweeps/sine' put: snd.	SirenSession sound: 'Sweeps/slower' put: snd.	SirenSession sound: 'Bursts/sine' put: snd.	SirenSession sound: 'Bursts/impulse' put: snd.	SirenSession sound: 'Bursts/noise' put: snd.	SirenSession sound: 'Notes/adsr' put: snd.	SirenSession sound: 'Notes/fm' put: snd."Create some voices"	Voices at: #MIDI put: Dictionary new.	Voices at: #OSC put: Dictionary new.	Voices at: #Snd put: Dictionary new."Create some timers""	EventScheduler addTimer: 0.0 interval: 2.0.	EventScheduler addTimer: 1.0 interval: 2.0.	EventScheduler  run."! !!Siren.SirenSession class methodsFor: 'instance creation'!instance	"Answer the 'global' session."	"SirenSession instance"	^self new!new	"Make sure there's only ever one of me."	useSingleton ifFalse: [^super new initialize].	singleton ifNil: [singleton := super new initialize].	^singleton!refresh	"Recreate the instance"	"SirenSession refresh"	singleton ifNotNil: [singleton release].	useSingleton ifTrue: [singleton := super new initialize]!release	"Make sure there's only ever one of me."	"SirenSession release"	singleton ifNotNil: 		[singleton release.		singleton := nil]! !!Siren.PortMIDIPort methodsFor: 'accessing'!isActive	"Answer whether the receiver is active."	^(status == #open)! !!Siren.PortMIDIPort methodsFor: 'read/write'!playOff: aPitch amp: anAmp voice: aVoice	"Play the argument on the receiver--no duration-->no note-off."	[self critical: [driver pm_write_data3: (Streams at: device) 			with: ((MIDICommands at: #noteOff) bitOr: aVoice) 			with: aPitch with: anAmp]]		on: Error		do: [ :ex | Transcript show: 'MIDI write error'; cr]!playOff: streamID pitch: pitch amp: amp voice: voice	"Play the argument on the receiver."	self critical: 		[driver pm_write_data3: (Streams at: streamID) 					with: ((MIDICommands at: #noteOn) bitOr: voice) with: pitch with: 0]!playOn: aPitch amp: anAmp voice: aVoice	"Play the argument on the receiver--no duration-->no note-off."	[self critical: [driver pm_write_data3: (Streams at: device)			with: ((MIDICommands at: #noteOn) bitOr: aVoice) 			with: aPitch with: anAmp]]		on: Error		do: [ :ex | Transcript show: 'MIDI write error.'; cr]!playOn: streamID pitch: pitch amp: amp voice: voice	"Play the argument on the receiver--no duration-->no note-off."	self critical: 		[driver pm_write_data3: (Streams at: streamID) 				with: ((MIDICommands at: #noteOn) bitOr: voice) with: pitch with: amp]!put: streamID data: data length: size	"Send the argument (a ByteArray for historical reasons) to the receiver now."	[(size < 2)		ifTrue: [^self error: 'Unknown MIDI command format -- illegal length'].	(size = 2)		ifTrue: [^self critical: [driver pm_write_data2: streamID with: (data at: 1) with: (data at: 2)]].	(size = 3)		ifTrue: [^self critical: [driver pm_write_data3: streamID with: (data at: 1) with: (data at: 2) with: (data at: 3)]].	(size > 3)		ifTrue: [self halt]] 		"not supported yet"			on: Error			do: [ :ex | Transcript show: 'MIDI write error'; cr].	^nil!put: data length: size	"Send the argument (a ByteArray for historical reasons) to the receiver now."	^self put: (Streams at: device ifAbsent: [self error: 'MIDI port not found']) data: data length: size!readControllersFrom: lo to: hi into: array	"Read a range of controllers"	self critical: [driver pm_read_controllers: (Streams at: device) with: lo with: hi with: array].! !!Siren.PortMIDIPort methodsFor: 'initialize release'!initialize	"Setup the receiver's instance variables."	"MIDIPort testANote"	"PortMIDIPort devices"	| return |	super initialize.	driver := PortMidiInterface new.	return := driver pm_initialize.	(return = 0)		ifFalse: [self error: 'MIDI initialize failed'].	status := #init.	self class resetDevices.	self critical: [1 to: driver pm_count_devices do:		[ :cnt | | nam |		nam := driver pm_get_name: cnt.		self class devices add: (DeviceModel new name: nam copyCStringFromHeap asSymbol; 						port: (cnt - 1); out: (driver pm_dev_dir: cnt))]].	(SirenUtility verbosity > 1)		ifTrue: [Transcript cr; show: 'Midi Device Table'; crtab.			self class devices do: [ :aDev | Transcript show: aDev port printString, ': ', aDev name.					(aDev out = 1) ifTrue: [Transcript show: ' - in'] ifFalse: [Transcript show: ' - out']]				separatedBy: [Transcript crtab].			Transcript cr]!release	"Release--break and dependencies on the error value."	super release.	[driver ifNotNil: [self critical: [driver pm_terminate]]]		on: Error		do: [ :ex | "ignore" ]! !!Siren.PortMIDIPort methodsFor: 'ioctl'!readLoop	"The MIDI driver input process loop."	| int packet delay dev |	delay := Delay forMilliseconds: 5.					"default loop delay"	dev := Streams at: device ifAbsent: [Streams at: self class in].	self resetInput."LOOP"	[true] whileTrue: 		[((driver pm_poll: dev) = 0)				"poll"			ifTrue: [delay wait]			ifFalse: [self critical: [int := driver pm_read: dev].	"read"				(int = 0) ifFalse: 					[packet := MIDIPacket fromInt: int 		"parse"								at: Time microsecondClock.					SirenUtility log: '		', packet printString level:2.					inputData addLast: packet.			"queue"					self changed: #read]]]					"signal"!startControllerCaching	"Start caching MIDI controller in the driver."	self critical: [driver pm_start_controller_cacheing]!stopControllerCaching	"Stop caching MIDI controller in the driver."	self critical: [driver pm_stop_controller_cacheing]! !!Siren.PortMIDIPort methodsFor: 'open/close'!close	"Close MIDI."	"MIDIPort instance close"	self close: device!close: stream	"Close MIDI."	"MIDIPort instance close"	| which |	readProcess ifNotNil: 			[readProcess terminate.			readProcess release].	readProcess := nil.	self breakDependents.	which := Streams at: stream ifAbsent: [nil].	self critical: [which ifNotNil:		[[driver pm_close: which]			on: Error			do: [ :ex | Transcript show: 'MIDI close error'; cr]]].	status := #closed.	^#OK!open	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	self isActive		ifTrue: [^self].	^self openOutput: self class out!openInput: dev	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	| which |	[which := driver pm_open: dev with: 1]		on: Error		do: [ :ex | Transcript show: 'MIDI openInput error'; cr.				which := -1].	(which < 0)		ifTrue: [self error: 'MIDI open failed'].	device := dev.	Streams at: dev put: which.	status := #open.	^which!openOutput: dev	"Open the MIDI driver -- start the lower-level driver up."	"MIDIPort default"	| which |	status == #open ifTrue: [^self].	self critical: [[which := driver pm_open: dev with: 0]		on: Error		do: [ :ex | which := 0.		"assume first slot"				Transcript show: 'MIDI open failed'; cr]].	(which < 0)		ifTrue: [self error: 'MIDI open failed'].	Streams at: dev put: which.	status := #open.	device := dev.	^which!terminate	"Close MIDI."	"MIDIPort instance close"	driver pm_terminate.	status := #init! !!Siren.PortMIDIPort class methodsFor: 'class initialization'!initializeData	"Set up the class defaults."	"PortMIDIPort initializeData"	singleton := nil.	devices := OrderedCollection new.	properties := Array new.	mutex := Semaphore forMutualExclusion.	useSingleton := true.			"PortMIDI allows multiple port objects, but we don't use it..."	out := SirenUtility defaultMIDIOut.	in := SirenUtility defaultMIDIIn.	rate := 0.	blockSize := 0.! !!Siren.PortMIDIPort class methodsFor: 'examples'!dump	"Dump port names"	"PortMIDIPort dump"	Transcript cr; show: 'Midi Device Table'; crtab.	self devices do: [ :aDev | Transcript show: aDev port printString, ': ', aDev name.					(aDev out = 1) ifTrue: [Transcript show: ' - in'] ifFalse: [Transcript show: ' - out']]				separatedBy: [Transcript crtab].	Transcript cr!testANote	"Open MIDI, play a note."	"PortMIDIPort testANote"	| inst |	inst := MIDIPort new.		"this answers an instance of me."	inst open.	inst playOn: 48 amp: 100 voice: 0.	1 wait.	inst playOff: 48 amp: 100 voice: 0.	inst close.	inst terminate.	MIDIPort cleanUp! !!Siren.FunctionController methodsFor: 'control defaults'!redButtonActivity	"Hit-detect items from the display list or drag a selection."	| cPoint value |	self model == nil ifTrue: [^nil].	cPoint := InputSensor cursorPoint - view class inset max: (0@0).	value := self model at: (cPoint x / view hRange) asFloat.							"If you're clicking near the function"	((value * (view vRange)) - (view vRange - cPoint y)) abs < 16		ifTrue: [(self model hasPointNear: (cPoint x / view hRange))			ifTrue: [self dragPoint: cPoint]			ifFalse: [self addPoint: cPoint]]!selectAtPoint: aPoint	"Hit-detect the model for the given pt."	| value transPt |	transPt := view transformPoint: aPoint.	value := self model at: (transPt x / view hRange) asFloat.	((value * (view vRange)) - (view vRange - transPt y)) abs < 16		ifTrue: [(self model hasPointNear: (transPt x / view hRange))			ifTrue: [self dragPoint: transPt]			ifFalse: [self addPoint: transPt]]! !!Siren.FunctionController methodsFor: 'accessing'!model	"Answer the view's model at the receiver's model index."	^view modelAt: modelIndex! !!Siren.FunctionController methodsFor: 'private'!addPoint: cPoint	"Add a new point to the model near the current point."	| x0 p1 p2 p3 index newFcn mod newPoint scalePoint |	mod := self model.	x0 := cPoint x / view hRange.	index := mod indexOfPointNearestX: x0.	(mod pointAt: index) x > x0		ifTrue: [index := index - 1].	p1 := ((mod pointAt: index) * view displayExtent) truncated.	p2 := cPoint.	p3 := ((mod pointAt: (index + 1)) * view displayExtent) truncated.	p2 := self rubberBandLinesBetween: p1 and: p2 and: p3.	newFcn := mod class ofSize: mod size + 1.	1 to: index do:		[ :i |		newFcn add: (mod realPointAt: i)].	newPoint := (mod realPointAt: index) copy.	scalePoint := (p2 / view displayExtent) float.	newPoint x: scalePoint x; y: scalePoint y.	"this is for handling ExpSegs"	newFcn add: newPoint.	index + 1 to: mod size do:		[ :i |		newFcn add: (mod realPointAt: i)].	view modelAt: modelIndex put: newFcn.	view invalidate!dragPoint: cPoint	"Drag the current point."	|  p1 p2 p3 index mod oldPt |	mod := self model.	index := mod indexOfPointNearestX: (cPoint x / view hRange).	index = 1		ifFalse: [p1 := ((mod pointAt: (index - 1)) * view displayExtent) truncated].	p2 := ((mod pointAt: index) * view displayExtent) truncated.	index = mod size		ifFalse: [p3 := ((mod pointAt: (index + 1)) * view displayExtent) truncated].	p2 := self rubberBandLinesBetween: p1 and: p2 and: p3.	oldPt := (mod realPointAt: index) copy.	oldPt x: (p2 x / view hRange) asFloat; 		y: ((1 - ((view vRange - p2 y) / view vRange) min: 1) max: 0) asFloat.	mod pointAt: index put: oldPt.	view invalidate!rubberBandLinesBetween: p1 and: p2 and: p3	"Drag two lines between the given end- and middle-points; 	answer the final mid-point"	| nPoint gc back fore |	gc := view graphicsContext.	back := DisplayListView backgroundColor.	fore := view colors at: modelIndex.	p1 == nil				"if dragging the first point"		ifTrue: [nPoint := p2.			[self sensor anyButtonPressed]				whileTrue:					[view updateBetween: nPoint and: p3 with: back on: gc.					nPoint := InputSensor cursorPoint - view class inset.					nPoint y: view vRange - nPoint y.					nPoint x: (nPoint x min: p3 x - 1).					view updateBetween: nPoint and: p3 with: fore on: gc].			^0 @ nPoint y].	p3 == nil		 		"if dragging the last point"		ifTrue: [nPoint := p2.			[self sensor anyButtonPressed]				whileTrue:					[view updateBetween: p1 and: nPoint with: back on: gc.					nPoint := InputSensor cursorPoint - view class inset.					nPoint y: view vRange - nPoint y.					nPoint x: (nPoint x max: p1 x + 1).					view updateBetween: p1 and: nPoint with: fore on: gc].			^view hRange @ nPoint y].							"else--dragging internal point"	nPoint := p2.	[self sensor anyButtonPressed]		whileTrue: [view updateBetween: p1 and: nPoint with: back on: gc.			view updateBetween: nPoint and: p3 with: back on: gc.			nPoint := InputSensor cursorPoint - view class inset.			nPoint y: view vRange - nPoint y.			nPoint x: ((nPoint x min: p3 x - 1) max: p1 x + 1).			view updateBetween: p1 and: nPoint with: fore on: gc.			view updateBetween: nPoint and: p3 with: fore on: gc].		^nPoint!selectModel: index	"Set the model index of the receiver to the argument."	modelIndex := index! !!Siren.FunctionController methodsFor: 'menu messages'!addFunction	"Add a new function to the view's model array."	| class new nameArray |	(class := (Menu labels: 'LinSeg\ExpSeg\SplineSeg' withCRs) startUp) = 0			ifTrue: [^self].	nameArray := Array with: LinearFunction with: ExponentialFunction with: SplineFunction.	new := (nameArray at: class) perform: #default.	view models at: modelIndex put: new.	view invalidate!clearFunction	"Clear the current function to the view's model array."	view modelAt: modelIndex put: nil.	view invalidate!doInspect	"Inspect the receiver's array of models"	InputState default shiftDown		ifTrue: [self model inspect]		ifFalse: [view models inspect]!enterFunction	"Add a new function to the view's model array after typing in its breakpoints."	| class new nameArray wgc done block points |	(class := (Menu labels: 'LinearFunction\ExpSeg\SplineSeg' withCRs) startUp) = 0			ifTrue: [^self].	nameArray := Array with: LinearFunction with: ExponentialFunction with: SplineFunction.	Cursor crossHair showWhile:		[wgc := view graphicsContext.		done := false.		block := [| p |				self sensor waitButton.				p := InputSensor cursorPoint.				done := self sensor redButtonPressed not.				self sensor waitNoButton.				ScheduledControllers checkForEvents.				p].		wgc flush.		points := Array new writeStream.		[done] whileFalse:			[points nextPut: block value]].	points := points contents collect:		[ :pt |		((pt x / view hRange)@ (view vRange - pt x / view vRange)) float].	points first x: 0.	points last x: 1.	new := (nameArray at: class) from: points.	view models at: modelIndex put: new.	view invalidate!redraw	"Redraw the view and clear the selection."	view invalidate!setAScale	"comment stating purpose of message"	|num |	num := Number readFromString: (Dialog request: 'set scale:'			initialAnswer: view aScale printString).	num = 0 ifTrue: [^self].	view aScale: num.	view invalidate! !!Siren.FunctionController methodsFor: 'initialize-release'!initialize	super initialize.	modelIndex := 1.!initializeMenu	"Set up the receiver's YellowButtonMenu"	self menuHolder: (ValueHolder with: (Menu				labelList: #(('inspect') ('redraw' 'set scale') ('add' 'clear' 'enter'))				values: #(doInspect redraw setAScale addFunction clearFunction enterFunction)))! !!Siren.FunctionController methodsFor: 'events'!mouseMovedEvent: anEvent	"Mouse dragging"	anEvent redButtonPressed ifFalse: [^self].	model selection == nil		ifTrue: [self selectEvent: anEvent]		ifFalse: [self dragSelection: anEvent]! !!Siren.TypedOSCMessage methodsFor: 'osc'!argumentsToOSCBytes: convertor 	"Convert the args and type string to OSC format"	convertor nextPut: $, asInteger.	self typesToOSC: convertor.	super argumentsToOSCBytes: convertor.	^self!typesToOSC: converter 	"Convert the arguments to an OSC type string."	| t2 t3 |	arguments isEmpty ifTrue: [^self].	arguments do: [:t4 | t4 toOSCTypeOn: converter].	t2 := 1.	t3 := 4 - (converter position \\ 4).	[t2 <= t3]		whileTrue: 			[converter nextPut: 0.			t2 := t2 + 1].	^self! !!Siren.TypedOSCMessage class methodsFor: 'examples'!changeFreq	"TypedOSCMessage changeFreq"	^self for: '/freq' with: #(440)!scDecreaseVolume	"TypedOSCMessage scDecreaseVolume"	^self for: '/sc/mixer/volume' with: #(1 0.2)!scIncreaseVolume	"TypedOSCMessage scIncreaseVolume"	^self for: '/sc/mixer/volume' with: #(1 1.0)!scRun	"TypedOSCMessage scRun"	^self for: '/sc/run'!scStop	"TypedOSCMessage scStop"	^self for: '/sc/stop'!start	"TypedOSCMessage start"	^self for: '/start'! !!Siren.ScheduleRecord methodsFor: 'accessing'!loop	^loop!loop: aBool	loop := aBool!next	"Answer the receiver's 'next'."	^next!next: anObject	"Set the receiver's instance variable 'next' to be anObject."	next := anObject!previous	"Answer the receiver's 'previous'."	^previous!previous: anObject	"Set the receiver's instance variable 'previous' to be anObject."	previous := anObject!start	^self key! !!Siren.ScheduleRecord methodsFor: 'testing'!isActive	^value isActive! !!Siren.ScheduleRecord methodsFor: 'control'!clear	key :=  nil.	value :=  nil.!stop	value ifNotNil: [value stop]! !!Siren.Analysis methodsFor: 'automatic access'!degree   ^degree!degree: x 	degree := x!scale   ^scale!scale: x   scale := x! !!Siren.Analysis methodsFor: 'printing'!printOn: s	s nextPutAll: '{',self romanDegree,' of ',scale printString,'}'!romanDegree	^#(I II III IV V VI VII) at: degree! !!Siren.Analysis class methodsFor: 'examples'!examples"	(FPChord newFromString: 'B min ') analyseIn: (N C majorScale) 		->  {VII de C MajorScale}	(FPChord newFromString: 'C min dim5') possibleTonalitiesInScaleClass:  MajorScale		-> AnalysisList ({VII of Db MajorScale} )	(FPChord newFromString: 'C') possibleTonalitiesInScaleClass:  MajorScale		-> AnalysisList ({I de C MajorScale} {IV de G MajorScale} {V de F MajorScale}"! !!Siren.ComponentSound methodsFor: 'accessing'!offset	"Answer the receiver's 'offset'."	^offset!offset: anObject	"Set the receiver's 'offset' to be anObject."	offset := anObject!sound	"Answer the receiver's 'sound'."	^sound!sound: anObject	"Set the receiver's 'sound' to be anObject."	sound := anObject!start	"Answer the receiver's 'start'."	^start!start: anObject	"Set the receiver's 'start' to be anObject."	start := anObject!stop	"Answer the receiver's 'stop'."	^stop!stop: anObject	"Set the receiver's 'stop' to be anObject."	stop := anObject.	((start ~~ nil) & (sound ~~ nil))		ifTrue: [self duration: (stop - start / sound rate) asFloat]! !!Siren.ComponentSound methodsFor: 'printing'!printOn: aStream	"Pretty-print the receiver on the argument."	| ra |	sound ifNil: [^super printOn: aStream].	ra := sound rate asFloat.	aStream nextPutAll: '(ComponentSound on ', sound name, 			' from ', ((start asFloat / ra) printWidth: 6), 			' to ', ((stop asFloat / ra) printWidth: 6).	offset ifNotNil: 		[aStream nextPutAll: ' starting at ', offset printString].	aStream nextPutAll: ')'; cr.! !!Siren.ComponentSound methodsFor: 'testing'!includes: anIndex	"Answer whether the argument is within the range of the receiver."	^(anIndex >= start) & (anIndex <= stop)! !!Siren.ComponentSound class methodsFor: 'instance creation'!on: sound from: start to: stop	"Answer a new instance initialized with the arguments."	^(self new) sound: sound; start: start; stop: stop!on: sound start: start stop: stop	"Answer a new instance initialized with the arguments."	^(self new) sound: sound; start: start; stop: stop!on: sound start: start stop: stop offset: offset	"Answer a new instance initialized with the arguments."	^(self new) sound: sound; start: start; stop: stop; offset: offset! !!Siren.CmusicVoice methodsFor: 'events'!endLine	stream nextPut: $;; cr.	^self!writeFooter	stream cr; nextPutAll: 'ter;'; cr; cr.	^self!writeHeader	"Write the cmusic score file header."	stream nextPutAll: '/* cmusic score file created ', Date today printString , ' */'; cr.	stream cr; nextPutAll: '#include <carl/cmusic.h>'; cr.	stream nextPutAll: '#include "instruments.sc"'; cr.	stream cr; nextPutAll: 'SINE(f1);'; cr; cr.	^self! !!Siren.CmusicVoice class methodsFor: 'examples'!randomExampleToFileAndEdit	"CmusicVoice randomExampleToFileAndEdit"	self randomExampleToFileNamed: 'rand.sc'.	^self!randomExampleToFileNamed: fnam 	"Store the given score to a file"	| ev strm list rand vox |	strm := (Filename named: fnam) writeStream.	rand := Random new."Create the event list and add a few additional properties"	(list := EventList randomExample: 64)		do: 			[ :ass | 			(ev := ass event) at: #pos put: rand next.			ev at: #prop1 put: (rand nextFrom: 320 to: 480).			ev at: #prop2 put: (rand nextIntFrom: 12000 to: 23000)]."Create a cmusic voice and customize its parameter map."	(vox := CmusicVoice newNamed: 'violin' onStream: strm) parameterMap at: 3 			put: [ :t8 | #(#in1 #in2 #in3 #in4) at: t8 voice \\ 4 + 1].	vox addMap: [ :t9 | (t9 pitch asHz value printString: 5), 'Hz'].	vox addMap: #pos.	vox addMap: [ :it | ((it at: #prop1) / 10) truncated printString].	vox addMap: #prop2."Play the list on the voice."	vox play: list.	strm close.	(Filename named: fnam) edit.	^self!randomExampleToTranscript	"CmusicVoice randomExampleToTranscript"	(CmusicVoice newNamed: 'violin' onStream: Transcript)		play: (EventList randomExample: 8).	^self! !!Siren.CmusicVoice class methodsFor: 'instance creation'!defaultPMap	"Answer the default cmusic p-map"	| map |	map := OrderedCollection new: 8.	map add: 'note '.	map add: #start.	map add: 'ins'.	map add: [ :t2 | t2 duration asSec value printString ].	map add: [ :t3 | (t3 loudness asDB value printString ), 'dB'].	^map! !!Siren.MIDIVelocity methodsFor: 'accessing'!value: theValue	"Truncate"	super value: theValue.	value := value truncated.! !!Siren.MIDIVelocity methodsFor: 'printing'!printOn0: aStream	"Print the receiver as a MIDI velocity."	aStream nextPutAll: "'v:'," value printString!units	"Answer the units string of the receiver."	^' vel'! !!Siren.MIDIVelocity methodsFor: 'converting'!asDB	"Answer a dB loudness; ratio 1 = 0dB, ratio 0.5 = -6dB, etc."	"(MIDIVelocity value: 64) asDB"	^DBLoudness new value: (20 * ((value / 127) asFloat log))!asMIDI	"Answer a MIDIVelocity."	^self!asRatio	"Answer a RatioLoudness."	^RatioLoudness new value: ((value / 127.0) asFloat)!asSymbol	"Answer a symbolic loudness."	"(Amplitude value: 107) asSymbol"	"107 is fff"	^SymbolicLoudness fromMIDI: value!mostGeneral	"Answer the most numerically meaningful version of the receiver."	^self asRatio! !!Siren.MIDIVelocity methodsFor: 'private'!species	"Answer Amplitude."	^Amplitude! !!Siren.MIDIVelocity class methodsFor: 'class initialization'!initialize	"Initialize the class instance variable."	"MIDIVelocity initialize."	range := 0 to: 127! !!Siren.MIDIVelocity class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asVelocity! !!Siren.Timer methodsFor: 'control'!play	"Start a timer"	^self start!reset	"Start a timer"	startTime := Time microsecondClock.	lastUpdate :=  startTime.	self changed: #start!restart	"Start a timer"	^self start!scheduleAt: aTime	"update a timer"	running 		ifFalse: [self error: 'Scheduling a stopped timer'].	lastUpdate :=  aTime.	self changed: #timer with: aTime."	Transcript show: '		T ', ((aTime - startTime) / 1000000.0 printString: 3); cr."	^aTime + (interval * 1000000) rounded!start	"Start a timer"	running := true.	startTime ifNil: [startTime := Time microsecondClock].	lastUpdate :=  startTime.	self changed: #start!stop	"Start a timer"	running := false.	lastUpdate :=  Time microsecondClock.	EventScheduler instance removerTimer: self	self changed! !!Siren.Timer methodsFor: 'accessing'!accumulator	^accumulator!accumulator: aValue	accumulator := aValue!interval	^interval!interval: aValue	interval := aValue!lastUpdate	^lastUpdate!lastUpdate: aValue	lastUpdate := aValue!name	^name!name: aValue	name := aValue!running	^running!running: aValue	running := aValue!startTime	^startTime!startTime: aValue	startTime := aValue.	running := false! !!Siren.LPCView methodsFor: 'accessing'!editor: ed	editor := ed! !!Siren.LPCView methodsFor: 'display'!displayOn: aGraphicsContext	"Show the receiver's pitch function and smoothed versions."	"LPCEditor openOn: LPCSound someInstance"	| data smoothed smoothed2 |	winSize := aGraphicsContext clippingBounds extent.	displayList := DisplayList new.	data := Array new: model frames size.	smoothed := Array new: model frames size.	smoothed2 := Array new: model frames size.				"draw raw data in gray"	editor showPitch value ifTrue: 		[1 to: model frames size do:			[ :i | data at: i put: ((model frames at: i) pitch value)].		self draw: data into: displayList color: ColorValue gray scale: 2 dots: true].				"running avg data in blue"	editor showRunning value ifTrue: 		[model smoothRunning: data into: smoothed.		self draw: smoothed into: displayList color: ColorValue blue scale: 2 dots: true].				"avg smoothed data in red"	editor showSmoothed value ifTrue: 		[model smoothAvg: data into: smoothed.		self draw: smoothed into: displayList color: ColorValue red scale: 2 dots: true].	editor showSmoothed2 value ifTrue: 		[model smoothAvg: data into: smoothed.		model smoothAvg: smoothed into: smoothed2.		self draw: smoothed2 into: displayList color: ColorValue green scale: 2 dots: true].	editor showRMS value ifTrue: 		[1 to: model frames size do:			[ :i | data at: i put: ((model frames at: i) rmsO)].		self draw: data into: displayList color: ColorValue yellow scale: 0.01 dots: false].	editor showResid value ifTrue: 		[1 to: model frames size do:			[ :i | data at: i put: ((model frames at: i) rmsR)].		self draw: data into: displayList color: ColorValue orange scale: 0.5 dots: false.		1 to: model frames size do:			[ :i | data at: i put: ((model frames at: i) err)].		self draw: data into: displayList color: ColorValue cyan scale: 500 dots: false].				"show the display list"	displayList displayOn: aGraphicsContext!draw: data into: list color: co scale: yScale dots: showD	"Answer a display list with the receiver's pitch function."	"LPCEditor openOn: LPCSound someInstance."	| pointArray boxArray xScale numFr x y w |	inset := 2.	w := 4.		"point w/h"	numFr := data size.	xScale := winSize x - (2 * inset) / numFr.	pointArray := Array new: numFr.	boxArray := Array new: numFr.	1 to: numFr do:		[ :i |		x := inset + (i * xScale).		y := winSize y - (yScale * (data at: i)).		pointArray at: i put: (x @ y).		showD ifTrue: [boxArray at: i 					put: ((DisplayRectangle offset: ((x-2)@(y-2)) extent: (w@w)) 							color: ColorValue black)]].	list add: ((DisplayPolyline			offset: 0@0)			color: co;			stroke: 2;			vertices: pointArray).	showD ifTrue: [list addAll: boxArray]! !!Siren.FunctionGraph methodsFor: 'accessing'!at: anIndex 	"Answer the value at the given index (between 0 and 1 -or- 1 and data size)."	| op1 op2 |	anIndex isSymbol		ifTrue: [^operandL at: anIndex].	operandL isEvent		ifFalse: [op1 := operandL]		ifTrue: [op1 := operandL at: anIndex].	operandR isEvent		ifFalse: [op2 := operandR]		ifTrue: [op2 := operandR at: anIndex].	^op1 perform: operation with: op2!operandL: aFcn	operandL := aFcn.	range := aFcn range.	domain := aFcn domain.!operandR: aValue	operandR := aValue!operation	^operation!operation: aValue	operation := aValue! !!Siren.FunctionGraph class methodsFor: 'instance creation'!opL: opL opR: opR operation: op	"Answer a new function graph"	^self new operandL: opL; operandR: opR; operation: op! !!Siren.FunctionGraph class methodsFor: 'examples'!example	"Open the sum of a triangle and a sine"	"FunctionGraph example"	| fcn1 fcn2 |	fcn1 := LinearFunction from: #((0 0) (0.5 0.9) (1 0)).	fcn2 := FourierSummation from: #((17 0.05 0))."	(FunctionGraph opL: fcn1 opR: fcn2 operation: #+) open"	(fcn1 + fcn2) open.! !!Siren.SmartAudioPort methodsFor: 'accessing'!inChannels	^inChannels!inChannels: aValue	inChannels := aValue!outClients	^outClients!setInputDevice	"Set the port to use the default input device"	self critical: [device := interface pa_out_device].		"output by default"! !!Siren.SmartAudioPort methodsFor: 'play/record'!callback	"Handle a callback from PortAudio; this is sent an an external callback""	verbose ifTrue: [Transcript show: '.']."	useProcess		ifTrue: [ioSemaphore signal]		ifFalse: [self doIO].	^nil!doIO	"Handle a callback from PortAudio; this is sent an an external callback through the class""	counter := counter + 1."	inChannels > 0 ifTrue: [self nextInBuffer]. 	outChannels > 0 ifTrue: [self nextOutBuffer]!nextInBuffer	"Get the next input buffer for the clients from the interface."	| index snd |	inClient ifNil: [^self].			"no input"	snd := inClient key.	index := inClient value.	1 to: bufferSize do:			"loop copying sample to the destination sound"		[ :count |		snd sampleAt: (count + index) put: (inBuffer at: count)].	inClient value: index + bufferSize!nextOutBuffer	"Get the next output buffer from the clients and sum it into my buffer for playing.""Loop through the output clients asking them to contribute to the buffer."	1 to: outClients size do:		[ :count | | ass ind |		ass := outClients at: count.					" aSound -> anIndex"		ind := ass key nextBufferInto: outBuffer 					frames: bufferSize channels: outChannels 					format: format startingAt: ass value."They return their frame index or nil when done."		ind isNil			ifTrue: [Transcript show: 'Playing client ', count printString, ' terminated'; cr.					outClients removeAtIndex: count]			ifFalse: [ass value: ind]]!play: aSound	"Play the argument on the receiver over the DACs."	outClients add: (aSound -> 0).	self nextOutBuffer.					"prime the pump"	self start: aSound duration asSec value.!record: aSound	"Record into the argument via the receiver."	inClient :=  (aSound -> 0).	self start: aSound duration asSec value.!start: duration	"Start the receiver's IO loop for the given duration."	self open."Start up the IO process"	useProcess		ifTrue: [ioProcess priority: Processor userInterruptPriority.			ioProcess resume]."Set up for the external callback"	CCallback classPool		at: #ForeignCallbackPriority		put: Processor userInterruptPriority - 1."Start PA thread"	self start."Fork a process to shut it down"		[duration wait.		useProcess ifTrue: [ioProcess terminate].		self stop] fork! !!Siren.SmartAudioPort methodsFor: 'initialize/release'!initialize	"Answer an initialized version of the receiver."	super initialize.	useProcess := true.					"use a separate thread, or do the IO in the callback thread"	inClient := nil.	outClients := OrderedCollection new.	counter := 0."Set the default settings"	bufferSize := self class blockSize.	inChannels := self class in.			"default = stereo input"	outChannels := self class out.			"default = stereo input""Set up callback block for driver"	callbackBlock := CCallback do: [SmartAudioPort callback] 								ofType: interface CallbackFcn."Set up semaphore and read/write loop"	useProcess		ifTrue: [ioSemaphore := Semaphore new.			ioProcess := [[ioSemaphore wait. 				self doIO. 				true] whileTrue] newProcess]! !!Siren.SmartAudioPort methodsFor: 'open/close'!close	"Close the receiver sound port"	super close.	useProcess ifTrue: [ioProcess terminate]."	Transcript show: counter printString, ' callbacks received'; cr."!open	"Open the receiver sound port"	| val |	isOpen ifTrue: [^self].	interface ifNil: [self initialize]."Allocate I/O buffers and put them in the heap."	((outChannels > 0) and: [outBuffer isNil])		ifTrue: [outBuffer := (UninterpretedBytes new: bufferSize * outChannels * 2) gcCopyToHeap].	((inChannels > 0) and: [inBuffer isNil])		ifTrue: [inBuffer := (UninterpretedBytes new: bufferSize * inChannels *2) gcCopyToHeap]."Open the PortAudio interface so that it sends the out-board fnuction."	self critical: [val := interface pa_open_s: device 						with: inChannels 						with: outChannels 						with: (PortAudioInterface const: format) 						with: rate 						with: bufferSize 						with: callbackBlock 				"the callback fnuction"						with: inBuffer 						with: outBuffer]."Report, set my status, and plug me in as the singleton"	SirenUtility log: 'SmartAudio open returned: ', val printString level: 1.	isOpen := true.	self class instance: self! !!Siren.SmartAudioPort class methodsFor: 'examples'!testPlay	"Test playing a sound through the call-back interface"	"SmartAudioPort testPlay"	"PortModel initialize"	"SmartAudioPort instance"	| port snd dur |	dur := 4.						" play for 4 seconds"	port := self new initialize.	port open.	snd := (SampledSound sawtoothDur: dur rate: 44100 freq: 10 chans: 1) scaleBy: 0.9."	snd := (SampledSound sweepDur: dur rate: 44100 from: 50 to: 500 chans: 2) scaleBy: 0.1."	port play: snd.	(dur + 0.5) wait.	port close.!testRecord	"SmartAudioPort testRecord"	| port snd |	port := self new initialize.	port in: 2.	port out: 0.	port setInputDevice.	port open.	snd := SampledSound duration: 5.0 named: 'recorded' rate: 44100 channels: 2 format: #lin16Bit.	port record: snd.	6 wait.	snd edit! !!Siren.SmartAudioPort class methodsFor: 'instance creation'!new	"Answer a new instance, or the singleton"	^useSingleton		ifTrue:  [singleton ifNil: [singleton := self basicNew initialize]. singleton]		ifFalse: [self basicNew initialize]! !!Siren.SmartAudioPort class methodsFor: 'callbacks'!callback	"Forward the callback to an instance"	singleton ifNotNil: [singleton callback]! !!Siren.Length methodsFor: 'private'!species	"Answer Duration."	^Duration! !!Siren.Length class methodsFor: 'examples'!example	"Demonstrate the use of an OrdinalMagnitude with a scale of length."	"Length example"	| a b c d e f |		"define six values with names."	Length useTable.	a := Length value: #sip.	b := Length value: #gasp.	c := Length value: #focus.	d := Length value: #inhale.	e := Length value: #gesture.	f := Length value: #breath.					"put them in some order."	a << b.	b << c.	c << d.	d << e.	e << f.					"now ask some queries and let them extrapolate."	Transcript show: '(f > e) ', (f > e) printString; cr.	Transcript show: '(f > b) ', (f > b) printString; cr.	Transcript show: '(f =? f) ', (f =? f) printString; cr.	Transcript show: '(f =? a) ', (f =? a) printString; cr.	Transcript show: '(f >= a) ', (f >= a) printString; cr.	Transcript show: '(d >= b) ', (d >= b) printString; cr.	Transcript show: '(b >= d) ', (b >= d) printString; cr.	Transcript show: '(f < a) ', (f < a) printString; cr.	Transcript show: '(a < f) ', (a < f) printString; cr.					"inspect them if you hold down <LEFT-SHIFT>"	Length allInstances asSortedCollection inspect! !!Siren.SpeciesTrainingTool class methodsFor: 'token stats'!addSrcTokens: srcFile	"Add tokens to the discriminator match methods in the given file"	"SpeciesTrainingTool 		addSrcTokens: '/Content/Code/BirdsEar/BirdsEarApp_Code/Discriminators/DiscriminatorsEast2.cpp'"	| src tok clName pos1 pos2 |	src := (Filename named: srcFile) contentsOfEntireFile.	pos1 := 1.	tok := '::match(Engine *eng, Recording * rec)'.	[pos1 > 0] whileTrue:		[pos1 := src findString: tok startingAt: pos1.		pos2 := pos1.		[(src at: pos2) == $ "space"] whileFalse: [pos2 := pos2 - 1].		clName := src copyFrom: pos2 + 1 to: pos1 - 1.		Transcript show: clName; cr.	]	"	float AmericanGoldfinchSong::match(Engine *eng, Recording * rec) {	#if TRAIN		TRAIN_SPECIES	#else		MATCH_PREAMBLE							// preamble declares conf, evts, labs, mnD & mxD		CHECK_ELIST_SIZE(0, 20, 0.9f, false)		CHECK_ELIST_DUR(1.625, 3.109, 0.9f, false)		CHECK_MN_DUR(0.024, 0.025, 0.9f)		CHECK_MX_DUR(0.191, 0.211, 0.9f)		EVENT_LOOP_OPEN							// event loop; defines ev, lab & tag			SIF_TAG_NIN(tag, tDUR, '456', 0.9f)		EVENT_LOOP_CLOSE		return conf;								// bingo!!		MATCH_HANDLER								// catch exceptions	#endif"!addSrcTokens: srcFile to: outFile	"Add tokens to the discriminator match methods in the given file"	"SpeciesTrainingTool 		addSrcTokens: '/Content/Code/BirdsEar/BirdsEarApp_Code/Discriminators/DiscriminatorsEast1.cpp'		to: '/Content/Code/BirdsEar/BirdsEarApp_Code/Discriminators/DiscriminatorsEast1b.cpp' "	| src clName pos0 pos1 pos2 out |	src := (Filename named: srcFile) contentsOfEntireFile.	out := (Filename named: outFile) writeStream.	pos0 := pos1 := 1." Loop looking for matching method signature"	[pos1 > 0] whileTrue:		[pos1 := src findString: '::match(Engine *eng, Recording * rec)' startingAt: pos1.		(pos1 > 0) ifTrue:			[pos2 := pos1.			[(src at: pos2) == $ "space"] whileFalse: [pos2 := pos2 - 1]."copy class name"			clName := src copyFrom: pos2 + 1 to: pos1 - 1.			Transcript show: clName; cr.			pos1 := src findString: 'MATCH_PREAMBLE' startingAt: pos1.			(pos1 > 0) ifTrue:				[pos1 := src nextIndexOf: Character cr from: pos1 to: src size."write up through MATCH_PREAMBLE, then class token"				out nextPutAll: (src copyFrom: pos0 to: pos1).				out nextPutAll: ('	//-- ', clName, ' match'); cr.				pos0 := pos1 + 1.				pos1 := src findString: 'EVENT_LOOP_CLOSE' startingAt: pos1.				pos1 := src nextIndexOf: Character cr from: pos1 to: src size.				out nextPutAll: (src copyFrom: pos0 to: pos1).				out nextPutAll: ('	//-- END'); cr.				pos0 := pos1 + 1.	]]].	out close"	float AmericanGoldfinchSong::match(Engine *eng, Recording * rec) {	#if TRAIN		TRAIN_SPECIES	#else		MATCH_PREAMBLE							// preamble declares conf, evts, labs, mnD & mxD		CHECK_ELIST_SIZE(0, 20, 0.9f, false)		CHECK_ELIST_DUR(1.625, 3.109, 0.9f, false)		CHECK_MN_DUR(0.024, 0.025, 0.9f)		CHECK_MX_DUR(0.191, 0.211, 0.9f)		EVENT_LOOP_OPEN							// event loop; defines ev, lab & tag			SIF_TAG_NIN(tag, tDUR, '456', 0.9f)		EVENT_LOOP_CLOSE		return conf;								// bingo!!		MATCH_HANDLER								// catch exceptions	#endif"!confusionStatsSummaryFor: txtFile	"BEApp confusion stats summary - read confusion summary spreadsheet and print the 'noisiest' species"	"SpeciesTrainingTool confusionStatsSummaryFor: '/Content/Code/BirdsEar/Doc/SpeciesConfusion_141128.txt' "	| inF spec results confusion scoll |	Transcript clear; cr; show: '--------------------------------------------------------------------------------------'; cr; cr.	Transcript show: 'Summary Stats'; cr; cr.	inF := txtFile asFilename readStream.	results := Dictionary new.	confusion := Dictionary new."Loop through file reading the song names"	[inF atEnd] whileFalse:		[ | lin tok num ch |		lin := ReadStream on: (inF upTo: Character cr).		ch := lin peek.		((ch == nil) or: [(ch == Character cr) or: [(ch == Character tab) or: [ch == $-]]]) ifFalse:			[tok := (lin upTo: Character tab) asSymbol.			lin skip: 2.			num := Number readFrom: lin.			Transcript show: tok string, '		', num printString; cr.			results at: tok put: num asFloat.			confusion at: tok put: 0.0]].	inF close."Print sorted summary stats"	Transcript cr; show: '--------------------------------------------------------------------------------------'; cr.	Transcript cr; show: 'Summary Stats Sorted'; cr; cr.	scoll := SortedCollection new.	results associationsDo: [ :ass | scoll add: ass].	scoll sort: [:a :b | a value > b value].	scoll do: [ :ass |		(ass value > 0) ifTrue: 			[Transcript show: ass key string, '		',  ass value asInteger printString; cr]].	Transcript cr; show: '--------------------------------------------------------------------------------------'; cr.	Transcript cr; show: 'Confusion Stats'; cr; cr.	inF := txtFile asFilename readStream."Loop through the file accumulating confusing species"	spec := ''.	[inF atEnd] whileFalse:		[ | lin tok num val ch |		lin := ReadStream on: (inF upTo: Character cr).		val := 1.0.		ch := lin peek.		((ch == nil) or: [(ch == Character cr) or: [ch == $-]]) ifFalse:		[(ch == Character tab)			ifFalse:				[spec := (lin upTo: Character tab) asSymbol.				val := results at: spec.				val == 0.0 ifTrue: [val := 1.0]]			ifTrue: [lin skip: 1.				tok := (lin upTo: Character tab) asSymbol.				tok == spec ifFalse:					[num := Number readFrom: lin."					Transcript show: spec printString, '		',  tok printString, '		', num printString; cr."					(confusion includesKey: tok) ifTrue:						[confusion at: tok put: ((confusion at: tok) + (num / (val)))]]]]]."Copy results to a sorted collection, reverse sort and print"	scoll := SortedCollection new.	confusion associationsDo: [ :ass | scoll add: ass].	scoll sort: [:a :b | a value > b value].	scoll do: [ :ass |		(ass value > 0) ifTrue: 			[Transcript show: ass key string, '		',  ass value asInteger printString; cr]].	inF close.	Transcript cr" ; show: 'Found ', confusion size printString, ' items'; cr."!copyPlayList: srcFile	"Copy and rename MP3 files"	"copyPlayList: srcFile"	| src tok clName pos1 pos2 |	src := (Filename named: srcFile) contentsOfEntireFile.	pos1 := 1.	tok := '::match(Engine *eng, Recording * rec)'.	[pos1 > 0] whileTrue:		[pos1 := src findString: tok startingAt: pos1.		pos2 := pos1.		[(src at: pos2) == $ "space"] whileFalse: [pos2 := pos2 - 1].		clName := src copyFrom: pos2 + 1 to: pos1 - 1.		Transcript show: clName; cr.	]	""!copyPlayList: srcFile in: folder	"Copy and rename MP3 files"	"SpeciesTrainingTool copyPlayList: 'list.txt' in: '/Content/Sound/Sampler CDs/Sumer2014/' "	| list srcName destName count pref pos |	list := (Filename named: folder, srcFile) readStream.	count := 1.	Transcript clear.	[list atEnd] whileFalse:		[srcName := list upTo: Character cr.		pos := srcName lastIndexOf: $/.		count < 10			ifTrue: [pref := '0', count printString]			ifFalse: [pref := count printString].		destName := folder, pref, ' - ', (srcName copyFrom: pos + 1 to: srcName size)."		Transcript show: 'Copy ', srcName; crtab; show: ' to ', destName; cr."		[(Filename named: srcName) copyTo: destName]			on: Error			do: [Transcript show: 'Error copying ', srcName; crtab; show: ' to ', destName; cr.].		count := count + 1.	]!copySelectionFrom: topFolder in: inFolders to: outFolder	"Copy a random sample of the old files to the new folder"	"SpeciesTrainingTool copySelectionFrom: '/Users/stp/Business/BirdsEar/Analysis4/' 		in: #('AMECRO' 'AMEGOL L flight call long' 'AMEGOL flight call short' 'AMEGOL song' 'AMEROB high call' 'AMEROB regular call' 			'AMEROB song' 'BALORI songs' 'BAROWL full call' 'BLCACH harsh call' 'BLCACH song' 'BLUJAY main call' 'BLUJAY short shriek' 			'BRHCOW high slur' 'BRHENU calls' 'BROTHR songs' 'CARCHI harsh' 'CARCHI song only' 'CARWRE call' 'CARWRE songs' 			'CEDWAX' 'CHISPA song' 'COMGRA' 'COMYEL' 'COOHAW' 'DAEJUN trill' 'DAEJUN tu tu' 'DOWWOO call' 'DOWWOO whinny' 			'EASOWL Whinny Files' 'EASPHO 2' 'EASTOW drink only' 'EASTOW drink tea' 'EAWOPE' 'EUCDOV songs' 'EURSTA scold' 			'EUSTAR general call' 'FISCRO ts' 'GRACAT call' 'GRACAT song' 'GRCFLY clear only' 'GRCFLY wheep only' 'GRHOOW main song' 			'HAIWOO' 'HOUFIN' 'HOUSPA' 'HOUWRE ts' 'INDBUN song' 'KILDEE strip' 'MOUDOV' 'NORCAR' 'NORFLI LONG CALLS' 			'NORFLI SHORT EUW CALL' 'NORMOC files to use' 'ORCORI songs' 'PILWOO main calls' 'PURFIN songs ID Criteria' 			'REBEWO CHACK CALLS' 'REBEWO CHURR' 'REBRNU calls' 'REEVIR songs' 'RESHAW' 'REWBLA oklee' 'ROBGRO songs' 			'ROCPIG call seq' 'ROCPIG single calls' 'SCATAN songs' 'SONSPA' 'SUMTAN songs' 'TUFTIT harsh call' 'TUFTIT peter song' 			'VEERY songs' 'WARVIR SONGS' 'WHBRNU' 'WHPOWI call' 'WHTHSP SONG analyze' 'WOOTHR songs' 'YELWAR')		to: '/Users/stp/Business/BirdsEar/Analysis4/3b_Selections' "	|  num outF inFolder inFiles fi rnd oFiles |	num := 5.	outF := outFolder asFilename.	outF exists ifFalse: [ ^nil ].	rnd := Random new.	Transcript clear.	inFolders do: [ :di |		Transcript show: di; cr.		inFolder := (topFolder, di) asFilename.		inFiles := inFolder directoryContents.		inFiles := inFiles select: [ :it | '*.wav' match: it].		oFiles := OrderedCollection new.		1 to: num do: [ : ind |			fi := inFiles atRandom: rnd.			[(topFolder, di, '/', fi) asFilename isDirectory] whileTrue: [fi := inFiles atRandom: rnd].			[oFiles includes: fi] whileTrue: [fi := inFiles atRandom: rnd].			(topFolder, di, '/', fi) asFilename copyTo: (outFolder, '/', di, '_', ind printString, '.wav').			oFiles addLast: fi.		]	]!cvsTranslate: inFile toXML: dir	"Take the metadata spreadsheet and copy it to the XML folders"	"SpeciesTrainingTool 		cvsTranslate: '/Users/stp/Business/BirdsEar/Analysis4/0_Metadata/SpecDataEast.tsv'		toXML: '/Content/Code/BirdsEar/BirdsEarApp_Code/Data/XML/' "	| src list lin snam tnam fnam xml desc crTab |	Transcript clear.	src := (Filename named: inFile) readStream."Skip first line"	lin := src skipThrough: Character cr."loop through lines creating the XML files"	[src atEnd] whileFalse:		[lin := src upTo: Character cr.		lin isEmpty ifFalse:			[list := lin asSequenceableCollection: $	 "tab" .			(list size < 22) ifTrue:				[22 - list size timesRepeat: [list addLast: '']].			snam := list first.								"spec name"			tnam := snam copyReplaceAll: ' ' with: '_'.		"token name"			fnam := tnam copyReplaceAll: '''' with: ''.		"file name""			Transcript show: fnam; cr.""Create and write XML file"			fnam := dir, fnam, '.xml'.			xml := (Filename named: fnam) writeStream.			Transcript show: 'Writing ', fnam; cr."add CRs to description""			crTab := '.', (String with: Character cr), '    '. "			crTab := '.', (String with: Character cr with: Character cr).			desc := (list at: 3) copyReplaceAll: '.    ' with: crTab.			desc := desc copyReplaceAll: '.   ' with: crTab.			desc := desc copyReplaceAll: '.  ' with: crTab.			xml nextPutAll: ('<?xml version="1.0" encoding="UTF-8" ?><BE_SPECIES>	<Name>', snam, '</Name>	<LatinName>', (list at: 2), '</LatinName>	<MinimumLatitude>-90</MinimumLatitude>	<MaximumLatitude>90</MaximumLatitude>	<MinimumLongitude>-180</MinimumLongitude>	<MaximumLongitude>180</MaximumLongitude>	<MinimumDay>0</MinimumDay>	<MaximumDay>365</MaximumDay>	<MinimumTime>0</MinimumTime>	<MaximumTime>2400</MaximumTime>	<MinimumDuration>0.01</MinimumDuration>	<MaximumDuration>10.0</MaximumDuration>	<WP_URL>http://en.wikipedia.org/wiki/', tnam, '</WP_URL>	<IB_URL>', (list at: 4), '</IB_URL>	<Picture1>', (list at: 5), '</Picture1>	<Picture2>', (list at: 6), '</Picture2>	<Picture3>', (list at: 7), '</Picture3>	<Picture4>', (list at: 8), '</Picture4>	<Song1>', (list at: 9), '</Song1>	<Song1Title>', (list at: 10), '</Song1Title>	<Song2>', (list at: 11), '</Song2>	<Song2Title>', (list at: 12), '</Song2Title>	<Song3>', (list at: 13), '</Song3>	<Song3Title>', (list at: 14), '</Song3Title>	<Song4>', (list at: 15), '</Song4>	<Song4Title>', (list at: 16), '</Song4Title>	<Song5>', (list at: 17), '</Song5>	<Song5Title>', (list at: 18), '</Song5Title>	<Song6>', (list at: 19), '</Song6>	<Song6Title>', (list at: 20), '</Song6Title>	<Song7>', (list at: 21), '</Song7>	<Song7Title>', (list at: 22), '</Song7Title>	<Description>', desc, '</Description></BE_SPECIES>'); cr.				xml close]].	src close"FieldsCommon NameLatin NameDescriptionAllAboutBirds LinkPicture 1 NamePicture 2 NamePicture 3 NamePicture 4 NameSong 1Song 1 TitleSong 2Song 2 TitleSong 3Song 3 TitleSong 4Song 4 TitleSong 5Song 5 TitleSong 6Song 6 TitleSong 7Song 7 Title"!eventStatsFor: toks	"BEApp event list stats"	| cnt stats nams num |	nams := #(nEvts Dur mnDur mxDur ).	stats := Array new: 4.	num := toks size / 4.	cnt := 1.	Transcript clear; cr; show: 'Processing ', num printString, ' lines; '; cr."Init arrays"	1 to: 4 do: [ :ind |		stats at: ind put: (Array new: num)]."copy data to matrix"	1 to: num do: [ :ind |		1 to: 4 do: [ :in2 | (stats at: in2) at: ind put: (toks at: cnt). 			cnt := cnt + 1]]."Calc min/max"	1 to: 4 do: [ :ind |  | mn mx sm va av dv |		mx := -1000000.		mn := 1000000.		sm := 0.		dv := 0.		1 to: num do: [ :in2 |			va := (stats at: ind) at: in2.			(va > mx) ifTrue: [mx := va].			(va < mn) ifTrue: [mn := va].			sm := sm + va].		av := (sm / num) asFloat.		dv := 0.		1 to: num do: [ :in2 |			va := (stats at: ind) at: in2.			dv := dv + (va - av) squared].		dv := dv / num.		Transcript tab; show: (nams at: ind) printString, '		', 				mn printString, '	-	', 				mx printString, '		a ', 				av printString, '	d ', 				dv asFloat printString, '		s0 ', 				((av - dv) max: 0) printString, '	s1 ', 				(av + dv) asFloat printString; cr]!removeDupFiles0: oldFolder with: newFolder	"Remove files in old from new"	"SpeciesTrainingTool removeDupFiles: '/Content/Code/new/birdsearappPreEx164' with: '/Content/Code/new/birdsearapp499'  "	| inFiles outFiles cmpBlok iFil oFil inDir outDir |	inFiles := oldFolder asFilename directoryContents.	outFiles := newFolder asFilename directoryContents.	cmpBlok := [ :old1 :new1 | | newF | 			newF := new1 asFilename. 			(newF exists) ifTrue: 				[Transcript show: 'Remove ',  new1 printString; cr.			"	newF delete]"].	inFiles do: [ :fNam | 		iFil := fNam asFilename.		oFil := outFiles detect: [ :ea | ea = fNam] ifNone: [nil].		oFil ifNotNil: 			[iFil isDirectory				ifTrue: [ | iFi2 oFi2 |					inDir := iFil directoryContents.					outDir := oFil asFilename directoryContents.				"		iFi2 := iFil constructSafe:  "						inFiles do: [ :fNa2 | 						iFil := fNa2 asFilename. ]]				ifFalse: [					]			]]]!removeDupFiles: oldFolder with: newFolder	"Remove files in old from new"	"SpeciesTrainingTool removeDupFiles: '/Content/Code/new/birdsearappPreEx164' with: '/Content/Code/new/birdsearapp499'  "	| inFiles outFiles cmpBlok iFil oFil inFolder outFolder |	inFolder := oldFolder asFilename.	outFolder := newFolder asFilename.	outFolder exists ifFalse: [ ^nil ].	inFiles := inFolder directoryContents.	outFiles := outFolder directoryContents."	Transcript show: 'removeDupFiles: ', oldFolder, ' with: ', newFolder; cr."	cmpBlok := [ :old1 :new1 | | newF | 			newF := new1 asFilename. 			(newF exists) ifTrue: 				[Transcript show: 'Remove ',  new1 printString; cr.				newF delete  ]].	(inFiles select: [ :fn | fn ~= '.svn']) do: [ :fNam | 		iFil := oldFolder asFilename construct: fNam.		oFil := outFiles select: [ :ea | ea = fNam].		oFil isNil			ifTrue: [Transcript show: '	Not found: ',  fNam printString; cr.] 			ifFalse: [oFil := newFolder asFilename construct: fNam.				iFil exists ifTrue: [iFil isDirectory					ifTrue: [SpeciesTrainingTool removeDupFiles: (iFil asString) with: (oFil asString) ]					ifFalse: [cmpBlok value: (iFil asString) value: (oFil asString)]]]]!tokenStatsFor: toks	"BEApp Token list stats"	"SpeciesTrainingTool tokenStatsFor: #( 547835 557735 357875 555835 ) "	| nams sums val |	nams := #(Dur Pitch BWidth Gliss Harm Ampl ).	sums := Array new: 10.	Transcript clear; cr; show: 'Processing ',  toks size printString, ' tokens; ',						toks first printString size printString, ' labels.'; cr.	1 to: toks first printString size do: [ :ind |		1 to: 10 do: [ :in2 | sums at: in2 put: 0].		toks do: [ :to |			val := (to printString at: ind) asInteger - $0 asInteger."			Transcript show: ' ',  val printString."			sums at: val put: ((sums at: val) + 1)].		Transcript show: 'Res for ', (nams at: ind) printString; cr.		1 to: 10  do: [ :in2 | ((sums at: in2) > 0) 			ifTrue: [Transcript tab; show: in2 printString, ' = ', (sums at: in2) printString; cr]]]! !!Siren.Oriental class methodsFor: 'interval list'!intervalList	"tire de McLaughlin et le Mahavishnu Orchestra"	^#(#unison #minorSecond #minorThird #perfectFourth #diminishedFifth #majorSixth #majorSeventh )! !!Siren.SpectrumView methodsFor: 'controller access'!defaultControllerClass	"Answer the default controller class for use with the receiver."	^ControllerWithMenu! !!Siren.SpectrumView methodsFor: 'accessing'!color: aBoolean	"set the color/bw switch"	isColor := aBoolean! !!Siren.SpectrumView methodsFor: 'displaying'!colorForValue: theDatum	"Answer the color to use for the given data value"	| compressedDatum |	compressedDatum :=  theDatum sqrt sqrt.		^isColor == true		ifTrue: [ColorValue hue: (1.0 - compressedDatum) saturation: 1 brightness: 1]		ifFalse: [ColorValue brightness: (1.0 - (compressedDatum min: 1.0))]!displayOnGC1: aGC	"Show the receiver's sound on the GC."	"Spectrum sweepExample display"	 Tools.ProfilerCore new			samplingInterval: 3;			profile:	[self displayOnGC0: aGC]!displayOnGC: aGC	"Show the receiver's sound on the GC."	"Spectrum sweepExample display"	| sound box ssize fftLen boxW boxH ext range dscale doffset bottom |	box := aGC clippingBounds.	aGC clear.	aGC paint: DisplayListView foregroundColor.	model ifNil: [^self].	sound := self sound.	sound ifNil: [^self].	ssize := sound size.	fftLen := ((sound windowSize / 4) min: box height).	bottom := box bottom.	boxW := box width / ssize.		"slice width"	boxH := box height / fftLen.	"bin height"	ext := boxW @ boxH.	range := sound range.	dscale := (1.0 / range size) * 0.9.			"clip a bit at the top"	doffset :=  range first."Loop for the spectral slices"	1 to: ssize do:		[ :counter | | slice |"Loop for the values within the slice"		slice := sound data at: counter.		1 to: fftLen do:			[ :bin | | datum |			datum :=  ((slice at: bin) - doffset * dscale).		"sqrt to compress a bit"			aGC paint: (self colorForValue: datum).			aGC displayRectangle: (((counter - 1 * boxW) @ (bottom - (bin - 1 * boxH))) extent: ext)]]! !!Siren.SpectrumView class methodsFor: 'instance creation'!openOn: aSound	"Open a SpectrumView"	| topView topWindow |	topView := (self spectrumViewOn: aSound) components first.	topWindow := (ScheduledWindow model: aSound			label: ('Spectrum View on: ', aSound name)			minimumSize: 800@500).	topWindow component: topView.	topWindow icon: (Icon constantNamed: #systemBrowser).	topWindow openWithExtent: topWindow minimumSize!spectrumViewOn: aSpectrum	"Take the given spectrum as model and open a SpectrumView"	| topView me editor edgeDecorator |	topView := CompositePart new.	me := self new initialize.	editor := SoundEditor new sound: aSpectrum.	me model: editor.	me color: true.	editor view: me."SoundView"	edgeDecorator := LookPreferences edgeDecorator on: me.	edgeDecorator noVerticalScrollBar; noHorizontalScrollBar; noMenuBar.	topView add: edgeDecorator			in: (LayoutFrame new leftFraction: 0; topFraction: 0; rightFraction: 1; bottomFraction: 1).	^topView! !!Siren.MIDIPitch methodsFor: 'printing'!units	"Answer the units string of the receiver."	^' key'! !!Siren.MIDIPitch methodsFor: 'converting'!asFracMIDI	"Answer a fractionalMIDIPitch (or integer if value is no fraction)."	"60 key asFracMIDI "	"60.4 key asFracMIDI "	^self!asFracSymbol	"Assuming value is a key number, answer a symbolic pitch name"	"(Pitch value: 37) asSymbol "	"(Pitch value: 41.6 key) asSymbol "	"(443 Hz) asFracSymbol inspect"	"( asSymbol throws away microtonal offset, asFracSymbol keeps it.)"		^SymbolicPitch fromFracMIDI: value.!asHertz	"Assuming value is a key number, answer a frequency"	"(Pitch value: 69) asHertz"			"440.0 is Midi key 69"	"(Pitch value: 60) asHertz"			"261.62... is Midi key 60"	"(Pitch value: 60.51 key) asHertz"	"269.44... is Midi key 60 + 51 cents."			"NOTE: the key message coerces a float to become a MIDIPitch;			by default a float becomes a PitchHertz. 			(see class Pitch, instance creation)"	"(8.17579891564371 = MIDInote 0 in Hz.)"	^HertzPitch new value: (8.17579891564371 * (2.0 raisedTo:									((value asFloat) / 12.0)))!asHz	"Assuming value is a key number, answer a frequency"	"(Pitch value: 69) asHertz"		"440.0 is Midi key 69"	"(Pitch value: 60) asHertz"		"261.0 is Midi key 60"	"(Pitch value: 60.51 key) asHertz"	"269.44... is Midi key 60 + 51 cents."	^self asHertz!asMIDI	"Answer a MIDIPitch."	"60 key asMIDI "	"60.6 key asMIDI "	(value isMemberOf: SmallInteger)			ifTrue: [^self].	(value isMemberOf: Float)			ifTrue: [^self value rounded key].!asSymbol	"Assuming value is a key number, answer a symbolic pitch name"	"(Pitch value: 37) asSymbol"	^SymbolicPitch fromMIDI: value!mostGeneral	"Answer the most numerically meaningful version of the receiver."	^self asHertz! !!Siren.MIDIPitch methodsFor: 'private'!species	"Answer Pitch."	^Pitch! !!Siren.MIDIPitch class methodsFor: 'class initialization'!initialize	"Initialize the class instance variable."	"MIDIPitch initialize."	range := 1 to: 127! !!Siren.MIDIPitch class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asKey! !!Siren.MSecondDuration methodsFor: 'printing'!units	"Answer the units string of the receiver."	^' msec'! !!Siren.MSecondDuration methodsFor: 'converting'!asMseconds	"Answer a MSecondDuration."	^self!asSeconds	"Answer a float of seconds."	^SecondDuration new value: (value / 1000) asFloat!asUseconds	"Answer a float of micro seconds."	^USecondDuration new value: (value * 1000) truncated! !!Siren.MSecondDuration class methodsFor: 'coercion'!ddMsgName	"Answer the selector to be used in coercing double-dispatching messages."	^#asMsec! !!Tools.ListWorkBook class methodsFor: 'interface specs'!listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&Page' 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&New' 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Open...' 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Save' 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save &As...' 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Load All...' 							#nameKey: #loadAll 							#value: #loadAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save All...' 							#nameKey: #saveAll 							#value: #saveAll ) 						#(#{UI.MenuItem} 							#rawLabel: '&Rename...' 							#nameKey: #pageRename 							#value: #pageRename 							#enablementSelector: #canRenamePage ) 						#(#{UI.MenuItem} 							#rawLabel: '&Tear Off' 							#nameKey: #pageTearOff 							#value: #pageTearOff 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Re&move' 							#nameKey: #pageClose 							#value: #pageClose 							#enablementSelector: #canClosePage ) ) #(1 5 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&Edit' 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&Undo' 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Cu&t' 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Copy' 							#nameKey: #editCopy 							#value: #copySelection 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Paste' 							#nameKey: #editPaste 							#value: #paste 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Select &All' 							#nameKey: #editSelectAll 							#value: #selectAll 							#shortcutKeyCharacter: $A 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: '&Encoding' 							#nameKey: #editEncoding ) ) #(1 3 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&Smalltalk' 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&Do it' 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Print it' 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Inspect it' 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $I 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'De&bug it' 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&File it In' 							#value: #smalltalkFileItIn ) 						#(#{UI.MenuItem} 							#rawLabel: '&Namespaces...' 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #namespaces ) ) ) #(4 1 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray!menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&Page' 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&New' 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Open...' 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Save' 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save &As...' 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Load All...' 							#nameKey: #loadAll 							#value: #loadAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save All...' 							#nameKey: #saveAll 							#value: #saveAll ) 						#(#{UI.MenuItem} 							#rawLabel: '&Rename...' 							#nameKey: #pageRename 							#value: #pageRename 							#enablementSelector: #canRenamePage ) 						#(#{UI.MenuItem} 							#rawLabel: '&Tear Off' 							#nameKey: #pageTearOff 							#value: #pageTearOff 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Re&move' 							#nameKey: #pageClose 							#value: #pageClose 							#enablementSelector: #canClosePage ) ) #(1 5 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&Edit' 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&Undo' 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Cu&t' 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Copy' 							#nameKey: #editCopy 							#value: #copySelection 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Paste' 							#nameKey: #editPaste 							#value: #paste 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Select &All' 							#nameKey: #editSelectAll 							#value: #selectAll 							#shortcutKeyCharacter: $A 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: '&Encoding' 							#nameKey: #editEncoding ) ) #(1 3 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&Smalltalk' 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&Do it' 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Print it' 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Inspect it' 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $I 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'De&bug it' 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&File it In' 							#value: #smalltalkFileItIn ) 						#(#{UI.MenuItem} 							#rawLabel: '&Namespaces...' 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #namespaces ) ) ) #(4 1 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray!topicMenu	"MenuEditor new openOnClass: self andSelector: #menuBar"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&Page' 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&New' 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Open...' 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Save' 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save &As...' 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Load All...' 							#nameKey: #loadAll 							#value: #loadAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save All...' 							#nameKey: #saveAll 							#value: #saveAll ) 						#(#{UI.MenuItem} 							#rawLabel: '&Rename...' 							#nameKey: #pageRename 							#value: #pageRename 							#enablementSelector: #canRenamePage ) 						#(#{UI.MenuItem} 							#rawLabel: '&Tear Off' 							#nameKey: #pageTearOff 							#value: #pageTearOff 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Re&move' 							#nameKey: #pageClose 							#value: #pageClose 							#enablementSelector: #canClosePage ) ) #(1 5 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&Edit' 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&Undo' 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Cu&t' 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Copy' 							#nameKey: #editCopy 							#value: #copySelection 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Paste' 							#nameKey: #editPaste 							#value: #paste 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Select &All' 							#nameKey: #editSelectAll 							#value: #selectAll 							#shortcutKeyCharacter: $A 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: '&Encoding' 							#nameKey: #editEncoding ) ) #(1 3 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&Smalltalk' 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&Do it' 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Print it' 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&Inspect it' 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $I 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'De&bug it' 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&File it In' 							#value: #smalltalkFileItIn ) 						#(#{UI.MenuItem} 							#rawLabel: '&Namespaces...' 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #namespaces ) ) ) #(4 1 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray!windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Workspace Outline' 			#min: #(#{Core.Point} 128 156 ) 			#max: #(#{Core.Point} 1600 1600 ) 			#bounds: #(#{Graphics.Rectangle} 636 281 1099 790 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -4 0.333333 ) 					#name: #pageList 					#model: #pageList 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.333333 0 1 0 1 ) 					#name: #textView 					#flags: 0 					#clientKey: #textView ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -4 0.333333 0 1 0 0.333333 ) 					#name: #ResizingSplitter1 					#flags: 8 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'pageList' 					#belowWidgets: 'textView' ) ) ) )! !!Siren.EventListTreeEditor class methodsFor: 'interface specs'!windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Siren EventList Tree' 			#bounds: #(#{Graphics.Rectangle} 528 71 1119 589 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #treeView 					#model: #listTree 					#menu: #treeMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'treeView' 					#belowWidgets: 'subcanvas' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #subcanvas 					#majorKey: #{Siren.DisplayListSubcanvas} 					#minorKey: #windowSpec 					#clientKey: #scoreView ) ) ) )! !!Siren.DisplayListController class methodsFor: 'resources'!defaultEditMenu	"MenuEditor new openOnClass: self andSelector: #defaultEditMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'group' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'group' 							#value: #groupItems 							#shortcutKeyCharacter: $g 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'ungroup' 							#value: #ungroupItems 							#shortcutKeyCharacter: $u 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'flatten' 							#value: #flattenItems ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'edit' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'copy' 							#value: #copyItem 							#shortcutKeyCharacter: $c 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'cut' 							#value: #cutItem 							#shortcutKeyCharacter: $x 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'paste' 							#value: #pasteItem 							#shortcutKeyCharacter: $v 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'paste from buffer...' 							#value: #pasteFromBuffer 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'again' 							#value: #again 							#shortcutKeyCharacter: $a 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'undo' 							#value: #undo 							#shortcutKeyCharacter: $z 							#shortcutModifiers: 2 ) ) #(4 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'inspect' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'model' 							#value: #inspectModel 							#shortcutKeyCharacter: $i 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'editor' 							#value: #inspectEditor 							#shortcutKeyCharacter: $e 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'display' 							#value: #inspectDisplayList ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'display' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'redraw' 							#value: #redrawView ) 						#(#{UI.MenuItem} 							#rawLabel: 'zoom to 1:1' 							#value: #zoomTo1 							#shortcutKeyCharacter: $1 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'zoom in to point' 							#value: #zoomInPoint ) 						#(#{UI.MenuItem} 							#rawLabel: 'zoom out from point' 							#value: #zoomOutPoint ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'options...' 				#value: #optionsDialog ) ) #(5 ) nil ) decodeAsLiteralArray! !!Siren.TimeSequenceController class methodsFor: 'resources'!defaultEditMenu	"Tools.MenuEditor new openOnClass: self andSelector: #defaultEditMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'play' 				#value: #play ) 			#(#{UI.MenuItem} 				#rawLabel: 'group' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'group' 							#value: #groupItems 							#shortcutKeyCharacter: $g 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'ungroup' 							#value: #ungroupItems 							#shortcutKeyCharacter: $u 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'flatten' 							#value: #flattenItems ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'edit' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'copy' 							#value: #copyItem 							#shortcutKeyCharacter: $c 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'cut' 							#value: #cutItem 							#shortcutKeyCharacter: $x 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'paste' 							#value: #pasteItem 							#shortcutKeyCharacter: $v 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'paste from buffer...' 							#value: #pasteFromBuffer 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'again' 							#value: #again 							#shortcutKeyCharacter: $a 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'undo' 							#value: #undo 							#shortcutKeyCharacter: $z 							#shortcutModifiers: 2 ) ) #(4 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'inspect' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'model' 							#value: #inspectModel 							#shortcutKeyCharacter: $i 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'editor' 							#value: #inspectEditor 							#shortcutKeyCharacter: $e 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'display' 							#value: #inspectDisplayList ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'display' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'redraw' 							#value: #redrawView ) 						#(#{UI.MenuItem} 							#rawLabel: 'zoom to 1:1' 							#value: #zoomTo1 							#shortcutKeyCharacter: $1 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 'zoom in to point' 							#value: #zoomInPoint ) 						#(#{UI.MenuItem} 							#rawLabel: 'zoom out from point' 							#value: #zoomOutPoint ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'options...' 				#value: #optionsDialog ) ) #(6 ) nil ) decodeAsLiteralArray! !!Siren.SoundFileViewer class methodsFor: 'interface specs'!windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 640 427 1120 731 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -28 1 ) 					#name: #text 					#model: #textHolder 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -24 1 -2 0.2 -2 1 ) 					#name: #ActionButton1 					#model: #playFile 					#label: 'Play' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.2 -24 1 -2 0.4 -2 1 ) 					#name: #ActionButton2 					#model: #editFile 					#label: 'Edit' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.8 -24 1 -2 1 -2 1 ) 					#name: #ActionButton3 					#model: #deleteFile 					#label: 'Delete' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.6 -24 1 -2 0.8 -2 1 ) 					#name: #ActionButton4 					#model: #makeS7 					#label: 'make S7' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.4 -24 1 -2 0.6 -2 1 ) 					#name: #ActionButton5 					#model: #loadFile 					#label: 'Load' 					#style: #systemDefault 					#defaultable: true ) ) ) )! !!Siren.EventListPanel class methodsFor: 'interface specs'!windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Event List Panel' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 645 261 1119 889 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.416666 ) 					#name: #Dialog 					#majorKey: #{Siren.EventListDialog} 					#minorKey: #dialogCanvas 					#clientKey: #editorView ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.416666 0 1 0 0.666666 ) 					#name: #Text 					#majorKey: #{Siren.EventListText} 					#minorKey: #textCanvas1 					#clientKey: #textView ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.666666 0 1 0 1 ) 					#name: #Score 					#majorKey: #{ScoreView} 					#minorKey: #scoreCanvas1 					#clientKey: #scoreView ) ) ) )! !!Siren.DisplayListSubcanvas class methodsFor: 'interface specs'!windowSpec4Square	"UIPainter new openOnClass: self andSelector: #windowSpec4Square"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Display List View' 			#bounds: #(#{Graphics.Rectangle} 640 236 1031 679 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 16 0 -16 1 0 1 ) 					#name: #displayListView 					#flags: 0 					#component: #createDisplayListView ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 0 0 -16 1 16 0 ) 					#name: #hZoom 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 3026 3026 6051 ) ) 					#model: #hZoom 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #zoomChanged ) 					#orientation: #horizontal 					#start: 0.25 					#stop: 4 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} -16 1 16 0 0 1 -16 1 ) 					#name: #vZoom 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 3026 3026 6051 ) ) 					#model: #vZoom 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #zoomChanged ) 					#orientation: #vertical 					#start: 0.25 					#stop: 4 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 0 16 16 ) 					#name: #zoomTo1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8117 8117 5073 ) ) 					#model: #zoomTo1 					#tabable: false 					#label: 'z' 					#style: #pixelSmall ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -16 1 16 0 0 1 ) 					#name: #prevPage 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 4248 4248 6789 ) ) 					#model: #prevPage 					#label: '-' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -16 1 -16 1 0 1 0 1 ) 					#name: #nextPage 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6789 2557 2557 ) ) 					#model: #nextPage 					#label: ' ' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -16 1 0 0 0 1 16 0 ) 					#name: #zoomToLast 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 5631 3072 ) ) 					#model: #zoomToLast 					#label: '0' 					#defaultable: true ) ) ) )!windowSpecLeftBottom	"Tools.UIPainter new openOnClass: self andSelector: #windowSpecLeftBottom"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Display List View' 			#min: #(#{Core.Point} 200 200 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1084 499 1984 949 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 0 0 0 1 -16 1 ) 					#name: #displayListView 					#flags: 0 					#component: #createDisplayListView ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 -16 1 -16 1 0 1 ) 					#name: #hZoom 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #hZoom 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #zoomChanged ) 					#orientation: #horizontal 					#start: 0.25 					#stop: 4 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 16 0 16 0 -16 1 ) 					#name: #vZoom 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #vZoom 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #zoomChanged ) 					#orientation: #vertical 					#start: 0.25 					#stop: 4 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 16 0 16 0 ) 					#name: #zoomTo1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 8117 8117 5073 ) ) 					#model: #zoomTo1 					#tabable: false 					#label: 'z' 					#style: #pixelSmall ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -16 1 16 0 0 1 ) 					#name: #prevPage 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 4248 4248 6789 ) ) 					#model: #prevPage 					#label: '-' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -16 1 -16 1 0 1 0 1 ) 					#name: #nextPage 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 6789 2557 2557 ) ) 					#model: #nextPage 					#label: ' ' 					#defaultable: true ) ) ) )! !!Siren.SoundCanvas class methodsFor: 'interface specs'!windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SoundView' 			#bounds: #(#{Graphics.Rectangle} 548 59 1107 313 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 0 0 0 1 -16 1 ) 					#name: #soundView 					#flags: 0 					#component: #createSoundView ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 -16 1 0 1 0 1 ) 					#name: #hZoom 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #hZoom 					#orientation: #horizontal 					#start: 1 					#stop: 100 					#step: 20 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 16 0 -16 1 ) 					#name: #vZoom 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #vZoom 					#orientation: #vertical 					#start: 0.5 					#stop: 5.0 					#step: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -16 1 16 0 0 1 ) 					#name: #ActionButton1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 8191 3072 3072 ) ) 					#model: #zoomToZero 					#label: 'z' 					#defaultable: true ) ) ) )! !!Siren.PortAudioInterface methodsFor: 'types'!Callback	<C: typedef void (* Callback)(void)>!CallbackFcn	<C: typedef void (* CallbackFcn)(void)>!OEoop	<C: typedef void * OEoop>! !!Siren.PortMidiInterface methodsFor: 'types'!OEoop	<C: typedef void * OEoop>! !!Siren.LPCEditor class methodsFor: 'interface specs'!windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'LPC Pitch Data' 			#bounds: #(#{Graphics.Rectangle} 640 328 1222 854 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 48 0 -4 1 -4 1 ) 					#name: #View1 					#component: #theLPCView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 16 4 90 44 ) 					#name: #ActionButton1 					#model: #redraw 					#label: 'Redraw' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 4 0 -8 1 44 0 ) 					#name: #ActionButton2 					#model: #closeWindow 					#label: 'Close' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 100 4 ) 					#name: #CheckBox1 					#model: #showRMS 					#label: 'RMS' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 100 24 ) 					#name: #CheckBox2 					#model: #showResid 					#label: 'Resid' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 170 4 ) 					#name: #CheckBox3 					#model: #showPitch 					#label: 'Pitch' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 170 24 ) 					#name: #CheckBox4 					#model: #showRunning 					#label: 'Running' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 240 4 ) 					#name: #CheckBox5 					#model: #showSmoothed 					#label: 'Smoothed' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 240 24 ) 					#name: #CheckBox6 					#model: #showSmoothed2 					#label: 'Smoothed 2' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 340 2 440 22 ) 					#name: #ActionButton3 					#model: #overwritePitch 					#label: 'Smooth' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 340 26 440 46 ) 					#name: #ActionButton4 					#model: #save 					#label: 'Save' 					#defaultable: true ) ) ) )! !!Siren.DataSetTool class methodsFor: 'interface specs'!windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SndsLike Data Set' 			#bounds: #(#{Graphics.Rectangle} 489 281 951 619 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 24 0 -4 1 -4 1 ) 					#name: #TreeView1 					#flags: 15 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #tree 					#menu: #treeMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )! !!Siren.DataSetTool class methodsFor: 'resources'!menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'file' ) 			#(#{UI.MenuItem} 				#rawLabel: 'edit' ) 			#(#{UI.MenuItem} 				#rawLabel: 'view' ) 			#(#{UI.MenuItem} 				#rawLabel: 'tools' ) ) #(4 ) nil ) decodeAsLiteralArray!treeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #treeMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'spawn' 				#value: #spawnItem ) 			#(#{UI.MenuItem} 				#rawLabel: 'inspect' 				#value: #inspect ) ) #(2 ) nil ) decodeAsLiteralArray! !!Siren.SirenSession methodsFor: 'resources'!voiceMenu	"Tools.MenuEditor new openOnClass: self andSelector: #voiceMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'All' 				#value: #allVoices ) 			#(#{UI.MenuItem} 				#rawLabel: 'MIDI' 				#value: #MIDIVoice ) 			#(#{UI.MenuItem} 				#rawLabel: 'OSC' 				#value: #OSCVoice ) 			#(#{UI.MenuItem} 				#rawLabel: 'CSL' 				#value: #OSCVoice ) 			#(#{UI.MenuItem} 				#rawLabel: 'Audio' 				#value: #SoundVoice ) 			#(#{UI.MenuItem} 				#rawLabel: 'SuperCollider' 				#value: #SuperColliderVoice ) 			#(#{UI.MenuItem} 				#rawLabel: 'None' 				#value: #noVoice ) ) #(6 ) nil ) decodeAsLiteralArray! !!Siren.SirenSession class methodsFor: 'resources'!blocksizeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #blocksizeMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '64' 				#value: 64 ) 			#(#{UI.MenuItem} 				#rawLabel: '128' 				#value: 128 ) 			#(#{UI.MenuItem} 				#rawLabel: '256' 				#value: 256 ) 			#(#{UI.MenuItem} 				#rawLabel: '512' 				#value: 512 ) 			#(#{UI.MenuItem} 				#rawLabel: '1024' 				#value: 1024 ) 			#(#{UI.MenuItem} 				#rawLabel: '2048' 				#value: 2048 ) 			#(#{UI.MenuItem} 				#rawLabel: '4096' 				#value: 4096 ) ) #(7 ) nil ) decodeAsLiteralArray!chMenu	"Tools.MenuEditor new openOnClass: self andSelector: #chMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '0' 				#value: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: '1' 				#value: 1 ) 			#(#{UI.MenuItem} 				#rawLabel: '2' 				#value: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: '4' 				#value: 4 ) 			#(#{UI.MenuItem} 				#rawLabel: '5.1' 				#value: 6 ) 			#(#{UI.MenuItem} 				#rawLabel: '8' 				#value: 8 ) 			#(#{UI.MenuItem} 				#rawLabel: '10.2' 				#value: 12 ) 			#(#{UI.MenuItem} 				#rawLabel: '16' 				#value: 16 ) ) #(7 ) nil ) decodeAsLiteralArray!clockMenu	"Tools.MenuEditor new openOnClass: self andSelector: #clockMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'zero' 				#value: #zeroTimer ) 			#(#{UI.MenuItem} 				#rawLabel: 'copy' 				#value: #copyTimer )  ) #(2 ) nil ) decodeAsLiteralArray!forwardButton	"UIMaskEditor new openOnClass: self andSelector: #forwardButton"	<resource: #image>	^CachedImage on: (Image extent: 32@32 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7131 7131 7131)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3951 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 2891 2891)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1831 1831 1831)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4754 4754 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3694 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 4240 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 2377 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2634 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3951)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'CPHVA XFA XFA XFA XFA XFA XFA XFA XFA XFCPHFA XGF@@GA0\XA0<@C1 OC0<OC0<OC0<OC08QA0XFA!!XOC0PIBPPDBPPIA@$IBP$IBP$IBP$CBPLI@04HDP,FA!!DLA@TMAP4MCP4MCP4MCQXM@ 4VCP4ECPTEA@4S@@XFDPTMA 4FCPXFA XFA XFA XFA XFA!!@FA XMAQDGC0XHA 4MA 4MA 4FCPXMA XFA XFA XFCQXFA!!XMDP\OA  FCP4MCPXMA 4FCPXMA 4FCPXMA XFA 4FA 4QA0<KB@XMCP4MCP4MA!!XFCPXFA 4FCPXFCPXMA XMCQDNC0XHA 4MA 4MDP\MCPXFCP4GB@XFCPXFCPXMA 4MDP\OB0 FCP4MCP4NE1HFCP4MA <WB@4FCP4MA 4MCPTQC <KDP4MCP4MCQDWB XMA 4MC1\WA04MCPXECPTECQDGF@XHCP4MCP4MA1\WE0<MCP4RE1\WA04MCPTEAP4EDP8OC1DMCP4MCP4QE0(WB 4MCP<WE1\WC0TEAPTEAP4QA0<FB@TMAP4MCP\WE0(WB!!XMC0(WB!!\WA TEAP0EAQDGF@,QAPTEC@TEA1\WE0(WD04OE1\WB!!\JCP0EAP0EDP\OA  EAP0EC@0GE0(WE1\WD1XWE0(WE1\WCP0LC@TGC <PA0TLAP0LAP\WE0(WE1\HA!!\J@P(WB (MC@0ECADGF@XQAP0LC@TDA0(WE1\WB@TME1\JE0(WAP0LC@0LDP8OC1DLC@0LC@0O@P(WB!!LLC@4WE1\WE04DA@0LC@0GDP<KDP0LC@0LC@\JE1\SC@PLCQ\WB!!\FA@PLA@PLAADGC0XQC@0LC@0DC1\WB TDA@PME0(ACPPDA@PLA@PLDP\XC0\LC@0LC@0OE0(LA@PIA@TWE0XDA@PDA@PDA@0GC <KDPPLC@PLA@\JAPPDBPPICQ\GA@PDBPPDA@PDCADGC0XQC@PLC@PLC04DA@$DBP$LA0PIBP$IA@$DA@PDDP\XB0\LA@PLA@PDA@$DBP$IBP$CBP$IBP$IA@$DA@0GDP<FDPPDC@PDA@PIA@$IBP$IBP$IBP$IBP$IBPPIAADNC1@GC@PDA@PDBPPIBP$I@0$CBPLI@0$IBP$IBPPDDP\XA!!PMA@PDA@$IBPLIBPLIBP$IBP$IBPLI@0$IA@TQEP<KD1DEC@0LC@0DC@PDC@PDA@PDA@0DC@PLA@0MC0 GC0XQB  GC0<FC0XOA <FC0<OC0<OC0\OC0<OA0\HBADOB0<QD1LHD1LHD1LSBALSBALSD1LHD1LSD1LSBADNA0<FC0\NA1DQA1DNDP\QDP\QDP\NA1DQA1DNDP\QDP\OB0@a'))!midiTestMenu	"Tools.MenuEditor new openOnClass: self andSelector: #midiTestMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'test input' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'start input' 							#value: 1 ) 						#(#{UI.MenuItem} 							#rawLabel: 'stop input' 							#value: 2 ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'test output' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'single note' 							#value: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'scale' 							#value: 4 ) 						#(#{UI.MenuItem} 							#rawLabel: 'clouds' 							#value: 5 ) ) #(3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray!playButton	"UIMaskEditor new openOnClass: self andSelector: #playButton"	<resource: #image>	^CachedImage on: (Image extent: 32@32 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7131 7131 7131)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3951 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 2891 2891)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4754 4754 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3694 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2634 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 2377 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1831 1831 1831)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 4240 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3951)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'E 0EAPDEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEC@DLAP(FF@XFA XFF@XNF@8XC 8NC 8NC 8NC XGA TEAPTNC LHB@LCB@LHB@ HB@ HB@ HB@ H@  H@ POD@(EAQ@K@0PLA@0LC@0AC@0LC@DLAP0VC@PLBPPD@00RC TED@PLAP0EE TLAPTEAPTEAPTEAPTEB TEAPTLA@<FC (GAP0LAP0LC@TLAP0EAPTEAPTEAPTEAPTEAPTDD XNAP\EC@0LC@TLAPTLAP0EC@TLAP0EC@TLAQXEC@0GDP8JA0TLC@0LC@TLC@TLAPTEC@TLAP0EAPTLAP0ECAHFC TGAP0LC@TLC@TLC@TRC@TEC@TEAP0EC@TEAP0LA04NC \LC@TLC@0LC@0ECA\RC@0EAP0LAP0EC@0LC@PRA 8EA00LC@0LC@0LC@0LE1\RAP0LAP0LC@0LA@PDC@<FC (GC@0LC@0LC@0LC@0WD0@PC@0LC@0LA@0DA@PLA04XAQ@LC@0LC@0LC@0LCA\WD0@PC@0DA@0DA@PDA@PRA 8JA0PDC@PLC@0LC@0LE1\WD1\PA@0DA@PKA@PDA@\QC (PC@PKA@PDA@PDC@0WE1\WE1\NA@PKA@PKA@,DD XXAP\DB0PKB0,DA@PDAA\SE1\WE1\NB0PKB0,KA@PGCP8TA PDB0PKB0,KA@,KE1\WD1\WE0TKB0,KB0,KB1HFC TPA@,KB0,KB0,KB0LWE1\WE1\EA@PKB0,KB0,KA0XXC!!@KB0,KB0,KB0LKB1\WD1\WAPPKB0LCB0,KB0,RA 8ED@,KA@,KB0,KB0LCE1\WE08KB0,K@0,C@0,CB0\QC (PB0,KB0,K@0LK@0LWE1\E@0,KB0,C@0LC@0,CC0XXC XK@0,KB0,CB0LC@1\WAP,K@0,C@0LC@0LC@0,GCP8JD@LKB0LK@0,C@0LCE0TC@0LC@0LH@0 C@0LCB0\MC TPB0LKB0LC@0LC@0 NB@ HB@LHB@ H@0 C@0LCD XNE@XK@0LK@0,CB@LH@0 HB@ HB@ HB@ H@0 C@0,GDP8ECPLCB0LKB@LCB@ HB@ BB@ BB@ HB@ HB@LH@0<FF@(P@0LC@0LCB@ HB@ HB@ BB@ H@  HB@ HB@LCD XNAP\L@0LC@0 HB@ HB@ BB@ HB@HHB@HH@  H@0PGCP8ND!!@LB0,KB0,C@0LC@0,C@0LCB0LK@0LK@0PDC \PC TPD0\NC TNAP8UC 8JEP8NC 8NC 8NA 8FC XGA0XXB 8PD!!HRD \RC0<GD \RD <RD!!HRD!!HRD!!HRD!!@MA (EC XFDA@FDA@FDA@FDA@FD@XMA!!@FD@XPA!!@FDPXXAP@a'))!rateMenu	"Tools.MenuEditor new openOnClass: self andSelector: #rateMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '22k' 				#value: 22050 ) 			#(#{UI.MenuItem} 				#rawLabel: '32k' 				#value: 32000 ) 			#(#{UI.MenuItem} 				#rawLabel: '44k' 				#value: 44100 ) 			#(#{UI.MenuItem} 				#rawLabel: '48k' 				#value: 48000 ) 			#(#{UI.MenuItem} 				#rawLabel: '88k' 				#value: 88020 ) 			#(#{UI.MenuItem} 				#rawLabel: '96k' 				#value: 96000 ) ) #(6 ) nil ) decodeAsLiteralArray!recordButton	"UIMaskEditor new openOnClass: self andSelector: #recordButton"	<resource: #image>	^CachedImage on: (Image extent: 32@32 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3951 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3694 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6360 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 2891 2891)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 771 771)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4754 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 2377 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4754 4754 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 3180 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1831 1831 1831)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3951 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 2891 2891)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7131 7131 7131)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2634 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 4240 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 4754 4754)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'BA @CP4MCP4MCP4MCP4MCP4MCP4MCP4MCP4MCP4XBA M@A(A@QDA@P<A@Q(QF <ZF!!(ZF!!(ZF!!(ZF DS@Q(@CP4ZF!!0TEA0\GAP\EAPTEAPTEAPTEAPBEAPT@ @[D1(@CQLLGAT@@AT@@@@@@@@@@@@M@A @@@@@EQTUG@@KF!!(MD1T@F@@MCP@MCP4MCP4MCP4MCP4MCP4NCP4@EQ4AF 8[CP@@CP@@@@4XCP@MCP4MCP4MCP4MB@4MCQ @F0DZCQ,M@@@@@@4@@@4@CP@MF@4@CP@MF@@M@@4M@@@K@Q(MF04@@@@@@@@M@@4MCP@M@@4@CP@MCP@MCP@M@A,AF 8[@@4@@@4@@@@M@@@MCP@MCP4MCP@MCP@MCP@@GPDZCQ,M@@@@@@@@CP@@@@@@@@@@@@@@CP@@CP@U@@@[G!!(NF0@@@@@@@@@@@@4HG0TYFPTQCP@@@@@@@ATU@A,CF!!(S@@@@@@@@@@@@BA@FA XFA XEA0@@@ATUEQTUB0DZC!!,U@@@@@@@@@@@EA (FA (FA XP@ATUEQTUEP@[@1(MD0@U@AT@@@@@DPXFFPXFFPXFA XQ@ATUEQTUEQ4AC1(SEQTUEP0UEQTEA XFA XFA XFA!!@UEP0LEP0UF18ZCQ,UEP0LEP0UEQ$FA XFB XFFPXJFQTLCATLEP0]@Q(ND1TLEP0LEP0LFP(FA XYA XFA XYC@0LC@0LEQ,CF 8SEP0LC@0LCATEFPXFA XFA (FA!!@LC@0LC@0LF0DOCQLLC@0LC@0LCA<FA XFA XFFPXFB@0LG@0LC@0K@Q(ND00LEP0LC@0LD $FE XFA XFA $UGA0LG@0\CA,CF 8SC@0LC@0\G@0\E0$FA XFA XQEPP\GA0\G@0\GPDOG0DLG@0LC@0LGA0\D"@PAQ$QBAH\GA0\GA0\G@0[@1(MD00LCA0\CA0\GA0\GA0LGA0\GA0TGAP\GA0\CA,AF 8SCA0\C@0\GA0\GAP\EAPTEA0\EAPTGAP\GA0LF0LOCPL\C@0\G@0\GAP\EAPTEAPTEAPTEAPTGAP\GA0K@Q(Z@Q0\CA0\GA0TGAPTEAPTE@HT@!!PTEAPTEA0TGA,CF 8SGA0\GA0\EAPTEAPT@!!PTE@HTE@HTEAPTEA0LF0DOC!!,@GA0\GAPTEAPTE@HTE@HTEAPBEAPT@!!PTGAT[G!!(NB1L@C@0LC@0\GA0\CA0\CA0\G@0\GA0LGATUF!!,CF 4SE!!,ZF!!(MF 4ZF!!(MF!!(ZF!!(ZF DZ@Q(AF D[F0DZC!!(SB0,KF0,[B0,[B0,[B1,KB0,[B0,KB0,KB1LC@Q(MF DAD0DS@1LS@QLS@QLSD0DS@QLAD0D^@QLAG DOCP@a'))!rewindButton	"UIMaskEditor new openOnClass: self andSelector: #rewindButton"	<resource: #image>	^CachedImage on: (Image extent: 32@32 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7131 7131 7131)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3951 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 2891 2891)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1831 1831 1831)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4754 4754 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3694 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 4240 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2634 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 2377 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3951)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'CPHVA XFA XFA XFA XFA XFA XFA XFA XFA XFCPHFA XGF@@GA0\XA0<@C1 OC0<OC0<OC0<OC0\QA0,FCQXOC0PIBPPDBPPIA@$IBP$IBP$IBP$CBP$I@04HDQ@VA!!DLA@TMAP4MCP4MCP4MCP4FCQXMCP4MAPTEA@4SC0XFDPTMA 4FCPXFA XFA XFA XFA XFA XKA XMAQHGC0XHA 4MCP4FCPXMA 4VA XF@ XFA XF@ XFA!!XMB@\OA  FCP4FCP4FCPXMA XMA 4FCPXMA!!XFCPXMA 4SA0<KB@XMCP4MCP4FCPXFCPXMA 4FA XMA 4FA XMCP NC0XHA 4MCP4FCP4FCP<SCPXFA 4FCP(MA 4FCPXMB@\OC0 MCPXMCP4MCP4OB!!LMA 4MA 4HE04MA 4MCPTSA1 KB@4MCP4MCP4MA!!LWD04MA 4FBA\WCP4MAPTECP QC0<QCP4MCP4MCPXSE1\SCP4MCQDWE1\MCPTEAPTMB@8OB0 ECP4MCP4MB!!\WE0 MCP4GE1\JE0TEAPTEAPTSA0<FB@TMAP4MCP WE0(WD04MA1\WB!!\WAPTEAPTEAQHGF@,QCP0EC@TQE1\J@P(SAP\WE1\WE0(LAP0EC@TEBAPOC1DEAP0LDQ\WE1\JE1LFB!!\JE0(WE0TLC@0LAP0RA0<FDPTEC@TQE0(WE1\JB@XJE1\WE0(WA@0LC@0LAP NC0<QAP0LC@0GE1\JE1\HCATWE0(WE1\LC@0LC@0LB@8OB1DLC@0LC@0QE1\JE0 DC@XWE0(WE0PDC@0LC@0SA0<FDP0LAP0LC@0HE1\WB@PLCAXWE1\WA@0DA@0DC@ GF@,QA@0LC@0LA@0SE1\QA@PLC@\WB!!\DA@PDA@0DD0\OC0\LC@0LC@0DC@PHE0 IA@0DA@\WE0PDA@PDA@0HE@<FDP0DC@PLA@0DA@TJB@PIA@PDA@\WBP$DA@PDC@ NC0,QC@PLC@0DA@PDA@0QBP$IBPPIBP IBPPDA@PDB@8OA!!DDC@PDA@PDA@$IA@$IBP$IBP$IBP$IBPPIA@0HA1 OA0PDA@0DA@PIA@$IBP$CBP$CBP$CBP$IBPPDA@ QC0,QC@PDA@PDBPPIBP$I@0$I@0$IBP$IBP$IBP$LD0\OB0 MA@PDA@$IBPLIBPLIBP$IBP$CBPLI@0$IC@THA1 FD1DEAP0LC@0DC@PDC@PDA@PDA@0DC@PLA@0EC1HGC1@QB  OA <FC0XOA <FC0<OC0<OC0<OA0<OA0\HDP8OA \QD1LSD1LHD1LSD!!LHD1LSD1LSD1LHD1LSD1DQA0<FD@\GDQDNA1DNDP\QA1DQA1DGDP\QA1DQDQDGDP\OB0@a'))!scheduleMenu	"Tools.MenuEditor new openOnClass: self andSelector: #scheduleMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'play' 				#value: #playItem ) 			#(#{UI.MenuItem} 				#rawLabel: 'stop' 				#value: #stopItem ) 			#(#{UI.MenuItem} 				#rawLabel: 'edit' 				#value: #spawnItem ) 			#(#{UI.MenuItem} 				#rawLabel: 'delete' 				#value: #deleteItem ) ) #(4 ) nil ) decodeAsLiteralArray!stopButton	"UIMaskEditor new openOnClass: self andSelector: #stopButton"	<resource: #image>	^CachedImage on: (Image extent: 32@32 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7131 7131 7131)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3951 3951 3951)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2891 2891 2891)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7677 7677)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4754 4754 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3694 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2634 2634 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2377 2377 2377)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 4240 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1831 1831 1831)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 1060 2634)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4240 4240 3951)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'C@DWAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEAPTEE00WAPTF@@XFA XFF@XNF@8XC 8NC 8NC 8NC XGA TE@PTNC LHB@LCB@LHB@ HB@ HB@ HB@ H@  H@ POD@(EAQ@K@0PLA@0LC@0AC@0LC@DLAP0WC@PLBPPD@00RC TED@PLE0TEC@TEAP0EAPTEAPTEAPTEB TEAPTLA@\FC TGAP0LC@0LAP0LAPTEAPTEAPTEAPTEAPTEAPTLA04QB \EC@0LC@TLAPTLAP0EC@TLAP0EC@TLAQ\EC@0RA 8EA0TLAP0LC@TLC@TLAP0EC@TLAPTEC@TLAP0EC@\FC (GC@0LC@0LC@TLC@TLAP0EAPTLAP0EAPTLAP0LA1LNAP\EC@0LAP0LC@0EC@TLAP0EC@TLC@TLC@0LC@0GCQDJA00LC@0LC@0NDA@PDA@PDA@PDA@NC@0LC@PDC@\FF@8PC@0LC@0LC@8VE!!XVE!!XVE!!XVE!!@LC@PDA@PDA04NB \DC@0LC@0LDQXVE!!XVE!!XVE!!XVA PDA@PDA@0GD@8ED@0DC@PLC@0EE!!XVE!!XVE!!XVE!!XPA@PDA@PDAAHFC!!PPA@PKA@PDA@TVE!!XVE!!XVE!!XVE XKA@,DB0PDA04NB!!@DA@PKB0,DCAXVE!!XVE!!XVE!!XVA PKB0,DB0,GCP8JD@PKB0PKB0,LE!!XVE!!XVE!!XVE!!XNB0,KB0,KA@\FF@TPA@,DB0,KB00VE!!XVE!!XVE!!XVE XKB0,KB0,KA1LNC!!@KB0,KB0,KAAXVE!!XVE!!XVE!!XVA LCB0,KB0,OA 8ED@,KB0,KB0,DE!!XVE!!XVE!!XVE!!XF@0,C@0LCB0\FF@8MB0,KB0,K@00VE!!XVE!!XVE!!XVE!!DC@0LK@0,CD 4NB!!@CB0,KB0,CAAXVE!!XVE!!XVE!!XVC LC@0LC@0,GA 8ED@,CB0,C@0,DA@PDA@PDA@0DA@PKB@LC@0LCB0\MDP(PB0LKB0LK@0LC@0 CB@ HB@ CB@ CB@LH@0LCC0XNAQ@CB0LCB0LC@0 CB@ HB@ HB@ HB@ HB@LC@0LGDADNA LCB0LC@0LH@0 HB@ BB@ H@  HB@ HB@ C@0<FF@(P@0LCB0LH@0 HB@ HB@ BB@ H@  BB@ HB@ KA1LNAQHL@0LH@0 HB@ HB@ BB@ H@  HB@ HB@ HB0PGCP8TC1@LB0PKB0LK@0LC@0,C@0LC@0,C@0LCB0,DC!!HFC TPEP\XDPTEDQDEDPTQDQDNDP8NC!!DFC XNA XGD@XNB 8PD!!HRD!!HOC1HRD <OD \RD!!HRD \RD!!HRA0\SA 8EC XFD@XSA!!@FD@XSA!!@FDA@FD@XFDA@FD@XPCPXNB @a'))!timerMenu	"Tools.MenuEditor new openOnClass: self andSelector: #timerMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'zero' 				#value: #zeroTimer ) 			#(#{UI.MenuItem} 				#rawLabel: 'stop' 				#value: #stopTimer ) 			#(#{UI.MenuItem} 				#rawLabel: 'start' 				#value: #startTimer ) 			#(#{UI.MenuItem} 				#rawLabel: 'copy' 				#value: #copyTimer ) 			#(#{UI.MenuItem} 				#rawLabel: 'spawn' 				#value: #spawn ) ) #(5 ) nil ) decodeAsLiteralArray!verbosityMenu	"Tools.MenuEditor new openOnClass: self andSelector: #verbosityMenu"	<resource: #menu>	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '0' 				#value: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: '1' 				#value: 1 ) 			#(#{UI.MenuItem} 				#rawLabel: '2' 				#value: 2 ) ) #(3 ) nil ) decodeAsLiteralArray! !!Siren.SirenSession class methodsFor: 'interface specs'!transportButtonSpec	"Tools.UIPainter new openOnClass: self andSelector: #transportButtonSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 520 600 720 638 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 				#setSelectionForegroundColor: #(#{Graphics.ColorValue} #white ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 3276 3276 3276 ) 				#setBorderColor: #(#{Graphics.ColorValue} #black ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 2 0 38 36 ) 					#name: #rewindButton 					#flags: 0 					#model: #rewind 					#tabable: false 					#label: #rewindButton 					#hasCharacterOrientedLabel: false 					#style: #large 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 40 0 78 36 ) 					#name: #recordButton 					#flags: 0 					#model: #record 					#tabable: false 					#label: #recordButton 					#hasCharacterOrientedLabel: false 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 120 0 158 36 ) 					#name: #playButton 					#flags: 0 					#model: #play 					#tabable: false 					#label: #playButton 					#hasCharacterOrientedLabel: false 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 160 0 198 36 ) 					#name: #forwardButton 					#flags: 0 					#model: #forward 					#tabable: false 					#label: #forwardButton 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 80 0 118 36 ) 					#name: #stopButton 					#flags: 0 					#model: #stop 					#tabable: false 					#label: #stopButton 					#hasCharacterOrientedLabel: false 					#style: #large ) ) ) )!transportWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #transportWindowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Siren Transport Panel' 			#min: #(#{Core.Point} 572 200 ) 			#max: #(#{Core.Point} 1600 1000 ) 			#bounds: #(#{Graphics.Rectangle} 640 427 1212 607 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 100 78 192 110 ) 					#name: #voiceMenuButton 					#model: #voice 					#label: 'Voices' 					#menu: #voiceMenu ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 202 0 38 0 -2 1 -2 1 ) 					#name: #scheduleListView 					#model: #scheduleListText					#menu: #scheduleMenu 					#multipleSelections: false 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 300 0 2 0 -50 1 32 0 ) 					#name: #clockField 					#model: #clock 					#tabable: false 					#menu: #clockMenu 					#alignment: #right 					#style: #fixed 					#isReadOnly: true 					#numChars: 24 					#type: #string ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.Rectangle} 0 0 200 38 ) 					#name: #transportButtons 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) 						#setSelectionForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#majorKey: #{Siren.SirenSession} 					#minorKey: #transportButtonSpec 					#clientKey: #transport ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 100 112 192 144 ) 					#name: #listMenuButton 					#model: #eventList 					#label: 'Lists' 					#menu: #listMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 100 146 192 178 ) 					#name: #soundMenuButton 					#model: #sound 					#label: 'Sounds' 					#menu: #soundMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 212 2 286 38 ) 					#name: #utilityButton 					#model: #openSirenUtility 					#label: 'Utility' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -44 1 2 0 -4 1 32 0 ) 					#name: #allOffButton 					#model: #allOff 					#tabable: false 					#label: 'X' 					#defaultable: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 78 96 110 ) 					#name: #soundPortMenu 					#model: #soundPort 					#label: 'Sound IO' 					#menu: #soundPortMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 112 96 144 ) 					#name: #midiPortMenu 					#model: #midiPort 					#label: 'MIDI IO' 					#menu: #midiPortMenu ) 				#(#{UI.MenuButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.Rectangle} 4 146 96 178 ) 					#name: #timerMenu 					#model: #timer 					#label: 'Timers' 					#menu: #timerMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 36 42 156 78 ) 					#name: #ActionButton 					#model: #inspectSession 					#label: 'I/O and Data' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.Rectangle} 0 38 200 42 ) 					#name: #Divider1 ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.Rectangle} 200 0 201 38 ) 					#name: #Divider2 					#orientation: #vertical ) ) ) )!utilWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #utilWindowSpec"	<resource: #canvas>	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionAutoSave true #sizeType #specifiedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 'Siren Configuration' 			#min: #(#{Core.Point} 572 200 ) 			#max: #(#{Core.Point} 572 200 ) 			#bounds: #(#{Graphics.Rectangle} 520 600 1092 780 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 32 216 60 ) 					#name: #voiceMenu 					#model: #defaultVoiceClass 					#menu: #voiceMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 28 30 ) 					#name: #Label1 					#label: 'Default voice' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 424 90 544 120 ) 					#name: #ActionButton5 					#model: #loadAll 					#label: 'Load all' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 424 150 544 180 ) 					#name: #ActionButton6 					#model: #freeLists 					#label: 'Flush data' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 20 4 ) 					#name: #Label8 					#label: 'Score IO and Voices' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 420 4 ) 					#name: #Label9 					#label: 'OpenSoundControl' 					#style: #large ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 280 4 ) 					#name: #Label10 					#label: 'Sound IO' 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 92 216 116 ) 					#name: #ActionButton2 					#model: #testSoundIn 					#label: 'Test sound in' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 120 216 144 ) 					#name: #ActionButton7 					#model: #testSndFileIn 					#label: 'Test sound file' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 16 92 112 116 ) 					#name: #ActionButton1 					#model: #testMIDI 					#label: 'Test MIDI I/O' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 16 64 112 88 ) 					#name: #configMIDI 					#model: #configureMIDI 					#label: 'Configure MIDI' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 16 120 112 144 ) 					#name: #testOSC 					#model: #testOSCout 					#label: 'Test OSC' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 64 216 88 ) 					#name: #testSoundOut 					#model: #testSoundOut 					#label: 'Test sound out' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 16 148 112 172 ) 					#name: #ActionButton3 					#model: #stopMIDI 					#label: 'Stop MIDI' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 120 148 216 172 ) 					#name: #ActionButton8 					#model: #stopSound 					#label: 'Stop sound' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 280 148 380 172 ) 					#name: #ActionButton9 					#model: #resetSound 					#label: 'Reset Sound' 					#style: #systemDefault 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.Rectangle} 80 84 148 112 ) 							#name: #MenuButton4 							#model: #blockSize 							#menu: #blocksizeMenu ) 						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.Rectangle} 80 0 148 28 ) 							#name: #MenuButton1 							#model: #sampleRate 							#menu: #rateMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 6 4 ) 							#name: #Label2 							#label: 'Sample rate' 							#style: #systemDefault ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 10 32 ) 							#name: #Label4 							#label: 'In channels' 							#style: #systemDefault ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 60 ) 							#name: #Label3 							#label: 'Out channels' 							#style: #systemDefault ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 18 88 ) 							#name: #Label5 							#label: 'BlockSize' 							#style: #systemDefault ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 232 32 380 144 ) 						#name: #Composite1 ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 424 120 544 150 ) 					#name: #ActionButton4 					#model: #cleanUp 					#label: 'Clean up' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 318 64 360 84 ) 					#name: #inChannelsField 					#model: #inChannels 					#style: #systemDefault 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 318 92 360 112 ) 					#name: #OutputField1 					#model: #outChannels 					#style: #systemDefault 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 170 0 260 32 ) 					#name: #ActionButton10 					#model: #openTransport 					#label: 'Transport' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 454 32 564 56 ) 					#name: #oscAddressField 					#model: #oscAddress 					#style: #systemDefault 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 420 36 ) 					#name: #Label6 					#label: 'Host' 					#style: #systemDefault ) 				#(#{UI.MenuButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.Rectangle} 424 60 544 90 ) 					#name: #verbosityMenu 					#model: #verbosity 					#label: '  Verbosity' 					#menu: #verbosityMenu ) ) ) )! !!Siren.LibSndFileInterface methodsFor: 'procedures'!lsf_close: which	<C: int lsf_close(unsigned int which)>	^self externalAccessFailedWith: _errorCode!lsf_create: name with: mode with: format with: rate with: channels	<C: int lsf_create(char * name, unsigned int mode, unsigned int format, unsigned int rate, unsigned int channels)>	^self externalAccessFailedWith: _errorCode!lsf_get_channels: which	<C: int lsf_get_channels(unsigned int which)>	^self externalAccessFailedWith: _errorCode!lsf_get_format: which	<C: int lsf_get_format(unsigned int which)>	^self externalAccessFailedWith: _errorCode!lsf_get_frames: which	<C: int lsf_get_frames(unsigned int which)>	^self externalAccessFailedWith: _errorCode!lsf_get_rate: which	<C: int lsf_get_rate(unsigned int which)>	^self externalAccessFailedWith: _errorCode!lsf_open: name with: mode	<C: int lsf_open(char * name, unsigned int mode)>	^self externalAccessFailedWith: _errorCode!lsf_read_Fsamples: which with: where with: count	<C: int lsf_read_Fsamples(unsigned int which, float * where, unsigned int count)>	^self externalAccessFailedWith: _errorCode!lsf_read_Isamples: which with: where with: count	<C: int lsf_read_Isamples(unsigned int which, short * where, unsigned int count)>	^self externalAccessFailedWith: _errorCode!lsf_seek: which with: pos with: key	<C: int lsf_seek(unsigned int which, unsigned int pos, unsigned int key)>	^self externalAccessFailedWith: _errorCode!lsf_write_Fsamples: which with: where with: count	<C: int lsf_write_Fsamples(unsigned int which, float * where, unsigned int count)>	^self externalAccessFailedWith: _errorCode!lsf_write_Isamples: which with: where with: count	<C: int lsf_write_Isamples(unsigned int which, short * where, unsigned int count)>	^self externalAccessFailedWith: _errorCode! !!Siren.PortAudioInterface methodsFor: 'procedures'!pa_close	<C: int pa_close(void)>	^self externalAccessFailedWith: _errorCode!pa_dev_in: which	<C: int pa_dev_in(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pa_dev_out: which	<C: int pa_dev_out(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pa_dev_rate: which	<C: int pa_dev_rate(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pa_get_name: which	<C: const char *  pa_get_name(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pa_get_name: which with: resultString	<C: int pa_get_name(unsigned int which, OEoop resultString)>	^self externalAccessFailedWith: _errorCode!pa_in_device	<C: int pa_in_device(void)>	^self externalAccessFailedWith: _errorCode!pa_in_rate	<C: int pa_in_rate(void)>	^self externalAccessFailedWith: _errorCode!pa_initialize	<C: int pa_initialize(void)>	^self externalAccessFailedWith: _errorCode!pa_num_devices	<C: int pa_num_devices(void)>	^self externalAccessFailedWith: _errorCode!pa_num_in	<C: int pa_num_in(void)>	^self externalAccessFailedWith: _errorCode!pa_num_out	<C: int pa_num_out(void)>	^self externalAccessFailedWith: _errorCode!pa_open_p: device with: out_ch with: format with: rate with: blockSize	<C: int pa_open_p(int device, unsigned int out_ch, unsigned long format, unsigned int rate, unsigned int blockSize)>	^self externalAccessFailedWith: _errorCode!pa_open_s: device with: in_ch with: out_ch with: format with: rate with: blockSize with: cbBlock with: in_buffer with: out_buffer	<C: int _threaded pa_open_s(int device, unsigned int in_ch, unsigned int out_ch, unsigned long format, unsigned int rate, unsigned int blockSize, CallbackFcn cbBlock, unsigned short * in_buffer, unsigned short * out_buffer)>	^self externalAccessFailedWith: _errorCode!pa_out_device	<C: int pa_out_device(void)>	^self externalAccessFailedWith: _errorCode!pa_out_rate	<C: int pa_out_rate(void)>	^self externalAccessFailedWith: _errorCode!pa_play: out_buffer with: numChannels with: numFrames	<C: int pa_play(unsigned short * out_buffer, unsigned int numChannels, unsigned int numFrames)>	^self externalAccessFailedWith: _errorCode!pa_play: out_buffer with: numChannels with: numFrames with: swap	<C: int pa_play(unsigned short * out_buffer, unsigned int numChannels, unsigned int numFrames, unsigned int swap)>	^self externalAccessFailedWith: _errorCode!pa_start	<C: int _threaded pa_start(void)>	^self externalAccessFailedWith: _errorCode!pa_stop	<C: int pa_stop(void)>	^self externalAccessFailedWith: _errorCode!pa_terminate	<C: int pa_terminate(void)>	^self externalAccessFailedWith: _errorCode! !!Siren.PortMidiInterface methodsFor: 'procedures'!pm_close: which	<C: int pm_close(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_count_devices	<C: int pm_count_devices(void)>	^self externalAccessFailedWith: _errorCode!pm_default_input_device	<C: int pm_default_input_device(void)>	^self externalAccessFailedWith: _errorCode!pm_default_output_device	<C: int pm_default_output_device(void)>	^self externalAccessFailedWith: _errorCode!pm_dev_dir: which	<C: int pm_dev_dir(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_get: which	<C: long pm_get(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_get_name: which	<C: const char *  pm_get_name(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_has_error: which	<C: int pm_has_error(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_initialize	<C: int pm_initialize(void)>	^self externalAccessFailedWith: _errorCode!pm_open: device with: direction	<C: int pm_open(int device, unsigned int direction)>	^self externalAccessFailedWith: _errorCode!pm_poll: which	<C: int pm_poll(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_read: which	<C: long pm_read(unsigned int which)>	^self externalAccessFailedWith: _errorCode!pm_read_controllers: which with: fromController with: toController with: data	<C: int pm_read_controllers(unsigned int which, unsigned int fromController, unsigned int toController, short * data)>	^self externalAccessFailedWith: _errorCode!pm_start_controller_cacheing	<C: int pm_start_controller_cacheing(void)>	^self externalAccessFailedWith: _errorCode!pm_stop_controller_cacheing	<C: int pm_stop_controller_cacheing(void)>	^self externalAccessFailedWith: _errorCode!pm_terminate	<C: int pm_terminate(void)>	^self externalAccessFailedWith: _errorCode!pm_test	<C: void pm_test(void)>	^self externalAccessFailedWith: _errorCode!pm_write_data2: which with: d1 with: d2	<C: int pm_write_data2(unsigned int which, unsigned char d1, unsigned char d2)>	^self externalAccessFailedWith: _errorCode!pm_write_data3: which with: d1 with: d2 with: d3	<C: int pm_write_data3(unsigned int which, unsigned char d1, unsigned char d2, unsigned char d3)>	^self externalAccessFailedWith: _errorCode!pm_write_long: which with: msg with: length	<C: int pm_write_long(unsigned int which, long * msg, unsigned int length)>	^self externalAccessFailedWith: _errorCode!pm_write_short: which with: msg	<C: int pm_write_short(unsigned int which, long msg)>	^self externalAccessFailedWith: _errorCode! !!Siren.FFTWInterface methodsFor: 'procedures'!fftw_float_to_short: data	<C: void fftw_float_to_short(short * data)>	^self externalAccessFailedWith: _errorCode!fftw_forward_transform	<C: void fftw_forward_transform(void)>	^self externalAccessFailedWith: _errorCode!fftw_initialize: size with: samples with: spectrum	<C: int fftw_initialize(unsigned int size, float * samples, float * spectrum)>	^self externalAccessFailedWith: _errorCode!fftw_mag_spectrum: data	<C: void fftw_mag_spectrum(float * data)>	^self externalAccessFailedWith: _errorCode!fftw_phas_spectrum: data	<C: void fftw_phas_spectrum(float * data)>	^self externalAccessFailedWith: _errorCode!fftw_reverse_transform	<C: void fftw_reverse_transform(void)>	^self externalAccessFailedWith: _errorCode!fftw_short_to_float: data	<C: void fftw_short_to_float(short * data)>	^self externalAccessFailedWith: _errorCode! !#{Siren.DisplayListView} initialize!#{Siren.PortModel} initialize!#{Siren.PitchClass} initialize!#{Siren.MusicEvent} initialize!#{Siren.EventList} initialize!#{Siren.Scale} initialize!#{Siren.Voice} initialize!#{Siren.LibSndFileInterface} initialize!#{Siren.Pitch} initialize!#{Siren.MIDIDevice} initialize!#{Siren.Amplitude} initialize!#{Siren.SymbolicPitch} initialize!#{Siren.EventScheduler} initialize!#{Siren.SymbolicLoudness} initialize!#{Siren.Duration} initialize!#{Siren.SirenUtility} initialize!#{Siren.FunctionView} initialize!#{Siren.PortAudioInterface} initialize!#{Siren.SoundFile} initialize!#{Siren.SEventQueue} initialize!#{Siren.MIDIVoice} initialize!#{Siren.OSCBundle} initialize!#{Siren.SirenSession} initialize!#{Siren.MIDIVelocity} initialize!#{Siren.MIDIPitch} initialize!"Imported Classes:"!self error: 'Attempting to file-in parcel imports.  Choose terminate or close'!Smalltalk.Core defineClass: #Object	superclass: nil	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Kernel-Objects'!Smalltalk.External defineClass: #ExternalInterface	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: 'includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel '	imports: '			private Kernel.OpcodePool.*			'	category: 'External-Interface'!Smalltalk.UI defineClass: #Model	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'dependents '	classInstanceVariableNames: ''	imports: ''	category: 'Kernel-Objects'!Smalltalk.UI defineClass: #ApplicationModel	superclass: #{UI.Model}	indexedType: #none	private: false	instanceVariableNames: 'builder uiSession eventHandlers '	classInstanceVariableNames: 'savedWindowInformation '	imports: ''	category: 'UIBuilder-Framework'!Smalltalk.Core defineClass: #Magnitude	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Magnitude-General'!Smalltalk.Core defineClass: #Point	superclass: #{Core.ArithmeticValue}	indexedType: #none	private: false	instanceVariableNames: 'x y '	classInstanceVariableNames: ''	imports: ''	category: 'Graphics-Geometry'!Smalltalk.UI defineClass: #SelectionTracker	superclass: #{Core.Object}	indexedType: #none	private: false	instanceVariableNames: 'controller '	classInstanceVariableNames: ''	imports: ''	category: 'Interface-Events-Trackers'!Smalltalk.Tools defineClass: #Workbook	superclass: #{Tools.AbstractWorkspace}	indexedType: #none	private: false	instanceVariableNames: 'pageHolder lastInstalledPage '	classInstanceVariableNames: ''	imports: ''	category: 'Tools-Workspace'!Smalltalk.Graphics defineClass: #DependentPart	superclass: #{Graphics.VisualPart}	indexedType: #none	private: false	instanceVariableNames: 'model '	classInstanceVariableNames: ''	imports: ''	category: 'Graphics-Visual Objects'!Smalltalk.UI defineClass: #AutoScrollingView	superclass: #{UI.View}	indexedType: #none	private: false	instanceVariableNames: 'scrollOffset '	classInstanceVariableNames: ''	imports: ''	category: 'Interface-Support'!Smalltalk.Core defineClass: #SequenceableCollection	superclass: #{Core.Collection}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Collections-Abstract'!Smalltalk.Core defineClass: #OrderedCollection	superclass: #{Core.SequenceableCollection}	indexedType: #objects	private: false	instanceVariableNames: 'firstIndex lastIndex '	classInstanceVariableNames: ''	imports: ''	category: 'Collections-Sequenceable'!Smalltalk.UI defineClass: #ControllerWithMenu	superclass: #{UI.Controller}	indexedType: #none	private: false	instanceVariableNames: 'menuHolder performer '	classInstanceVariableNames: ''	imports: ''	category: 'Interface-Framework'!Tools.FileTools defineClass: #FileInformationViewer	superclass: #{Tools.FileTools.FileBlurbViewer}	indexedType: #none	private: false	instanceVariableNames: ''	classInstanceVariableNames: ''	imports: ''	category: 'Tools-File Browser'!Smalltalk.Core defineClass: #Association	superclass: #{Core.LookupKey}	indexedType: #none	private: false	instanceVariableNames: 'value '	classInstanceVariableNames: ''	imports: ''	category: 'Collections-Support'!Smalltalk.Graphics defineClass: #DependentComposite	superclass: #{Graphics.CompositePart}	indexedType: #none	private: false	instanceVariableNames: 'model '	classInstanceVariableNames: ''	imports: ''	category: 'Graphics-Visual Objects'!