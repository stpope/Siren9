<?xml version="1.0"?><st-source><!-- Name: OldBrowsersNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: OldBrowsers contains the some of the VisualWorks 5i Browser framework.  That browser framework has been replaced by the Refactoring Browser, however some VisualWorks Tools (such as the Store Database browsers) still require these classes.  Not all of the classes (such as the original Debugger) that are part of the framework are in this parcel, some are still in the base image.  However at some point in the future, we will be removing all of the 5i Browser framework.DbIdentifier: bear73DbTrace: 438518DbUsername: mlucas-smithDbVersion: 8.0 - 2PackageName: OldBrowsersParcel: #('OldBrowsers')ParcelName: OldBrowsersPrintStringCache: (8.0 - 2,mlucas-smith)Version: 8.0 - 2Pre-Unload Block: 	[:package |Glorp.Dialect reset.ObjectMemory globalGarbageCollect.Undeclared purgeUnusedBindings]Post-Unload Block: 	[Glorp.Dialect reset.ObjectMemory globalGarbageCollect.Undeclared purgeUnusedBindings]Date: 12:43:19 PM July 1, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jun14.3) of June 20, 2014 on July 1, 2014 at 12:43:19 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PickASomethingDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>OldBrowsers</package></attributes></class><class><name>BrowserHelper</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>module selectionId attribute </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.DbRegistry			private Store.Policies			</imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.BrowserHelper</class-id><body>BrowserHelpers represent the personality of a list view in a source code browser. Usually, a list view will only have one personality, but on occasion, it is necessary for a list view to have various personalities based on the state of other list views. For example, if a NameSpace is selected in the second pane of a four-pane browser, the fourth pane would probably show shared variables within that NameSpace. But if a Class is selected, the same fourth pane will usually show messages implemented by that class. This is accomplished by attaching two different BrowserHelpers to the list view (which is represented by a SimpleBrowserModule) and allowing the BrowserModule to choose which is the current helper depending on what is selected in other BrowserModules.The BrowserHelper is responsible for supplying the list view's menu, the appropriate submenu on the menu bar, and for implementing all of the actions reachable from that menu. It also computes the contents of the list view, and for setting some guidelines on how those list items appear.Instance Variables:module	&lt;SimpleBrowserModule&gt;	represents the list view to which this helper is connected</body></comment><class><name>MethodsBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Registry			</imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.MethodsBrowserHelper</class-id><body>This class represents a list of methods--being abstract, it does not make any assumptions about the origin of those methods.The actual list elements may be message selectors, MethodDefinitions, or Contexts. As such, if one wanted to add a generic implementation of a method to this class, it would need to access the selector, method, or implementing class of a selected method via a message like "self definitionOf: aSelection". Concrete subclasses will implement #definitionOf: to return instances of MethodDefinition, or of a similar class. The generic method can then operate on the MethodDefinition to get the selector, method, implementingClass, source code, et al.Class Variables:MethodMoveProtocol	&lt;ClassOfVariable&gt;	The last protocol used in a "move method" operation</body></comment><class><name>SelectorBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.PackageChooser			private Store.DbRegistry			</imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.SelectorBrowserHelper</class-id><body>This class represents a list of all the message selectors that are in a particular protocol of a particular class or metaclass. It requires that its module's "primaryObject" be a Class or Metaclass, which is accessed via "self targetClass". The module's "secondaryObject" must be a Symbol, which names a particular protocol within the class, and is accessed via "self protocol".</body></comment><class><name>ParcelSelectorBrowserHelper</name><environment>Tools</environment><super>Tools.SelectorBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>Emphasizer</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.Emphasizer</class-id><body>An emphasizer provides the emphasis for items displayed the browser. Emphasis is based on a criteria (eg. parcel or package) queried from the browser, which allowsthe client to display emphasis without knowing the criteria upon which it's based.Subclasses should define:	#currentCriteria: aBrowser id: selectionId - answer the basis for emphaisand all the "private-staus" methods not provided by the superclass.#emphasisForAttribute: can be used to override the default highlighting.</body></comment><class><name>BrowserTabApplication</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components canvas browser blankCategoryCanvas indexOfCategoryCanvas icon categoryIcon emphasizer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelTabApplication</name><environment>Tools</environment><super>Tools.BrowserTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager parcelFilterOn unparceledFilterOn conflictsFilterOn savedParcels parcelDefType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>TabbedDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars>developmentTabLabels runtimeTabLabels tabSpecsAndHelpSelectors </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>UI.TabbedDialog</class-id><body>TabbedDialog is an abstract class that provides for tabbed selection and acceptance of user modifiable setting or property pages. Subclasses must implement the following messages:	class protocol:		constants			windowLabelInstance Variables:	disturbed	&lt;ValueModel on: Boolean&gt;	True on page entry change.	list	&lt;SelectionInList&gt;	Selection model.	subBuilder	&lt;UIBuilder&gt;	Page subcanvas builder.Class Instance Variables:	developmentTabLabels	&lt;OrderedCollection of: String&gt;  Labels of the dialog tabs shown at development time.  	runtimeTabLabels	&lt;OrderedCollection of: String&gt; Labels of the dialog tabs shown at runtime. 	tabSpecsAndHelpSelectors	&lt;OrderedCollection of: Array&gt; A collection of the same size as developmentTabLabels, with two-element arrays as entries. The first element is the spec to use for the tab, the second is the selector to send to the application to get help text for the tab.   </body></comment><class><name>PackagePropertiesDialog</name><environment>UI</environment><super>UI.TabbedDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>UI.PackagePropertiesDialog</class-id><body>A PackagePropertiesDialog provides an user-interface for editing a CodeComponents properties.  Typically, this will be a parcel, package or bundle.  These properties include the various action blocks (preload, postload, presave, etc), development and deployed prerequisites properties.  The receiver also provides the ability to add or remove arbitrary properties via a specialized inspector embedded  in the Other Properties tab.  All of the editing is buffered, i.e. a user will have to click on the accept button on each page to cause the desired property to be effected.Instance Variables:	package	&lt;Parcel | PackageModel | BundleModel&gt;  The component whose properties are being modified	properties	&lt;IdentityDictionary key: Symbol value: ValueHolder&gt;  The aspects for the components on each tab</body></comment><class><name>FullSystemBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentDictionary components coordinator text inBatchMode meta defType toolBar selectionDictionary disableBatchUpdates ignoreNamepaceChanges listMenuMap menuBarMenuMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ClassesBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastSelection </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.PackageChooser			private Store.DbRegistry			private Store.Registry			</imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.ClassesBrowserHelper</class-id><body>This class represents a list of shared variables--frequently classes.</body></comment><class><name>NameSpaceCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.ClassesBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id><body>This class represents a list of all the shared variables that are in a particular category of a particular NameSpace. It requires that its module's "primaryObject" be a Class or NameSpace--if it is a Class, its class pool is treated as a NameSpace for purposes of browsing. This NameSpace can be accessed via "self environment". The module's "secondaryObject" must be a Symbol, which names a particular category within the NameSpace, and can be accessed via "self category".</body></comment><class><name>NameSpaceGlobalCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.NameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.PackageChooser			</imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.ProtocolBrowserHelper</class-id><body>This class represents a list of all the categories that are in a particular NameSpace (or the classPool of a Class). It requires that its module's "primaryObject" be a Class or Metaclass, which can be accessed via "self targetClass".Class Variables:LastProtocol	&lt;Symbol&gt;	The last protocol selected--used as a possible name when adding a new protocol.</body></comment><class><name>ParcelProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.ProtocolBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NameSpaceOrganizerBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchChildNamespaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id><body>This class represents a list of all the categories that are in a particular NameSpace (or the classPool of a Class). It requires that its module's "primaryObject" be a Class or NameSpace, which is accessed via "self environment".</body></comment><class><name>NamespaceTabApplication</name><environment>Tools</environment><super>Tools.BrowserTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ContextDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelNameSpaceOrganizerBrowserHelper</name><environment>Tools</environment><super>Tools.NameSpaceOrganizerBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelEmphasizer</name><environment>Tools</environment><super>Tools.Emphasizer</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>TabApplicationSystemBrowser</name><environment>Tools</environment><super>Tools.FullSystemBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tabApplication </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelNameSpaceCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.NameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelNameSpaceGlobalCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.ParcelNameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>DebugContextsBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stackSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.DebugContextsBrowserHelper</class-id><body>This class represents a list of contexts in a debugger.Instance Variables:stackSize		&lt;Integer&gt;		how long a list of contexts is desired?</body></comment><class><name>SimpleBrowserModule</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list forcedValue nextModule browser selectionCandidates helpers deselectNext cachedComponents allowsMultiSelect specName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.SimpleBrowserModule</class-id><body>This represents a browser's interface onto one of its list views. This particular class supports a list with multiple selections, but only one BrowserHelper, or personality. This means that the list view will always contain generally the same kind of data, as opposed to (say) a list view that sometimes displays shared variables and sometimes message selectors.The module accesses whichever BrowserHelper is currently appropriate via "self currentHelper."Instance Variables:list	&lt;SelectionInList | MultiSelectionInList&gt;	The list plus selection combination that interfaces to the list widgetforcedValue	&lt;nil | Object&gt;	If nil, the module is attached to a list view, and can ask one of its helpers to compute a list for the list view. If not nil, the module does not correspond to a list view, and appears only as a submenu on the menu bar. It behaves to its helpers as though it had a list with a single item (the forced value) which is always selected.nextModule	&lt;SimpleBrowserModule&gt;	The next module in the list, which allows the list of modules to trigger cascading reactions based on selections or on menu actionsbrowser	&lt;SystemBrowser&gt;	Allows the module or its helpers to access the entire containing browser, for global information.selectionCandidates	&lt;nil | Set&gt;	cache of selections so that the module can update these selections at the same time as it updates the list, rather than updating the list, followed by updating the selections, which would flash badly.primaryObject	&lt;Object&gt;	A piece of context possibly used by the BrowserHelper to compute a list. For example, if the list displays some of the shared variables in a NameSpace, this might hold the NameSpace that is being viewed.secondaryObject	&lt;Object&gt;	A secondary piece of information used to filter the information that a BrowserHelper presents. For example, if the primaryObject is a NameSpace, the secondaryObject might be a category within that NameSpace.helpers	&lt;Array of: BrowserHelper&gt;	list of the possible BrowserHelpers, or personalities, that the module can express. If this list contains more than one helper, the receiver needs to implement some algorithm for deciding which one is currently appropriate.</body></comment><class><name>HierarchicalBrowserModule</name><environment>Tools</environment><super>Tools.SimpleBrowserModule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>HierarchyBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>BlankUI</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blankList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>MethodListBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label baseList initialSelection </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.PackageChooser			private Store.DbRegistry			</imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.MethodListBrowserHelper</class-id><body>This class represents a list of independent MethodDefinitions collected from some external source.Instance Variables:label	&lt;String&gt;	label for the windowbaseList	&lt;List&gt;		collection of MethodDefinitions to be displayed. This list may shrink over time as methods are found to no longer exist.initialSelection	&lt;String&gt;	When a method is selected, the string that should be high-lighted in the method's source code.</body></comment><class><name>NameSpaceNavigator</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>home list path action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ClassHierarchyBrowserHelper</name><environment>Tools</environment><super>Tools.ClassesBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.ClassHierarchyBrowserHelper</class-id><body>This class represents a class hierarchy, including a class, all of its superclasses, and all of its subclasses. It requires that its module's "primaryObject" be a class, which it uses as the starting point for creating the class hierarchy. This primaryObject can be accessed via "self baseClass".</body></comment><class><name>ParcelListBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>MorphingBrowserModule</name><environment>Tools</environment><super>Tools.SimpleBrowserModule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.MorphingBrowserModule</class-id><body>This class refines its superclass to allow more than one BrowserHelper, with a very specific mechanism for choosing. If the primaryObject is a class, and the browser's "mode" for classes is either #instance or #class, then the module uses the BrowserHelper that is appropriate for looking at the class's methods (or those of its metaclass). But if the primaryObject is a NameSpace, or if it is a class but the browser's mode is #data, then the module's currentHelper is the BrowserHelper appropriate for showing shared variables in a NameSpace. In this case, the BrowserHelper treats a Class as a NameSpace by showing the contents of its classPool.Instance Variables:specName	&lt;Symbol&gt;	class-side message selector that returns an encoded UISpec for the list view.</body></comment><class><name>BrowserListEntry</name><environment>Tools</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type offset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NameSpaceHierarchyBrowserHelper</name><environment>Tools</environment><super>Tools.HierarchyBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><shared-variable><name>Map</name><environment>Tools.BrowserListEntry</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OldBrowsers</package></attributes></shared-variable><shared-variable><name>MaxMenuEntryWidth</name><environment>Tools.BrowserHelper</environment><private>false</private><constant>false</constant><category>Menus</category><initializer>36</initializer><attributes><package>OldBrowsers</package></attributes></shared-variable><shared-variable><name>MaxSelectorSubMenuEntries</name><environment>Tools.BrowserHelper</environment><private>false</private><constant>false</constant><category>Menus</category><initializer>20</initializer><attributes><package>OldBrowsers</package></attributes></shared-variable><shared-variable><name>MethodMoveProtocol</name><environment>Tools.MethodsBrowserHelper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OldBrowsers</package></attributes></shared-variable><shared-variable><name>LastProtocol</name><environment>Tools.ProtocolBrowserHelper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OldBrowsers</package></attributes></shared-variable><methods><class-id>Tools.PickASomethingDialog</class-id> <category>private</category><body package="OldBrowsers">selectedVisualBlock	"Supply the block that determins the appearance for selected list entries."	^[ :view :index | | aText anItem listEntry label |	   listEntry :=  view sequence at: index.	   anItem := listEntry value.	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).  	   (label:= listEntry displayLabel: aText) attributes: view textStyle; offset: label offset.	   label:= ReversingWrapper on: label.	   label reverse setValue: true.	   BoundedWrapper on: label]</body><body package="OldBrowsers">textEmphasisForItem: anItem	"Supply the default emphasis for list items"		^#( #norm )</body><body package="OldBrowsers">textForItem: aListEntry	^aListEntry fullName asText</body><body package="OldBrowsers">visualBlock	"Supply the block that determins the appearance for unselected list entries."	^[:view :index | | aText anItem listEntry label |	   listEntry := view sequence at: index.	   anItem := listEntry value.	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).	   (label := listEntry displayLabel: aText) attributes: view textStyle; offset: label offset.	   BoundedWrapper on: label]</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>change</category><body package="OldBrowsers">changedSelection	self list selection isNil 		ifTrue: [accept value: false]		ifFalse: [accept value: true]</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>intialize</category><body package="OldBrowsers">intialize	self list onChangeSend: #changedSelection to: self</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>interface opening</category><body package="OldBrowsers">postBuildWith: aBuilder	| component |	(component := aBuilder componentAt: #list) isNil ifTrue: [^self].	component widget		visualBlock: self visualBlock;		selectedVisualBlock: self selectedVisualBlock</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>actions</category><body package="OldBrowsers">doAccept	self list selection isNil		ifTrue: [accept value: false]		ifFalse: 			[accept value: true.			self close]</body><body package="OldBrowsers">doubleClick	self doAccept</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>aspects</category><body package="OldBrowsers">list	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^list isNil		ifTrue:			[list := SelectionInList new]		ifFalse:			[list]</body></methods><methods><class-id>Tools.PickASomethingDialog class</class-id> <category>opening</category><body package="OldBrowsers">pickASomethingFrom: aListOfBrowserListEntries	| sd |	sd := self new.	sd list list: aListOfBrowserListEntries.	sd open ifFalse:[^nil].	^sd list selection</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>utility</category><body package="OldBrowsers">findASomething: prompt		"Repeatedly prompt the user for a name or pattern, allowing retries	until the user cancel's or returns an empty string.	Answer the obj or nil"	| test |	[ test := self pickASomething: prompt.	( test == false )		and:	[ ( Dialog confirm: (#NoMatchingObjectTryAgainQ &lt;&lt; #dialogs &gt;&gt; 'No matching object, try again?') for: self interfaceWindow )					ifFalse: [ ^nil ]					ifTrue: [ true ] 		]	] whileTrue.	^test</body><body package="OldBrowsers">pickASomething: prompt 	"Choose a class, namespace or global name with a prompter."	"Prompt the user for a name or pattern. 	Answer nil if the user cancelled. 	Answer the class/namespace, if there is only one class/namespace that matches. 	If there is more than one match, prompt the user with a choice of matches, and	return the selected or an empty string. 	If there are no matches, answer the first global name that 		matches, or nil if there are none."	| destName pick matches |	destName := Dialog request: prompt for: self interfaceWindow.	destName = '' ifTrue: [^nil].	Cursor execute		showWhile: 			[| objects |			objects := Root withAllNameSpacesAndAllClassesAndStatics.			matches := objects select: [:mod | (destName includes: $.)							ifFalse: [destName match: mod name]							ifTrue: [destName match: mod fullName]]].	(matches == nil or: [matches size = 0])		ifTrue: [^false].	matches size = 1 ifTrue: [^matches first].	matches := matches asSortedCollection: [:a :b | a fullName &lt; b fullName].	pick := #{Tools.PickASomethingDialog} value pickASomethingFrom: (matches collect: [:m | self decorateForAnyType: m]).	^pick value</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForMultiSelect	^#(#fileOut #hardcopy #remove)</body><body package="OldBrowsers">actionsForNoSelect	^#()</body><body package="OldBrowsers">augmentMenuBarMenu: menu	menu menuItems do: 		[ :item |  | aModule action |		aModule := self  menuHeader.		item truePerformerBlock: [ :cont | cont performer truePerformerFor: aModule ].		item submenu == nil			ifFalse: [ self augmentMenuBarMenu: item submenu ].		action := item value.		action isSymbol			ifTrue: 				[ item value:	[:cont | cont performer browser module: aModule action: action ] ]		]</body><body package="OldBrowsers">buildToolBar: aMenu</body><body package="OldBrowsers">buildViewMenu: aMenu</body><body package="OldBrowsers">flushMenus	self browser notNil ifTrue:		[self browser			setListMenu: nil for: self;			setMenuBarMenu: nil for: self]</body><body package="OldBrowsers">getListMenu	| theMenu |	(theMenu := self browser getListMenuFor: self) == nil ifTrue: 		[theMenu := self class getListMenu.		 self browser setListMenu: theMenu for: self].	^theMenu</body><body package="OldBrowsers">getListMenu: forMenuBar	| menu |	menu := forMenuBar			ifTrue: [self getMenuBarMenu]			ifFalse: [self getListMenu].	menu == nil ifTrue: [menu := Menu new].	self setEnablement: menu.	^menu</body><body package="OldBrowsers">getMenuBarMenu	| theMenu |	(theMenu := self browser getMenuBarMenuFor: self) == nil ifTrue: 		[theMenu := self class getListMenu.		 self browser setMenuBarMenu: theMenu for: self.		 self augmentMenuBarMenu: theMenu].	^theMenu</body><body package="OldBrowsers">menuHeader	^self class menuHeader</body><body package="OldBrowsers">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Any item that has an enablementSelector will override this."	"Don't override a menu items particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	self howManySelections = 0		ifTrue: 			[self menu: menu do: [:item | item disable].			self actionsForNoSelect do: [:nm | self enable: nm on: menu]]		ifFalse: [self howManySelections = 1				ifTrue: [self menu: menu do: [:item | item enable]]				ifFalse: 					[self menu: menu do: [:item | item disable].					self actionsForMultiSelect do: [:nm | self enable: nm on: menu]]].	^menu</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>private</category><body package="OldBrowsers">changeRequest	^self browser changeRequest</body><body package="OldBrowsers">decorate: item	^#{Tools.BrowserListEntry} value value: item type: nil</body><body package="OldBrowsers">decorateForAnyType: item		| type |	type := nil.	item isForNameSpace		ifTrue: [type := #nameSpace].	item isBindingReference ifTrue: [type := 	#variable ].	^#{Tools.BrowserListEntry} value value: item type: type</body><body package="OldBrowsers">enable: itemName on: menu	menu == nil ifTrue: [^false].	menu menuItems do: [:it |		it nameKey = itemName			ifTrue:				[it enable.				self menu: it submenu do: [:i | i enable].				^true].		(self enable: itemName on: it submenu)			ifTrue: [it enable]].	^false</body><body package="OldBrowsers">fileEncoding	^self browser fileEncoding</body><body package="OldBrowsers">hardcopyStream: aStream	Cursor wait		showWhile: 			[aStream contents asComposedText hardcopy]</body><body package="OldBrowsers">interfaceWindow	^self browser interfaceWindow</body><body package="OldBrowsers">listBrowserClass	^#{Tools.FullSystemBrowser} value</body><body package="OldBrowsers">logProtocolChange: aString	"Add aString, which is an executable account of the last protocol change (rename,	remove, selector move) to the changes file."	SourceFileManager default logChange: aString</body><body package="OldBrowsers">menu: menu do: aBlock	menu == nil ifTrue: [^self].	menu menuItems do: [:it |		aBlock value: it.		it submenu == nil			ifFalse: [self menu: it submenu do: aBlock]]</body><body package="OldBrowsers">methodCollector	^self browser methodCollector</body><body package="OldBrowsers">prompt: promptString initially: initialString	"Prompt the user with the message question promptString, with initial 	answer initialString, and accept the answer either with the menu 	item accept or the keyboard press RETURN. Answer the string that 	the user provides."	^Dialog 		request: promptString		initialAnswer: initialString		for: self interfaceWindow</body><body package="OldBrowsers">textEmphasisForItem: anItem	"Supply the default emphasis for list items"		^#( #norm )</body><body package="OldBrowsers">textForItem: aListEntry	^aListEntry displayString asText</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">broadcastUpdate: aspect	module nextModule == nil		ifFalse: [module nextModule broadcastUpdate: aspect]</body><body package="OldBrowsers">spawnBrowser	"Trigger the 'spawn' action, via a double-click.	If there are more than one types of spawning,	this may not necessarily be the same as the	'spawn' menu item."	self spawn</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">attribute	^attribute</body><body package="OldBrowsers">attribute: aSymbol	"Set the attribute that this helper is responsible for selecting."	attribute := aSymbol</body><body package="OldBrowsers">category	^self selected: #category</body><body package="OldBrowsers">currentParcel	^self selectedParcel</body><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	self subclassResponsibility</body><body package="OldBrowsers">defaultSelectionId	"Answer the default id used for making and querying selections."	^#default</body><body package="OldBrowsers">environment	^self selected: #environment</body><body package="OldBrowsers">selected: aSymbol	"Answer the selected value for an atttirbute."	^self browser selected: aSymbol for: self selectionId</body><body package="OldBrowsers">selectedClassOrNameSpace	^self selected: #classOrNameSpace</body><body package="OldBrowsers">selectedParcel	^self browser selectedParcelFor: self selectionId</body><body package="OldBrowsers">selectionId	^selectionId</body><body package="OldBrowsers">selectionId: aSymbol	"Set the id used for setting selections."	selectionId := aSymbol</body><body package="OldBrowsers">setSelection	"Inform the browser that the selection has changed."		self setSelection: self selectedItem.</body><body package="OldBrowsers">setSelection: aValue	"Inform the browser that the selection has changed."		self browser setSelection: attribute for: selectionId to: aValue</body><body package="OldBrowsers">setSelection: attr for: id to: aValue	"Inform the browser that the selection has changed."		self browser setSelection: attr for: id to: aValue</body><body package="OldBrowsers">targetClass	"Answer the browsers currently selected class, nil if no class selected"	| obj |	obj := self selectedClassOrNameSpace.	^( obj ~~ nil and: [ obj isForClass ] )		ifTrue: [ obj ]</body><body package="OldBrowsers">targetClassOrNameSpace	"Answer the browsers currently selected class, namespace or classes namespace."	| obj |	obj := self selected: #classOrNameSpace.	^( obj ~~ nil and: [ self browser isData ] )		ifTrue: [ obj asNameSpace ]		ifFalse: [ obj ]</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>testing</category><body package="OldBrowsers">allowsMultiSelect	^true</body><body package="OldBrowsers">hasSelections	"Does the receiver have any selections?"	^self selections isEmpty not</body><body package="OldBrowsers">isData	^module browser isData</body><body package="OldBrowsers">isMeta	^module browser isMeta</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>initialize</category><body package="OldBrowsers">initialize	attribute:= self defaultAttribute.	selectionId := self defaultSelectionId.</body><body package="OldBrowsers">module: aModule	module := aModule</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">addClientDataTo: anIdentityDict	"If a drag is possible, add the current selection(s) to the dictionary and answer true.	 Otherwise answer false."	^false</body><body package="OldBrowsers">canAcceptDropFrom: aDC 	self subclassResponsibility</body><body package="OldBrowsers">doDrag: aController	"Drag the currently selected category."	| clientData data ds dm |	clientData := IdentityDictionary new.	(self addClientDataTo: clientData ) ifFalse:[^self].	data := DragDropData new.	data key: self getDragDropKey.	data contextWindow: self interfaceWindow.	data contextWidget: aController view.	data contextApplication: self browser.	data contextApplicationType: self contextApplicationKey.	data clientData: clientData.	ds := DropSource new.	dm := DragDropManager withDropSource: ds withData: data.	dm doDragDrop</body><body package="OldBrowsers">dragEnter: aDragContext 	"A drag has just entered"	(self canAcceptDropFrom: aDragContext)		ifFalse: [^#dropEffectNone].	aDragContext dropTarget clientData: self module initialListDropState.	^#dropEffectMove</body><body package="OldBrowsers">dragLeave: aDragContext 	"A drag has left the category list of a normal browser. If the drag contains a 	class, we must restore the state of the category list."	(self canAcceptDropFrom: aDragContext)		ifFalse: [^#dropEffectNone].	self restoreListStateFrom: aDragContext dropTarget clientData.	aDragContext dropTarget clientData: nil.	^#dropEffectNone</body><body package="OldBrowsers">dragOver: aDragContext 	"A drag is over us "	^(self canAcceptDropFrom: aDragContext)		ifTrue: 			[self showDropFeedbackFor: aDragContext.				#dropEffectMove]		ifFalse: [#dropEffectNone]</body><body package="OldBrowsers">drop: aDragContext	"A drop has occurred in the category list of a normal brower.	If the drop contained a class, move the class to the category targetted.	If the drop contained a category, the user has aborted a category	drag. By default do nothing."	^#dropEffectNone</body><body package="OldBrowsers">getDragDropKey	"return the data key for the drag"	self subclassResponsibility</body><body package="OldBrowsers">initialListDropState	^self module initialListDropState</body><body package="OldBrowsers">restoreListStateFrom: aDictionary	self module restoreListStateFrom: aDictionary</body><body package="OldBrowsers">showDropFeedbackFor: aDragContext	self module showDropFeedbackFor: aDragContext</body><body package="OldBrowsers">wantToDrag: aController	^self module list list size &gt; 0</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>drag and drop keys</category><body package="OldBrowsers">allowsMultiSelectKey	^self class allowsMultiSelectKey</body><body package="OldBrowsers">categoryKey	^self class categoryKey</body><body package="OldBrowsers">classOrNamespaceKey	^self class classOrNamespaceKey</body><body package="OldBrowsers">contextApplicationKey	^self class contextApplicationKey</body><body package="OldBrowsers">parcelKey	^self class parcelKey</body><body package="OldBrowsers">protocolKey	^self class protocolKey</body><body package="OldBrowsers">selectorOrStaticKey	^self class selectorOrStaticKey</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">howManySelections	^module howManySelections</body><body package="OldBrowsers">intializeListFull	"if there is a speed problem follow the other examples that initialize the list wit setListSilently:"	self updateListFull</body><body package="OldBrowsers">selectedItem	^self selection</body><body package="OldBrowsers">selection	^module selection</body><body package="OldBrowsers">selectionChanged	self browser		batchUpdates: []</body><body package="OldBrowsers">selections	^module selections</body><body package="OldBrowsers">setNewList: newList	^module setNewList: newList</body><body package="OldBrowsers">updateListFull	^self</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">browser	^module browser</body><body package="OldBrowsers">emphasizer	^self browser emphasizer</body><body package="OldBrowsers">initialSelection	^nil</body><body package="OldBrowsers">module	^module</body><body package="OldBrowsers">nextModule	^module nextModule</body><body package="OldBrowsers">selector	^nil</body><body package="OldBrowsers">windowLabel	^(#UnknownBrowserType &lt;&lt; #dialogs &gt;&gt; 'Unknown Browser type')</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptDefinition: aText from: aController	"Compiles random defintion."	| thing |	thing :=		[ | theThing |		Cursor execute showWhile: 			[ theThing := self definitionCompilerClass new				evaluate: aText string				in: nil				allowReceiver: false				receiver: nil				environment: self doItEnvironment				notifying: aController				ifFail: [^false]			].		SourceFileManager default logChange: aText string.		theThing		] on: Object errorSignal do: 			[ :ex | 			ex willProceed				ifTrue: 					[ (Dialog confirm: ((#IsnDoYouWantToContinueQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;&lt;n&gt;Do you want to continue?') expandMacrosWith: ex errorString)							for: self interfaceWindow)						ifTrue: [ex proceed]]						ifFalse: [Dialog warn: ex errorString for: self interfaceWindow].					ex returnWith: nil					].	(thing allowsSelfDefinition or: [thing isBindingReference])		ifTrue: 			[ thing isBehavior ifTrue: [ thing := thing instanceBehavior ].			self updateListForDefinedThing: thing.			^true]		ifFalse: [^false]</body><body package="OldBrowsers">acceptText: text from: textController	"Indicate that we didn't even try."	^nil</body><body package="OldBrowsers">definitionCompilerClass	^Compiler</body><body package="OldBrowsers">doItEnvironment	^nil</body><body package="OldBrowsers">doItReceiver	^nil</body><body package="OldBrowsers">explainSpecial: string for: explainer	"Answer with a string explaining the code view selection if it is 	displaying one of the special edit functions."	^nil</body><body package="OldBrowsers">formatFor: aController	^self</body><body package="OldBrowsers">text	^nil</body><body package="OldBrowsers">updateListForDefinedThing: class	^nil</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>drag and drop keys</category><body package="OldBrowsers">allowsMultiSelectKey	^#allowsMultiSelect</body><body package="OldBrowsers">categoryKey	^#category</body><body package="OldBrowsers">classOrNamespaceKey	^#classOrNamespace</body><body package="OldBrowsers">contextApplicationKey	^#vw_browser</body><body package="OldBrowsers">parcelKey	^#parcel</body><body package="OldBrowsers">protocolKey	^#protocol</body><body package="OldBrowsers">selectorKey	^#selector</body><body package="OldBrowsers">selectorOrStaticKey	^#selectorOrStatic</body><body package="OldBrowsers">staticKey	^#static</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">listMenu	^nil</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">getListMenu	| theMenu |	theMenu := self listMenu.	^[theMenu			augmentFrom: self			to: #{BrowserHelper} value			menuName: self listMenuName			for: self]		on: Error		do: [:ex| theMenu]</body><body package="OldBrowsers">listMenuName	^#listMenu</body><body package="OldBrowsers">menuHeader	^self name</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>instance creation</category><body package="OldBrowsers">new	^super new initialize</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>class initialization</category><body package="OldBrowsers">classMethodsChanged	#{BrowserHelper} value flushMenus</body><body package="OldBrowsers">flushMenus	"Flush the receiver's menus.  If the receiver is the abstract superclass then flush all subclasses too."	"BrowserHelper flushMenus"	self allInstancesDo: [:bh| bh flushMenus].	self == #{BrowserHelper} value ifTrue:		[self allSubclassesDo:			[:helperClass| helperClass flushMenus]]</body><body package="OldBrowsers">instanceMethodsChanged	#{BrowserHelper} value flushMenus</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForClassesOnly	^#( #allSenders #allImplementors #localSenders #localImplementors )</body><body package="OldBrowsers">actionsForMultiSelect	^#(#fileOut #hardcopy #spawn  #remove)</body><body package="OldBrowsers">actionsForStaticsOnly	^#( #initializeStatic )</body><body package="OldBrowsers">getListMenu: forMenuBar	| menu sel md |	menu := super getListMenu: forMenuBar.	( (sel := self selection) == nil  )		ifTrue: [ md := nil ]		ifFalse:			[ md := self definitionOf: sel].	self enhance: menu for: md		submenu: #allSenders		sending: (md isBindingReference ifTrue:[#browseAllStaticReferences: ] ifFalse:[#browseAllReferences:]).	self enhance: menu for: md		submenu: #allImplementors		sending:  (#browseAllImplementors:). 	self enhance: menu for: md		submenu: #localSenders		sending: (#browseLocalReferences:). 	self enhance: menu for: md		submenu: #localImplementors		sending:(#browseLocalImplementors:).  	self enhance: menu for: md		submenu: #initializeStatic		sending: #initializeStatic.	^menu</body><body package="OldBrowsers">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Don't override a menu items particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	self menu: menu do: 		[ :item | 		( self actionsForStaticsOnly includes: item nameKey )			ifTrue: 				[ self isData					ifTrue: [ item enabled: ( self selection ~~ nil ) ]					ifFalse: [ item disable ]				]		].		^menu</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#method</body><body package="OldBrowsers">selectMethod: aSymbol	module select: aSymbol whenFinished: [module updateList]</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">proposedWindowLabel	^self windowLabel</body><body package="OldBrowsers">selector	| def |	self selection == nil ifTrue: [^nil].	^(self definitionOf: self selection) isNil 		ifTrue:[ self selection ] 		ifFalse:			[ ( def := self definitionOf: self selection ) isBindingReference				ifTrue: [ nil ]				ifFalse: [ def selector ]			]</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">browseAllImplementors: aSelector	| def realSelector mc |	def := self definitionOf: self selection.	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#BrowseAllImplementors &lt;&lt; #dialogs &gt;&gt; 'View all implementors&lt;n&gt;of which selector?') from: def]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect: (mc implementorsOf: realSelector)</body><body package="OldBrowsers">browseAllReferences: aSelector	| def realSelector mc |	def := self definitionOf: self selection.	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#BrowseAllImplementors &lt;&lt; #dialogs &gt;&gt; 'View all implementors&lt;n&gt;of which selector?') from: def]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect: (mc referencesTo: realSelector)</body><body package="OldBrowsers">browseAllStaticImplementors: aStatic| mc |	Cursor wait showWhile:[	mc := self methodCollector.	mc browseSelect: (mc implementorsOf: (aStatic environment bindingFor: aStatic name ))]."	| def realSelector mc |	def := self definitionOf: module selection.	realSelector := aSelector == nil		ifTrue: [self chooseSelector: 'View all implementors&lt;n&gt;of which selector?' from: def]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect: (mc implementorsOf: realSelector)"</body><body package="OldBrowsers">browseAllStaticReferences: aStatic	| mc |	Cursor wait showWhile:[	mc := self methodCollector.	mc browseSelect: (mc referencesTo: (aStatic environment bindingFor: aStatic name ))]</body><body package="OldBrowsers">browseLocalImplementors: aSelector	| def realSelector mc |	def := self definitionOf: self selection.	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#ViewLocalImplementorsnOfWhichSelectorQ &lt;&lt; #dialogs &gt;&gt; 'View local implementors&lt;n&gt;of which selector?') from: def]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect:			(mc searchClassHierarchy: def implementingClass)			&amp; (mc implementorsOf: realSelector)</body><body package="OldBrowsers">browseLocalReferences: aSelector	| def realSelector mc |	def := self definitionOf: self selection.	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#ViewLocalSendersnOfWhichSelectorQ &lt;&lt; #dialogs &gt;&gt; 'View local senders&lt;n&gt;of which selector?') from: def]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect:			(mc searchClassHierarchy: def implementingClass)			&amp; (mc referencesTo: realSelector)</body><body package="OldBrowsers">browseLocalStaticImplementors: aSelector</body><body package="OldBrowsers">browseLocalStaticReferences: aSelector</body><body package="OldBrowsers">fileOut	| fileName sel fileManager toBeSaved |	toBeSaved := module selections collect: 		[:slctn | self definitionOf: slctn ].	toBeSaved first isBindingReference ifTrue:[^self fileOutStatic].	toBeSaved := toBeSaved select: [ :md | md method notNil ].	toBeSaved size = module selections size		ifFalse: [Dialog warn: (#SomeMethodsDoNotExistNotFiledOut &lt;&lt; #dialogs &gt;&gt; 'Some methods do not exist, and will not be filed out')					for: self interfaceWindow].	toBeSaved isEmpty ifTrue: [ ^self ].	toBeSaved size = 1		ifTrue: [sel := toBeSaved first selector copyWithout: $:.				sel := toBeSaved first implementingClass name, '-', sel, '.st']		ifFalse: [sel := 'methods.st'].	fileName := Dialog				requestNewFileName: (#FileOutAs &lt;&lt; #dialogs &gt;&gt; 'File out as')				default: (Filename filterFilename: sel).	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[ fileManager timeStamp.	toBeSaved do: 		[ :md |		fileManager fileOutMessages: ( Array with: md selector )			for: md implementingClass		]	] ensure: [ fileManager close ]</body><body package="OldBrowsers">fileOutStatic	| fileName fileManager nm toBeSaved |		toBeSaved := self selections collect: 		[:slctn | self definitionOf: slctn ].	nm := module selection == nil			ifTrue: [(#Definitions &lt;&lt; #dialogs &gt;&gt; 'Definitions') asString]			ifFalse: [(self textForItem: module selection) asString].	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	toBeSaved				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers">hardcopy	"Print the method."		| stream toBeSaved |	toBeSaved := module selections collect: [:slctn |			self definitionOf: slctn].	toBeSaved first isBindingReference ifTrue:[^self hardcopyStatic].	toBeSaved := toBeSaved select: [:md | md method notNil].	toBeSaved size = module selections size		ifFalse: [Dialog warn: (#SomeMethodsDoNotExistNotBePrintedOut &lt;&lt; #dialogs &gt;&gt; 'Some methods do not exist, and will not be printed out')					for: self interfaceWindow].	toBeSaved isEmpty ifTrue: [^self].	stream := TextStream on: (String new: 1000).	toBeSaved do: [:md |		md implementingClass printMethod: md selector on: stream].	self hardcopyStream: stream</body><body package="OldBrowsers">hardcopyStatic	"Print the category."		| stream toBePrinted |		toBePrinted := module selections collect: 		[:slctn | self definitionOf: slctn ].	stream := TextStream on: (String new: 1000).	toBePrinted				do: [:thing |					stream nextPutAll: thing definition.					stream cr; cr].	self hardcopyStream: stream</body><body package="OldBrowsers">initializeStatic	module selections do: 		[:slctn |  | def |		def := self definitionOf: slctn.		def isBindingReference ifTrue:			[def initialize. 			 SourceFileManager default putInitializeFor: def]]</body><body package="OldBrowsers">move	| newProtocol classPart destClass protStart moved destClassName selector def |		self changeRequest ifFalse: [^self].	def := self definitionOf: self selection.	def isBindingReference ifTrue:[ ^self moveStatic: def].	selector := def selector.	#{MethodsBrowserHelper.MethodMoveProtocol} value == nil ifTrue: [#{MethodsBrowserHelper.MethodMoveProtocol} value: ''].	newProtocol := self prompt: (#EnterTargetProtocolCopy &lt;&lt; #dialogs &gt;&gt; 'Type destination protocol(Class&gt;protocol will copy)') initially: #{MethodsBrowserHelper.MethodMoveProtocol} value.	newProtocol isEmpty ifTrue: [^self].	#{MethodsBrowserHelper.MethodMoveProtocol} value: newProtocol.	moved := false.	(newProtocol includes: $&gt;)		ifTrue: 			["copy to another class"			classPart := newProtocol copyUpTo: $&gt;.			destClassName := classPart copyUpTo: Character space.			destClass := destClassName asQualifiedReference valueOrDo: [].			destClass isBehavior				ifFalse: [ ^nil].			classPart size = destClassName size				ifFalse:					[(classPart size-destClassName size = 6						and: [(classPart copyFrom: classPart size - 5 to: classPart size) = ' class'])								ifTrue: [destClass := destClass class]								ifFalse: [^nil]].			protStart := classPart size + 2.			[(newProtocol at: protStart) = $ ]				whileTrue: [protStart := protStart + 1].			newProtocol := (newProtocol copyFrom: protStart to: newProtocol size) asSymbol.			destClass == def implementingClass				ifFalse:					[moved := true.					destClass compile: self text classified: newProtocol notifying: nil]]		ifFalse: 			["move within this class"			destClass := def implementingClass.			newProtocol := newProtocol asSymbol].	moved		ifFalse: 			[(destClass organization categories includes: newProtocol)				ifFalse: 					[destClass organization addCategory: newProtocol].			destClass classifySymbol: selector under: newProtocol.			self logProtocolChange: ('&lt;1p&gt; organization classify: &lt;2p&gt; under: &lt;3p&gt;'						expandMacrosWith: destClass						with: selector						with: newProtocol)].	module select: module selection		whenFinished: [self browser updateLists].</body><body package="OldBrowsers">moveStatic: aBindingReference	| newProtocol moved classPart destClassName destClass protStart |	#{MethodsBrowserHelper.MethodMoveProtocol} value == nil ifTrue: [#{MethodsBrowserHelper.MethodMoveProtocol} value: ''].	newProtocol := self prompt: (#EnterTargetProtocolMove &lt;&lt; #dialogs &gt;&gt; 'Type destination protocol(Class&gt;protocol will move)') initially: #{MethodsBrowserHelper.MethodMoveProtocol} value.	newProtocol isEmpty ifTrue: [^self].	#{MethodsBrowserHelper.MethodMoveProtocol} value: newProtocol.	moved := false.	(newProtocol includes: $&gt;)		ifTrue: 			["copy to another class"			classPart := newProtocol copyUpTo: $&gt;.			destClassName := classPart copyUpTo: Character space.			destClass := destClassName asQualifiedReference valueOrDo: [].			(destClass isBehavior or: [destClass isNameSpace])				ifFalse: [ ^nil].			protStart := classPart size + 2.			[(newProtocol at: protStart) = Character space]				whileTrue: [protStart := protStart + 1].			newProtocol := (newProtocol copyFrom: protStart to: newProtocol size) asSymbol.			destClass == aBindingReference environment 				ifFalse:					[moved := true.					aBindingReference relocateTo: destClass.					destClass asNameSpace classifySymbol: aBindingReference name under: newProtocol asSymbol]]		ifFalse: 			["move within this class"			aBindingReference environment asNameSpace classifySymbol: aBindingReference name under: newProtocol asSymbol.			destClass := aBindingReference environment.			newProtocol := newProtocol asSymbol].	moved		ifFalse: 			[self logProtocolChange: ('&lt;1p&gt; organization classify: &lt;2p&gt; under: &lt;3p&gt;'						expandMacrosWith: destClass						with: aBindingReference						with: newProtocol)].	module select: self selection		whenFinished: [module updateList].</body><body package="OldBrowsers">remove	| toBeSaved staticsToBeRemoved |	toBeSaved := module selections collect: [:slctn | self definitionOf: slctn].	staticsToBeRemoved := toBeSaved select: [:each | (each respondsTo: #selector) not].	self removeStatics: staticsToBeRemoved.	toBeSaved := toBeSaved select:[:each | (each respondsTo: #selector)].	toBeSaved isEmpty ifTrue: [^false].	toBeSaved := toBeSaved select: [:md | md method notNil].	(self changeRequest 	and: [Dialog			confirm: (#AreYouCertainYouWantnRemoveMethodsQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you want&lt;n&gt;to remove these methods?') expandMacros				for: self interfaceWindow])  ifTrue:		[toBeSaved do: [:md | md implementingClass removeSelector: md selector].		module updateList.		^true].	^false</body><body package="OldBrowsers">removeStatics: staticCollection		| bindings | 	self changeRequest ifFalse: [^false].	bindings := staticCollection asArray collect:				[:ref | 				ref isDefined					ifTrue: [ref]					ifFalse:						[Dialog warn: ((#CantRemoveObject1sNoLongerExists &lt;&lt; #dialogs &gt;&gt; 'Can''t remove the object. &lt;1s&gt; no longer exists.')										expandMacrosWith: ref simpleName asString)							for: self interfaceWindow.						nil]].	bindings := bindings copyWithout: nil.	bindings isEmpty ifTrue: [^false].	bindings := SystemUtils sortForLoading: bindings.	bindings reverseDo:		[:varRef |		(Dialog confirm: ((#DoYouWantToRemove1sQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you&lt;n&gt;want to remove &lt;1s&gt;?')					expandMacrosWith: varRef asString)				for: self interfaceWindow)			ifTrue: 				[(varRef subrequisites size = 0					or: [Dialog confirm: ((#HasDependentObjectsRemoveItAnywayQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dependent objects. Remove it anyway?')									expandMacrosWith: varRef asString)							for: self interfaceWindow])					ifTrue: [varRef removeFromSystem. 							module updateList.]]].		^false</body><body package="OldBrowsers">spawn	| toBeViewed |	toBeViewed := module selections collect: [:slctn |			self definitionOf: slctn].	toBeViewed := toBeViewed select:[:each | each isBindingReference ifTrue:[true] ifFalse:[each method notNil]].	toBeViewed size = module selections size		ifFalse: [Dialog warn: (#SomeMethodsDoNotExistAndIncluded &lt;&lt; #dialogs &gt;&gt; 'Some methods do not exist, and will not be included')					for: self interfaceWindow].	toBeViewed isEmpty ifTrue: [^self].	self browser		spawnForMethodsLabel:self proposedWindowLabel		list: toBeViewed asSortedCollection asList		initialSelection: nil.</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">addClientDataTo: anIdentityDict	| theSelectors theStatics theClassOrNameSpace |	self hasSelections ifFalse: [^false].	theStatics := self selections collect: [:slctn | self definitionOf: slctn].	theStatics := theStatics select: [:each | each isBindingReference].	theSelectors := self selections.	theSelectors := theSelectors select: [:each | (self definitionOf: each) isBindingReference not].	(theClassOrNameSpace := self selectedClassOrNameSpace) isNil ifTrue:		[^false].	theSelectors do: 		[:eachSel | 		(theClassOrNameSpace findSelector: eachSel) isNil ifTrue:			[Dialog warn: ((#Selector1pNoLongerExists &lt;&lt; #dialogs &gt;&gt; 'Selector &lt;1p&gt; no longer exists.') expandMacrosWith: self selection asString)					for: self interfaceWindow.			^false]].	anIdentityDict at: #environment put: theClassOrNameSpace environment.	anIdentityDict at: #selector put: theSelectors.	anIdentityDict at: #class put: theClassOrNameSpace.	anIdentityDict at: #protocol put: self protocols.	anIdentityDict at: #meta put: self browser meta.	anIdentityDict at: #category put: self category.	anIdentityDict at: #data put: theStatics.	^true</body><body package="OldBrowsers">canAcceptDropFrom: aDC	^false</body><body package="OldBrowsers">getDragDropKey	"return the data key for the drag"	^self selectorOrStaticKey.</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">doItEnvironment	| sel |	sel := self selection.	^sel == nil		ifTrue: [nil]		ifFalse: [(self definitionOf: sel) isBindingReference ifTrue:[(self definitionOf: sel) environment ] ifFalse:[(self definitionOf: sel) method environment]]</body><body package="OldBrowsers">doItReceiver	| sel |	sel := self selection.	^sel == nil		ifTrue: [nil]		ifFalse: [(self definitionOf: sel) implementingClass instanceBehavior]</body><body package="OldBrowsers">explainerClass	| def |	^self selection == nil		ifTrue: [ nil ]		ifFalse: 			[ ( def := self definitionOf: module selection ) isBindingReference				ifTrue: [ nil ]				ifFalse: [ def implementingClass ]			].</body><body package="OldBrowsers">formatFor: aController 	"Format the text. Have the controller replace its contents with the new Text, 	or nil if the format operation was unsuccessful."	| selectedClass aCompiler newText aText def |	aText := aController text.	def := self definitionOf: self selection.	(def isBindingReference or: [def isNil])		ifTrue: [ ^self ].	selectedClass := def implementingClass.	selectedClass isNil ifTrue: [^self].	aCompiler := selectedClass compilerClass new.	newText := aCompiler				format: aText				in: selectedClass				notifying: aController.	newText == nil ifFalse: [newText := newText asText makeSelectorBoldIn: selectedClass].	newText == nil		ifFalse: 			[aController 				selectFrom: 1 to: aController text size; 				deselect; 				replaceSelectionWith: newText asText; selectAt: 1.			aController view selectionStopIndex: aController text size + 1.			aController view invalidate]</body><body package="OldBrowsers">text	| choice |	choice := self selection.	^choice == nil		ifTrue: [self selections isEmpty			ifTrue: [nil]			ifFalse: [Text new]]		ifFalse:			[ | def |			def := self definitionOf: choice.			def isBindingReference				ifTrue: [ ( def definitionIfAbsent: [ (#noSource &lt;&lt; #dialogs &gt;&gt; 'no source') ] ) asText ]				ifFalse:					[ [ def sourceCode asText makeSelectorBoldIn: def implementingClass ] 						on: MethodDictionary keyNotFoundSignal do: 							[ :ex | ((#noSourceCodeFor1s &lt;&lt; #dialogs &gt;&gt; 'no source code for &lt;1s&gt;')			expandMacrosWith: def printString) asText 								emphasizeAllWith: #italic;								yourself							]					]			]</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">chooseSelector: label from: def	| msgs |	msgs := def method allSymbolLiterals asSortedCollection.	^Dialog choose: label expandMacros			fromList: msgs			values: msgs			lines: 20			cancel: []			for: self interfaceWindow</body><body package="OldBrowsers">decorate: item	| obj type |	obj := self definitionOf: item.	type := obj isBindingReference		ifTrue: [ 	#variable ]		ifFalse: [ obj method resourceType].	^#{Tools.BrowserListEntry} value value: item type: type</body><body package="OldBrowsers">enhance: menu for: md submenu: nameKey sending: msg 	| item modName selector selectors submenu otherItem |	modName := self menuHeader.	item := menu atNameKey: nameKey.	item isNil ifTrue: [^self].	md isBindingReference		ifTrue: 			[(self actionsForStaticsOnly includes: nameKey) ifTrue:				[item 					value: [:controller | self perform: msg]; 					submenu: nil.				^self ].			nameKey == #allSenders 				ifFalse: [^item disable; hidden: true].			item value: [:cont | cont performer					module: modName					action: msg					with: md].			item rawLabel: (#ReferencesTo &lt;&lt; #labels &gt;&gt; 'References to').			submenu := Menu new.			submenu addItem: ((MenuItem labeled: (md name asSymbol contractTo: #{BrowserHelper.MaxMenuEntryWidth} value))					value: item value).			item submenu: submenu]		ifFalse: [(md == nil or: [md method == nil])				ifFalse: 					[selector := md selector.					item hidden: false.					nameKey == #allSenders ifTrue: [item rawLabel: (#Senders &lt;&lt; #menus &gt;&gt; 'Senders')].					item value: [:cont | cont performer							module: modName							action: msg							with: selector].					submenu := Menu new.					"If selector is nil, then the ContextDefinition is a BlockContext whose source					does not have the #unboundMethod selector.  These types of contexts are 					typically created by CodeComponent and its #actionBlockFromString:. No use					in augmenting a menu for selector that does not exist.  Nor is there a real use					for augmenting the menu for the #unboundMethod selector, however we will					address that in the future."					selector isNil 						ifFalse: [submenu addItem: ((MenuItem labeled: (selector contractTo: #{BrowserHelper.MaxMenuEntryWidth} value)) value: item value)].					selectors := md method allSymbolLiterals.					selectors remove: selector ifAbsent: nil.					selectors := selectors asSortedCollection.					selectors isEmpty						ifFalse: 							[otherItem := MenuItem labeled: (#AllItemsDot &lt;&lt; #menus &gt;&gt; 'All Items...').							otherItem labelText: (Text string: otherItem rawLabel asString emphasis: #(#bold)).							otherItem value: [:cont | cont performer									module: modName									action: msg									with: nil].							submenu addLine; addItem: otherItem; addLine.							selectors := selectors copyFrom: 1 to: (selectors size min: #{BrowserHelper.MaxSelectorSubMenuEntries} value).							selectors								do: 									[:sel | 									otherItem := MenuItem labeled: (sel contractTo: #{BrowserHelper.MaxMenuEntryWidth} value).									otherItem value: [:cont | cont performer											module: modName											action: msg											with: sel].									submenu addItem: otherItem]].					item submenu: submenu]]</body><body package="OldBrowsers">open: editorName on: class selector: sel 	editorName isDefined		ifFalse:			[^Dialog warn: ((#HasNotBeenLoaded &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has not been loaded')						expandMacrosWith: editorName)				for: self interfaceWindow].	editorName value new openOnClass: class andSelector: sel</body></methods><methods><class-id>Tools.MethodsBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">menuHeader	^(#Method &lt;&lt; #menus &gt;&gt; '&amp;Method') asString</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	| newSelector |	(self protocols isNil or: [self protocols isEmpty])		ifTrue: [ ^nil ].	self targetClassOrNameSpace isNil ifTrue:[^nil].	newSelector := self targetClassOrNameSpace isForNameSpace 		ifTrue: [ self acceptTextForData: text from: textController ]		ifFalse: [ self acceptTextForMethod: text from: textController ].	newSelector == nil ifTrue: [ ^false ].	module select: newSelector	whenFinished: [ module updateList ].	^true</body><body package="OldBrowsers">acceptTextForData: text from: textController	^Compiler 		evaluate: text 		notifying: textController 		logged: true</body><body package="OldBrowsers">acceptTextForMethod: text from: textController	"If more than one protocol is selected, guess the one to use as follows:	if there is a selector selected, put the new method in the same protocol,	else ask the user.  This preserves the protocol of already existing	methods."	| protocol |	self protocols size = 0 ifTrue: 		[protocol := nil].	self protocols size = 1 ifTrue:		[protocol := self protocols first].	self protocols size &gt; 1 ifTrue:		[protocol := self targetClassOrNameSpace organization			categoryOfElement: self selector.		protocol isNil ifTrue:			[protocol := Dialog choose: (#PutMethodInColon &lt;&lt; #dialogs &gt;&gt; 'Put the method in:')					fromList: self protocols					values: self protocols					lines: 8					cancel: [^nil]]].	^self targetClass		compile: text		classified: protocol		notifying: textController.</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">definitionOf: anItem	| target |	target := self selectedClassOrNameSpace.	target == nil ifTrue: [ ^nil ].	^(  self isData or: [ target isForNameSpace ] )		ifTrue: [ BindingReference simpleName: anItem in: target ]		ifFalse: [ MethodDefinition class: target selector: anItem ]</body><body package="OldBrowsers">updateListFull	| protocolList target newList |	protocolList := self protocols.	target := self targetClassOrNameSpace.	(target isNil or: [protocolList isNil or: [protocolList isEmpty]])		ifTrue: [^module setNewList: List new].	newList := (target organization listAtCategoriesNamed: protocolList)		asSortedCollection.	target isForNameSpace		ifTrue: [ newList := newList select: [ :key | ( target bindingFor: key ) isForGeneral ] ].	module setNewList: newList asList</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">proposedWindowLabel	| writeStream |	self selection isNil ifFalse:		[^(#Ip2sMessageBrowser &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt;&gt;&gt;&lt;2s&gt; Message Browser')			expandMacrosWith: self selectedClassOrNameSpace			with: self selection].	writeStream := (String new: 30) writeStream.	self protocols do: [:protocol | writeStream nextPutAll: protocol; space].	^(#Ip2sMessageCategoryBrowser &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; {&lt;2s&gt;} Message Category Browser')			expandMacrosWith: self selectedClassOrNameSpace			with: writeStream contents</body><body package="OldBrowsers">protocols	"This replaces #protocol from the older code now that multiple	selection is supported.  It answers a collection of selected protocols,	or an empty collection; never nil. The original #protocol is obsolete	and its use is discouraged."	| protocols |	protocols := self selected: #protocol.	^protocols isNil 		ifTrue: [#()] 		ifFalse: [protocols]</body><body package="OldBrowsers">windowLabel	| stream |	stream := String new writeStream.	self protocols 		do: [ :p | stream nextPutAll: p ]		separatedBy: [ stream nextPutAll: ', ' ].	^(#Ip2sMessageCategoryBrowser &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; {&lt;2s&gt;} Message Category Browser')			expandMacrosWith: self selectedClassOrNameSpace			with: stream contents</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>obsolete</category><body package="OldBrowsers">protocol	"This method was used to return the selected protocol or nil. Now that multiple selection	of protocols is allowed, it is being sunset in favour of #protocols. Ideally, all users of this	method should switch to using #protocols. For now, it is here to prevent things from	breaking but it returns only the first selected protocol."	| protocols |	protocols := self protocols.	^protocols isEmpty 		ifTrue: [nil]		ifFalse: [protocols first]</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	"Override to add prompt for parcel membership, and	 retention of old method in parcel overrides."	| currentParcel theClass previousSelector result selector dialog spec aBuilder addSelector addOverride extent over |	currentParcel := self selectedParcel.	"below, answers nil if namespace. doesn't handle statics."	(theClass := self targetClass) isNil ifTrue: [^nil].	(currentParcel notNil	and: [(currentParcel definesClass: theClass) not	and: [(previousSelector := self selection) notNil]]) ifTrue:		[ over := Override forSelector: self selection class: theClass ].	result := super acceptText: text from: textController.	result ~~ true ifTrue: [^result].	selector := self selection.	selector isNil ifTrue:[^true ].	(currentParcel isNil	or: [currentParcel definesSelector: selector forClass: theClass]) ifTrue: [^true].	(over isNil	or: [previousSelector ~= selector]) ifTrue:		[(Dialog confirm: ((#Add1sToParcel &lt;&lt; #dialogs &gt;&gt; 'Add &lt;1s&gt; to parcel?') expandMacrosWith: selector)) ifTrue:			[self addSelectionToParcel].		^true].	dialog := SimpleDialog new.	spec := (dialog class interfaceSpecFor: #emptySpec).	aBuilder := dialog builder.	dialog initializeBuilderFor: self browser builder window.	aBuilder add: spec window.	aBuilder add: spec component.	dialog initializeWindowFor: self browser builder window.	dialog setInitialGap.	dialog		addMessage: ((#Add1sToParcel &lt;&lt; #dialogs &gt;&gt; 'Add &lt;1s&gt; to parcel?') expandMacrosWith: selector)		centered: true. 	dialog addGap: 4.	dialog		addCheckLabels: (Array with: (#addToParcel &lt;&lt; #dialogs &gt;&gt; 'add to parcel') with: (#overrideMove &lt;&lt; #dialogs &gt;&gt; 'move old version to overridden'))		values: (Array					with: (addSelector := true asValue)					with: (addOverride := over notNil asValue))		equalize: true		columns: 1.	dialog addDivider.	dialog addOK: [true].	dialog preOpen.	extent := aBuilder window displayBox extent.	aBuilder window maximumSize: extent.	aBuilder window minimumSize: extent.	aBuilder openDialogWithExtent: extent.	dialog cancel value ifTrue: [^true].	addSelector value ifTrue:		[self addSelectionToParcel.		(over notNil and: [addOverride value]) 			ifTrue: [ Override installMethodOverride: over ].		].	^true</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>parcel actions</category><body package="OldBrowsers">addSelectionToParcel	| target |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue: [ self selectedParcel addName: self selection in: target ]		ifFalse: [ self selectedParcel	addSelector: self selection forClass: target ].	self browser updateLists</body><body package="OldBrowsers">moveSelectionToParcel: aParcel	| target |	self changeRequest ifFalse: [^self].	target := self targetClassOrNameSpace.	self browser saveParcelsForUndo.	target isForNameSpace		ifTrue: 			[ self browser 				moveData: ( IdentitySet with: self selection )				inNameSpace: target				fromParcel: self  selectedParcel 				toParcel: aParcel			]		ifFalse:			[ self browser				moveSelectors: ( IdentitySet with: self selection )				inClass: target				fromParcel: self  selectedParcel 				toParcel: aParcel			].	self browser updateLists</body><body package="OldBrowsers">removeSelectionConflictsFromParcel	self unimplemented</body><body package="OldBrowsers">removeSelectionFromParcel	| target |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue: [ self selectedParcel removeName: self selection in: target ]		ifFalse: [ self selectedParcel	removeSelector: self selection forClass: target ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">remove	"Override to ensure the parcel forgets the selector if removed."	| removed parcel |	(removed := super remove) ifTrue:		[(parcel := self selectedParcel) notNil ifTrue: [parcel cleanse]].	^removed</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">selector	^self selection</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers">textEmphasisForItem: anItem	| target |	target := self selectedClassOrNameSpace.	target == nil ifTrue: [ ^#( norm ) ].	^( ( self isData or: [ target isForNameSpace ] )			ifTrue:				[ self emphasizer 					emphasisForStaticKey: anItem					for: self browser 					id: self selectionId				]			ifFalse: 				[ self emphasizer 					emphasisForSelector: anItem					for: self browser 					id: self selectionId				]			)</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">getListMenu: forMenuBar	| selector parcels cl menu |	selector := self selection.	cl := self targetClass.		"nil if namespace selected."	menu := super getListMenu: forMenuBar.	^self browser		addParceling: 			(selector isNil				ifTrue: [#()]				ifFalse:					[(parcels := self browser manager parcelsForClassOrNameSpace: cl) notEmpty ifTrue:						[(self definitionOf: selector) isBindingReference							ifTrue: [parcels select: [:p| p definesName: selector in: cl]]							ifFalse: [parcels select: [:p| p definesSelector: selector forClass: cl]]]])		to: menu		forHelper: self</body></methods><methods><class-id>Tools.Emphasizer</class-id> <category>private-status</category><body package="OldBrowsers">classOrNameSpaceStatus: anObject  criteria: criteria	^anObject isForClass		ifTrue: [ self classStatus: anObject criteria: criteria ]		ifFalse: [ self nameSpaceStatus: anObject criteria: criteria ]</body><body package="OldBrowsers">dataDefinitionStatus: aStaticDef  criteria: package 	^#( )		"the default highlighting is none."</body><body package="OldBrowsers">methodDefinitionStatus: aMethodDef  criteria: package 	^self 		selectorStatus: aMethodDef selector 		class: aMethodDef implementingClass		criteria: package</body></methods><methods><class-id>Tools.Emphasizer</class-id> <category>private</category><body package="OldBrowsers">currentCriteria: aBrowser id: selectionId	"Answer what we are highlighting based on."		^nil	"Ensures that the default Emphasizer adds no emphasis."</body><body package="OldBrowsers">emphasisForAttribute: status	"Answer an array of emphasis for a status. Default mapping is:		#entirelyDefined 	bold &amp; underline		#defined			bold		#definedByOther	italic		#extended			bold		#extendedByOther	italic		#conflict			red "	( ( #extended ==  status ) or: [ #defined == status] ) 		ifTrue: [ ^#( bold ) ].	#entirelyDefined == status 		ifTrue: [ ^#( #bold #underline ) ].	( ( #definedByOther == status ) or: [ #extendedByOther == status ] ) 		ifTrue: [ ^( #italic ) ].	#conflict == status 		ifTrue: [ ^Array with: ( #color-&gt;ColorValue red ) ] .	#notFound == status 		ifFalse: [ Transcript cr; print: status; endEntry ].	^#( #strikeout ) "as an error indication"</body><body package="OldBrowsers">manager	self subclassResponsibility</body><body package="OldBrowsers">mapStatusToEmphasis: statusSet	"Answer an array of emphasis for statusSet.	Status is: 		#entirelyDefined 			#defined  		#definedByOther			#extended					#extendedByOther			#conflict"	| emphasis |	emphasis := Set new: 4.	statusSet do: 		[ :status | emphasis addAll: ( self emphasisForAttribute: status ) ].	^emphasis asArray</body></methods><methods><class-id>Tools.Emphasizer</class-id> <category>api</category><body package="OldBrowsers">emphasisForCategory: aCategory for: aBrowser id: selectionId	"Answer the emphasis set for aCategory displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self categoryStatus: aCategory in: nil criteria: criteria ).</body><body package="OldBrowsers">emphasisForCategory: aCategory in: anEnvironment for: aBrowser id: selectionId	"Answer the emphasis set for aCategory displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self categoryStatus: aCategory in: anEnvironment criteria: criteria ).</body><body package="OldBrowsers">emphasisForClassButtons: aBehavior for: aBrowser id: selectionId	"Answer an array of emphasis sets for aBehavior (class or metaclass)	for the instance, class and static buttons."	| criteria ref |	( ( ( criteria := self currentCriteria: aBrowser id: selectionId ) == nil ) or: [ aBehavior == nil ] ) 		ifTrue: [ ^#( #( #norm ) #( #norm ) #( norm ) ) ].	ref := aBehavior isForNameSpace		ifTrue: [ aBehavior namedReferent ] 		ifFalse: [ aBehavior ].	^ref isForNameSpace		ifTrue: 			[ Array 				with: #( #norm ) 				with: #( #norm )				with: ( self  mapStatusToEmphasis: ( self classDataStatus: ref criteria: criteria  ) )			]		ifFalse:			[ ^Array 				with: ( self  mapStatusToEmphasis: 						( self behaviorStatus: ref instanceBehavior criteria: criteria  ) )				with: ( self  mapStatusToEmphasis: 						( self behaviorStatus: ref classBehavior criteria: criteria  ) )				with: ( self  mapStatusToEmphasis: 						( self classDataStatus: ref instanceBehavior criteria: criteria  ) )			]</body><body package="OldBrowsers">emphasisForClassOrNameSpace: aClassOrNameSpace for: aBrowser id: selectionId	"Answer the emphasis set for aClassOrNameSpace displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self 			classOrNameSpaceStatus: aClassOrNameSpace  			criteria: criteria		).</body><body package="OldBrowsers">emphasisForMethodDefinition: aMethodDef for: aBrowser id: selectionId	"Answer the emphasis set for aMethodDef displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis: 		( self methodDefinitionStatus: aMethodDef criteria: criteria )</body><body package="OldBrowsers">emphasisForProtocol: aProtocol for: aBrowser id: selectionId	"Answer the emphasis set for aProtocol displayed in aBrowser with a selectionId."	| criteria owner status |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	( owner := aBrowser selectedClassOrNameSpaceFor: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	status := ( owner isForNameSpace or: [ aBrowser isData ] )		ifTrue: [ self dataProtocolStatus: aProtocol owner: owner criteria: criteria ]		ifFalse: [ self methodProtocolStatus: aProtocol class: owner criteria: criteria ].	^self  mapStatusToEmphasis: status.</body><body package="OldBrowsers">emphasisForSelector: aSelector for: aBrowser id: selectionId	"Answer the emphasis set for aSelector displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self			selectorStatus: aSelector 			class: ( aBrowser selectedClassOrNameSpaceFor: selectionId )			criteria: criteria		)</body><body package="OldBrowsers">emphasisForSelectorProtocol: aProtocol for: aBrowser id: selectionId	"Answer the emphasis set for aProtocol displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self 			methodProtocolStatus: aProtocol 			class: ( aBrowser selectedClassOrNameSpaceFor: selectionId )			criteria: criteria		)</body><body package="OldBrowsers">emphasisForStaticDefinition: aStaticDef for: aBrowser id: selectionId	"Answer the emphasis set for aStaticDef displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis: ( self dataDefinitionStatus: aStaticDef criteria: criteria )</body><body package="OldBrowsers">emphasisForStaticKey: aStaticKey for: aBrowser id: selectionId	"Answer the emphasis set for aStaticKey displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self 		dataKeyStatus: aStaticKey 			owner: ( aBrowser selectedClassOrNameSpaceFor: selectionId )			criteria: criteria		)</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>menus</category><body package="OldBrowsers">buildToolBar: aMenu	canvas buildToolBar: aMenu.	self components do:		[ :comp | comp buildToolBar: aMenu ]</body><body package="OldBrowsers">buildViewMenu: aMenu	canvas buildViewMenu: aMenu.	self components do:		[ :comp | comp buildViewMenu: aMenu ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>selection utlity</category><body package="OldBrowsers">selectBehavior: aBehavior 	(self components at: components size - 2) currentHelper selectBehavior: aBehavior</body><body package="OldBrowsers">selectCategory: aCategory 	(self components at: components size - 3) currentHelper selectCategory: aCategory</body><body package="OldBrowsers">selectMethod: aSymbol 	(self components at: components size) currentHelper selectMethod: aSymbol</body><body package="OldBrowsers">selectProtocol: aProtocol 	(self components at: components size - 1) currentHelper selectProtocol: aProtocol</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>updating</category><body package="OldBrowsers">intializeListFull	self canvas intializeListFull.	^self</body><body package="OldBrowsers">refreshLists</body><body package="OldBrowsers">swapIn</body><body package="OldBrowsers">swapOut</body><body package="OldBrowsers">updateList	self canvas updateList</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>initialize</category><body package="OldBrowsers">initialize	self buildComponentArray.</body><body package="OldBrowsers">initializeForClass: aClass	self subclassResponsibility</body><body package="OldBrowsers">initializeForClassHierarchy: aClass	self subclassResponsibility</body><body package="OldBrowsers">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector	self subclassResponsibility</body><body package="OldBrowsers">initializeForNameSpace: aNameSpace	self subclassResponsibility</body><body package="OldBrowsers">initializeForNameSpaces	self subclassResponsibility</body><body package="OldBrowsers">initializeForNameSpaces: aNameSpace category: aCategory	self subclassResponsibility</body><body package="OldBrowsers">initializeNull	components := #() copy</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>spawning</category><body package="OldBrowsers">spawnForMethodsLabel: aLabel list: list initialSelection: selection with: aTabApplication 	TabApplicationSystemBrowser initializeForMethodsLabel: aLabel list: list initialSelection: selection with: NamespaceTabApplication</body><body package="OldBrowsers">spawnOnClass: aClass with: aTabApplication 	TabApplicationSystemBrowser openOnClass: aClass with: NamespaceTabApplication</body><body package="OldBrowsers">spawnOnClass: aClass with: aTabApplication protocol: aSelection	TabApplicationSystemBrowser openOnClass: aClass with: NamespaceTabApplication protocol: aSelection</body><body package="OldBrowsers">spawnOnClassHierarchy: aClass 	TabApplicationSystemBrowser openOnClassHierarchy: aClass with: NamespaceTabApplication</body><body package="OldBrowsers">spawnOnClassHierarchy: aClass with: aTabApplication 	TabApplicationSystemBrowser openOnClassHierarchy: aClass with: NamespaceTabApplication</body><body package="OldBrowsers">spawnOnNameSpace: aNamespace with: aTabApplication 	TabApplicationSystemBrowser 		openOnNameSpace: aNamespace 		with: NamespaceTabApplication</body><body package="OldBrowsers">spawnOnNameSpace: aNamespace with: aTabApplication category: aCategory 	TabApplicationSystemBrowser		openOnNameSpace: aNamespace		with: NamespaceTabApplication		on: aCategory</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>components</category><body package="OldBrowsers">windowLabel	^components isEmpty		ifTrue: [(#FullBrowser &lt;&lt; #labels &gt;&gt; 'Full Browser')]		ifFalse: [components first windowLabel]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>componentBuilding</category><body package="OldBrowsers">buildComponentArray	self buildComponentList.	self setComponentIds: components.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.</body><body package="OldBrowsers">buildComponentList	components := List new.	components add: self categoriesComponent.	components add:  self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.</body><body package="OldBrowsers">categoriesComponent	self subclassResponsibility</body><body package="OldBrowsers">classesComponent	self subclassResponsibility</body><body package="OldBrowsers">componentId	^#default</body><body package="OldBrowsers">protocolsComponent	self subclassResponsibility</body><body package="OldBrowsers">selectorsComponent	self subclassResponsibility</body><body package="OldBrowsers">setComponentIds	components do:		[ :comp | comp helpers do: [ :h | h selectionId: self componentId ] ]</body><body package="OldBrowsers">setComponentIds: aComponentList	aComponentList do:		[ :comp | comp helpers do: [ :h | h selectionId: self componentId ] ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>accessing</category><body package="OldBrowsers">blankCategoryCanvas	^blankCategoryCanvas isNil ifTrue:[blankCategoryCanvas := BlankUI new] ifFalse:[blankCategoryCanvas ]</body><body package="OldBrowsers">browser	^browser</body><body package="OldBrowsers">browser: aBrowser	browser := aBrowser</body><body package="OldBrowsers">canvas	^canvas isNil ifTrue:[canvas := self getCanvas] ifFalse:[canvas]</body><body package="OldBrowsers">categoriesLabel	^(#NoCategories &lt;&lt; #labels &gt;&gt; 'No Categories')</body><body package="OldBrowsers">categoryIcon	^categoryIcon isNil ifTrue:[ categoryIcon := self eraseBackgroundOnImage: self class categoryIcon] ifFalse:[categoryIcon ]</body><body package="OldBrowsers">components	components == nil 		ifTrue:[ self buildComponentArray ].	^components</body><body package="OldBrowsers">defaultEmphasizer	^Emphasizer new.</body><body package="OldBrowsers">emphasizer	emphasizer == nil ifTrue:		[emphasizer := self defaultEmphasizer].	^emphasizer</body><body package="OldBrowsers">emphasizer: anEmphasizer	emphasizer := anEmphasizer</body><body package="OldBrowsers">icon	^icon isNil ifTrue:[ icon := self class blankIcon] ifFalse:[icon ]</body><body package="OldBrowsers">indexOfCategoryCanvas	" I am defauling this to 0 so teamworks code will run on entry. 0 means there is no categories component"	^indexOfCategoryCanvas isNil ifTrue:[ indexOfCategoryCanvas := 0] ifFalse:[indexOfCategoryCanvas ]</body><body package="OldBrowsers">indexOfCategoryCanvas: aNumber	"index in the compnents array of the categories subcanvas"	indexOfCategoryCanvas:= aNumber</body><body package="OldBrowsers">label	^self class label</body><body package="OldBrowsers">rightHandComponents	^components copyFrom: 2 to: components size</body><body package="OldBrowsers">subCanvasSpec	^canvas listSpec"^#listSpec"</body><body package="OldBrowsers">systemBrowserComponents	^self components</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>release</category><body package="OldBrowsers">release		canvas == nil		ifFalse: [ self canvas release ].	self components do:[:each | each release].</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>canvases</category><body package="OldBrowsers">categoryTabCanvas	"By default this is blank. if a subclass has a categories view then they nee to supply one with this by setting indexOfCategoryCanvas"	^self indexOfCategoryCanvas == 0 ifTrue:[self blankCategoryCanvas ] ifFalse:[components at: self indexOfCategoryCanvas ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>accessing subcanvases</category><body package="OldBrowsers">getCanvas	self subclassResponsibility</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>private</category><body package="OldBrowsers">eraseBackgroundOnImage: anImage	"The rules for the BitBlt operation are documented in		ByteArray&gt;&gt;copyBitsStride:width:atX:y:from:stride:width:atX:y:width:height:rule:	Rule number 9 is used to get the resulting interior figure"	| pix im2   imageMask sourceImage |	"inactiveMasks  := masks  := nil."	imageMask := nil.	"imageMask := self masks at: anImage hash ifAbsent: [nil]." " we have precomputed masks so we don't have to do this all the time"	"The mask is in the shape of the figure so the rest can be the back ground color" 	imageMask == nil		ifTrue:			[sourceImage := anImage asImage.			pix := sourceImage atPoint: 0@0. "Take the Pixel at 0@0 as the one you want to be the background sourounding the figure" 			imageMask := Image extent: sourceImage extent depth: 1 palette: CoveragePalette monoMaskPalette.			"find and write the interiror shape"			0 to: sourceImage width-1 do: [:x |				0 to: sourceImage height-1 do: [:y |					(sourceImage atPoint: x@y) = pix						ifFalse: [imageMask atPoint: x@y put: 1]]].			"get the exteriror mess"			im2 := imageMask filledShapeAround: 0@0.			"now combine the two according to rule 9 the D bitXor: S bitInvert"			imageMask copy: imageMask bounds from: 0@0 in: im2 rule: 9.			imageMask := CachedImage on: imageMask.			"self masks at: anImage hash put: imageMask"]."	self inactiveMasks at: anImage hash	ifAbsent: 			[self inactiveMasks at: anImage hash					put: (self masks at: anImage hash)]."	"Return the neat class the knows how to display himself with the background left untouched according to the mask we just built"	"^OpaqueImageWithEnablement figure: anImage shape: imageMask 				inactiveMask: (self inactiveMasks at: anImage hash)."^OpaqueImageWithEnablement figure: anImage shape: imageMask 				inactiveMask: (imageMask).</body><body package="OldBrowsers">linkComponentsInArray: aCollection 	1 to: aCollection size - 1 do: [:i | (aCollection at: i)			browser: self browser;			nextModule: (aCollection at: i + 1)].	aCollection last browser: self browser.	self browser currentTabApplication: self. 	aCollection first intializeListFull</body><body package="OldBrowsers">linkFirstComponentToSubcanvas	self canvas browser: self browser.	self canvas nextModule: self components first."	self canvas updateList."</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>testing</category><body package="OldBrowsers">isNamspaceTabApp	^false</body></methods><methods><class-id>Tools.BrowserTabApplication class</class-id> <category>instance creation</category><body package="OldBrowsers">basicNewOnBrowser: aBrowser	| inst |	inst := self basicNew.	inst browser: aBrowser.	inst initializeNull.	^inst</body><body package="OldBrowsers">newOnBrowser: aBrowser	| inst |	inst := self basicNew.	inst browser: aBrowser.	inst initialize.	^inst</body></methods><methods><class-id>Tools.BrowserTabApplication class</class-id> <category>accessing</category><body package="OldBrowsers">label	self subclassResponsibility</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>private-parcel operations</category><body package="OldBrowsers">addClassToParcel	| thing |	self changeRequest ifFalse: [^self].	self saveParcelsForUndo.	thing := self selectedThing.	thing == nil ifFalse:		[thing isBehavior			ifTrue: [ self currentParcel addEntiretyOfClass: thing]			ifFalse: [self currentParcel addObject: thing]].	self updateBrowser</body><body package="OldBrowsers">canUndo	"Answer if the receiver can do an undo."	^savedParcels notNil</body><body package="OldBrowsers">clearUndoState	"Free the Parcel copies for undo."	savedParcels := nil</body><body package="OldBrowsers">doUndo	"Restore the previous set of Parcels prior to the last parcelling operation and clear the history."	(Dialog confirm: (#UndoLastParcellingQ &lt;&lt; #dialogs &gt;&gt; 'Undo last parcelling?')) ifTrue:		[savedParcels notNil ifTrue:			[savedParcels do: [:parcel| manager replaceParcel: parcel].			savedParcels := nil.			self updateLists]]</body><body package="OldBrowsers">moveBehaviors: aBehaviorSet toParcel: theParcelOrNil	"Move the classes in aBehaviorSet into theParcelOrNil according	 to the current filtering and selected parcel.  Read the comment	 in moveSelectors:inClass:toParcel: for a specification."	| classesToMove theClasses parcels |	(self currentParcel notNil and: [unparceledFilterOn]) ifTrue: [^Screen default ringBell].	"First move the selectors..."	aBehaviorSet do:		[:aBehavior|		self moveSelectors: aBehavior selectors			inClass: aBehavior			toParcel: theParcelOrNil].	"Now handle class definitions..."	theClasses := (aBehaviorSet collect: [:ea| ea instanceBehavior]) asSet.	classesToMove := IdentitySet new.	parcels := theClasses inject: IdentitySet new into:					[:set :aClass| | ps |					(ps := manager parcelsForClass: aClass) isNil ifFalse:						[set addAll: ps].					set].	parcelFilterOn		ifTrue:			[conflictsFilterOn				ifTrue:					[parcels size &gt; 1 ifTrue: "optimization - only conflicts if more than 1 parcel"						[theClasses do: [:aClass| | count |							count := 0.							parcels do: [:p|								(p definesClass: aClass) ifTrue:									[count := count + 1]].							count &gt; 1 ifTrue:								[self currentParcel isNil									ifTrue:										[classesToMove add: aClass.										parcels do: [:p| p undefineClass: aClass]]									ifFalse:										[(self currentParcel definesClass: aClass) ifTrue:											[classesToMove add: aClass.											self currentParcel undefineClass: aClass]]]]]]				ifFalse:					[self currentParcel notNil ifTrue: [parcels := IdentitySet with: self currentParcel].					theClasses do: [:aClass|						parcels do: [:p|							(p definesClass: aClass) ifTrue:								[classesToMove add: aClass.								p undefineClass: aClass]]]]]		ifFalse:			[unparceledFilterOn				ifTrue:					[theClasses do: [:aClass|						(parcels contains: [:p| p definesClass: aClass]) ifFalse:							[classesToMove add: aClass]]]				ifFalse:					[theClasses do: [:aClass|						classesToMove add: aClass.						parcels do: [:p| p undefineClass: aClass]]]].	theParcelOrNil notNil ifTrue:		[classesToMove do: [:aClass| theParcelOrNil addClass: aClass]]</body><body package="OldBrowsers">moveClassesAndNameSpaces: aSet toParcel: theParcelOrNil	"Move the classes in aSet into theParcelOrNil according to the current filtering and selected parcel.  	Read the comment in moveSelectors:inClass:toParcel: for a specification."	self notImplemented.</body><body package="OldBrowsers">moveData: aKeySet inNameSpace: theNameSpace fromParcel: fromParcel toParcel: theParcelOrNil	self notYetImplemented.	"Move the methods in aSelectorSet into theParcel according to the following rules.	 If no Parcel is selected ...		- If filtering is off then move all the methods to theParcelOrNil		and remove all the methods from all other parcels.	 	- If filtering is on then move all the methods that are		defined by other parcels into theParcelOrNil, and		remove just those methods from all other parcels.	 	- If conflict filtering is on then move all the methods that		are defined by more than one parcel into theParcelOrNil,		and remove just those methods from all other parcels.		- if unparcelled filtering is on then add only code that is		unparcelled.  This is a noop if theParcelOrNil is nil.	 If a Parcel is selected ...		move as described above, but only code that is defined		by the selected parcel.	 If aParcelOrNil is nil then the effect is simply to remove the methods from	 other parcels as described above.  This is used in e.g. removing conflicts."</body><body package="OldBrowsers">moveSelectors: aSelectorSet inClass: theClass fromParcel: fromParcel toParcel: theParcelOrNil	"Move the methods in aSelectorSet into theParcel according to the following rules.	 If no Parcel is selected ...		- If filtering is off then move all the methods to theParcelOrNil		and remove all the methods from all other parcels.	 	- If filtering is on then move all the methods that are		defined by other parcels into theParcelOrNil, and		remove just those methods from all other parcels.	 	- If conflict filtering is on then move all the methods that		are defined by more than one parcel into theParcelOrNil,		and remove just those methods from all other parcels.		- if unparcelled filtering is on then add only code that is		unparcelled.  This is a noop if theParcelOrNil is nil.	 If a Parcel is selected ...		move as described above, but only code that is defined		by the selected parcel.	 If aParcelOrNil is nil then the effect is simply to remove the methods from	 other parcels as described above.  This is used in e.g. removing conflicts."	| selectorsToMove parcels |	"Here's the state space:	MA = move all/move any	MU = move unparcelled	MCP = move only in current	MCC = move only conflicts in current	MAC = move any conflicts	MAP = move any parcelled		filter:			none	x	unparcelled	x	parcelled	x	multiply parcelled	current parcel		MA				nop				MAC			MCC	no current parcel	MA				MU					MAP			MAC"	(fromParcel notNil and: [unparceledFilterOn]) ifTrue: [^Screen default ringBell].	selectorsToMove := IdentitySet new: aSelectorSet size.	parcels := manager parcelsForClassOrNameSpace: theClass.	parcels isEmpty ifTrue: [parcels := IdentitySet new].	parcelFilterOn		ifTrue:			[conflictsFilterOn				ifTrue:					[parcels size &gt; 1 ifTrue: "optimization - only conflicts if more than 1 parcel"						[aSelectorSet do: [:sel| | count |							count := 0.							parcels do: [:p|								(p definesSelector: sel forClass: theClass) ifTrue:									[count := count + 1]].							count &gt; 1 ifTrue:								[fromParcel isNil									ifTrue:										[selectorsToMove add: sel.										parcels do: [:p| p removeSelector: sel forClass: theClass]]									ifFalse:										[(fromParcel definesSelector: sel forClass: theClass) ifTrue:											[selectorsToMove add: sel.											fromParcel removeSelector: sel forClass: theClass]]]]]]				ifFalse:					[fromParcel notNil ifTrue: [parcels := IdentitySet with: fromParcel].					aSelectorSet do: [:sel|						parcels do: [:p|							(p definesSelector: sel forClass: theClass) ifTrue:								[selectorsToMove add: sel.								p removeSelector: sel forClass: theClass]]]]]		ifFalse:			[unparceledFilterOn				ifTrue:					[aSelectorSet do: [:sel|						(parcels contains: [:p| p definesSelector: sel forClass: theClass]) ifFalse:							[selectorsToMove add: sel]]]				ifFalse:					[aSelectorSet do: [:sel|						selectorsToMove add: sel.						parcels do: [:p| p removeSelector: sel forClass: theClass]]]].	theParcelOrNil notNil ifTrue:		[selectorsToMove do:			[:aSelector|			theParcelOrNil addSelector: aSelector forClass: theClass]].	self updateListsForParcels.</body><body package="OldBrowsers">moveSelectors: aSelectorSet inClass: theClass toParcel: theParcelOrNil	"Move the methods in aSelectorSet into theParcel according to the following rules.	 If no Parcel is selected ...		- If filtering is off then move all the methods to theParcelOrNil		and remove all the methods from all other parcels.	 	- If filtering is on then move all the methods that are		defined by other parcels into theParcelOrNil, and		remove just those methods from all other parcels.	 	- If conflict filtering is on then move all the methods that		are defined by more than one parcel into theParcelOrNil,		and remove just those methods from all other parcels.		- if unparcelled filtering is on then add only code that is		unparcelled.  This is a noop if theParcelOrNil is nil.	 If a Parcel is selected ...		move as described above, but only code that is defined		by the selected parcel.	 If aParcelOrNil is nil then the effect is simply to remove the methods from	 other parcels as described above.  This is used in e.g. removing conflicts."	| selectorsToMove parcels |	"Here's the state space:	MA = move all/move any	MU = move unparcelled	MCP = move only in current	MCC = move only conflicts in current	MAC = move any conflicts	MAP = move any parcelled		filter:			none	x	unparcelled	x	parcelled	x	multiply parcelled	current parcel		MA				nop				MAC			MCC	no current parcel	MA				MU					MAP			MAC"	(self currentParcel notNil and: [unparceledFilterOn]) ifTrue: [^Screen default ringBell].	selectorsToMove := IdentitySet new: aSelectorSet size.	parcels := manager parcelsForClassOrNameSpace: theClass.	parcels isEmpty ifTrue: [parcels := IdentitySet new].	parcelFilterOn		ifTrue:			[conflictsFilterOn				ifTrue:					[parcels size &gt; 1 ifTrue: "optimization - only conflicts if more than 1 parcel"						[aSelectorSet do: [:sel| | count |							count := 0.							parcels do: [:p|								(p definesSelector: sel forClass: theClass) ifTrue:									[count := count + 1]].							count &gt; 1 ifTrue:								[self currentParcel isNil									ifTrue:										[selectorsToMove add: sel.										parcels do: [:p| p removeSelector: sel forClass: theClass]]									ifFalse:										[(self currentParcel definesSelector: sel forClass: theClass) ifTrue:											[selectorsToMove add: sel.											self currentParcel removeSelector: sel forClass: theClass]]]]]]				ifFalse:					[self currentParcel notNil ifTrue: [parcels := IdentitySet with: self currentParcel].					aSelectorSet do: [:sel|						parcels do: [:p|							(p definesSelector: sel forClass: theClass) ifTrue:								[selectorsToMove add: sel.								p removeSelector: sel forClass: theClass]]]]]		ifFalse:			[unparceledFilterOn				ifTrue:					[aSelectorSet do: [:sel|						(parcels contains: [:p| p definesSelector: sel forClass: theClass]) ifFalse:							[selectorsToMove add: sel]]]				ifFalse:					[aSelectorSet do: [:sel|						selectorsToMove add: sel.						parcels do: [:p| p removeSelector: sel forClass: theClass]]]].	theParcelOrNil notNil ifTrue:		[selectorsToMove do:			[:aSelector|			theParcelOrNil addSelector: aSelector forClass: theClass]].	self updateListsForParcels</body><body package="OldBrowsers">saveParcelsForUndo	"Compute a set of Parcel copies for undo."	manager broadcastClearUndoStateFrom: self.	savedParcels := manager parcels collect: [:ea| ea copy]</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>initialize</category><body package="OldBrowsers">addDependents	self manager addDependent: self.</body><body package="OldBrowsers">initialize	manager := Parcel.	parcelFilterOn := unparceledFilterOn := conflictsFilterOn := false.	parcelDefType := #parcelComment asValue.	self addDependents.	super initialize.</body><body package="OldBrowsers">initializeForClassHierarchy: aClass	| cls |	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	cls := aClass instanceBehavior.	components := List new.	components add: self parcelsComponent.	components add: self classHierarchyComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.	self browser updateLists.	self	setClassOrNameSpaceFor: #default to: aClass.	components first		updateList;		selection:  ( cls fullyQualifiedReference ).</body><body package="OldBrowsers">release	super release.	self removeDependents.</body><body package="OldBrowsers">removeDependents	self manager removeDependent: self.</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>menus</category><body package="OldBrowsers">addParceling: parcelSet to: aMenu forHelper: aBrowserHelper 	^self class		addParceling: parcelSet		to: aMenu		forHelper: aBrowserHelper</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>componentBuilding</category><body package="OldBrowsers">allCategoriesComponent	^SimpleBrowserModule singleSelect		specName: #listSpecSingleSelect;		helpers: (Array with: (ParcelNameSpaceOrganizerBrowserHelper new searchChildNamespaces: true) ).</body><body package="OldBrowsers">allClassesComponent	^SimpleBrowserModule new 		helperType: ParcelNameSpaceGlobalCategoryBrowserHelper;		yourself</body><body package="OldBrowsers">buildComponentArray	super buildComponentArray.	self indexOfCategoryCanvas: 1.</body><body package="OldBrowsers">categoriesComponent	^self browser searchChildNamespaces		ifTrue: [self allCategoriesComponent]		ifFalse: [(SimpleBrowserModule singleSelect) specName: #listSpecSingleSelect; helperType: ParcelNameSpaceOrganizerBrowserHelper]</body><body package="OldBrowsers">classesComponent	^self browser searchChildNamespaces		ifTrue: [self allClassesComponent]		ifFalse: [	SimpleBrowserModule new		helperType: ParcelNameSpaceCategoryBrowserHelper;		yourself]</body><body package="OldBrowsers">componentId	^#parcelTab</body><body package="OldBrowsers">protocolsComponent	^SimpleBrowserModule singleSelect		specName: #listSpecProtocolsSingleSelect;		helperType: ParcelProtocolBrowserHelper;		yourself</body><body package="OldBrowsers">selectorsComponent	^SimpleBrowserModule new		helperType: ParcelSelectorBrowserHelper;		yourself</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>parcel Specific accessing </category><body package="OldBrowsers">behaviorStatus: aBehavior currentParcel: aParcel	"Compute the status for a Behavior (class or metaclass)."	| parcels status definedCount extendedCount |	status := Set new: 4.	aBehavior isNil ifTrue: [^status "shouldn't happen"].	parcels := self manager parcelsForClassOrNameSpace: aBehavior.	nil == parcels ifFalse:		[definedCount := extendedCount := 0.		parcels do:			[:parcel|			(parcel definesClass: aBehavior) ifTrue:				[definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				(parcel == aParcel				and: [| defined selectors |					"This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented selectors."					defined := parcel definedSelectorsFor: aBehavior.					selectors := aBehavior organization elements.					defined size = selectors size					and: [nil == (selectors detect: [:sel| (defined includes: sel) not] ifNone: [])]]) ifTrue:						[status add: #entirelyDefined]].			(parcel extendsBehavior: aBehavior) ifTrue:				[extendedCount := extendedCount + 1.				status add: (parcel == aParcel ifTrue: [#extended] ifFalse: [#extendedByOther])]].			(definedCount &gt; 1 "more than one parcel defines the behavior"			or: [definedCount + extendedCount &gt; 1 "may be multiply parcelled selectors - go check"				and: [(self computeConflictsFor: (Array with: aBehavior) within: nil) first size &gt; 0]])				ifTrue:					[status add: #conflict]].	^status</body><body package="OldBrowsers">classDataStatus: aClass  currentParcel: aParcel	"Compute the status for a Class's static variables."	| parcels status definedCount names |	status := Set new: 4.	aClass isNil ifTrue: [^status "shouldn't happen"].	names := aClass asNameSpace localBindingNames.	names isEmpty ifTrue:		[(aParcel ~~ nil		   and: [aParcel definesClass: aClass])			ifTrue: [status add: #entirelyDefined].		^status].	parcels := manager parcelsForClassOrNameSpace: aClass.	nil == parcels ifTrue: [^status].	definedCount := 0.	parcels do:		[:parcel| | defined |		(defined := parcel definedNamesFor: aClass) size &gt; 0 ifTrue:			[definedCount := definedCount + 1.			parcel == aParcel				ifTrue:					["This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented names."					status add: (((parcel definesClass: aClass)								and: [defined size = names size								and: [nil == (names detect: [:name| (defined includes: name) not] ifNone: nil)]])									ifTrue: [#entirelyDefined]									ifFalse: [#defined])]				ifFalse: [status add: #extendedByOther]].	(definedCount &gt; 1 "more than one parcel defines data in aClass"	and: [(self computeDataConflictsFor: (Array with: aClass) within: nil) first size &gt; 0])		ifTrue:			[status add: #conflict]].	^status</body><body package="OldBrowsers">classNameStatus: aClass environment: environment currentParcel: aParcel	"Compute the status for a class name (class and its metaclass)."	| classStatus metaclassStatus entirelyDefined |	aClass isBehavior ifFalse: [^self definedThingStatus: aClass  currentParcel: aParcel].	classStatus := self behaviorStatus: aClass currentParcel: aParcel.	metaclassStatus := self behaviorStatus: aClass class currentParcel: aParcel.	entirelyDefined := (classStatus includes: #entirelyDefined)							and: [metaclassStatus includes: #entirelyDefined].	classStatus addAll: metaclassStatus.	entirelyDefined ifFalse: [classStatus remove: #entirelyDefined ifAbsent: nil].	^classStatus</body><body package="OldBrowsers">currentParcel	^self canvas currentParcel</body><body package="OldBrowsers">currentParcelsFor: aClass currentParcel: aParcel	"Answer the current set of relevant parcels.  If the currentParcel is selected	 then this is simply the set containing the currentParcel.  Otherwise it is the	 set of parcels that define or extend aClass."	| parcels |	^aParcel isNil		ifTrue:			[(parcels := self manager parcelsForClassOrNameSpace: aClass) isNil				ifTrue: [IdentitySet new]				ifFalse: [parcels]]		ifFalse: [IdentitySet with: aParcel]</body><body package="OldBrowsers">dataKeyStatus: aKey class: aClass currentParcel: aParcel	"Compute the status for a data key in a given class/namespace with respect to 	the parcels in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == aClass or: [nil == aKey]) ifTrue: [^status].	nil == (parcels := manager parcelsForClassOrNameSpace: aClass) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesName: aKey in: aClass) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers">dataProtocolStatus: aSymbol class: aClass currentParcel: aParcel	"Compute the status for a data protocol in a class."	| thingsInProtocol status parcels |	status := Set new: 4.	nil == aClass ifTrue: [^status].	thingsInProtocol := aClass asNameSpace organization listAtCategoryNamed: aSymbol.	(thingsInProtocol isEmpty	or: [nil == (parcels := manager parcelsForClassOrNameSpace: aClass)]) ifTrue:		[^status].	"Assume entirely defined; search for exceptions in the loop below."	(aParcel notNil	and: [parcels includes: aParcel]) ifTrue:		[status add: #entirelyDefined].	thingsInProtocol do:		[:aThing| | count |		count := 0.		parcels do:			[:p|			(p definesName: aThing in: aClass)				ifTrue:					[count := count + 1.					status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]				ifFalse: [aParcel == p ifTrue: [status remove: #entirelyDefined ifAbsent: nil]]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers">dataStatus: aBinding class: aClass currentParcel: aParcel	"Compute the status for aBinding in a given class with respect to the parcels	 in manager and aParcelOrNil."	^self  dataKeyStatus: aBinding key class: aClass currentParcel: aParcel</body><body package="OldBrowsers">isUnparceledCodeInBehavior: aBehavior  currentParcel: aParcel	"Answer if there is any unparceled code in aBehavior (either it is undefined	 or contains methods that are undefined) for the currently 'relevant' parcels."	| parcels selectors |	"This also needs to account for unparcelled statics"	aParcel isNil		ifTrue: [parcels := manager parcelsForClassOrNameSpace: aBehavior.				parcels isEmpty ifTrue: [^true].				parcels := parcels asArray]		ifFalse: [parcels := Array with: aParcel].	parcels do: [:p| (p definesClass: aBehavior) ifFalse: [^true]].	"This is performance critical.  So we unroll the loop and use the class's organization.	 Code should be equivalent to		^class selectors contains: [:sel| parcels contains: [:p| (p definesSelector: sel forClass: class) not]]"	selectors := aBehavior organization elements.	1 to: selectors size do:		[:si| | sel |		sel := selectors at: si.		1 to: parcels size do:			[:pi|			((parcels at: pi) definesSelector: sel forClass: aBehavior) ifFalse: [^true]]].	^false</body><body package="OldBrowsers">isUnparceledCodeInClass: aClass  currentParcel: aParcel 	"Answer if there is any unparceled code in aClass (either it is undefined or	 contains methods that are undefined) for the currently 'relevant' parcels."	^(self isUnparceledCodeInBehavior: aClass currentParcel: aParcel)		or: [self isUnparceledCodeInBehavior: aClass class currentParcel: aParcel]</body><body package="OldBrowsers">isUnparceledCodeInNameSpace: aNamespace	"This isn't implemented yet."	^false</body><body package="OldBrowsers">manager	^manager</body><body package="OldBrowsers">mapStatusToEmphasis: statusSet	"Compute the emphasis for aSet.  aSet has the following members		#entirelyDefined		#defined		#definedByOther		#extended		#extendedByOther		#conflict"	| emphasis |	emphasis := Set new: 4.	statusSet do:		[:status|		(#extended == status		or: [#defined == status]) ifTrue: [emphasis add: #bold] ifFalse: [		#entirelyDefined == status ifTrue:			[emphasis add: #bold; add: #underline] ifFalse: [		(#definedByOther == status		or: [#extendedByOther == status]) ifTrue: [emphasis add: #italic] ifFalse: [		#conflict == status ifTrue:			[emphasis add: #color-&gt;ColorValue red] ifFalse: [		#notFound == status ifFalse: [Transcript cr; print: status; endEntry].		emphasis add: #strikeout "as an error indication"]]]]].	^emphasis asArray</body><body package="OldBrowsers">selectorStatus: aSelector class: aClass  currentParcel: aParcel 	"Compute the status for a selector in a given classwith respect to the parcels	 in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == aClass or: [nil == aSelector]) ifTrue: [^status].	nil == (parcels := manager parcelsForClassOrNameSpace: aClass) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesSelector: aSelector forClass: aClass) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>accessing</category><body package="OldBrowsers">categoriesLabel	^self browser selectedEnvironment notNil		ifTrue: [ self categoryTabCanvas selection notNil ifTrue:[self categoryTabCanvas selection ] ifFalse:[(#ParcelCategories &lt;&lt; #labels &gt;&gt; 'Parcel Categories') asString]]		ifFalse: [(#ParcelCategories &lt;&lt; #labels &gt;&gt; 'Parcel Categories') asString]</body><body package="OldBrowsers">defaultEmphasizer	^ParcelEmphasizer new.</body><body package="OldBrowsers">icon	^icon isNil ifTrue:[ icon := self eraseBackgroundOnImage: (self class parcelIcon)] ifFalse:[icon ]</body><body package="OldBrowsers">label	^self canvas selection == nil 		ifTrue: [ self class label ] 		ifFalse: [ self canvas selection name ]</body><body package="OldBrowsers">parcelDefType	^parcelDefType</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>private parcel</category><body package="OldBrowsers">computeDataConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a Set of statics that are multiply parcelled	return and Array with a Set of statics that have conflicts"	| bindings |	bindings := IdentitySet new: 8.	aSetOfClasses do:		[:class| | parcels |		(parcels := manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[|  staticBag  |			staticBag := Bag identityNew: 4.			parcels do:				[:parcel|				staticBag addAll: (parcel definedBindingsFor: class)].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding]]]].	^Array with: bindings</body><body package="OldBrowsers">isConflictsFilterOn	^conflictsFilterOn</body><body package="OldBrowsers">isParcelFilterOn	"Determine if filtering by Parcel is in effect."	^parcelFilterOn or: [conflictsFilterOn]</body><body package="OldBrowsers">isUnparceledFilterOn	"Determine if filtering by Parcel is in effect."	^unparceledFilterOn</body><body package="OldBrowsers">parcelTextMode: aSymbol	self changeRequest ifFalse: [ ^self ].	components do: [ :comp | comp deselect ].	parcelDefType value: aSymbol.	self browser updateText</body><body package="OldBrowsers">parcelTextMode: aSymbol value: aText	self changeRequest ifFalse: [ ^self ].	components do: [ :comp | comp deselect ].	parcelDefType value: aSymbol.	self browser text value: aText</body><body package="OldBrowsers">toggleConflicts	"Toggle multiply parcelled code filtering."	self changeRequest ifFalse: [^false].	conflictsFilterOn		ifTrue: [conflictsFilterOn := false]		ifFalse:			[unparceledFilterOn := false.			parcelFilterOn := conflictsFilterOn := true].	self updateBrowser.	self updateLists.</body><body package="OldBrowsers">toggleParceled	"Toggle by-Parcel code filtering."	self changeRequest ifFalse: [^false].	parcelFilterOn		ifTrue: [parcelFilterOn := conflictsFilterOn := false]		ifFalse:			[unparceledFilterOn := false.			parcelFilterOn := true].	self updateBrowser</body><body package="OldBrowsers">toggleUnparceled	"Toggle Unparceled code filtering."	self changeRequest ifFalse: [^false].	unparceledFilterOn		ifTrue: [unparceledFilterOn := false]		ifFalse:			[unparceledFilterOn := true.			parcelFilterOn := conflictsFilterOn := false].	self updateBrowser.	self updateLists</body><body package="OldBrowsers">turnOffParcelFilters	parcelFilterOn := unparceledFilterOn := conflictsFilterOn := false.</body><body package="OldBrowsers">updateWindowLabel	(self browser builder notNil	and: [self browser builder window notNil]) ifTrue:		[self browser builder window label: self windowLabel]</body><body package="OldBrowsers">windowLabel	^components isEmpty		ifTrue: [(#ParcelBrowser &lt;&lt; #labels &gt;&gt; 'Parcel Browser')]		ifFalse: [self canvas windowLabel asString, ' ', (components at: 2) windowLabel asString]</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>parcel emphassis</category><body package="OldBrowsers">computeConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a triple of a Set of MethodDefinitions identifying all methods that are	 multiply parcelled, a Set of statics that are multiply parcelled, and a Set	 of classes that either contain multiply parcelled methods or are themselves	 multiply parcelled.  If aSetOfParcelsOrNil is non-nil then only include conflicts	 that are parcelled within aSetOfParcels	 Express the triple as an Array, method definitions first, bindings next, classes last."	| methods bindings classes |	methods := Set new: 64.	bindings := IdentitySet new: 8.	classes := IdentitySet new: 4.	aSetOfClasses do:		[:class| | parcels |		(parcels := manager parcelsForClassOrNameSpace: class) notEmpty ifTrue:			[| instanceSelectorBag classSelectorBag staticBag classBag |			instanceSelectorBag := Bag identityNew: 32.			classSelectorBag := Bag identityNew: 32.			staticBag := Bag identityNew: 4.			classBag := Bag identityNew: 2.			parcels do:				[:parcel|				(parcel definesClass: class) ifTrue: [classBag add: class].				instanceSelectorBag addAll: (parcel definedSelectorsFor: class).				classSelectorBag addAll: (parcel definedSelectorsFor: class class).				staticBag addAll: (parcel definedBindingsFor: class)].			instanceSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class selector: sel)]].			classSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class class selector: sel)]].			classBag valuesAndCountsDo:				[:clss :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[classes add: class]].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding.						classes add: class]]]].	^Array with: methods with: bindings with: classes</body><body package="OldBrowsers">definedThingStatus: anObject  currentParcel: aParcel	"Compute the status for a Static."	| status definedCount |	status := Set new: 4.	anObject isNil ifTrue: [^status "shouldn't happen"].	definedCount := 0.	manager parcels do:		[:parcel|		(parcel definesObject: anObject) ifTrue:			[definedCount := definedCount + 1.			status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).			(parcel == aParcel) ifTrue:				[status add: #entirelyDefined]]].	(definedCount &gt; 1 "more than one parcel defines the behavior") ifTrue:		[status add: #conflict].	^status</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>accessing subcanvases</category><body package="OldBrowsers">getCanvas	| module |	module := self parcelsComponent.						 module	browser: self browser.	^module</body><body package="OldBrowsers">parcelsComponent	^SimpleBrowserModule singleSelect		deselectNextModuleOnReselect: false;		helperType: ParcelListBrowserHelper;		yourself</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>parcel actions</category><body package="OldBrowsers">moveSelectionToParcel: aParcel	self changeRequest ifFalse: [^self].	self 		saveParcelsForUndo;		moveSelectors: ( IdentitySet with: self selection )			inClass: self targetClass			fromParcel: self  selectedParcel 			toParcel: aParcel;		updateLists</body><body package="OldBrowsers">openParcelProperties	PackagePropertiesDialog on: self currentParcel</body><body package="OldBrowsers">parcelComment	self parcelTextMode:  #parcelComment</body><body package="OldBrowsers">parcelDanglingReferences	self parcelTextMode:  #parcelDanglingReferences</body><body package="OldBrowsers">parcelDefinition	"Fake parcel mode so we can accept class defs with only the 	parcel selected."	self parcelTextMode: #parcelDefintion</body><body package="OldBrowsers">parcelSummary	self parcelTextMode:  #parcelSummary</body><body package="OldBrowsers">selectParcel: aParcel	| newSelection |	newSelection := aParcel notNil ifTrue: [aParcel].	self canvas  module select: newSelection whenFinished:[self canvas module updateList].</body><body package="OldBrowsers">updateBrowser	self canvas updateLists.	self updateWindowLabel.		manager flushClassParcelMap</body><body package="OldBrowsers">updateLists	self browser batchUpdates:		[| theParcel | 		"Remember the currentParcel because updating the parcel list		 will change the currentParcel."		theParcel := self currentParcel.		self canvas updateListFull.		((self components) at:1  ) updateListFull.		((self components) at: 2  ) updateList.		 self selectParcel: theParcel.		self browser updateWindowLabel]</body><body package="OldBrowsers">updateListsForParcels	self browser batchUpdates:		[ self components first updateListFull ].</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>updating</category><body package="OldBrowsers">update: anAspectSymbol with: aParameter from: aSender 	browser currentTabApplication == self		ifFalse: [ ^super update: anAspectSymbol with: aParameter from: aSender ].	#parcels == anAspectSymbol 		ifTrue: 			[ ^self ~~ aSender 				ifTrue: [ self clearUndoState. self updateList ].			].		#clearUndoState == anAspectSymbol 		ifTrue: [  ^self ~~ aSender ifTrue: [ self clearUndoState ] ].	^super update: anAspectSymbol with: aParameter from: aSender</body></methods><methods><class-id>Tools.ParcelTabApplication class</class-id> <category>accessing</category><body package="OldBrowsers">label	^(#Parcels &lt;&lt; #menus &gt;&gt; 'Parcels') asString</body></methods><methods><class-id>Tools.ParcelTabApplication class</class-id> <category>menus</category><body package="OldBrowsers">addParceling: parcelSet to: aMenu forHelper: aBrowserHelper	"Add the various parcelling operations and undo to aMenu.	 Make sure the various actions refer to parcels weakly so as	 not to prevent clean unloading."	| parcelMenuItem parcelSubMenu submenu	 locateParcels locateList locateNames	 moveToParcels moveToList moveToNames |		parcelMenuItem := aMenu atNameKey: #parcelSubMenu.	parcelMenuItem == nil ifTrue:		[parcelMenuItem := (MenuItem labeled: (#Parcel &lt;&lt; #menus &gt;&gt; 'Parcel'))				nameKey: #parcelSubMenu;				submenu: self parcelSubMenu.		aMenu addItem: parcelMenuItem atPosition: 33.01].	parcelSubMenu := parcelMenuItem submenu.	1 to: parcelSubMenu numberOfItems - 2 do: "add to, remove from, move to"		[:i| 			(parcelSubMenu menuItemAt: i) nameKey = #parcelAddTo ifTrue:[(parcelSubMenu menuItemAt: i)  enabled: (aBrowserHelper selectedParcel notNil and:[(aBrowserHelper selectedParcel definesClass: aBrowserHelper selection) not]) ]		ifFalse:[ (parcelSubMenu menuItemAt: i) enabled: aBrowserHelper selectedParcel notNil]].	locateParcels :=  parcelSubMenu atNameKey: #parcelLocate.	locateList := (parcelMenuItem isEnabled				and: [parcelSet size &gt; 0])					ifTrue: [(parcelSet asSortedCollection: [:p1 :p2| p1 name &lt;= p2 name])]					ifFalse: [#()].	locateList isEmpty		ifTrue:			[locateParcels disable; submenu: nil]		ifFalse:			[locateNames := (locateList collect: [:ea| ea name]) asArray.			locateList := WeakArray withAll: locateList.			submenu := (Menu							labelArray: locateNames							values: ((1 to: locateList size) collect:										[:i|										[| p |										((p := locateList at: i) ~= locateList tombstone and: [p ~= nil]) ifTrue:											[Cursor execute showWhile:												[aBrowserHelper browser selectParcel: p]]]])).			locateParcels submenu: submenu; enable].	moveToParcels :=  parcelSubMenu atNameKey: #parcelMoveTo.	moveToList := parcelMenuItem isEnabled					ifTrue: [(aBrowserHelper browser manager parcels								asSortedCollection: [:p1 :p2| p1 name &lt;= p2 name])]					ifFalse: [#()].	moveToList isEmpty		ifTrue:			[moveToParcels disable; submenu: nil]		ifFalse:			[moveToNames := (moveToList collect: [:ea| ea name]) asArray.			moveToList := WeakArray withAll: moveToList.			submenu := (Menu							labelArray: moveToNames							values: ((1 to: moveToList size) collect:										[:i|										[| p |										((p := moveToList at: i) ~= moveToList tombstone and: [p ~= nil]) ifTrue:											[Cursor execute showWhile:												[aBrowserHelper  moveSelectionToParcel: p]]]])).			moveToParcels submenu: submenu; enable].	aBrowserHelper augmentMenuBarMenu: parcelSubMenu.	^aMenu</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>private</category><body package="OldBrowsers">disturb	disturbed value: true.	^true</body><body package="OldBrowsers">enableButtons	| button |	(button := subBuilder namedComponents at: #resetButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]].	(button := subBuilder namedComponents at: #acceptButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]]</body><body package="OldBrowsers">helpAction	| sh |	sh := SimpleHelp helpString: self helpString.	sh class  openOn: sh</body><body package="OldBrowsers">helpString	^self perform: (self class tabSpecsAndHelpSelectors at: list selectionIndex) last.</body><body package="OldBrowsers">masterList	^self class masterList.</body><body package="OldBrowsers">rebuild	| canvas next |	canvas := builder componentAt: #activeComponents.	(next := (self class tabSpecsAndHelpSelectors at: list selectionIndex) first) == #textSizeBSpec		ifTrue:			[Cursor execute showWhile:				[canvas widget					client: self					spec: next					builder: (subBuilder := self builder newSubBuilder)]]		ifFalse:			[canvas widget				client: self				spec: next				builder: (subBuilder := self builder newSubBuilder)]</body><body package="OldBrowsers">requestSliceChange	| win |	builder notNil ifTrue: [win := builder window].	self disturbed		ifTrue:			[(Dialog					confirm: (#alteredNotAccepted &lt;&lt; #dialogs &gt;&gt; 'Settings have been altered but not accepted.Do you wish to discard the changes?')					for: win)				ifTrue: [self resetForSlice. ^true]				ifFalse: [^false]]		ifFalse: [^true]</body><body package="OldBrowsers">resetForSlice	(subBuilder componentAt: #resetButton) widget model value: true.	self undisturb</body><body package="OldBrowsers">setFocus	"Set the keyboard input focus to be the first text input widget on the focus chain."		builder keyboardProcessor keyboardConsumers		do:			[:aWidget | 			(aWidget isKindOf: ComposedTextView)				ifTrue:					[builder keyboardProcessor setActive: aWidget controller.					(aWidget isKindOf: TextEditorView)						ifTrue: [aWidget controller selectEntireText].					^aWidget invalidate]]</body><body package="OldBrowsers">undisturb	disturbed value: false</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>accessing</category><body package="OldBrowsers">disturbed	^disturbed value</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>initialize-release</category><body package="OldBrowsers">initialize	super initialize.	list := SelectionInList new.	list list: self masterList.	list selectionIndexHolder value: 1.	list selectionIndexHolder onChangeSend: #updatePreferences to: self.	(disturbed := false asValue) onChangeSend: #enableButtons to: self</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>interface opening</category><body package="OldBrowsers">postOpenWith: aBuilder 	| canvas |	canvas := builder componentAt: #notebook.	canvas isNil ifTrue: [^self].	canvas widget		client: self		spec: #activeAreaSpec		builder: builder.	builder window keyboardProcessor keyboardHook: [:ev :ctrlr | self disturb. ev].	self updatePreferences</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>top level</category><body package="OldBrowsers">preferenceChoice	^list selectionIndexHolder</body><body package="OldBrowsers">preferenceMasterList	^list</body><body package="OldBrowsers">preferenceTopMenu	| menuList |	menuList := list list.	^Menu labelArray: (menuList collect: [:item | item key])		values: (1 to: menuList size)</body><body package="OldBrowsers">updatePreferences	"Update the subcanvas for the currently selected preference item. Answer the receiver."	self rebuild.	self setFocus</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>events</category><body package="OldBrowsers">requestForWindowClose	builder window keyboardProcessor requestGlobalAutoAccept.	^self requestSliceChange</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>interface specs</category><body package="OldBrowsers">windowSpec	^( UISettings preferenceFor: #notebookStyle ) == #notebook		ifTrue: [ self windowNotebookSpec ]		ifFalse: [ self windowMenuSpec ]</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>constants</category><body package="OldBrowsers">windowLabel	"Answer a string for the window label."	self subclassResponsibility</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>accessing</category><body package="OldBrowsers">developmentTabLabels	^developmentTabLabels</body><body package="OldBrowsers">masterList	^DeploymentOptionsSystem isDevelopment 		ifTrue: [self developmentTabLabels]		ifFalse: [self runtimeTabLabels]</body><body package="OldBrowsers">runtimeTabLabels	^runtimeTabLabels</body><body package="OldBrowsers">tabSpecsAndHelpSelectors	^tabSpecsAndHelpSelectors</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>initialization</category><body package="OldBrowsers">actionStringFor: aPackageAction numArgs: numArgs	| string |	string := CodeComponent stringFromAction: (package perform: aPackageAction).	^(string isNil		ifTrue: [self defaultActionTextFor: numArgs]		ifFalse: [string]) asText</body><body package="OldBrowsers">initializeProperties	"Initialize the receiver's values from the package."	properties := IdentityDictionary new.	properties		at: #deploymentPrerequisites		put: package deploymentPrerequisites storeString asValue;		at: #developmentPrerequisites		put: package developmentPrerequisites storeString asValue;		at: #versionSelection		put: (package versionSelectionBlock == nil					ifTrue: [self defaultVersionSelectionText]					ifFalse: [package versionSelectionBlock]) asValue.	#(#preload #postload #preunload #presave)	  with: #(#preLoadBlock #postLoadBlock #preUnloadBlock #preSaveBlock)	  do: [:aspect :action |		properties at: aspect put: (self actionStringFor: action numArgs: 1) asValue].	properties		at: #warningSuppression		put: (package warningSuppressionBlock == nil					ifTrue: [self defaultWarningSuppressionText]					ifFalse: [package warningSuppressionBlock]) asValue.	properties		at: #preRead		put: (package preReadBlock == nil				ifTrue: [self defaultPreReadText]				ifFalse: [self actionStringFor: #preReadBlock numArgs: 0]) asValue.	properties		at: #postunload		put: (self actionStringFor: #postUnloadBlock numArgs: 0) asValue.	properties		at: #generalProperties		put: (ParcelPropertiesInspector new inspect: package properties).	^properties</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>private</category><body package="OldBrowsers">defaultActionTextFor: numArgs	^(numArgs =1 ifTrue: [(#defaultActionText &lt;&lt; #dialogs &gt;&gt; '[ :pkg | &lt;nn&gt;]')] ifFalse: ['[&lt;nn&gt;]']) expandMacros asText</body><body package="OldBrowsers">defaultPreReadText	^(#defaultPreReadText &lt;&lt; #dialogs &gt;&gt; '[&lt;nn&gt;booleanExpression&lt;nn&gt;]') expandMacros asText</body><body package="OldBrowsers">defaultVersionSelectionText	^(#defaultVersionSelectionText &lt;&lt; #dialogs &gt;&gt; '[ :parcelName :versionString :requiredVersionString |&lt;n&gt;  booleanExpression&lt;n&gt;]') expandMacros asText</body><body package="OldBrowsers">defaultWarningSuppressionText	^(#defaultWarningSuppressionText &lt;&lt; #dialogs &gt;&gt; '[:prerequisiteName|&lt;n&gt;booleanExpression&lt;n&gt;]') expandMacros asText</body><body package="OldBrowsers">rebuild	"We need to ensure that we get callback notification on changes 	to the TextEditors and that the proper menu is used for the TextEditor.	Fortunately, we thought ahead and chose a naming convention for the 	editors to allow for easy selecting from the subBuilder."	| textEditorNames |	super rebuild.	textEditorNames := subBuilder namedComponents keys select: [:name | '*Text' match: name].	textEditorNames do: [:name | | textController |		textController := (subBuilder componentAt: name) widget controller.		textController continuousAccept: true.		textController initializeMenuForCode]</body><body package="OldBrowsers">removeAction: actionSymbol	( Dialog confirm: 		( (#prereqRemove &lt;&lt; #dialogs &gt;&gt; 'Remove &lt;1s&gt; from &lt;2s&gt;?') expandMacrosWith: actionSymbol with: package name )	)		ifTrue: [ package propertyAt: actionSymbol put: nil ]</body><body package="OldBrowsers">validateBlock: code numberOfArguments: integer notifying: aController 	"Validate that code compiles to a block with integer # of arguments. 	Accepts empty strings as an attempt to remove an attribute. 	Return a symbol to the receiver that indicates what the problem is."	| blk |	(code == nil or: [code isEmpty])		ifTrue: [^#ok].	code = (self defaultActionTextFor: integer) ifTrue: [ ^#unspecified ].	blk := self class compilerClass new				evaluate: code string				in: nil				allowReceiver: false				receiver: nil				environment: CodeComponent environmentForActionBlocks				notifying: aController				ifFail: [^#compile].	^[blk numArgs == integer			ifTrue: [#ok]			ifFalse: [#arguments]]		on: MessageNotUnderstood		do: [:e | e return: #compile]</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>properties</category><body package="OldBrowsers">deploymentPrerequisitesText	^properties at: #deploymentPrerequisites</body><body package="OldBrowsers">developmentPrerequisitesText	^properties at: #developmentPrerequisites</body><body package="OldBrowsers">generalProperties	^properties at: #generalProperties</body><body package="OldBrowsers">generalPropertiesAccept	"Update the properties to the package/parcel with the modified properties."	| editingProperties |	editingProperties := self generalProperties object.	editingProperties associationsDo:		[ :assoc | 		( self package propertyAt: assoc key ) = assoc value			ifTrue: [ editingProperties removeKey: assoc key ]		].	self package copyPropertiesFrom: editingProperties.	self generalProperties inspect: self package properties.</body><body package="OldBrowsers">generalPropertiesReset	| oldSelection |	oldSelection := self generalProperties fieldListHolder selection.	[self generalProperties inspect: self package properties]		ensure: [self generalProperties fieldListHolder selection: oldSelection]</body><body package="OldBrowsers">loadAccept	| postLoadStatus textController numBlockArgs preLoadStatus |	numBlockArgs := 1.	textController := (subBuilder componentAt: #postloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	postLoadStatus := self						validateBlock: (properties at: #postload) value						numberOfArguments: numBlockArgs						notifying: textController.	postLoadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPostLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Post-Load action has wrong number of arguments. It expects &lt;1p&gt;')expandMacrosWith:numBlockArgs)].	postLoadStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	textController := (subBuilder componentAt: #preloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	preLoadStatus := self						validateBlock: (properties at: #preload) value						numberOfArguments: numBlockArgs						notifying: textController.	preLoadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Load action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	preLoadStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preLoadBlock:		(preLoadStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #preload) value]).	package postLoadBlock:		(postLoadStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #postload) value])</body><body package="OldBrowsers">loadOptionsAccept	| numBlockArgs textController warningSuppressionStatus |	numBlockArgs := 1.	textController := (subBuilder componentAt: #warningSuppressionText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	warningSuppressionStatus := self						validateBlock: (properties at: #warningSuppression) value						numberOfArguments: numBlockArgs						notifying: textController.	warningSuppressionStatus == #arguments ifTrue:		[^Dialog warn: ((#errSuppressionArguments &lt;&lt; #dialogs &gt;&gt; 'Warning suppression action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	warningSuppressionStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package warningSuppressionBlock:		(warningSuppressionStatus == #unspecified			ifTrue: [nil]			ifFalse: [(CodeComponent asActionBlock: (properties at: #warningSuppression) value)])</body><body package="OldBrowsers">loadOptionsRemove	self removeAction: #warningSuppressionBlock.	self loadOptionsReset.</body><body package="OldBrowsers">loadOptionsReset	| warningSuppression |	(warningSuppression := CodeComponent stringFromAction: (package perform: 	#warningSuppressionBlock)) isNil		ifTrue: [warningSuppression := self defaultWarningSuppressionText].	( properties at: #warningSuppression )		value: ( warningSuppression ).</body><body package="OldBrowsers">loadRemove	self removeAction: #preLoadBlock.	self removeAction: #postLoadBlock.	self loadReset.</body><body package="OldBrowsers">loadReset	(properties at: #preload)		value: (self actionStringFor: #preLoadBlock numArgs: 1).	(properties at: #postload)		value: (self actionStringFor: #postLoadBlock numArgs: 1)</body><body package="OldBrowsers">postloadText	^properties at: #postload</body><body package="OldBrowsers">postunloadText	^properties at: #postunload</body><body package="OldBrowsers">preReadAccept	| readStatus textController numBlockArgs versionStatus |	numBlockArgs := 0.	textController := (subBuilder componentAt: #preReadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	readStatus := (properties at: #preRead) value = self defaultPreReadText					ifTrue: [#unspecified]					ifFalse:						[self							validateBlock: (properties at: #preRead) value							numberOfArguments: 0							notifying: textController].	readStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Load action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	readStatus == #compile ifTrue:		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	numBlockArgs := 0.	versionStatus :=		(properties at: #versionSelection) value = self defaultVersionSelectionText			ifTrue: [#unspecified]			ifFalse: [(self						validateBlock: ( properties at: #versionSelection ) value						numberOfArguments: 3						notifying: (subBuilder componentAt: #versionSelectionText) widget controller)].	versionStatus == #arguments ifTrue:		[^Dialog warn: ((#errVersionSelectionArguments &lt;&lt; #dialogs &gt;&gt; 'version selection action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	versionStatus == #compile ifTrue:		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preReadBlock: 		(readStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #preRead) value]).	package versionSelectionBlock:		(versionStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #versionSelection) value])</body><body package="OldBrowsers">preReadRemove	self removeAction: #preReadBlock.	self removeAction: #versionSelectionBlock.	self preReadReset</body><body package="OldBrowsers">preReadReset	( properties at: #preRead ) value:			( package preReadBlock == nil				ifTrue: [ self defaultPreReadText ]				ifFalse: [ self actionStringFor: #preReadBlock numArgs: 0 ] ).	( properties at: #versionSelection ) value: 			( package versionSelectionBlock == nil				ifTrue: [ self defaultVersionSelectionText ]				ifFalse: [ package versionSelectionBlock ] ).</body><body package="OldBrowsers">preReadText	^properties at: #preRead</body><body package="OldBrowsers">preloadText	^properties at: #preload</body><body package="OldBrowsers">prerequisitesAccept	| missing devSet |	package deploymentPrerequisites: 		(Compiler evaluate: ( properties at: #deploymentPrerequisites ) value asString).	package developmentPrerequisites: 		(Compiler evaluate: ( properties at: #developmentPrerequisites ) value asString).	missing := OrderedCollection new.	devSet := ( package developmentPrerequisites collect: [ :array | array at: 2 ] ) asSet.	package deploymentPrerequisites do:		[ :array |		( devSet includes: array first )			ifFalse: [ missing add: ( array first ) ].		].	missing isEmpty 		ifFalse: 			[ | str |			str := (String new: 256) writeStream.			missing do: [ :name | str nextPutAll: ' ', name ].			Dialog warn: ((#DevPrereqsMissing &lt;&lt; #dialogs &gt;&gt; 'Development prerequisites appear to be missing:&lt;1s&gt;.')				expandMacrosWith: str contents).			].</body><body package="OldBrowsers">prerequisitesRemove	( Dialog confirm: 		( (#prereqRemove &lt;&lt; #dialogs &gt;&gt; 'Remove &lt;1s&gt; from &lt;2s&gt;?') expandMacrosWith:  #deploymentPrerequisites with: package name )	)		ifTrue: [ package deploymentPrerequisites: nil ].	self removeAction: #developmentPrerequisites.	self prerequisitesReset.</body><body package="OldBrowsers">prerequisitesReset	( properties at: #deploymentPrerequisites ) 		value: ( package deploymentPrerequisites storeString ).	( properties at: #developmentPrerequisites ) 		value: ( package developmentPrerequisites storeString ).</body><body package="OldBrowsers">prerequisitesText	^properties at: #prerequisites</body><body package="OldBrowsers">presaveText	^properties at: #presave</body><body package="OldBrowsers">preunloadText	^properties at: #preunload</body><body package="OldBrowsers">saveAccept	| validationStatus textController numBlockArgs |	numBlockArgs := 1.	textController := (subBuilder componentAt: #presaveText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	validationStatus := self						validateBlock: (properties at: #presave) value						numberOfArguments: numBlockArgs						notifying: textController.	validationStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreSaveArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Save action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	validationStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preSaveBlock: 		(validationStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #presave) value])</body><body package="OldBrowsers">saveRemove	self removeAction: #preSaveBlock.	self saveReset.</body><body package="OldBrowsers">saveReset	(properties at: #presave)		value: (self actionStringFor: #preSaveBlock numArgs: 1).</body><body package="OldBrowsers">unloadAccept	| postUnloadStatus textController numPreUnloadBlockArgs numPostUnloadBlockArguments preUnloadStatus |	numPreUnloadBlockArgs := 1.	numPostUnloadBlockArguments := 0.	textController := (subBuilder componentAt: #postunloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	postUnloadStatus := self							validateBlock: (properties at: #postunload) value							numberOfArguments: numPostUnloadBlockArguments							notifying: textController.	postUnloadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPostLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Post-Load action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numPostUnloadBlockArguments)].	postUnloadStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	textController := (subBuilder componentAt: #preunloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	preUnloadStatus := self							validateBlock: (properties at: #preunload) value							numberOfArguments: numPreUnloadBlockArgs							notifying: textController.	preUnloadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreUnloadArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Unload action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numPreUnloadBlockArgs)].	preUnloadStatus == #compile		ifTrue: 			[self undisturb.			^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preUnloadBlock: 		(preUnloadStatus == #unspecified 			ifTrue: [nil]			ifFalse: [(CodeComponent asActionBlock: (properties at: #preunload) value)]).	package postUnloadBlock: 		(postUnloadStatus == #unspecified			ifTrue: [nil]			ifFalse: [(CodeComponent asActionBlock: (properties at: #postunload) value)])</body><body package="OldBrowsers">unloadRemove	self removeAction: #preUnloadBlock.	self removeAction: #postUnloadBlock.	self unloadReset.</body><body package="OldBrowsers">unloadReset	(properties at: #preunload)		value: (self actionStringFor: #preUnloadBlock numArgs: 1).	(properties at: #postunload)		value: (self actionStringFor: #postUnloadBlock numArgs: 0)</body><body package="OldBrowsers">versionSelectionText	^properties at: #versionSelection</body><body package="OldBrowsers">warningSuppressionText	^properties at: #warningSuppression</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>help</category><body package="OldBrowsers">generalPropertiesHelp	^(#generalPropertiesHelp &lt;&lt; #dialogs &gt;&gt; 'This is an inspector on &lt;1s&gt;''s properties.  The properties are stored in a IdentityDictionary, and what you see is something that should have the same type of behavior as a normal DictionaryInspector. &lt;n&gt;&lt;n&gt;You should be able  to add any key-&gt;value pair you want.  For example, one might want to add a Author property for &lt;1s&gt;.  To do so, simply invoke the operate menu from the left pane of the inspector and select "add-field".   The Accept button at the bottom of this page will only be enabled after you actually accept from the operate menu in the embedded inspector''s right pane.&lt;n&gt;NOTE: properties with a value of nil will be removed.') expandMacrosWith: self package name</body><body package="OldBrowsers">loadHelp^(#packagePropertiesHelp &lt;&lt; #dialogs &gt;&gt; 'Loading actions are one argument blocks that take the package / parcel being loaded as an argument.In the case of parcels, the PreLoadAction is run after all the code from a parcel has been parsed but before the code has been installed in the system.  Hence the pre-load action may happen too late to do things that affect the contents of a parcel.  Use the pre-read action if you want an action that runs before the parcel''s contents are parsed.In the case of packages, code is currently compiled definition by definition so the pre-read and pre-load actions are run immediately consecutively.	PreReadAction	&lt;code parsed from parcel and built&gt;	PreLoadAction	&lt;code installed into the system&gt;	PostLoadAction')</body><body package="OldBrowsers">loadOptionsHelp	^(#loadOptionsHelp &lt;&lt; #dialogs &gt;&gt; 'A Parcel''s warning suppression action must be a block taking one argument, the name of a prerequisite Parcel being loaded.  The block should answer true if any warnings caused by loading the prerequsiite shouild be suppressed.The warning suppression block is run before any of the Parcel''s code is loaded. Consequently it cannot and should not mention any code in this Parcel.')</body><body package="OldBrowsers">preReadHelp^(#preReadHelp &lt;&lt; #dialogs &gt;&gt; 'A Parcel''s pre-read action is a zero argument block, which is run before any of the Parcel is read, but after any of its prerequisites are loaded.  The block should answer true if loading is to continue; any other return value will abort the load.A Parcel''s prerequisite version block must be a block taking three arguments, the name of a prerequisite Parcel being loaded, its version string, and the version string defined in the Parcel''s list of prerequisites. The block should answer true if the prerequsite''s version is acceptable, and should be loaded.  Otherwise the loader will continue to search for another parcel of the same name with a different version.')</body><body package="OldBrowsers">prerequisitesHelp	^(#prerequisitesHelp &lt;&lt; #dialogs &gt;&gt; 'Deployment prerequsites are an array of prerequisite parcels.  Each individual prerequisite is a name, version pair.  On loading the Parcel loader searches along the SearchPath for .pcl files that have the required name and attempts to load them.  All parcels have a version which is an arbitrary string, that defaults to the empty string.  Each Parcel can also define a prerequisite version block which it can use to select appropriate versions of prerequisite parcels.Development prerequisites are used in loading from Store. Each prerequisite is an array with a type (#parcel #package #bundle or #any), a name and a version string. Developement prerequisites are usually supersets of the deployment prerequisities.')</body><body package="OldBrowsers">saveHelp	^(#saveHelp &lt;&lt; #dialogs &gt;&gt; 'Save actions are one argument blocks that take the package / parcel being saved as an argument.	PreSaveAction')</body><body package="OldBrowsers">unloadHelp	^(#unloadHelp &lt;&lt; #dialogs &gt;&gt; 'Unloading actions are actions run when unloading a package or parcel.  The preUnloadAction is run before unloading commences.  It is a one-argument block that takes the package or parcel being unloaded as an argument.  The postUnloadAction is a zero-argument block run after the package or parcel has been unloaded and discarded.	PreUnloadAction	&lt;code removed from system&gt;	PostUnloadAction')</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>interface</category><body package="OldBrowsers">labelFor: aKey 	"Return an instance of a non-abstract subclass of CharacterArray, 	that will be used as a label for a component."	^[ self perform: aKey ] on: MessageNotUnderstood do:		[ : e | e return: aKey ].</body><body package="OldBrowsers">windowLabel	^package  == nil		ifTrue: [ (#PackageProperties &lt;&lt; #labels &gt;&gt; 'Package properties') ]		ifFalse: [ (#packageName &lt;&lt; #labels &gt;&gt; '&lt;1s&gt; properties') expandMacrosWith: package name ]</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>events</category><body package="OldBrowsers">noticeOfWindowClose: aWindow 	super noticeOfWindowClose: aWindow.	self release</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>accessing</category><body package="OldBrowsers">package	^package</body><body package="OldBrowsers">package: aPackage	package := aPackage.	self initializeProperties.</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>interface opening</category><body package="OldBrowsers">postOpenWith: aBuilder 	"We do not use the keyboard hook that the superclass sets up 	because of our implementation of #rebuild. Also, we set up a 	dependency on our embedded inspector to get the Accept and 	Reset buttons to reflect the true state of things"	super postOpenWith: aBuilder.	self builder window keyboardProcessor keyboardHook: nil.	self generalProperties fieldListHolder listHolder onChangeSend: #disturb to: self.	self generalProperties addDependent: self</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>initialize-release</category><body package="OldBrowsers">release	super release.	self generalProperties removeDependent: self.	self generalProperties fieldListHolder listHolder retractInterestsFor: self</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>updating</category><body package="OldBrowsers">update: anAspectSymbol with: aParameter from: aSender 	(anAspectSymbol = #accept and: ([aSender class = ParcelPropertiesInspector and: [aParameter]]))		ifTrue: [self disturb].	^super update: anAspectSymbol with: aParameter</body></methods><methods><class-id>UI.PackagePropertiesDialog class</class-id> <category>interface opening</category><body package="OldBrowsers">invalidUseWarning	"Raise a Dialog to warn the client of the receiver that they are not	using the correct protocol to open an instance."	Dialog warn: ((#invalidDialogUseWarning &lt;&lt; #dialogs &gt;&gt; 'You must open up &lt;1s&gt; with #on:&lt;n&gt;&lt;1s&gt; requires a subclass of&lt;n&gt;CodeComponent to be properly initialized.') expandMacrosWith: self name)</body><body package="OldBrowsers">open	"Use #on: instead, as the receiver relies on a CodeComponent to 	properly initialize itself."	self invalidUseWarning</body></methods><methods><class-id>UI.PackagePropertiesDialog class</class-id> <category>class initialization</category><body package="OldBrowsers">initialize	"self initialize"	| complexList |	complexList :=		OrderedCollection new			add: (#Prerequisites &lt;&lt; #labels &gt;&gt; 'Prerequisites')-&gt;#(#prerequisitesSpec #prerequisitesHelp);			add: (#LoadOptions &lt;&lt; #labels &gt;&gt; 'Load Options')-&gt;#(#loadOptionsSpec #loadOptionsHelp);			add: (#PrereadActions &lt;&lt; #labels &gt;&gt; 'Preread Actions')-&gt;#(#preReadSpec #preReadHelp);			add: (#LoadActions &lt;&lt; #labels &gt;&gt; 'Load Actions')-&gt;#(#loadSpec #loadHelp);			add: (#UnloadActions &lt;&lt; #labels &gt;&gt; 'Unload Actions')-&gt;#(#unloadSpec #unloadHelp);			add: (#SaveActions &lt;&lt; #labels &gt;&gt; 'Save Actions')-&gt;#(#saveSpec #saveHelp);			add: (#OtherProperties &lt;&lt; #labels &gt;&gt; 'Other Properties')-&gt;#(#generalPropertiesSpec #generalPropertiesHelp);			asArray.	developmentTabLabels := (complexList collect: [:each | each key]) asArray.	tabSpecsAndHelpSelectors := (complexList collect: [:each | each value]) asArray.	runtimeTabLabels := Array new</body><body package="OldBrowsers">masterList	"For the VisualWorks tools use case we only want to use the development lables.	 In other words, we do not encourage deployment of our tools."	^self developmentTabLabels</body><body package="OldBrowsers">on: aPackage	"Open  a properties dialog  on aPackage."	self openOn: ( self new package: aPackage; yourself )</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>private</category><body package="OldBrowsers">changeRequest	| w |	builder == nil ifTrue: [^true].	w := builder componentAt: #text.	^w == nil or: [w widget updateRequest]</body><body package="OldBrowsers">fileEncoding	^#Source</body><body package="OldBrowsers">interfaceName	^#(windowSpec0 windowSpec1 windowSpec2 windowSpec3 windowSpec4 windowSpec5)		at: self numberOfLists+1</body><body package="OldBrowsers">interfaceWindow	^self builder == nil		ifTrue: [nil]		ifFalse: [self builder window]</body><body package="OldBrowsers">labelFor: aKey	"Return an instance of a non-abstract subclass of CharacterArray, 	that will be used as a label for a widget.  Check the label registry if	no implementation has been provided."	^self application  messageNotUnderstoodSignal		handle: [:ex | | sel |				sel := ex parameter selector.				(sel == aKey)					ifTrue: [ex returnWith: (self application labelFor: aKey)]					ifFalse: [ex reject]]		do: [self perform: aKey].</body><body package="OldBrowsers">linkComponents	1 to: components size-1 do: [:i |		(components at: i)			browser: self;			nextModule: (components at: i+1)].	components last browser: self.	self updateLists</body><body package="OldBrowsers">methodCollector	^MethodCollector new		browser: self</body><body package="OldBrowsers">model: aValueHolder choose: aValue	^(PluggableAdaptor on: aValueHolder)		getBlock: [:b | b value = aValue]		putBlock: [:b :v | b value: aValue]		updateBlock: [:b :a :p | true]</body><body package="OldBrowsers">numberOfLists	| n |	n := coordinator == nil		ifTrue: [0]		ifFalse: [coordinator numberOfLists].	^components inject: n into: [:i :comp | i + comp numberOfLists]</body><body package="OldBrowsers">openInterface	"Open the ApplicationModel's user interface, using the specification 	resource of the standard name."	^self openInterface: self interfaceName</body><body package="OldBrowsers">postBuildWith: aBuilder	(aBuilder componentAt: #text) widget controller		autoAccept: false;		supportCodeEditingFeels: true;		flushFeels.</body><body package="OldBrowsers">specificationFor: aKey	^self perform: aKey</body><body package="OldBrowsers">tryAll: testBlock default: defaultBlock	components reverseDo:		[:comp | | val |		val := testBlock value: comp.		val == nil ifFalse: [^val]].	^defaultBlock value</body><body package="OldBrowsers">visibleComponentAt: index	| n |	n := 0.	coordinator == nil		ifFalse:			[n := n + coordinator numberOfLists.			n &gt;= index ifTrue: [^coordinator]].	components do: [:comp |		n := n + comp numberOfLists.		n &gt;= index ifTrue: [^comp]].	^self error: ((#Component1pNotFound &lt;&lt; #dialogs &gt;&gt; 'Component &lt;1p&gt; not found') expandMacrosWith: index)</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>coordination</category><body package="OldBrowsers">computeDisplayString: aThing	^coordinator == nil		ifTrue: [aThing simpleDisplayString]		ifFalse: [coordinator computeDisplayString: aThing]</body><body package="OldBrowsers">getListMenuFor: aHelper	"Answer the listMenu for a particular helper, or nil"	^listMenuMap ~~ nil ifTrue:		[listMenuMap at: aHelper class ifAbsent: []]</body><body package="OldBrowsers">getMenuBarMenuFor: aHelper	"Answer the menuBarMenu for a particular helper, or nil"	^menuBarMenuMap ~~ nil ifTrue:		[menuBarMenuMap at: aHelper class ifAbsent: []]</body><body package="OldBrowsers">setListMenu: aMenu for: aHelper	"Set the listMenu for a particular helper, or nil"	listMenuMap == nil ifTrue:		[listMenuMap := IdentityDictionary new].	listMenuMap at: aHelper class put: aMenu</body><body package="OldBrowsers">setMenuBarMenu: aMenu for: aHelper	"Set the menuBarMenu for a particular helper, or nil"	menuBarMenuMap == nil ifTrue:		[menuBarMenuMap := IdentityDictionary new].	menuBarMenuMap at: aHelper class put: aMenu</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>private-components</category><body package="OldBrowsers">allCategoriesComponent	^SimpleBrowserModule new		helpers: (Array with: (NameSpaceOrganizerBrowserHelper new searchChildNamespaces: true) ).</body><body package="OldBrowsers">allClassesComponent	^SimpleBrowserModule new 		helperType: NameSpaceGlobalCategoryBrowserHelper;		yourself</body><body package="OldBrowsers">categoriesComponent	^SimpleBrowserModule new		helperType: NameSpaceOrganizerBrowserHelper.</body><body package="OldBrowsers">classHierarchyComponent	^SimpleBrowserModule new		helperType: ClassHierarchyBrowserHelper;		yourself</body><body package="OldBrowsers">classesComponent	^SimpleBrowserModule new 		helperType: NameSpaceCategoryBrowserHelper;		yourself</body><body package="OldBrowsers">currentTextEditor	"A subclass with more than one text widget needs to override this to	answer the controller of the one that is currently being used, or nil.  	This is needed by commands that work on the current text selection, 	such as 'Explain' or 'Format'."	^(builder componentAt: #text) widget controller</body><body package="OldBrowsers">parcelsComponent"do a parcels componet later ight now return the systems Component because it handles everything"	| comp |	comp := self systemComponent.	comp currentHelper attribute: #parcel.	^comp.</body><body package="OldBrowsers">protocolsComponent	^SimpleBrowserModule new		specName: #listSpecProtocols;		helperType: ProtocolBrowserHelper;		yourself</body><body package="OldBrowsers">selectorsComponent	^SimpleBrowserModule new		helperType: SelectorBrowserHelper;		yourself</body><body package="OldBrowsers">systemComponent	^HierarchicalBrowserModule new		helperType: HierarchyBrowserHelper</body><body package="OldBrowsers">systemNotebookComponent	^HierarchicalBrowserModule new		helperType: HierarchyBrowserHelper</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>selections</category><body package="OldBrowsers">behaviorStatus: aBehavior currentParcel: aParcel	"Compute the status for a Behavior (class or metaclass)."	| parcels status definedCount extendedCount |	status := Set new: 4.	aBehavior isNil ifTrue: [^status "shouldn't happen"].	parcels := self manager parcelsForClassOrNameSpace: aBehavior.	nil == parcels ifFalse:		[definedCount := extendedCount := 0.		parcels do:			[:parcel|			(parcel definesClass: aBehavior) ifTrue:				[definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				(parcel == aParcel				and: [| defined selectors |					"This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented selectors."					defined := parcel definedSelectorsFor: aBehavior.					selectors := aBehavior organization elements.					defined size = selectors size					and: [nil == (selectors detect: [:sel| (defined includes: sel) not] ifNone: [])]]) ifTrue:						[status add: #entirelyDefined]].			(parcel extendsBehavior: aBehavior) ifTrue:				[extendedCount := extendedCount + 1.				status add: (parcel == aParcel ifTrue: [#extended] ifFalse: [#extendedByOther])]].			(definedCount &gt; 1 "more than one parcel defines the behavior"			or: [definedCount + extendedCount &gt; 1 "may be multiply parcelled selectors - go check"				and: [(self computeConflictsFor: (Array with: aBehavior) within: nil) first size &gt; 0]])				ifTrue:					[status add: #conflict]].	^status</body><body package="OldBrowsers">classNameStatus: aClass environment: environment currentParcel: aParcel	"Compute the status for a class name (class and its metaclass)."	| classStatus metaclassStatus entirelyDefined |	aClass isForClass ifFalse: [^self definedThingStatus: aClass  currentParcel: aParcel].	classStatus := self behaviorStatus: aClass currentParcel: aParcel.	metaclassStatus := self behaviorStatus: aClass class currentParcel: aParcel.	entirelyDefined := (classStatus includes: #entirelyDefined)							and: [metaclassStatus includes: #entirelyDefined].	classStatus addAll: metaclassStatus.	entirelyDefined ifFalse: [classStatus remove: #entirelyDefined ifAbsent: nil].	^classStatus</body><body package="OldBrowsers">selected: attribute for: id	"Answer the currently selected value for an attribute within an id."	| selection |	selection :=  selectionDictionary 		at: id ifAbsent: [ id == #default ifFalse: [ ^self selected: attribute for: #default ] ] .	^selection isNil ifTrue: [nil ] ifFalse:[ selection at: attribute ifAbsent: [ id == #default ifFalse: [ self selected: attribute for: #default ] ]].</body><body package="OldBrowsers">selectedCategoryFor: id	"Answer the currently selected category within an id."		^self selected: #category for: id</body><body package="OldBrowsers">selectedClassOrNameSpaceFor: id	"Answer the currently selected class within an id."		^self selected: #classOrNameSpace for: id.</body><body package="OldBrowsers">selectedEnvironment	^self selectedNameSpaceFor: #default</body><body package="OldBrowsers">selectedMethodFor: id	"Answer the currently selected method within an id."		^self selected:  #method for: id</body><body package="OldBrowsers">selectedNameSpaceFor: id	"Answer the currently selected namespace within an id."		^self selected:  #environment for: id</body><body package="OldBrowsers">selectedParcelFor: id	"Answer the currently selected parcel within an id."		^self selected: #parcel for: id</body><body package="OldBrowsers">selectedProtocolFor: id	"Answer the currently selected protocol within an id."		^self selected:  #protocol for: id</body><body package="OldBrowsers">setCategoryFor: id to: aValue	"Set the currently selected category within an id."		^self setSelection: #category for: id to: aValue</body><body package="OldBrowsers">setClassOrNameSpaceFor: id to: aValue	"Set the currently selected class within an id."		^self setSelection: #classOrNameSpace for: id to: aValue</body><body package="OldBrowsers">setMethodFor: id to: aValue	"Set the currently selected method within an id."		^self setSelection: #method for: id to: aValue</body><body package="OldBrowsers">setNameSpaceFor: id to: aValue	"Set the currently selected namespace within an id."		^self setSelection: #environment for: id to: aValue</body><body package="OldBrowsers">setParcelFor: id to: aValue	"Set the currently selected parcel within an id."		^self setSelection: #parcel for: id to: aValue</body><body package="OldBrowsers">setProtocolFor: id to: aValue	"Set the currently selected method within an id."		^self setSelection: #protocol for: id to: aValue</body><body package="OldBrowsers">setSelection: attribute for: id to: aValue	^( selectionDictionary at: id ifAbsentPut: [ IdentityDictionary new ] ) at: attribute put: aValue</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>initialize</category><body package="OldBrowsers">components: aList	components := aList.	self linkComponents</body><body package="OldBrowsers">initialize	super initialize.	inBatchMode := false.	components := List new.	text := String new asValue.	meta := #instance asValue.	meta onChangeSend: #updateProtocolLists to: self.	defType := #showDefinition asValue.	defType onChangeSend: #updateText to: self.	toolBar := nil asValue.	selectionDictionary := IdentityDictionary new.	self initializeForNameSpace: Smalltalk.</body><body package="OldBrowsers">initializeForAllNameSpaces	self	setNameSpaceFor: #default to: Root.	self ignoreNamepaceChanges: true.	components := List new.	components add: self allCategoriesComponent.	components add: self allClassesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponents</body><body package="OldBrowsers">initializeForClass: aClass	self meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	components := List new.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self setClassOrNameSpaceFor: #default to: aClass.	self linkComponents.	components first		forceSelection: aClass;		updateList</body><body package="OldBrowsers">initializeForClass: aClass protocol: aProtocol	self meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	components := List new.	components add: self protocolsComponent.	components add: self selectorsComponent.	self	setClassOrNameSpaceFor: #default to: aClass.	self	setProtocolFor: #default to: aProtocol.	self linkComponents.	components first		forceSelection: aProtocol;		updateList</body><body package="OldBrowsers">initializeForClassHierarchy: aClass	| cls |	self meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	cls := aClass instanceBehavior.	self	setClassOrNameSpaceFor: #default to: aClass.	components := List new.	components add: self classHierarchyComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponents.	components first		selection: cls</body><body package="OldBrowsers">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector	| helper module |	helper := MethodListBrowserHelper new.	helper		label: labelString;		baseList: aCollection asList;		initialSelection: selector.	module := SimpleBrowserModule new			helpers: (Array with: helper).	components := List new.	components add: module.	self linkComponents</body><body package="OldBrowsers">initializeForNameSpace: aNameSpace	components := List new.	self	setNameSpaceFor: #default to: aNameSpace.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponents</body><body package="OldBrowsers">initializeForNameSpace: aClassOrNameSpace protocol: aProtocol	| cns |	self meta value: #instance.	components := List new.	components add: self protocolsComponent.	components add: self selectorsComponent.	cns := aClassOrNameSpace asNameSpace namedReferent.  "just checking"	self	setClassOrNameSpaceFor: #default to: cns.	self	setProtocolFor: #default to: aProtocol.	self linkComponents.	components first		forceSelection: aProtocol;		updateList</body><body package="OldBrowsers">initializeForNameSpaces	components := List new.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponents</body><body package="OldBrowsers">initializeForNameSpaces: aNameSpace category: aCategory	components := List new.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self	setNameSpaceFor: #default to: aNameSpace.	self	setCategoryFor: #default to: aCategory.	self linkComponents.	components first		forceSelection: aCategory;		updateList</body><body package="OldBrowsers">initializeForParcels	components := List new.	components add: self parcelsComponent.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponents.	components first updateList</body><body package="OldBrowsers">initializeForSystem	components := List new.	components add: self systemComponent.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponents.	components first updateList</body><body package="OldBrowsers">release	| oldBrowserSize |	meta removeDependent: self.	defType removeDependent: self.	"If closing the last browser, which might be part of a packaging step, release all the menus that are stored in class variables. Allow for the possibility that RB is missing. If old browsers are missing then this code shouldn't exist any more "	#{Refactory.Browser.RefactoringBrowser} ifDefinedDo: 			[:rb | 			"First, do the cheapest test"			Screen default 				allScheduledControllersDo: [:each | each model class == rb ifTrue: [^self]].			rb allInstances size &gt; 0 ifTrue: [^self]].	oldBrowserSize := #{Tools.FullSystemBrowser} value allGeneralInstances size.	oldBrowserSize &lt;= 1 ifTrue: [#{BrowserHelper} value flushMenus]</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>text processing</category><body package="OldBrowsers">batchUpdates: aBlock	| old |	old := inBatchMode.	inBatchMode := true.	aBlock ensure: [inBatchMode := old].	old ifFalse: [self updateText].</body><body package="OldBrowsers">doItEnvironment	"Answer the object that should be informed of the result of evaluating a	text selection."	^self tryAll: [:c | c doItEnvironment] default: [ nil]</body><body package="OldBrowsers">doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^self tryAll: [:c | c doItReceiver] default: [nil]</body><body package="OldBrowsers">explainSpecial: string for: explainer	"Answer with a string explaining the code view selection if it is 	displaying one of the special edit functions."	^nil</body><body package="OldBrowsers">text	^text</body><body package="OldBrowsers">textAccepted: textController 	"First try the receiver's components to see if any of them can 	accept this text."	| compilerClass result |	result := self tryAll: [:c | c acceptText: textController text from: textController] default: [nil].		result notNil ifTrue: [^self].	"None of the Helpers could do anything with it."	compilerClass := (self selectedClassOrNameSpaceFor: #default) isNil				ifTrue: [self class compilerClass]				ifFalse: [(self selectedClassOrNameSpaceFor: #default) compilerClass].	compilerClass		evaluate: textController text		notifying: textController		logged: true</body><body package="OldBrowsers">textAction: aMessage	self currentTextEditor dispatchMenuSelection: aMessage</body><body package="OldBrowsers">textCancelled	self updateText</body><body package="OldBrowsers">updateText	| sel tv |	text value: (self tryAll: [:c | c text] default: [Text new]).	(sel := components first initialSelection) == nil		ifFalse: [builder == nil			ifFalse:				[tv := (builder componentAt: #text) widget.				tv deselect.				tv controller find: sel.				tv displaySelection: true.				tv selectAndScroll]]</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>components</category><body package="OldBrowsers">broadcastUpdate: aspect	self components first broadcastUpdate: aspect</body><body package="OldBrowsers">component1	^self visibleComponentAt: 1</body><body package="OldBrowsers">component2	^self visibleComponentAt: 2</body><body package="OldBrowsers">component3	^self visibleComponentAt: 3</body><body package="OldBrowsers">component4	^self visibleComponentAt: 4</body><body package="OldBrowsers">component5	^self visibleComponentAt: 5</body><body package="OldBrowsers">list1	^self component1 listSpec</body><body package="OldBrowsers">list2	^self component2 listSpec</body><body package="OldBrowsers">list3	^self component3 listSpec</body><body package="OldBrowsers">list4	^self component4 listSpec</body><body package="OldBrowsers">list5	^self component5 listSpec</body><body package="OldBrowsers">menuBar	| menu |	menu := Menu new		addPart: self class menuBarStart.	coordinator == nil ifFalse: [coordinator buildMenuBar: menu].	components do: [:comp | comp buildMenuBar: menu].	menu addPart: self class menuBarEnd.	(menu atNameKey: #edit) submenu: self remoteTextMenu.	(menu atNameKey: #view) submenu: [self viewMenu].	^menu</body><body package="OldBrowsers">resetToolBar	| menu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildToolBar: menu].	components do: [:comp | comp buildToolBar: menu].	toolBar value: menu</body><body package="OldBrowsers">toolBar	toolBar value == nil		ifTrue: [self resetToolBar].	^toolBar</body><body package="OldBrowsers">viewMenu	| menu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildViewMenu: menu].	components do: [:comp | comp buildViewMenu: menu].	^menu</body><body package="OldBrowsers">windowLabel	^components isEmpty		ifTrue: [(#SystemBrowser &lt;&lt; #labels &gt;&gt; 'System Browser')]		ifFalse: [components first windowLabel]</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>actions</category><body package="OldBrowsers">displayHelp	VisualLauncher openHelpBrowser</body><body package="OldBrowsers">explain	"Try to shed some light on what kind of entity the controller's	current selection is. The selection must be a single token or construct."	| aController |	aController := self currentTextEditor.	aController isNil ifTrue: [^self].	self components reverseDo: [:c |  		c selection notNil			ifTrue: [^c explainFor: aController]].	"Nobody cares, but try to explain at least something."	Explainer explain: aController selection string for: self</body><body package="OldBrowsers">format	"Format the text view's text."	| aController |	aController := self currentTextEditor.	aController isNil ifTrue: [^self].	self components reverseDo: 		[ :c |		c selection notNil			ifTrue: [ ^c formatFor: aController ]		].</body><body package="OldBrowsers">metaOff	self changeRequest ifFalse: [ ^self ].	meta value: #instance</body><body package="OldBrowsers">metaOn	self changeRequest ifFalse: [ ^self ].	meta value: #class</body><body package="OldBrowsers">metaShowData	self changeRequest ifFalse: [ ^self ].	meta value: #data</body><body package="OldBrowsers">metaShowDataSilently	meta retractInterestsFor: self.	meta value: #data.	meta onChangeSend: #updateProtocolLists to: self.</body><body package="OldBrowsers">module: moduleName action: action	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator perform: action].	components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers">module: moduleName action: action with: value	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator dispatch: action with: value].	components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action with: value]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers">showComment	self defType value: #showComment</body><body package="OldBrowsers">showDefinition	self defType value: #showDefinition</body><body package="OldBrowsers">showHierarchy	self defType value: #showHierarchy</body><body package="OldBrowsers">tearOff	"Tearing off is a special kind of spawning that creates a new standalone browser 	on the method, with unsaved code changes if any, and cancels any code changes	in the debugger."	| selectorHelper selection methodDefinition |	selectorHelper := self components last currentHelper.	selection := selectorHelper selection.	selection isNil ifTrue: [^self].	methodDefinition := selectorHelper definitionOf: selection.	methodDefinition notNil ifTrue: 		[self tearOffMethod: methodDefinition]</body><body package="OldBrowsers">truePerformerFor: moduleName	"Answer the module that is responsible for performing menu 	actions for moduleName. Answer the receiver if none."	( coordinator notNil and: [ coordinator menuHeader = moduleName ] )		ifTrue: [ ^coordinator ].	components do: 		[ :comp |		comp menuHeader = moduleName			ifTrue: [ ^comp ]		].	^nil</body><body package="OldBrowsers">updateLists	components first updateList</body><body package="OldBrowsers">updateMeta	self changeRequest ifFalse: [ ^self ].	self updateLists.</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>selection utlity</category><body package="OldBrowsers">selectBehavior: aBehavior	 (self  components at: (components size - 2)) currentHelper selectBehavior:aBehavior</body><body package="OldBrowsers">selectCategory: aCategory	(self  components at: (components size - 3)) currentHelper  selectCategory: aCategory</body><body package="OldBrowsers">selectMethod: aSymbol	(self  components at: (components size)) currentHelper selectMethod: aSymbol</body><body package="OldBrowsers">selectProtocol: aProtocol	(self  components at: (components size - 1)) currentHelper selectProtocol:aProtocol</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>spawning</category><body package="OldBrowsers">spawnForMethodsLabel: aLabel list: list initialSelection: selection	|newBrowser|	newBrowser := self spawningBrowser.	newBrowser initializeForMethodsLabel: aLabel		list: list		initialSelection: selection.		list size = 1		ifTrue:			[newBrowser components first forceSelection: list first.			newBrowser updateLists].	newBrowser open</body><body package="OldBrowsers">spawnOnClass: aClass	| newBrowser |	newBrowser := self  spawningBrowser.	newBrowser initializeForClass: aClass.	newBrowser open.</body><body package="OldBrowsers">spawnOnClass: aClass protocol: aSelection	| newBrowser |	newBrowser := self  spawningBrowser.	newBrowser initializeForClass: aClass protocol: aSelection.	newBrowser open.</body><body package="OldBrowsers">spawnOnClassHierarchy: aClass	| newBrowser |	newBrowser := self  spawningBrowser.	newBrowser initializeForClassHierarchy: aClass.	newBrowser open.</body><body package="OldBrowsers">spawnOnNameSpace: aNamespace 	| newBrowser |	newBrowser := self spawningBrowser.	newBrowser initializeForNameSpace: aNamespace.	newBrowser open</body><body package="OldBrowsers">spawnOnNameSpace: aClassOrNameSpace protocol: aSelection	| newBrowser |	newBrowser := self  spawningBrowser.	newBrowser initializeForNameSpace: aClassOrNameSpace protocol: aSelection.	newBrowser open.</body><body package="OldBrowsers">spawnOnNameSpaces: aNamespace category: aCategory	| newBrowser |	newBrowser := self  spawningBrowser.	newBrowser initializeForNameSpaces: aNamespace category: aCategory.	newBrowser open.</body><body package="OldBrowsers">tearOffMethod: methodDefinition		| newBuilder targetEditor sourceEditor |	sourceEditor := self currentTextEditor.	sourceEditor isNil ifTrue: [^self].	newBuilder := TabApplicationSystemBrowser		initializeForMethodsLabel: methodDefinition printString		list: (List with: methodDefinition)		initialSelection: methodDefinition		with: NamespaceTabApplication.	targetEditor := newBuilder source currentTextEditor.	targetEditor view editText: sourceEditor view displayContents.	sourceEditor accepted ifFalse: [targetEditor notAccepted].	self textCancelled</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>testing</category><body package="OldBrowsers">isClass	^meta value == #class</body><body package="OldBrowsers">isData	^meta value == #data</body><body package="OldBrowsers">isInstance	^meta value == #instance</body><body package="OldBrowsers">isMeta	^meta value == #class</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>change</category><body package="OldBrowsers">updateButtonLabels</body><body package="OldBrowsers">updateProtocolLists	self components size &gt; 3 ifTrue:[(self components at: (self components size - 2 )) updateList ] ifFalse:[self updateLists ]</body><body package="OldBrowsers">updateWindowLabel	(builder notNil	and: [builder window notNil]) ifTrue:		[builder window label: self windowLabel]</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>accessing</category><body package="OldBrowsers">browser	^self</body><body package="OldBrowsers">componentDictionary	^componentDictionary isNil ifTrue:[componentDictionary := Dictionary new] ifFalse:[componentDictionary ]</body><body package="OldBrowsers">components	^components</body><body package="OldBrowsers">coordinator	^coordinator</body><body package="OldBrowsers">defType	^defType</body><body package="OldBrowsers">disableBatchUpdates	^disableBatchUpdates isNil ifTrue:[ disableBatchUpdates := false] ifFalse:[disableBatchUpdates]</body><body package="OldBrowsers">emphasizer	^Emphasizer new</body><body package="OldBrowsers">ignoreNamepaceChanges	^ignoreNamepaceChanges isNil ifTrue:[ignoreNamepaceChanges := false] ifFalse:[ignoreNamepaceChanges ]</body><body package="OldBrowsers">ignoreNamepaceChanges: aBooleen	ignoreNamepaceChanges := aBooleen</body><body package="OldBrowsers">meta	^meta</body><body package="OldBrowsers">remoteTextMenu	| menu |	menu := self textMenu.	menu menuItems do: [:item | | action |		action := item value.		item value: [:cntrl | cntrl performer textAction: action]].	^menu</body><body package="OldBrowsers">setAndUpdateEnvironment: anEnvironment	self ignoreNamepaceChanges ifFalse:		[ self setNameSpaceFor: #default to: anEnvironment ]</body><body package="OldBrowsers">spawningBrowser	^#{Tools.FullSystemBrowser} value new</body><body package="OldBrowsers">textMenu	^Menu new		addPart: self class editGroup;		addPart: self class evaluateGroup;		addPart: (self class acceptCancel: #(#accept #textCancelled));		addPart: self class textMenuExtras;		addPart: self class hardcopyGroup;		yourself</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>copying</category><body package="OldBrowsers">postCopy	super postCopy.	builder := nil.	inBatchMode := false.	text := text value asValue.	meta := meta value asValue.	meta onChangeSend: #updateProtocolLists to: self.	defType := defType value asValue.	defType onChangeSend: #updateText to: self.	toolBar := nil asValue.	self components: (self components collect: [:i | i copy]).</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>events</category><body package="OldBrowsers">noticeOfWindowClose: aWindow 	^self release</body></methods><methods><class-id>Tools.FullSystemBrowser class</class-id> <category>private</category><body package="OldBrowsers">interfaceSpecFor: aSymbol	| spec |	spec := super interfaceSpecFor: aSymbol.	spec window toolBar: #toolBar.	^spec</body><body package="OldBrowsers">isVisualStartable	"Used by UIFinder to divine that the application will respond to Start"	^true</body><body package="OldBrowsers">listBrowserClass	^#{Tools.FullSystemBrowser} value</body><body package="OldBrowsers">openOn: anInstance	"Create a running instance of the application and open its user 	interface using the specification resource of the standard name."	^self openOn: anInstance withSpec: anInstance interfaceName</body></methods><methods><class-id>Tools.FullSystemBrowser class</class-id> <category>resources</category><body package="OldBrowsers">acceptCancel: values	| menu |	menu := self acceptCancel.	menu menuItems with: values do: [:it :val | it value: val].	^menu</body></methods><methods><class-id>Tools.FullSystemBrowser class</class-id> <category>interface specs</category><body package="OldBrowsers">windowSpec	^self windowSpec4</body></methods><methods><class-id>Tools.FullSystemBrowser class</class-id> <category>actions</category><body package="OldBrowsers">openOnAllNamespaces" self openOnAllNamespaces"	^self new		initializeForAllNameSpaces;		open</body><body package="OldBrowsers">openOnNameSpace: aNameSpace		"self openOnNameSpace: TeamWorks"	^self new 			initializeForNameSpace: aNameSpace;		open.</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController 	self selection == nil ifTrue: [^nil].	(self browser defType value == #showHierarchy and: [self selectionIsClass])		ifTrue: [^false].	(self browser defType value == #showComment and: [self selectionIsDefined])		ifTrue: 			[self selection asNameSpace namedReferent comment: text.			^true].	^self acceptDefinition: text from: textController</body><body package="OldBrowsers">doItEnvironment	^self selectionIsClass		ifTrue: [self selectedItem environment]		ifFalse: [self environment]</body><body package="OldBrowsers">doItReceiver	^self selectionIsClass		ifTrue: [self selectedItem instanceBehavior]		ifFalse: [nil]</body><body package="OldBrowsers">explainerClass	^self selectionIsClass		ifTrue: [self selectedItem]		ifFalse: [nil]</body><body package="OldBrowsers">text	^self selection == nil		ifTrue: [self selections isEmpty			ifTrue: [nil]			ifFalse: [Text new]]		ifFalse:			[self textWhenSelected]</body><body package="OldBrowsers">textWhenSelected	"Boy I hate this 'architecture'."	(self browser defType value == #showHierarchy and: [self selectionIsClass])		ifTrue: [^self isData				ifTrue: [self selectedItem printHierarchyWithStatics]				ifFalse: [self selectedItem printHierarchy]].	(self browser defType value == #showComment and: [self selectionIsDefined])		ifTrue: 			[ | comment |			comment := self selection comment.			^comment isEmpty 				ifTrue: [self selection commentTemplateString]				ifFalse: [comment]].	^self selectionIsDefined ifTrue: 		[self selection definition]</body><body package="OldBrowsers">updateListForDefinedThing: thing	module select: thing whenFinished: [ module updateList ]</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForClassesOnly	^#(#browseFieldReferences #browseClassVariables #instVarAssign #instVarRead)</body><body package="OldBrowsers">actionsForMultiSelect	^#(#fileOut #hardcopy #add #browseClass #move #remove)</body><body package="OldBrowsers">buildViewMenu: aMenu	| menu |	menu := self class metaMenu.	menu menuItems do: [:i |		i labelImage: nil.		i indication: self browser meta value == i nameKey].	aMenu addPart: menu.	menu := self class defTypeMenu.	menu menuItems do: [:i |		i labelImage: nil.		i indication: (self browser defType value = i value)].	aMenu addPart: menu</body><body package="OldBrowsers">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Don't override a menu items particular enablement"	| item |	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	( self selection == nil or: [ self selectionIsClass ] )		ifFalse:			[ self actionsForClassesOnly do: 				[:nm | 				( item := menu atNameKey: nm ) == nil					ifFalse: [ item disable ] 				]			].	^menu</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">addClientDataTo: anIdentityDict 	self hasSelections ifFalse: [^false].	anIdentityDict at: self classOrNamespaceKey put: self selections.	^true</body><body package="OldBrowsers">canAcceptDropFrom: aDC	^false</body><body package="OldBrowsers">dragEnter: aDragContext 	"Typically a class pane doesn't accept drops"^#dropEffectNone</body><body package="OldBrowsers">dragLeave: aDragContext 	"Typically a class pane doesn't accept drops"^#dropEffectNone</body><body package="OldBrowsers">dragOver: aDragContext 	"Typically a class pane doesn't accept drops"^#dropEffectNone</body><body package="OldBrowsers">getDragDropKey	"return the data key for the drag"	^self classOrNamespaceKey.</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">browseClassReferences	| calls mc filter |	mc := self methodCollector.	filter := mc nullFilter.	self selections do:		[ :obj |		filter := filter				| (mc referencesTo: obj name)				| (mc referencesTo: ( obj environment bindingFor: obj name ) )].	calls := mc select: filter.	calls isEmpty		ifTrue:			[Dialog warn: (#None &lt;&lt; #dialogs &gt;&gt; 'None')				for: self interfaceWindow.			^self].	^mc 		openListBrowserOn: calls		label: (self selection == nil				ifTrue: [(#ReferencesToVariousVariables &lt;&lt; #dialogs &gt;&gt; 'References to various variables')]				ifFalse: [(#ReferencesTo1s &lt;&lt; #dialogs &gt;&gt; 'References to &lt;1s&gt;') expandMacrosWith: self selection fullName])		initialSelection: (self selection == nil				ifTrue: [nil]				ifFalse: [self selection name])</body><body package="OldBrowsers">browseClassVariables	"Show a menu of all class variables of the currently selected class  	and its superclasses.  Browse all methods which refer to the variable selected."	| binding selectedClass mc |	selectedClass := self selectedItem instanceBehavior.	binding := self forClass: selectedClass		showVariableMenu: [:class | class localBindings asSortedCollection]		collect: [:bnd | bnd key].	binding notNil ifTrue:		[mc := self methodCollector.		mc browseSelect: (mc searchClassHierarchy: self selectedItem)							&amp; (mc referencesTo: binding)]</body><body package="OldBrowsers">browseFieldReferences	"Show a menu of all instance variables of the currently selected class 	and its superclasses. Browse all methods which refer to the variable 	selected."	| name mc |	name := self forClass: self selectedItem			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	mc := self methodCollector.	mc browseSelect:			(mc searchBehaviorHierarchy: self selectedItem)			&amp; (mc instVarUse: name access: #readWrite).</body><body package="OldBrowsers">fileOut	| fileName fileManager nm |	nm := self defaultFileName.	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr]].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers">hardcopy	"Print the category."		| stream |	stream := TextStream on: (String new: 1000).	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing printOutOn: stream.					stream cr; nextPut: Character newPage; cr]].	self hardcopyStream: stream</body><body package="OldBrowsers">move	"Move the selected classes to a user provided category." 	| selectedCategory aString newCategory |	self changeRequest ifFalse: [^self].	selectedCategory := self category.	aString := self				prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') 				initially: (selectedCategory isNil ifTrue: [(#NewCategory &lt;&lt; #labels &gt;&gt; 'New Category') asString] ifFalse: [selectedCategory]).	aString isEmpty ifTrue: [^self].	newCategory := aString asSymbol.	newCategory = selectedCategory ifTrue: [^self].	module selections do: 		[:aClass |		self environment classifySymbol: aClass name under: newCategory.		ChangeSet changeClass: aClass].	self browser broadcastUpdate: #category -&gt; newCategory</body><body package="OldBrowsers">moveNameSpace	| newSpace |	newSpace := NameSpaceNavigator					searchFrom:						(self defaultEnvironment isNil							ifTrue: [Smalltalk]							ifFalse: [self defaultEnvironment])					label: (#MoveToWhichEnvironmentQ &lt;&lt; #dialogs &gt;&gt; 'Move to which environment?').	newSpace == nil ifTrue: [^self].	module selections do:		[:sel | sel relocateTo: newSpace].	module updateList</body><body package="OldBrowsers">remove	"Prompt the user to remove the current class.  Answer if the class was removed or not."	| objs parentEvironment | 	self changeRequest ifFalse: [^false].	objs := module selections asArray collect: 		[ :obj |		obj isObsolete			ifFalse: [ obj ]			ifTrue:				[Dialog warn: ((#CantRemoveObject1sNoLongerExists &lt;&lt; #dialogs &gt;&gt; 'Can''t remove the object. &lt;1s&gt; no longer exists.')							expandMacrosWith: obj fullName)					for: self interfaceWindow.				nil]		].	objs := objs copyWithout: nil.	objs isEmpty ifTrue: [ ^false ].	objs := SystemUtils sortForLoading: objs.	objs reverseDo: 		[ :obj |		(Dialog confirm: ((#DoYouWantToRemove1sQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you&lt;n&gt;want to remove &lt;1s&gt;?')					expandMacrosWith: obj fullName )				for: self interfaceWindow)			ifTrue: 				[(obj subrequisites size = 0					or: [Dialog confirm: ((#HasDependentObjectsRemoveItAnywayQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dependent objects. Remove it anyway?')									expandMacrosWith: obj fullName)							for: self interfaceWindow])					ifTrue: [parentEvironment := obj environment.							obj removeFromSystem]]].	module updateList.	#{Tools.FullNotebookSystemBrowser}		ifDefinedDo: [:browser |			self browser class = browser ifTrue:[				self browser setAndUpdateEnvironment: parentEvironment.				self browser toggleNamespaceList ]].	^false</body><body package="OldBrowsers">rename	"Rename the currently selected thing, which can be (depending on the	selection and the meta switch) either a class, or a metaclass, 	or a namespace."	| newName target kind |	self changeRequest ifFalse: [^self].	target := self selected: #classOrNameSpace.	target isBehavior		ifTrue: 			[kind := (#class &lt;&lt; #labels &gt;&gt; 'class').			target := target instanceBehavior]		ifFalse: 			[kind := (#namespace &lt;&lt; #labels &gt;&gt; 'namespace')].	newName := self		prompt: ((#EnterNew1sName &lt;&lt; #dialogs &gt;&gt; 'Enter new &lt;1s&gt; name') expandMacrosWith: kind)		initially: self selection name asString.	newName isEmpty ifTrue: [^self].	newName := SystemUtils		validateStaticVariableName: newName		confirm: [:msg :nm | Dialog confirm: msg for: self interfaceWindow]		warn: [:msg | Dialog warn: msg for: self interfaceWindow].	newName isNil ifTrue: [^self].	SmalltalkWorkbench		rename: target		to: newName asSymbol		do: [:cls :nm | module select: cls whenFinished: [module updateList]]		for: self interfaceWindow		browser: self browser</body><body package="OldBrowsers">spawn	self selectedItem isNil ifTrue:[^self].    self browser spawnOnClass: (self selectedItem isMeta ifTrue:[ self selectedItem instanceBehavior] ifFalse:[ self selectedItem]).</body><body package="OldBrowsers">spawnBrowser	"Trigger the 'spawn' action, via a double-click.	If there are more than one types of spawning,	this may not necessarily be the same as the	'spawn' menu item."	self selectionIsClass		ifTrue: [SmalltalkWorkbench browseClass: self selectedItem]		ifFalse: [self spawn]</body><body package="OldBrowsers">spawnHierarchy	self selectedItem isForNameSpace ifTrue:[^self].	self browser spawnOnClassHierarchy: (self selectedItem isMeta ifTrue:[self selectedItem instanceBehavior] ifFalse:[self selectedItem ]).</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#classOrNameSpace</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">decorate: item	| type |	type := nil.	item isForNameSpace		ifTrue: [type := #nameSpace].	^#{Tools.BrowserListEntry} value value: item type: type</body><body package="OldBrowsers">defaultEnvironment	| all |	all := module selections collect: [:i | i environment].	all := all asSet asArray.	^all size = 1		ifTrue: [all first]		ifFalse: [Smalltalk]</body><body package="OldBrowsers">defaultFileName	"Answer a string as a suggested filename"	^self selection == nil		ifTrue: [ (#Definitions &lt;&lt; #labels &gt;&gt; 'Definitions') asString]		ifFalse: [ ( self textForItem: self selection ) asString ].</body><body package="OldBrowsers">definitionOfStatic: aVar	self subclassResponsibility</body><body package="OldBrowsers">forClass: aClass showVariableMenu: generatorBlock collect: valueBlock	"Construct a menu of variable names supplied by the generatorBlock,	with lines between classes in the superclass chain.  Show the menu,	returning the variable chosen by the user, or nil if no variable was chosen."	| variables labels tab listW sd spec buttons | 	variables := OrderedCollection new.	labels := SelectionInList new.	tab := String with: Character tab.	aClass withAllSuperclasses reverseDo:		[:eachClass | | varList |		varList := generatorBlock value: eachClass.		varList isEmpty			ifFalse:				[labels list add: (Text string: eachClass name emphasis: #italic).				labels selectionIndex: labels list size + 1.  "we know this will be legal"				variables add: nil.				(generatorBlock value: eachClass) do:					[:var |					labels list add: tab, (valueBlock value: var).					variables addLast: var]]].	variables isEmpty ifTrue: [^nil].  "Nothing to choose from"	sd := SimpleDialog new.	spec := (sd class interfaceSpecFor: #emptySpec).	sd builder add: spec window.	sd builder add: spec component.	sd setInitialGap.	sd addMessage: (#BrowseReferencesToWhichVariableQ &lt;&lt; #dialogs &gt;&gt; 'Browse references&lt;n&gt;to which variable?') expandMacros centered: true.	sd addGap: 8.	listW := sd			addList: labels			lines: (20 min: variables size+2)			validation: [labels selectionIndex &gt; 0].	listW widget setValidTargetIndex: labels selectionIndex.	sd addGap: 4.	buttons := sd addOK: [labels selectionIndex ~= 0].	sd addGap: 6.	sd bottomAlignLowerEdge: listW.	sd bottomAlign: (Array with: buttons).	labels selectionIndexHolder compute:			[:v |			(v &gt; 0 and: [(variables at: v) == nil])				ifTrue: [labels selectionIndex: 0.						listW widget targetIndex: 0]].	sd preOpen.	sd builder openDialogWithExtent: sd builder window displayBox extent.	^sd accept value		ifTrue: [variables at: labels selectionIndex]		ifFalse: [nil]</body><body package="OldBrowsers">selectedThingsWithOrder: aBlock	aBlock value: ( SystemUtils sortForLoading: self selections ).</body><body package="OldBrowsers">textEmphasisForItem: anItem	^self emphasizer 		emphasisForClassOrNameSpace: anItem		for: self browser 		id: self selectionId</body><body package="OldBrowsers">textForItem: aListEntry	^aListEntry name asText</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">selectedItem	| thing |	thing := self selection.	( self selectionIsClass and: [ self isMeta ] )		ifTrue: [ thing := thing class].	^thing</body><body package="OldBrowsers">selectionChanged	module nextModule == nil ifTrue: [ ^super selectionChanged ].	self browser updateWindowLabel.	self browser batchUpdates:		[		self setSelection.		self selection isNameSpace ifTrue:[ self browser metaShowDataSilently].		module nextModule updateList		]</body><body package="OldBrowsers">selectionIsClass	^self selection notNil and: 		[ self selection isSymbol 			ifTrue:[ false ] 			ifFalse:[ module selection isForClass ]		]</body><body package="OldBrowsers">selectionIsDefined	^self selection notNil and: [ self selection isSymbol not ]</body></methods><methods><class-id>Tools.ClassesBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">commentIcon	^OpaqueImage		figure: self commentIconColor		shape: self commentIconMask</body><body package="OldBrowsers">definitionIcon	^OpaqueImage		figure: self definitionIconColor		shape: self definitionIconMask</body><body package="OldBrowsers">hierarchyIcon	^OpaqueImage		figure: self hierarchyIconColor		shape: self hierarchyIconMask</body></methods><methods><class-id>Tools.ClassesBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">menuHeader	^(#Class &lt;&lt; #menus &gt;&gt; '&amp;Class') asString</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForNoSelect	^#(#add #addClassBytes #addClassFixedSize #addClassVariableSize)</body><body package="OldBrowsers">enhance: menu for: md submenu: nameKey subMenuName: aName	| item |	item := menu atNameKey: nameKey.	item isNil ifTrue: [^self].	((nameKey == #spawnHierarchy ))		ifTrue: [^self selection == nil				ifTrue: [item disable]				ifFalse: [self selection isForNameSpace ifTrue:[item disable] ifFalse:[item enable]]].</body><body package="OldBrowsers">getListMenu: forMenuBar	| menu |	menu := super getListMenu: forMenuBar.	self enhance: menu for: self selection submenu:  #spawnHierarchy   subMenuName: (#SpawnHierarchy &lt;&lt; #menus &gt;&gt; 'Spawn Hierarchy') .	^menu</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addBinding	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateBinding: self environment			category: self category)</body><body package="OldBrowsers">addClassBytes	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateClass: self environment			category: self category			type: #bytes)</body><body package="OldBrowsers">addClassFixedSize	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateClass: self environment			category: self category			type: #none)</body><body package="OldBrowsers">addClassVariableSize	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateClass: self environment			category: self category			type: #objects)</body><body package="OldBrowsers">addNameSpace	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateNameSpace: self environment			category: self category)</body><body package="OldBrowsers">move	| aString newCategory |	self changeRequest ifFalse: [^self].	aString := self prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') initially: (self category isNil ifTrue:[(#NewCategory &lt;&lt; #labels &gt;&gt; 'New Category') asString]ifFalse:[ self category]).	aString isEmpty ifTrue: [^ self].	newCategory := aString asSymbol.	newCategory == self category		ifTrue: [^self].	module selections do: 		[ :selection |		selection environment classifySymbol: selection name under: newCategory.		selection isForClass			ifTrue: [ ChangeSet changeClass: selection ]			ifFalse: [ ChangeSet changeNameSpace: selection ].		].	self browser broadcastUpdate: #category -&gt; newCategory</body><body package="OldBrowsers">moveNewParcel	| newName currentParcel obj |	self changeRequest ifFalse: [^self].	newName := Dialog						request: (#EnterNameForNewParcel &lt;&lt; #dialogs &gt;&gt; 'Enter name for the new parcel')						initialAnswer: ''						onCancel: [nil].	newName := Parcel normalizedNameFor: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(Parcel parcelNamed: newName) notNil ifTrue:		[Dialog warn: (#parcelExists &lt;&lt; #dialogs &gt;&gt; 'A parcel with this name already exists').		^self].	(currentParcel := Parcel createParcelNamed: newName) == nil ifTrue:		[^self].	obj := self selection.	obj isForClass		ifTrue: [ currentParcel addEntiretyOfClass: obj ]		ifFalse: 	[currentParcel addObject: obj ].</body><body package="OldBrowsers">selectBehavior: aBehavior	self setSelection: aBehavior.	module select: aBehavior whenFinished: [module updateList]</body><body package="OldBrowsers">spawn	self selection isNil ifTrue: [^self].	self selectionIsClass ifTrue: [^super spawn].	self selection isForNameSpace ifTrue: 		[self browser spawnOnNameSpace: module selection]</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">defaultEnvironment	^self environment</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">generateListFull	| env newList cat |	env := self environment.	cat := self category.	newList := env == nil		ifTrue: 			[ newList := cat == nil						ifTrue: [ Root withAllNameSpacesAndAllClasses ]						ifFalse: [ Root withAllNameSpacesAndAllClasses									select: [:ea| ea category == cat ] ] ]		ifFalse:			[ newList := cat == nil				ifTrue: [ env asNameSpace organization elements ]				ifFalse: [ env asNameSpace organization listAtCategoryNamed: cat ].			newList := newList collect: 				[ :nm | | bind |				( bind := env bindingFor: nm ) isForGeneral not					ifTrue: [ bind value ]				].			newList := newList reject: [ :ref | ref == nil ].			].	^newList.</body><body package="OldBrowsers">updateListFull	module setNewList: 		( self generateListFull asSortedCollection: 			[ :a :b | a name &lt; b name ] 		) asList.	module list list isEmpty ifTrue: 		[self broadcastUpdate: #classOrNameSpace -&gt; self environment]</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>templates</category><body package="OldBrowsers">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers">templateClass: nameSpace category: category type: type	| ns |	ns := nameSpace == nil		ifTrue: [ Smalltalk ]		ifFalse: [ nameSpace ].	^'&lt;1p&gt; defineClass: #&lt;2s&gt;	superclass: #{&lt;3s&gt;}	indexedType: #&lt;4s&gt;	private: false	instanceVariableNames: ''&lt;5s&gt;''	classInstanceVariableNames: ''''	imports: ''''	category: &lt;6p&gt;' 		expandMacrosWithArguments: (OrderedCollection new			add: (ns namedReferent unambiguousName);			add: #NameOfClass &lt;&lt; #browser &gt;&gt; 'NameOfClass';			add: #NameOfSuperclass &lt;&lt; #browser &gt;&gt; 'NameOfSuperclass';			add: type;			add: (type == #bytes				ifTrue: ['']				ifFalse: [(#instVarName1InstVarName2 &lt;&lt; #browser &gt;&gt; 'instVarName1 instVarName2')]);			add: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString]);			yourself)</body><body package="OldBrowsers">templateNameSpace: nameSpace category: category	^'&lt;1s&gt; defineNameSpace: #&lt;2s&gt;	private: false	imports: ''			&lt;3s&gt;.*			private Smalltalk.*			''	category: &lt;4p&gt;'		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfPool &lt;&lt; #browser &gt;&gt; 'NameOfPool'		with: #OtherNameSpace &lt;&lt; #browser &gt;&gt; 'OtherNameSpace'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">windowLabel	^(#ClassBrowserOn &lt;&lt; #labels &gt;&gt; 'Class Browser on &lt;1p&gt;') expandMacrosWith: self selection</body></methods><methods><class-id>Tools.NameSpaceGlobalCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">generateListFull	^(self environment == nil)		ifTrue: 			[Root withAllNameSpacesAndAllClasses ]		ifFalse:			[self category == nil 				ifTrue: [Root withAllNameSpacesAndAllClasses]				ifFalse: [Root withAllNameSpacesAndAllClasses select: [:each | each category = self category]]]</body><body package="OldBrowsers">updateListFull	Cursor wait showWhile: 		[module setNewList: (self generateListFull asSortedCollection: [:a :b | a name &lt; b name]) asList]</body></methods><methods><class-id>Tools.NameSpaceGlobalCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">textForItem: aListEntry	^aListEntry displayString asText</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	| protocol newSelector target |	protocol := self selection == nil		ifTrue: [self selections isEmpty			ifTrue: [nil]			ifFalse: [Dialog choose: (#CompileInWhichProtocol &lt;&lt; #dialogs &gt;&gt; 'Compile this in which protocol?')						fromList: module selections asSortedCollection						values: module selections asSortedCollection						lines: 10						cancel: [false]						for: self interfaceWindow]]		ifFalse: [self selection].	protocol isSymbol ifFalse: [^protocol].	target := self selectedClassOrNameSpace.	( self isData or: [ target isForNameSpace] )		ifTrue: [ ^self acceptDefinition: text from: textController ].	newSelector := self targetClass				compile: text				classified: protocol				notifying: textController.	newSelector == nil ifTrue: [^false].	module select: protocol		whenFinished:			[module nextModule select: newSelector				whenFinished: [module updateList]].	^true</body><body package="OldBrowsers">doItEnvironment	| target |	( target := self selectedClassOrNameSpace ) == nil		ifTrue: [ ^nil ].	^target isForNameSpace		ifTrue: [ target ]		ifFalse: [ target environment ]</body><body package="OldBrowsers">doItReceiver	| target |	( target := self selectedClassOrNameSpace ) == nil		ifTrue: [ ^nil ].	^target isForNameSpace		ifTrue: [ target ]		ifFalse: [ target instanceBehavior ]</body><body package="OldBrowsers">explainerClass	^self selectedClassOrNameSpace</body><body package="OldBrowsers">formatFor: aController	"Format the text. Have the controller replace its contents with the new Text, 	or nil if the format operation was unsuccessful."	| selectedClass aCompiler newText aText |	selectedClass := self targetClassOrNameSpace.	( selectedClass isNil or: [ selectedClass isForNameSpace ] )		ifTrue: [ ^self ].	aText := aController text.	aCompiler := selectedClass compilerClass new.	newText := aCompiler			format: aText			in: selectedClass			notifying: aController.	newText == nil		ifFalse: [ newText := newText asText makeSelectorBoldIn: selectedClass ].	newText == nil		ifFalse:			[ aController				selectFrom: 1 to: aController text size;				deselect;				replaceSelectionWith: newText asText;				selectAt: 1			]</body><body package="OldBrowsers">text	| target |	target := self targetClassOrNameSpace.	^( ( self selection == nil ) |  ( target == nil ) )		ifTrue: 			[ self selections isEmpty				ifTrue: [ nil ]				ifFalse: [ Text new ]			]		ifFalse: 			[ ^( target isForClass				ifTrue: [ target sourceCodeTemplate ]				ifFalse: [ self module templateBinding: target category: self selection ]			   )  asText			].</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForMultiSelect	^#(#fileOut #hardcopy #add #remove #findMethod)</body><body package="OldBrowsers">actionsForNoSelect	^self targetClassOrNameSpace == nil		ifTrue: [#()]		ifFalse: [#(#add #findMethod )]</body><body package="OldBrowsers">getListMenu	"Items in the list are either method protocols or static	categories. We need to be sure the label of the 'Find...' 	menu item makes sense. (So the label of that item in	the resource spec on the class side does not actually matter.)"	| menu target |	menu := super getListMenu.	target := self targetClassOrNameSpace.	(menu menuItemWithValue: #findMethod) rawLabel:		((target isNil or: [target isForNameSpace])			ifTrue: [(#FindVariable &lt;&lt; #menus &gt;&gt; 'Find Variable...')]			ifFalse: [(#FindMethod &lt;&lt; #menus &gt;&gt; 'Find Method...')]).	^menu</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">addClientDataTo: anIdentityDict 	self hasSelections ifFalse: [^false].	anIdentityDict at: #class put: self targetClassOrNameSpace.	anIdentityDict at: #protocol put: self selections.	anIdentityDict at: #meta put: self meta.	anIdentityDict at: #category put: self category.	^true</body><body package="OldBrowsers">canAcceptDropFrom: aDC	^aDC key == self selectorOrStaticKey or: [  aDC key == self protocolKey]</body><body package="OldBrowsers">drop: aDragContext	"A drop has occured in the protocol list of the browser. see if we can accept and if so move the methods."	| ctrl idx prot protUnder protocolList selectors statics |	(self canAcceptDropFrom: aDragContext)  ifFalse: [^#dropEffectNone].	"Locate the target protocol's index"	aDragContext clientData isNil ifTrue: [aDragContext clientData: self module initialListDropState].	ctrl := aDragContext clientData at: #ctrl 				ifAbsent: 					[self module addControllerDataTo: aDragContext clientData. 					ctrl := aDragContext clientData at: #ctrl].	(idx := ctrl view targetIndex) = 0 ifTrue: [^#dropEffectNone].	protocolList := self module list list.	"If a protocol has been dropped, do not do a move unless from the same browser."	aDragContext key == self protocolKey ifTrue: [		prot := aDragContext sourceData clientData at: #protocol.		idx := ctrl view elementIndexFor: ctrl sensor cursorPoint.  		protUnder := idx &lt; protocolList  size ifTrue: [protocolList  at: idx].		"Ignore other browsers"		aDragContext data contextApplication ~~ self module browser ifTrue: [^#dropEffectNone].		prot do:[:eachProtocol | self selectedClassOrNameSpace organization addCategory: eachProtocol value before: protUnder value.].		(self selectedClassOrNameSpace) 			reorganize; 			logOrganizationChange.		self module updateList.		^#dropEffectMove].	"If there are changes to the text, prompt before discarding them"	self changeRequest ifFalse: [^#dropEffectNone].	"If the data is not available in the correct format, do not drop."	selectors := aDragContext sourceData clientData at: #selector ifAbsent: [#()].	statics := aDragContext sourceData clientData at: #data ifAbsent: [#()].	(selectors isEmpty and: [statics isEmpty]) ifTrue: [^#dropEffectNone].	"Move the selector to the new protocol.  The selector is in the clientData of the dropSource"	selectors do:[:eachSelector |  self moveSelector: eachSelector intoProtocol: ((protocolList  at: idx) value)].	statics do: [:eachStatic |  eachStatic environment asNameSpace classifySymbol: eachStatic name under:  ((protocolList  at: idx) value)].	"Restore the state of the protocol list before leaving."	self restoreListStateFrom: aDragContext clientData.	aDragContext clientData: nil.	self module updateList.	self module nextModule updateList.	^#dropEffectMove</body><body package="OldBrowsers">getDragDropKey	"return the data key for the drag"	^self protocolKey</body><body package="OldBrowsers">moveSelector: aSelectorSymbol intoProtocol: aProtocolSymbol 	"Move aSelectorSymbol to protocol named aProtocolSymbol."	| destClass |	destClass := self targetClassOrNameSpace.	destClass classifySymbol: aSelectorSymbol under: aProtocolSymbol.	self module logProtocolChange: destClass fullName , ' organization classify: ' , 			aSelectorSymbol storeString , ' under: ' , aProtocolSymbol storeString.	Transcript cr; show: ((#MethodInNewProtocol &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; &lt;nt&gt;moved from protocol ''&lt;3s&gt;'' to protocol ''&lt;4s&gt;''')			expandMacrosWith: destClass printString			with: aSelectorSymbol asString			with: self selection asString			with: aProtocolSymbol asString).	self nextModule updateList</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">add	| aString newProtocol target |	self changeRequest ifFalse: [^self].	aString := self			prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name')			initially: (#{ProtocolBrowserHelper.LastProtocol} value == nil ifTrue: [(#protocolName &lt;&lt; #dialogs &gt;&gt; 'protocol name') asString] ifFalse: [#{ProtocolBrowserHelper.LastProtocol} value]).	aString isEmpty ifTrue: [^ self].	newProtocol := aString asSymbol.	target := self targetClassOrNameSpace.	target organization addCategory: newProtocol before: self selection.	SourceFileManager default logChange:				('&lt;1p&gt; organization addCategory: &lt;2p&gt; before: &lt;3p&gt;'					expandMacrosWith: target					with: newProtocol					with: module selection).	target reorganize.	module select: newProtocol whenFinished: [module updateList]</body><body package="OldBrowsers">broadcastUpdate: aspect 	aspect key == #classOrNameSpace		ifTrue: 			[self				setSelection: aspect key				for: self selectionId				to: aspect value.			module hasList				ifTrue: [module select: aspect value whenFinished: [module updateList]]				ifFalse: 					[module forceSelection: aspect value.					self setSelection: aspect value]]		ifFalse: [super broadcastUpdate: aspect]</body><body package="OldBrowsers">fileOut	| target suggestion fileName fileManager  |	target := self selectedClassOrNameSpace.	suggestion := self selection isNil					ifTrue: ['-protocols.st']					ifFalse: [self selections size &gt; 1								ifTrue: ['-protocols.st'] 								ifFalse: ['-', self selection, '.st']].	fileName := target name, suggestion.	fileName := Dialog				requestNewFileName: (#FileOutAs &lt;&lt; #dialogs &gt;&gt; 'File out as')				default: ( Filename filterFilename: fileName ). 	fileName isEmpty ifTrue: [ ^nil ].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	 fileManager deferInitializations.	 self selections do: 		[:protocol |		(target isForNameSpace or: [self isData])			ifTrue:				[(target asNameSpace organization listAtCategoryNamed: protocol) do:					[:key | | ref |					ref := target asNameSpace fullyQualifiedReferenceOf: key.					fileManager storeObjectDefinition: ref.					ref binding hasInitializer ifTrue:						[fileManager initializeThisObject: ref]]]			ifFalse:				[fileManager fileOutMessages: (target organization listAtCategoryNamed: protocol) for: target]].	 fileManager finishInitializations]  				ensure: [ fileManager close ]</body><body package="OldBrowsers">findMethod	"Show a list of the methods implemented by this class, 	OR a list of statics.  Select the chosen one."	| collection target prompt chosen |	( target := self targetClassOrNameSpace ) == nil	ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ].	prompt := target isForNameSpace		ifTrue: [ (#FindWhichSharedVariableQ &lt;&lt; #dialogs &gt;&gt; 'Find which shared variable?') ] ifFalse: [ (#FindWhichMethodQ &lt;&lt; #dialogs &gt;&gt; 'Find which method?') ].	( collection := target organization elements asSortedCollection ) size = 0		ifTrue: [ ^self ].	chosen := Dialog			choose: prompt			fromList: collection			values: collection			lines: 20			cancel: [nil]			for: self interfaceWindow.	chosen isNil ifFalse:		[module select: ( target organization categoryOfElement: chosen )			whenFinished: [module nextModule					select: chosen					whenFinished: [module updateList]]].</body><body package="OldBrowsers">hardcopy	"Print out protocol."	| stream |	stream := TextStream on: (String new: 1000).	self selections do: 		[ :protocol |		self targetClassOrNameSpace printOutCategory: protocol on: stream		].	self hardcopyStream: stream</body><body package="OldBrowsers">remove	"Remove the selected protocol if the user confirms.	Answer a Boolean indicating whether a protocol has indeed been removed."	| keys target |	self changeRequest ifFalse: [ ^false ].	target := self targetClassOrNameSpace.	keys := Set new.	module selections do: 		[ :protocol |		keys addAll: ( target organization listAtCategoryNamed: protocol )		].	keys isEmpty 		ifFalse:			[ ( Dialog confirm: (#YouWantToRemoveMethodsInCategoriesQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you want to&lt;n&gt;remove all methods in these categories?')								expandMacros						for: self interfaceWindow)				ifFalse: [ ^false ].			target isForNameSpace 				ifTrue: [ keys do: [ :key | | ref |					ref := BindingReference simpleName: key in: target namedReferent.					(target includesKey: key) ifTrue: [ref removeFromSystem]]]				ifFalse: [ keys do: [:sel | target removeSelector: sel ] ]			].	module selections do: 		[ :protocol |		target organization removeCategory: protocol.		self logProtocolChange: ('&lt;1p&gt; organization removeCategory: &lt;2p&gt;'					expandMacrosWith: target					with: protocol)].	target reorganize.	module updateList.	^true</body><body package="OldBrowsers">rename	| aString newProtocol target |	self changeRequest ifFalse: [^self].	target := self targetClassOrNameSpace.	aString := self prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') initially: self selection.	aString isEmpty ifTrue: [^ self].	newProtocol := aString asSymbol.	( target renameCategory: module selection to: newProtocol)		ifTrue:			[self logProtocolChange: ('&lt;1p&gt; organization renameCategory: &lt;2p&gt; to: &lt;3p&gt;'						expandMacrosWith: target						with: self selection						with: newProtocol).			module select: newProtocol whenFinished: [module updateList]]</body><body package="OldBrowsers">selectProtocol: aSymbol	module select: aSymbol whenFinished: [module updateList]</body><body package="OldBrowsers">spawn	| target |	( target := self targetClassOrNameSpace ) isForClass		ifTrue: [ self browser spawnOnClass: target protocol: self selection ]		ifFalse: 	[ self browser spawnOnNameSpace: target protocol: self selection ]</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#protocol</body><body package="OldBrowsers">setSelection	"Inform the browser that the selection has changed;	unlike the superclass allow multiple selections."	self setSelection: self selections</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">meta	^self browser meta</body><body package="OldBrowsers">windowLabel	^module hasList		ifTrue: [(#xpBrowser &lt;&lt; #labels &gt;&gt; '&lt;1p&gt; Browser')					expandMacrosWith: self selectedClassOrNameSpace ]		ifFalse: [(#xpxsMessageCategoryBrowser &lt;&lt; #labels &gt;&gt; '&lt;1p&gt; {&lt;2s&gt;} Message Category Browser')					expandMacrosWith: self selectedClassOrNameSpace					with: self selection]</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">selectionChanged	module nextModule == nil ifTrue: [^super selectionChanged].	self selection == nil ifFalse: [#{ProtocolBrowserHelper.LastProtocol} value: self selection].	self setSelection.	self browser	batchUpdates: [ module nextModule updateList ]</body><body package="OldBrowsers">updateListFull	| newList target |	( target := self targetClassOrNameSpace ) == nil		ifTrue: [ newList := List new ]		ifFalse: [ newList := target organization categories asList ].	module setNewList: newList</body></methods><methods><class-id>Tools.ProtocolBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">menuHeader	^(#Protocol &lt;&lt; #menus &gt;&gt; '&amp;Protocol') asString</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addSelectionToParcel	| target parcel selectorsOrKeys |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	parcel := self selectedParcel.	selectorsOrKeys := target organization listAtCategoryNamed: self selection.	target isForNameSpace		ifTrue: [parcel addNames: selectorsOrKeys in: target]		ifFalse: [parcel addSelectors: selectorsOrKeys forClass: target].	self browser updateLists</body><body package="OldBrowsers">moveSelectionToParcel: aParcel	"Move all methods in the current protocol into aParcel according to the following rules.	 If no Parcel is selected ...		If filtering is off then move all the methods to theParcel		and remove all the methods from all other parcels.	 	If filtering is on then move all the methods that are defined		by other parcels into theParcel, and remove just those methods		from all other parcels.	 If a Parcel is selected ...		move all the methods that are defined in the selected Parcel to		theParcel and remove just those methods from the selected parcel."	| theClass |	self changeRequest ifFalse: [^self].	self  browser saveParcelsForUndo.	theClass := self targetClassOrNameSpace.	( theClass isForNameSpace or: [ self isData ] )		ifTrue: [ ^Dialog warn: (#MoveOfSharedVariableNotYetSupported &lt;&lt; #dialogs &gt;&gt; 'Move of shared variables not yet supported.'). ].	self browser moveSelectors: (theClass organization listAtCategoryNamed: self selection)		inClass: theClass		toParcel: aParcel.	self browser updateBrowser</body><body package="OldBrowsers">remove	"Override to ensure the parcel forgets the protocol if removed."	| removed parcel |	(removed := super remove) ifTrue:		[(parcel := self selectedParcel) notNil ifTrue: [parcel cleanse]].	^removed</body><body package="OldBrowsers">removeSelectionConflictsFromParcel	self unimplemented</body><body package="OldBrowsers">removeSelectionFromParcel	| target parcel|	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	parcel := self selectedParcel.	target isForNameSpace		ifTrue: [ ^Dialog warn: (#NotImplemented &lt;&lt; #dialogs &gt;&gt; 'Not implemented.'). ]		ifFalse: [ parcel removeSelectors: ( target organization listAtCategoryNamed: self selection )  							forClass: target ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">filter: protocols	| class browser parcels currentParcel |	(protocols isEmpty or: [(class := self targetClassOrNameSpace) isNil]) ifTrue:		[^protocols].	class isForNameSpace ifTrue: [ ^self filterStatics: protocols in: class ].	browser := self browser.	currentParcel  := self selectedParcel.	browser isUnparceledFilterOn ifTrue:		[(parcels := browser currentParcelsFor: class currentParcel: currentParcel) isEmpty			ifTrue: [^protocols].		^protocols select:			[:prot| | list |			(list := class organization listAtCategoryNamed: prot) isEmpty			or: [list contains:					[:sel|					parcels contains: [:p| (p definesSelector: sel forClass: class) not]]]]].	browser isParcelFilterOn ifFalse: [^protocols].	browser isConflictsFilterOn ifTrue:		[| conflicts |		conflicts := browser computeConflictsFor: (Set with: class instanceBehavior)						within: (currentParcel notNil ifTrue: [Array with: currentParcel]).		conflicts := conflicts first collect: [:md| md protocol].		^protocols select: [:prot| conflicts includes: prot]].	(parcels := self browser currentParcelsFor: class currentParcel: currentParcel ) isNil 		ifTrue:[ parcels := #() ].	^protocols select:		[:prot|		prot == #'parcel load/unload/save'		or: [parcels contains:				[:p|				(p definedSelectorsFor: class andProtocol: prot) size &gt; 0]]]</body><body package="OldBrowsers">filterStatics: protocols in: nameSpace	| browser currentParcel org mgr usedCategories classOrNameSpace |	classOrNameSpace := nameSpace namedReferent.	mgr := (browser := self browser) manager.	currentParcel  := self selectedParcel.	org := nameSpace organization.	browser isUnparceledFilterOn ifTrue:		[^protocols select:			[:cat|			(org listAtCategoryNamed: cat) contains:				[:bn| | binding |				binding := nameSpace bindingFor: bn.				binding isForNameSpace "Treat NameSpaces as flat; don't consider contained NameSpaces"					ifTrue: [(mgr parcelsForClassOrNameSpace: binding value) size = 0]					ifFalse:						[binding isForClass							ifTrue: [browser									isUnparceledCodeInClass: binding value									currentParcel: currentParcel]							ifFalse: [(mgr parcelsForBinding: binding) size = 0]]]]].	browser isParcelFilterOn ifFalse: [^protocols].	browser isConflictsFilterOn ifTrue:		[| multiplyParcelledThings conflicts |		 multiplyParcelledThings := mgr multiplyParcelledThings.		 classOrNameSpace isBehavior ifTrue:			[^protocols select:				[:cat|				(org listAtCategoryNamed: cat) contains:					[:bn|					(multiplyParcelledThings includes: (nameSpace bindingFor: bn))					and: [currentParcel isNil or: [currentParcel definesName: bn in: classOrNameSpace]]]]].		 conflicts := browser						computeConflictsFor: (multiplyParcelledThings select: [:thing| thing isBehavior])						within: (currentParcel notNil ifTrue: [Array with: currentParcel]).		^protocols select:			[:cat| | list |			(list := org listAtCategoryNamed: cat) isEmpty			or: [list contains:				[:bn| | binding parcels |				binding := nameSpace bindingFor: bn.				binding isForNameSpace					ifTrue:						[parcels := (mgr parcelsForClassOrNameSpace: binding value) select:										[:p| p definesObject: binding value].						parcels size &gt; 1 and: [currentParcel isNil or: [parcels includes: currentParcel]]]					ifFalse:						[binding isForClass							ifTrue:								[((conflicts last contains: binding value)								  or: [conflicts first contains:										[:md| md protocol == cat and: [md class == binding value]]])]							ifFalse: [(conflicts at: 2) includes: binding]]]]]].	currentParcel == nil ifTrue:		[^protocols select:			[:cat| | list |			(list := org listAtCategoryNamed: cat) isEmpty			or: [list contains:				[:bn| | binding |				binding := nameSpace bindingFor: bn.				(binding isForNameSpace				or: [binding isForClass])					ifTrue: [(mgr parcelsForClassOrNameSpace: binding value) size &gt; 0]					ifFalse: [(mgr parcelsForBinding: binding) size &gt; 0]]]]].	classOrNameSpace isBehavior ifTrue:		[^protocols select:			[:cat| | list |			(list := org listAtCategoryNamed: cat) isEmpty			or: [list contains:					[:bn|					currentParcel definesName: bn in: classOrNameSpace]]]].	usedCategories := IdentitySet new.	usedCategories		addAll: currentParcel definedClasses;		addAll: currentParcel extendedClasses.	usedCategories := usedCategories collect: [:class| class category].	^protocols select: [:categorySymbol | usedCategories includes: categorySymbol]</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">getListMenu: forMenuBar	| protocol parcels cl parcelsForClass selectorsInProtocol |	(protocol := self selection) isNil		ifTrue: [parcels := #()]		ifFalse:			[parcels := IdentitySet new: 4.			cl := self selectedClassOrNameSpace.			nil == (parcelsForClass := self browser manager parcelsForClassOrNameSpace: cl) ifFalse:				[selectorsInProtocol := cl organization listAtCategoryNamed: protocol.				parcelsForClass do:					[:p|					selectorsInProtocol do:						[:sel|						(p definesSelector: sel forClass: cl) ifTrue: [parcels add: p]]]]].	^self browser 		addParceling: parcels		to: (super getListMenu: forMenuBar)		forHelper: self</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers">setButtonEmphasisFor: classOrNameSpace 	| buttons |	module builder == nil ifTrue: [^self].	buttons := self emphasizer 				emphasisForClassButtons: classOrNameSpace				for: self browser				id: self selectionId.	buttons with: #(#instanceButton #classButton #dataButton)		do: 			[:emphasis :componentName | 			| component widget text |			(component := module builder componentAt: componentName) ~~ nil 				ifTrue: 					[text := (widget := component widget) label text.					(text emphasisAt: 1) ~= emphasis 						ifTrue: 							[text emphasizeAllWith: emphasis.							widget invalidate.							widget label text: text.							widget invalidate]]]</body><body package="OldBrowsers">textEmphasisForItem: anItem	^self emphasizer emphasisForProtocol: anItem for: self browser id: self selectionId</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">updateListFull	| class list |	( class := self targetClassOrNameSpace ) == nil		ifTrue: [ list := List new ]		ifFalse: 	[ list := class organization categories asList ].	self setButtonEmphasisFor: class.	module setNewList: ( self filter: list )</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	"Indicate that we didn't even try."	^self selection == nil		ifTrue: [nil]		ifFalse: [self acceptDefinition: text from: textController]</body><body package="OldBrowsers">doItEnvironment	^self environment</body><body package="OldBrowsers">explainerClass	^nil</body><body package="OldBrowsers">text	^self selection == nil		ifTrue:			[self selections isEmpty				ifTrue: [nil]				ifFalse: [Text new]]		ifFalse:			[self browser meta value == #data				ifTrue:					[self						templateBinding: self environment						category: self selection]				ifFalse:					[self						templateClass: self environment						category: self selection						type: #none]]</body><body package="OldBrowsers">updateListForDefinedThing: class	module nextModule updateListForDefinedThing: class</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForMultiSelect	^#(#fileOut #hardcopy #add #remove #findClass)</body><body package="OldBrowsers">actionsForNoSelect	^#(#add #findClass)</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addCategory	"Prompt the user for a new category name. Insert the category into 	the class organization before the currently selected category."	| newCategory indx env list association |	self changeRequest ifFalse: [ ^self ].		list := (searchChildNamespaces				ifTrue: 					[self environment withAllNameSpaces						asSortedCollection: [:n1 :n2 | n1 name &lt; n2 name]]				ifFalse: [List with: self environment]).	(association := SmalltalkWorkbench 						promptForCategoryAndNamespace: list 						from: self browser builder window) isNil ifTrue: [^self].	newCategory := association key.	env := association value.	env organization addCategory: newCategory before: self selection.	env reorganize.	indx := module selectionIndex.	indx == nil		ifTrue: [module list list add: (self decorate: newCategory)]		ifFalse: [module list list add: (self decorate: newCategory) beforeIndex: indx].	module		select: newCategory		whenFinished: [module updateList].</body><body package="OldBrowsers">broadcastUpdate: aspect	aspect key == #category		ifTrue: 			[ module hasList				ifTrue: [module select: aspect value whenFinished: [module updateList]]				ifFalse:					[module forceSelection: aspect value.					self setSelection: aspect value.					"module nextModule secondaryObject: aspect value"					]			]		ifFalse: [super broadcastUpdate: aspect]</body><body package="OldBrowsers">fileOut	| fileName fileManager nm |	nm := self selection == nil			ifTrue: [(#Definitions &lt;&lt; #dialogs &gt;&gt; 'Definitions') asString]			ifFalse: [module selection asString].	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr]].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers">findClass	"Prompt for a class and position myself there."	| obj |	obj := self findASomething: (#FindClassColon &lt;&lt; #dialogs &gt;&gt; 'Find class:').	obj == nil ifTrue: [^self].	self changeRequest ifFalse: [^self].	self browser setAndUpdateEnvironment: obj environment.	obj isBindingReference		ifTrue:			[self browser batchUpdates:				[self browser metaShowData.				self browser selectCategory: obj environment category.				self browser selectBehavior: obj environment.				self browser selectProtocol: (obj environment asNameSpace categoryFor: obj name).				self browser selectMethod: obj name]]		ifFalse:			[module				select: obj category				whenFinished:					[module nextModule						select: obj						whenFinished: [module updateList]]]</body><body package="OldBrowsers">hardcopy	"Print the category."		| stream lastItemWasBig first |	stream := TextStream on: (String new: 1000).	lastItemWasBig := false.	first := true.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing || newItemIsBig |					newItemIsBig := thing isBindingReference not.					(first not and: [lastItemWasBig or: [newItemIsBig]])						ifTrue: [stream nextPut: Character newPage].					lastItemWasBig := newItemIsBig.					first := false.					thing printOutOn: stream.					stream cr; cr]].	self hardcopyStream: stream</body><body package="OldBrowsers">remove	self changeRequest ifFalse: [^self].	self selectedThingsWithOrder:			[:definedObjects |			definedObjects size = 0				ifFalse:					[(Dialog confirm: (#AreYouCertainRemoveAllDefinitionsInThisCategoryQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you want to remove all definitions in this category?')							for: self interfaceWindow)						ifFalse: [^self].					definedObjects reverseDo: [:thing | thing removeFromSystem]]].	self selections do: 		[ :category |		( self environmentsForCategory: category ) do:			[ :env | 			env organization removeCategory: category.			env reorganize			]		].	module listSelectionIndexes asSortedCollection reverseDo: 		[ :index | module list list removeAtIndex: index ].	module deselect</body><body package="OldBrowsers">rename	| aString newCategory envlist changed |	self changeRequest ifFalse: [^self].	aString := self prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') initially: self selection.	aString isEmpty ifTrue: [^self].	newCategory := aString asSymbol.	(envlist := self environmentsForCategory: self selection) == nil ifTrue: [^self].	changed := false.	envlist do: 		[:env | 		(env renameCategory: self selection to: newCategory) ifTrue: 			[changed := true]].	changed ifTrue: 		[module list list at: module list selectionIndexes asArray first put: (self decorate: newCategory).		self browser updateText]</body><body package="OldBrowsers">spawn	| envlist |	( envlist := self environmentsForCategory: self selection ) == nil		ifTrue: [ ^self ].	envlist isEmpty 		ifTrue: [ ^self ].	envlist do:		[ :env | self browser spawnOnNameSpaces: env category: self selection ].</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">addClientDataTo: anIdentityDict 	self hasSelections ifFalse: [^false].	anIdentityDict at: #category put: self selection.	anIdentityDict at: #environment put: self environment.	^true</body><body package="OldBrowsers">canAcceptDropFrom: aDC	^aDC key == self classOrNamespaceKey or: [  aDC key == self selectorOrStaticKey]</body><body package="OldBrowsers">drop: aDragContext	"A drop has occured in the category list of the browser. see if we can accept and if so move the class(es)."	| ctrl idx cNameArray |	(self canAcceptDropFrom: aDragContext) ifFalse:[^#dragEffectNone ].	self browser changeRequest ifFalse: [^#dropEffectNone].	"Locate the target category's index"	ctrl := aDragContext clientData at: #ctrl.	idx := ctrl view targetIndex.	idx = 0 ifTrue: [^#dropEffectNone].	"If the data is not available in the correct format, do not drop."	cNameArray := aDragContext sourceData clientData 				at: self classOrNamespaceKey ifAbsent: [^#dropEffectNone].	"Move the class or namspace to the new category"	"The class name is in the clientData of the dropSource"	cNameArray do:[:eachCName | 		eachCName environment classifySymbol: eachCName name under: (self module list list at: idx) value.		ChangeSet changeClass: eachCName ].	"Restore the state of the list before leaving."	self restoreListStateFrom: aDragContext clientData.	aDragContext clientData: nil.	self nextModule updateList.	^#dropEffectMove</body><body package="OldBrowsers">getDragDropKey	"return the data key for the drag"	^self categoryKey</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">allOrganizations	| list env |	list := IdentitySet new: 400.	env := self environment isNil				ifTrue: [Root]				ifFalse: [self environment].	list addAll: env organization categories.	env withAllNameSpaces do: 		[:nameSpace | 		nameSpace bindingsDo:			[:i | i isForClass ifTrue: [list add: i value category]]].	self selection notNil ifTrue:		[list add: self selection].	^list asSortedCollection asList</body><body package="OldBrowsers">environmentsForCategory: aCategory	"Answer all of the environments for aCategory."	| env |	env := self environment.	env == nil ifTrue: [ env := Root ].	searchChildNamespaces		ifFalse: [ ^Array with: env ].	^env withAllNameSpaces select:		[ :ns | ns organization categories includes: aCategory ].</body><body package="OldBrowsers">pickAClass: prompt		"Choose a class or global name with a prompter."	"Prompt the user for a name or pattern.	Answer an empty string if that's what the user returned.	Answer the class, if there is only one class that matches.	If there is more than one class match, prompt the user with a choice		of matches, and return the class selected or an empty string.	If there are no class matches, answer the first global name that		matches, or nil if there are none."	| destClassName classes  |	destClassName := Dialog request: prompt for: self interfaceWindow. 	destClassName = '' ifTrue: [^''].	classes := OrderedCollection new.	Cursor execute showWhile:		[classes := self environment keys select: [ :cn | destClassName match:cn]].		classes := classes asSortedCollection.		(classes == nil or: [classes size = 0])			ifTrue:				[^nil]			ifFalse: 				[classes size = 1					ifTrue: [destClassName := classes first]					ifFalse: [destClassName := Dialog								choose: (#ChooseAClass &lt;&lt; #dialogs &gt;&gt; 'Choose a class')								fromList: classes values: classes								lines: 10 cancel: [^'']								for: self interfaceWindow]].	^destClassName</body><body package="OldBrowsers">selectedNamesDo: aBlock	"For every selected category, within every visible namespace,	evaluate aBlock with the name &amp; environment."	self selections do: 		[ :category |		( self environmentsForCategory: category ) do:			[ :env |			( env organization listAtCategoryNamed: category ) do: 				[ :key | aBlock value: key value: env ].			]		].</body><body package="OldBrowsers">selectedThingsWithOrder: aBlock	| things |	things := OrderedCollection new.	module selections do: 		[ :category |		( self environmentsForCategory: category ) do:			[ :env |  			( env organization listAtCategoryNamed: category ) do: 				[ :key | | thing |				thing := env bindingFor: key.				thing := thing isForGeneral					ifTrue: [BindingReference simpleName: key in: env]					ifFalse: [thing value].				things add: thing ]			]		].	things := SystemUtils sortForLoading: things.	aBlock value: things</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#category</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">generateList	^self searchChildNamespaces		ifTrue: [self allOrganizations]		ifFalse: [self environment organization categories asList]</body><body package="OldBrowsers">selectionChanged	module nextModule == nil ifTrue: [^super selectionChanged].	self setSelection.	self browser updateWindowLabel.	self browser batchUpdates: 		[module nextModule updateList.		module list list isEmpty ifTrue:			[self broadcastUpdate: #classOrNameSpace-&gt;self environment]]</body><body package="OldBrowsers">updateListFull	| newList |	newList := self environment == nil			ifTrue: [self allOrganizations]			ifFalse: [self generateList].	module setNewList: newList</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">searchChildNamespaces	^searchChildNamespaces isNil ifTrue:[searchChildNamespaces := false] ifFalse:[ searchChildNamespaces]</body><body package="OldBrowsers">searchChildNamespaces: aBooleen	searchChildNamespaces := aBooleen</body><body package="OldBrowsers">selectCategory: categoryName	module		select: categoryName asSymbol		whenFinished: [module updateList]</body><body package="OldBrowsers">windowLabel	^module hasList		ifTrue: [(#SystemBrowserOn &lt;&lt; #labels &gt;&gt; 'System Browser on &lt;1p&gt;') expandMacrosWith: self environment]		ifFalse: [(#CategoryBrowserOn1pIn2p &lt;&lt; #labels &gt;&gt; 'Category Browser on &lt;1p&gt; in &lt;2p&gt;')					expandMacrosWith: self selection					with: self environment]</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>templates</category><body package="OldBrowsers">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers">templateClass: nameSpace category: category type: type	^'&lt;1p&gt; defineClass: #&lt;2s&gt;	superclass: #{&lt;3s&gt;}	indexedType: #&lt;4s&gt;	private: false	instanceVariableNames: ''&lt;5s&gt;''	classInstanceVariableNames: ''''	imports: ''''	category: &lt;6p&gt;' 		expandMacrosWithArguments: (OrderedCollection new			add: (nameSpace namedReferent unambiguousName);			add: #NameOfClass &lt;&lt; #browser &gt;&gt; 'NameOfClass';			add: #NameOfSuperclass &lt;&lt; #browser &gt;&gt; 'NameOfSuperclass';			add: type;			add: (type == #bytes				ifTrue: ['']				ifFalse: [(#instVarName1InstVarName2 &lt;&lt; #browser &gt;&gt; 'instVarName1 instVarName2')]);			add: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString]);			yourself)</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">menuHeader	^(#Category &lt;&lt; #menus &gt;&gt; '&amp;Category') asString</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>componentBuilding</category><body package="OldBrowsers">allCategoriesComponent	^SimpleBrowserModule new		helpers: (Array with: (NameSpaceOrganizerBrowserHelper new searchChildNamespaces: true) ).</body><body package="OldBrowsers">allClassesComponent	^SimpleBrowserModule new 		helperType: NameSpaceGlobalCategoryBrowserHelper;		yourself</body><body package="OldBrowsers">buildComponentArray	super buildComponentArray.	self indexOfCategoryCanvas: 1.</body><body package="OldBrowsers">categoriesComponent	^SimpleBrowserModule new		helperType: NameSpaceOrganizerBrowserHelper.</body><body package="OldBrowsers">classHierarchyComponent	^SimpleBrowserModule new		helperType: ClassHierarchyBrowserHelper;		yourself</body><body package="OldBrowsers">classesComponent	^SimpleBrowserModule new 		helperType: NameSpaceCategoryBrowserHelper</body><body package="OldBrowsers">componentId	^#NameSpaceTab</body><body package="OldBrowsers">protocolsComponent	^SimpleBrowserModule new		specName: #listSpecProtocols;		helperType: ProtocolBrowserHelper.</body><body package="OldBrowsers">selectorsComponent	^SimpleBrowserModule new		helperType: SelectorBrowserHelper</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>accessing</category><body package="OldBrowsers">categoriesLabel	^self browser selectedEnvironment notNil		ifTrue: [self categoryTabCanvas selection notNil				ifTrue: [self categoryTabCanvas selection]				ifFalse: [((#x1sCategories &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; Categories')			expandMacrosWith: self browser selectedEnvironment name asString)]]		ifFalse: [(#Categories &lt;&lt; #labels &gt;&gt; 'Categories') asString]</body><body package="OldBrowsers">icon	^icon isNil ifTrue:[ icon := self eraseBackgroundOnImage: (self class folderIcon)] ifFalse:[icon ]</body><body package="OldBrowsers">label	^self browser selectedEnvironment notNil		ifTrue: [((#x1sNameSpace &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; NameSpace')			expandMacrosWith: self browser selectedEnvironment name asString)]		ifFalse: [self class label]</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>accessing subcanvases</category><body package="OldBrowsers">getCanvas	| module |	module := self namespaceHierachyComponent.						 module	browser: self browser.	^module</body><body package="OldBrowsers">namespaceHierachyComponent	^HierarchicalBrowserModule new		helperType: NameSpaceHierarchyBrowserHelper</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>initialize</category><body package="OldBrowsers">initializeForAllNameSpaces	self	browser setNameSpaceFor: #default to: Root.	components := List new.	components add: self allCategoriesComponent.	components add: self allClassesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="OldBrowsers">initializeForClass: aClass	self	browser setNameSpaceFor: #default to: aClass environment.	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	components := List new.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self  browser setClassOrNameSpaceFor: #default to: aClass.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.	components first		forceSelection: aClass;		updateList</body><body package="OldBrowsers">initializeForClass: aClass protocol: aProtocol	self	browser setNameSpaceFor: #default to: aClass environment.	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	components := List new.	components add: self protocolsComponent.	components add: self selectorsComponent.	self  browser setClassOrNameSpaceFor: #default to: aClass.	self	browser setProtocolFor: #default to: aProtocol.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.	components first		forceSelection: aProtocol;		updateList</body><body package="OldBrowsers">initializeForClassHierarchy: aClass	| cls |	self	browser setNameSpaceFor: #default to: aClass environment.	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	cls := aClass instanceBehavior.	self browser	setClassOrNameSpaceFor: #default to: aClass.	components := List new.	components add: self classHierarchyComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.		self browser updateLists.	"self linkFirstComponentToSubcanvas."	components first		selection: cls;		updateList.</body><body package="OldBrowsers">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector	| helper module |	helper := MethodListBrowserHelper new.	helper		label: labelString;		baseList: aCollection;		initialSelection: selector.	module := SimpleBrowserModule new			helpers: (Array with: helper).	components := List new.	components add: module.self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.		self browser updateLists.</body><body package="OldBrowsers">initializeForNameSpace: aNameSpace	components := List new.	self browser	setNameSpaceFor: #default to: aNameSpace.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="OldBrowsers">initializeForNameSpaces	self browser	setNameSpaceFor: #default to: nil.	components := List new.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="OldBrowsers">initializeForNameSpaces: aNameSpace category: aCategory		components := List new.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self browser	setNameSpaceFor: #default to: aNameSpace.	self browser setCategoryFor: #default to: aCategory.	self linkComponentsInArray: components.	self browser updateLists	components first		forceSelection: aCategory;		updateList</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>testing</category><body package="OldBrowsers">isNamspaceTabApp	^true</body></methods><methods><class-id>Tools.NamespaceTabApplication class</class-id> <category>accessing</category><body package="OldBrowsers">label	^(#NameSpaces &lt;&lt; #labels &gt;&gt; 'NameSpaces') asString</body></methods><methods><class-id>Tools.ContextDefinition</class-id> <category>accessing</category><body package="OldBrowsers">context: c	context := c</body><body package="OldBrowsers">implementingClass	^context mclass</body><body package="OldBrowsers">inheritingClass	"Answer the inheritingClass of the receiver's method."	^context receiver class</body><body package="OldBrowsers">method	^context method homeMethod</body><body package="OldBrowsers">selector	^context selector</body><body package="OldBrowsers">sourceCode	^context sourceCode</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addSelectionToParcel	| currentParcel |	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	currentParcel := self currentParcel.	self selectedNamesDo:		[ :name :env | | obj |		( obj := env at: name ) isForClass			ifTrue: [ currentParcel addEntiretyOfClass: obj ]			ifFalse: [ currentParcel addNameSpace: obj ]		].	self browser updateLists</body><body package="OldBrowsers">moveSelectionToParcel: aParcel	"Move the selected category into theParcel according to the current parcel and filtering."	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	self selectedNamesDo:		[ :name :env | | obj |		( obj := env at: name ) isForClass			ifTrue: [ aParcel addEntiretyOfClass: obj ]			ifFalse: [ aParcel addNameSpace: obj ]		].	self browser updateLists.</body><body package="OldBrowsers">removeSelectionFromParcel	| currentParcel |	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	currentParcel := self currentParcel.	self selectedNamesDo:		[ :name :env | | obj |		( obj := env at: name ) isForClass			ifTrue: [ currentParcel removeEntiretyOfClass: obj ]			ifFalse: [ currentParcel removeNameSpace: obj ]		].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">filter: allCategoriesList	| env mgr browser currentParcel usedCategories filteredCategories orgCollection findBindingBlock |	env := self environment isNil ifTrue:[Root] ifFalse:[self environment ].	orgCollection := OrderedCollection new: 100.	self searchChildNamespaces	ifTrue: [ env allNameSpaces do:[:each | orgCollection add: each organization]]	ifFalse:[orgCollection add: env organization ].	findBindingBlock := [:aSymbol | | class | 					class := env at: aSymbol ifAbsent: nil.					class isNil ifFalse:[ env allNameSpaces detect:[:each | | cls| 										cls := env at: aSymbol ifAbsent: nil.										cls isNil ifFalse:[ class := cls. true] ifTrue:[false]] ifNone:[false]]].	mgr := (browser := self browser) manager.	currentParcel := self selectedParcel.	browser isUnparceledFilterOn ifTrue:		[ filteredCategories := OrderedCollection new: 500.		orgCollection do:[:eachOrg | filteredCategories addAll: (allCategoriesList select:			[:cat|			(eachOrg listAtCategoryNamed: cat) contains:				[:cn| browser isUnparceledCodeInClass: (findBindingBlock value: cn) currentParcel: currentParcel]])].			^filteredCategories ].	browser isParcelFilterOn ifFalse: [^allCategoriesList].	browser isConflictsFilterOn ifTrue:		[| conflicts |		conflicts := (browser computeConflictsFor: mgr multiplyParcelledThings						within: (currentParcel notNil ifTrue: [Array with: currentParcel])) last.		usedCategories := conflicts collect: [:class| class category].		^allCategoriesList select: [:cat| usedCategories includes: cat]].	currentParcel == nil ifTrue:		[ filteredCategories := OrderedCollection new: 500.		orgCollection do:[:eachOrg | filteredCategories addAll: (allCategoriesList select:			[:cat|			(eachOrg listAtCategoryNamed: cat) contains:				[:cn| (mgr parcelsForClassOrNameSpace: (findBindingBlock value: cn)) size &gt; 0]])].			^filteredCategories].	usedCategories := IdentitySet new.	usedCategories		addAll: currentParcel definedClasses;		addAll: currentParcel extendedClasses.	usedCategories := usedCategories collect: [:class| class category].	^allCategoriesList select: [:categorySymbol | usedCategories includes: categorySymbol]</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">getListMenu: forMenuBar	| parcels manager |	parcels := IdentitySet new: 16.	manager := self browser manager.	self selections do:		[ :selection | | parcelsOrNil |		parcelsOrNil := manager parcelsForClassOrNameSpace: selection.		nil == parcelsOrNil ifFalse: [ parcels addAll: parcelsOrNil ]		].	^self browser 		addParceling: parcels		to: ( super getListMenu: forMenuBar )		forHelper: self</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">selectCategory: categoryName	module		select: categoryName asSymbol		whenFinished: ["module updateList"]</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers">textEmphasisForItem: anItem	^self emphasizer 		emphasisForCategory: anItem		in: self environment		for: self browser 		id: self selectionId</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">updateListFull	| newList |	newList := self environment == nil			ifTrue: [List new]			ifFalse: [self generateList].	module setNewList: (self filter: newList)</body></methods><methods><class-id>Tools.ParcelEmphasizer</class-id> <category>private-status</category><body package="OldBrowsers">behaviorStatus: aBehavior criteria: aParcel	"Compute the status for a Behavior (class or metaclass)."	| parcels status definedCount extendedCount |	status := Set new: 4.	aBehavior isNil ifTrue: [ ^status "shouldn't happen" ].	parcels := self manager parcelsForClassOrNameSpace: aBehavior.	nil == parcels ifTrue: [ ^status ].	definedCount := extendedCount := 0.	parcels do:		[ :parcel |		( parcel definesClass: aBehavior ) 			ifTrue:				[ definedCount := definedCount + 1.				status add: ( parcel == aParcel ifTrue: [ #defined ] ifFalse: [ #definedByOther ] ).				( parcel == aParcel				and: [((aBehavior isMeta					   or: [aBehavior hasClassPool not])						ifTrue: [true]						ifFalse: [nil == (aBehavior classVarNames											detect: [:cvn| (parcel definesName: cvn in: aBehavior) not]											ifNone: [])])				and: [ | defined selectors |					"This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented selectors."					defined := parcel definedSelectorsFor: aBehavior.					selectors := aBehavior organization elements.					defined size = selectors size				and: [nil == (selectors detect: [:sel| (defined includes: sel) not] ifNone: [])]]]) 						ifTrue: [ status add: #entirelyDefined ] 				].		( parcel extendsBehavior: aBehavior) 			ifTrue:				[ extendedCount := extendedCount + 1.				status add: (parcel == aParcel 					ifTrue: [ #extended ] 					ifFalse: [ #extendedByOther ] )				]		].		( definedCount &gt; 1 	"more than one parcel defines the behavior"				or: [ definedCount + extendedCount &gt; 1 "may be multiply parcelled selectors - go check"				and: [(self computeConflictsFor: ( Array with: aBehavior  ) within: nil) first size &gt; 0]])			ifTrue: [ status add: #conflict ].	^status</body><body package="OldBrowsers">categoryStatus: aCategory  in: environment criteria: aParcel	"Compute the status for aCategory."	| list status definedEntirely |	status := Set new: 4.	environment == nil 		ifTrue: 			[ list := OrderedCollection new.			Root withAllNameSpaces do: 				[ :env | list addAll: ( env organization thingsAtCategoryNamed: aCategory ) ].			]		ifFalse: [ list := ( environment organization thingsAtCategoryNamed: aCategory ) ].	list := list reject:[ :each | each ==nil ].	list isEmpty ifTrue: [ ^status ].	definedEntirely := true.	list do: 		[ :aThing |  | thingStatus |		thingStatus := aThing isForNameSpace			ifTrue: [ self nameSpaceStatus: aThing criteria: aParcel ]			ifFalse:				[ aThing isForClass					ifTrue: [ self classStatus: aThing criteria: aParcel ]					ifFalse: [ #( #entirelyDefined ) ].	"ignore bindings"				].		definedEntirely := definedEntirely and: [ thingStatus includes: #entirelyDefined ].		status addAll: thingStatus		].	definedEntirely ifFalse: [ status remove: #entirelyDefined ifAbsent: nil ].	^status</body><body package="OldBrowsers">classDataStatus: aClass  criteria: aParcel	"Compute the status for a Class's static variables."	| parcels status definedCount names |	status := Set new: 4.	aClass isNil ifTrue: [ ^status "shouldn't happen" ].	names := aClass asNameSpace localBindingNames.	names isEmpty 		ifTrue: [ ( aParcel definesClass: aClass )					ifTrue: [ status add: #entirelyDefined ].		"why?"				^status				].	parcels := self manager parcelsForClassOrNameSpace: aClass.	nil == parcels ifTrue: [ ^status ].	definedCount := 0.	parcels do:		[ :parcel| | defined |		( defined := parcel definedNamesFor: aClass) size &gt; 0 			ifTrue:				[ definedCount := definedCount + 1.				parcel == aParcel					ifTrue:						["This is a performance-critical piece of code since it dominates						 computing category emphases for categories that are entirely						 defined by a Parcel.  Hence there is some effort to optimize						 the comparison of defined and implemented names."						status add: (((parcel definesClass: aClass)									and: [defined size = names size									and: [nil == (names detect: [:name| (defined includes: name) not] ifNone: nil)]])							ifTrue: [#entirelyDefined]							ifFalse: [#defined])]					ifFalse: [status add: #extendedByOther]].	( definedCount &gt; 1 "more than one parcel defines data in aClass"			and: [ (self computeDataConflictsFor: (Array with: aClass) within: nil) first size &gt; 0])		ifTrue:[ status add: #conflict ]].	^status</body><body package="OldBrowsers">classStatus: aClass  criteria: aParcel	"Compute the status for a Class."	| classStatus metaclassStatus entirelyDefined dataStatus |	classStatus := self behaviorStatus: aClass criteria: aParcel.	metaclassStatus := self behaviorStatus: aClass class criteria: aParcel.	dataStatus := self classDataStatus: aClass criteria: aParcel.	entirelyDefined := 		( ( classStatus includes: #entirelyDefined ) and: [ metaclassStatus includes: #entirelyDefined ] )				and: [ dataStatus includes: #entirelyDefined ].	classStatus addAll: metaclassStatus.	classStatus addAll: dataStatus.	entirelyDefined ifFalse: [ classStatus remove: #entirelyDefined ifAbsent: nil ].	^classStatus</body><body package="OldBrowsers">dataKeyStatus: aKey owner: anOwner criteria: aParcel	"Compute the status for a data key in a given class/namespace with respect to 	the parcels in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == anOwner or: [nil == aKey]) ifTrue: [^status].	nil == (parcels := self manager parcelsForClassOrNameSpace: anOwner) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesName: aKey in: anOwner) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers">dataProtocolStatus: aSymbol owner: aClassOrNameSpace criteria: aParcel	"Compute the status for a data protocol in a class."	| thingsInProtocol status parcels |	status := Set new: 4.	nil == aClassOrNameSpace ifTrue: [^status].	thingsInProtocol := aClassOrNameSpace asNameSpace organization listAtCategoryNamed: aSymbol.	( thingsInProtocol isEmpty			or: [nil == (parcels := self manager parcelsForClassOrNameSpace: aClassOrNameSpace)]) 		ifTrue: [ ^status ].	"Assume entirely defined; search for exceptions in the loop below."	(aParcel notNil	and: [parcels includes: aParcel]) ifTrue:		[status add: #entirelyDefined].	thingsInProtocol do:		[:aThing| | count |		count := 0.		parcels do:			[:p|			(p definesName: aThing in: aClassOrNameSpace)				ifTrue:					[count := count + 1.					status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]				ifFalse: [aParcel == p ifTrue: [status remove: #entirelyDefined ifAbsent: nil]]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers">definedThingStatus: anObject  criteria: aParcel	"Compute the status for a Static."	| status definedCount |	status := Set new: 4.	anObject isNil ifTrue: [ ^status "shouldn't happen"].	definedCount := 0.	self manager parcels do:		[ :parcel |		( parcel definesObject: anObject) 			ifTrue:				[ definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				( parcel == aParcel) 					ifTrue: [ status add: #entirelyDefined ]				]		].	(definedCount &gt; 1 "more than one parcel defines the behavior") ifTrue:		[status add: #conflict].	^status</body><body package="OldBrowsers">methodProtocolStatus: aSymbol class: aClass criteria: currentParcel	"Compute the status for a message protocol in a class."	| selectorsInProtocol status parcels |	status := Set new: 4.	nil == aClass ifTrue: [^status].	selectorsInProtocol := aClass organization listAtCategoryNamed: aSymbol.	(selectorsInProtocol isEmpty	or: [nil == (parcels := self manager parcelsForClassOrNameSpace: aClass)]) ifTrue:		[^status].	"Assume entirely defined; search for exceptions in the loop below."	(currentParcel notNil	and: [parcels includes: currentParcel]) ifTrue:		[status add: #entirelyDefined].	selectorsInProtocol do:		[:aSelector| | count |		count := 0.		parcels do:			[:p|			(p definesSelector: aSelector forClass: aClass)				ifTrue:					[count := count + 1.					status add: (currentParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]				ifFalse: [currentParcel == p ifTrue: [status remove: #entirelyDefined ifAbsent: nil]]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers">nameSpaceStatus: anObject  criteria: aParcel	"Compute the status for a NameSpace."	| status definedCount |	status := Set new: 4.	anObject isNil ifTrue: [ ^status "shouldn't happen"].	definedCount := 0.	self manager parcels do:		[ :parcel |		( parcel definesObject: anObject) 			ifTrue:				[ definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				( parcel == aParcel) 					ifTrue: [ status add: #entirelyDefined ]				]		].	(definedCount &gt; 1 "more than one parcel defines the behavior") ifTrue:		[status add: #conflict].	^status</body><body package="OldBrowsers">selectorStatus: aSelector class: aClass  criteria: aParcel 	"Compute the status for a selector in a given classwith respect to the parcels	 in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == aClass or: [nil == aSelector]) ifTrue: [^status].	nil == (parcels := self manager parcelsForClassOrNameSpace: aClass) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesSelector: aSelector forClass: aClass) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body></methods><methods><class-id>Tools.ParcelEmphasizer</class-id> <category>private</category><body package="OldBrowsers">computeConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a triple of a Set of MethodDefinitions identifying all methods that are	 multiply parcelled, a Set of statics that are multiply parcelled, and a Set	 of classes that either contain multiply parcelled methods or are themselves	 multiply parcelled.  If aSetOfParcelsOrNil is non-nil then only include conflicts	 that are parcelled within aSetOfParcels	 Express the triple as an Array, method definitions first, bindings next, classes last."	| methods bindings classes |	methods := Set new: 64.	bindings := IdentitySet new: 8.	classes := IdentitySet new: 4.	aSetOfClasses do:		[:class| | parcels |		(parcels := self manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[| instanceSelectorBag classSelectorBag staticBag classBag |			instanceSelectorBag := Bag identityNew: 32.			classSelectorBag := Bag identityNew: 32.			staticBag := Bag identityNew: 4.			classBag := Bag identityNew: 2.			parcels do:				[:parcel|				(parcel definesClass: class) ifTrue: [classBag add: class].				instanceSelectorBag addAll: (parcel definedSelectorsFor: class).				classSelectorBag addAll: (parcel definedSelectorsFor: class class).				staticBag addAll: (parcel definedBindingsFor: class)].			instanceSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class selector: sel)]].			classSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class class selector: sel)]].			classBag valuesAndCountsDo:				[:clss :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[classes add: class]].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding.						classes add: class]]]].	^Array with: methods with: bindings with: classes</body><body package="OldBrowsers">computeDataConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a Set of statics that are multiply parcelled	return and Array with a Set of statics that have conflicts"	| bindings |	bindings := IdentitySet new: 8.	aSetOfClasses do:		[:class| | parcels |		(parcels := self manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[|  staticBag  |			staticBag := Bag identityNew: 4.			parcels do:				[:parcel|				staticBag addAll: (parcel definedBindingsFor: class)].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding]]]].	^Array with: bindings</body><body package="OldBrowsers">currentCriteria: aBrowser id: selectionId	"Answer what we are highlighting based on."		^aBrowser selectedParcelFor: selectionId</body><body package="OldBrowsers">manager	^Parcel</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>accessing</category><body package="OldBrowsers">components	^self tabApplication systemBrowserComponents</body><body package="OldBrowsers">components: aList	self tabApplication components: aList.	self linkComponents</body><body package="OldBrowsers">currentTabApplication	"for sideways compatibility."	^tabApplication</body><body package="OldBrowsers">currentTabApplication: aTabApplication	"for sideways compatibility."	self tabApplication: aTabApplication</body><body package="OldBrowsers">tabApplication	^tabApplication</body><body package="OldBrowsers">tabApplication: aBrowserTabApplication	tabApplication := aBrowserTabApplication</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>delagating</category><body package="OldBrowsers">doesNotUnderstand: aMessage	"this delegates anything I don't understand to the current tab application.	this is so that behavour normally needed to be sent to the browser can be offloaded to the BrowserTabApplication. Thismakes adding Tab Applications that don't step on each other easier."	| tabApp |	tabApp := self tabApplication.	((tabApp) respondsTo: aMessage selector) ifFalse:		[^super doesNotUnderstand: aMessage].	^tabApp perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>initialize</category><body package="OldBrowsers">initialize	inBatchMode := false.	text := String new asValue.	meta := #instance asValue.	meta onChangeSend: #updateProtocolLists to: self.	defType := #showDefinition asValue.	defType onChangeSend: #updateText to: self.	toolBar := nil asValue.	selectionDictionary := IdentityDictionary new.	"self  initializeForNameSpace: Smalltalk."</body><body package="OldBrowsers">initializeForAllNameSpaces	self ignoreNamepaceChanges: true.	self tabApplication initializeForAllNameSpaces.	self setNameSpaceFor: #default to: Smalltalk.</body><body package="OldBrowsers">initializeForClass: aClass	self tabApplication initializeForClass: aClass</body><body package="OldBrowsers">initializeForClass: aClass protocol: aProtocol	self tabApplication initializeForClass: aClass protocol: aProtocol</body><body package="OldBrowsers">initializeForClassHierarchy: aClass	self tabApplication initializeForClassHierarchy: aClass</body><body package="OldBrowsers">initializeForMethodsLabel: labelString list: aCollection initialSelection: selectorself tabApplication initializeForMethodsLabel: labelString list: aCollection initialSelection: selector</body><body package="OldBrowsers">initializeForNameSpace: aNameSpace	self tabApplication initializeForNameSpace: aNameSpace</body><body package="OldBrowsers">initializeForNameSpacesself tabApplication initializeForNameSpaces</body><body package="OldBrowsers">initializeForNameSpaces: aNameSpace category: aCategory	self tabApplication initializeForNameSpaces: aNameSpace category: aCategory</body><body package="OldBrowsers">release	self tabApplication release.	super release</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>private</category><body package="OldBrowsers">linkComponents	1 to:  self components size-1 do: [:i |		(components at: i)			browser: self;			nextModule: ((i+1) &gt; components size ifTrue:[nil] ifFalse:[ components at: i+1])].	self components last browser: self.	self updateLists</body><body package="OldBrowsers">numberOfLists	| n |	n := coordinator == nil		ifTrue: [0]		ifFalse: [coordinator numberOfLists].	^self components inject: n into: [:i :comp | i + comp numberOfLists]</body><body package="OldBrowsers">tryAll: testBlock default: defaultBlock	self components reverseDo:		[:comp | | val |		val := testBlock value: comp.		val == nil ifFalse: [^val]].	^defaultBlock value</body><body package="OldBrowsers">visibleComponentAt: index	| n |	n := 0.	coordinator == nil		ifFalse:			[n := n + coordinator numberOfLists.			n &gt;= index ifTrue: [^coordinator]].	self components do: [:comp |		n := n + comp numberOfLists.		n &gt;= index ifTrue: [^comp]].	^self error: ((#Component1pNotFound &lt;&lt; #dialogs &gt;&gt; 'Component &lt;1p&gt; not found') expandMacrosWith: index)</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>components</category><body package="OldBrowsers">menuBar	| menu |	menu := Menu new		addPart: self class menuBarStart.	coordinator == nil ifFalse: [coordinator buildMenuBar: menu].	self components do: [:comp | comp buildMenuBar: menu].	menu addPart: self class menuBarEnd.	(menu atNameKey: #edit) submenu: self remoteTextMenu.	(menu atNameKey: #view) submenu: [self viewMenu].	^menu</body><body package="OldBrowsers">resetToolBar	| menu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildToolBar: menu].	self components do: [:comp | comp buildToolBar: menu].	toolBar value: menu</body><body package="OldBrowsers">viewMenu	| menu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildViewMenu: menu].	self components do: [:comp | comp buildViewMenu: menu].	^menu</body><body package="OldBrowsers">windowLabel	^self components isEmpty		ifTrue: [(#SystemBrowser &lt;&lt; #labels &gt;&gt; 'System Browser')]		ifFalse: [self components first windowLabel]</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>actions</category><body package="OldBrowsers">module: moduleName action: action	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator perform: action].	self components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers">module: moduleName action: action with: value	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator dispatch: action with: value].	self components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action with: value]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers">truePerformerFor: moduleName	"Answer the module that is responsible for performing menu 	actions for moduleName. Answer the receiver if none."	( coordinator notNil and: [ coordinator menuHeader = moduleName ] )		ifTrue: [ ^coordinator ].	self components do: 		[ :comp |		comp menuHeader = moduleName			ifTrue: [ ^comp ]		].	^nil</body><body package="OldBrowsers">updateLists	self tabApplication components isEmpty		ifFalse: [self tabApplication components first updateList]</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>interface opening</category><body package="OldBrowsers">postOpenWith: aBuilder 	"Make current selection visible."	super postOpenWith: aBuilder.	tabApplication components first checkVisibility</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>selection utlity</category><body package="OldBrowsers">selectBehavior: aBehaviorself currentTabApplication selectBehavior: aBehavior</body><body package="OldBrowsers">selectCategory: aCategoryself currentTabApplication selectCategory: aCategory</body><body package="OldBrowsers">selectMethod: aSymbolself currentTabApplication  selectMethod: aSymbol</body><body package="OldBrowsers">selectProtocol: aProtocolself currentTabApplication selectProtocol: aProtocol</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>spawning</category><body package="OldBrowsers">spawnForMethodsLabel: aLabel list: list initialSelection: selection 	self currentTabApplication		spawnForMethodsLabel: aLabel		list: list		initialSelection: selection		with: self currentTabApplication</body><body package="OldBrowsers">spawnOnClass: aClass	self currentTabApplication spawnOnClass: aClass with: self currentTabApplication</body><body package="OldBrowsers">spawnOnClass: aClass protocol: aSelection	self currentTabApplication spawnOnClass: aClass with: self currentTabApplication protocol: aSelection</body><body package="OldBrowsers">spawnOnClassHierarchy: aClass	self currentTabApplication spawnOnClassHierarchy: aClass with: self currentTabApplication</body><body package="OldBrowsers">spawnOnNameSpace:  aNamespace	self currentTabApplication 		spawnOnNameSpace: aNamespace 		with: self currentTabApplication</body><body package="OldBrowsers">spawnOnNameSpaces: aNamespace category: aCategory  	self currentTabApplication 		spawnOnNameSpace: aNamespace 		with: self currentTabApplication 		category: aCategory</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>change</category><body package="OldBrowsers">updateButtonLabels	self	updateMajorTabsListFor: self currentTabApplication</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>text processing</category><body package="OldBrowsers">updateText	| sel tv |	text value: (self tryAll: [:c | c text] default: [Text new]) asText addHyperlinkEmphases.	(sel := self tabApplication components first initialSelection) == nil		ifFalse: [builder == nil			ifFalse:				[tv := (builder componentAt: #text) widget.				tv deselect.				tv controller find: sel.				tv displaySelection: true.				tv selectAndScroll]]</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser class</class-id> <category>application configuration</category><body package="OldBrowsers">allButOpenOnClass: aClass	^self openOnClass: aClass with: NamespaceTabApplication</body><body package="OldBrowsers">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector with: aBrowserTabApplicationClass 	| inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	inst tabApplication: aBrowserTabApplication;		initializeForMethodsLabel: labelString		list: aCollection		initialSelection: selector.	aCollection size = 1		ifTrue: 			[inst components first forceSelection: aCollection first.			inst updateLists].	^inst open</body><body package="OldBrowsers">initializeForNamespacesWith: aBrowserTabApplicationClass | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForAllNameSpaces;		open.</body><body package="OldBrowsers">openOnAllNameSpaces		"self openOnAllNameSpaces"	^self initializeForNamespacesWith:  NamespaceTabApplication.</body><body package="OldBrowsers">openOnClass: aClass	^self openOnClass: aClass with: NamespaceTabApplication</body><body package="OldBrowsers">openOnClass: aClass with: aBrowserTabApplicationClass		"self openOnClass: self"	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForClass: aClass;		open.</body><body package="OldBrowsers">openOnClass: aClass with: aBrowserTabApplicationClass protocol: aSelection		"self openOnClass: self"	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForClass: aClass protocol: aSelection;		open.</body><body package="OldBrowsers">openOnClassHierarchy: aClass 		^self openOnClassHierarchy: aClass with: NamespaceTabApplication</body><body package="OldBrowsers">openOnClassHierarchy: aClass with: aBrowserTabApplicationClass		"self openOnClassHierarchy: self"	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst		tabApplication: aBrowserTabApplication;		initializeForClassHierarchy: aClass;		open.</body><body package="OldBrowsers">openOnNameSpace: aNameSpace with: aBrowserTabApplicationClass	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForNameSpace: aNameSpace;		open.</body><body package="OldBrowsers">openOnNameSpace: aNameSpace with: aBrowserTabApplicationClass on: aCategory	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForNameSpaces: aNameSpace category: aCategory ;		open.</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addBinding	self browser parcelDefType value: #parcelDefintion.	super addBinding.</body><body package="OldBrowsers">addClassBytes	self browser parcelDefType value: #parcelDefintion.	super addClassBytes.</body><body package="OldBrowsers">addClassFixedSize	self browser parcelDefType value: #parcelDefintion.	super addClassFixedSize.</body><body package="OldBrowsers">addClassVariableSize	self browser parcelDefType value: #parcelDefintion.	super addClassVariableSize.</body><body package="OldBrowsers">addNameSpace	self browser parcelDefType value: #parcelDefintion.	super addNameSpace.</body><body package="OldBrowsers">addSelectionToParcel	| obj |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	obj := self selection.	obj isForClass		ifTrue: [ self currentParcel addEntiretyOfClass: obj ]		ifFalse: [ self currentParcel addObject: obj ].	self browser updateLists</body><body package="OldBrowsers">moveNewParcel	| newName currentParcel obj |	self changeRequest ifFalse: [^self].	newName := Dialog						request: (#EnterNameForNewParcel &lt;&lt; #dialogs &gt;&gt; 'Enter name for the new parcel')						initialAnswer: ''						onCancel: [nil].	newName := self browser manager normalizedNameFor: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(self browser manager parcelNamed: newName) notNil ifTrue:		[Dialog warn: (#parcelExists &lt;&lt; #dialogs &gt;&gt; 'A parcel with this name already exists').		^self].	(currentParcel := self browser manager createParcelNamed: newName) == nil ifTrue:		[^self].	obj := self selection.	obj isForClass		ifTrue: [ currentParcel addEntiretyOfClass: obj ]		ifFalse: 	[ currentParcel addObject: obj ].	self browser updateParcelLists.	self module selection: currentParcel</body><body package="OldBrowsers">removeSelectionFromParcel	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	self selection isForClass		ifTrue: [self currentParcel					removeEntiretyOfClass: self selection ]		ifFalse:	[self currentParcel					removeNameSpace: self selection ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">enhance: menu for: md submenu: nameKey subMenuName: aName	| item |	item := menu atNameKey: nameKey.	item isNil ifTrue: [^self].	((nameKey == #moveNewParcel  )) ifTrue: [item enable ; hidden: false].</body><body package="OldBrowsers">getListMenu: forMenuBar	|  selection menu |	menu := super getListMenu: forMenuBar.	selection := ( self selection == nil or: [ self selection isSymbol ] )		ifTrue: [ #() ]		ifFalse: [ self selection ].	self enhance: menu for: self selection submenu:  #moveNewParcel   subMenuName: (#NewParcel &lt;&lt; #menus &gt;&gt; 'New Parcel') .	^self browser 		addParceling: ( self browser manager parcelsForClassOrNameSpace: selection )		to: (menu)		forHelper: self</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">decorate: item	| type | 	type := nil.	item class  name == #Parcel ifTrue:[type := #parcel]	ifFalse:[item isForNameSpace		ifTrue: [type := #nameSpace]].	^#{Tools.BrowserListEntry} value value: item type: type</body><body package="OldBrowsers">filter: ClassNameSpaceList	"Compute the list of things for the selected category.  Things are either	 classes  or nameSpaces.	 If the isInParcel filter is on and there is no selected parcel	 then display all classes in the category."	| browser currentParcel manager |	browser := self browser.	manager := browser manager.	currentParcel := self currentParcel.	browser isUnparceledFilterOn ifTrue:		[ ^ClassNameSpaceList select:			[ :obj |			obj isForClass				ifTrue: [browser isUnparceledCodeInClass: obj  currentParcel: currentParcel]				ifFalse:  [browser isUnparceledCodeInNameSpace: obj ]			]		].	browser isParcelFilterOn ifFalse: [^ClassNameSpaceList].	browser isConflictsFilterOn ifTrue:		[| conflicts |		conflicts := browser 						computeConflictsFor: ClassNameSpaceList 						within: (currentParcel notNil ifTrue: [Array with: currentParcel]).		conflicts := conflicts last collect: [:class| class fullName].		^ClassNameSpaceList select: [:obj| conflicts includes: obj fullName]].	currentParcel isNil ifTrue:		[^ClassNameSpaceList select:			[:ea| | |			(manager parcelsForClassOrNameSpace: ea ) size &gt; 0]].	^ClassNameSpaceList select:		[ :obj | 		obj isForClass  			ifTrue: [currentParcel definesOrExtendsClass: obj ]			ifFalse: [currentParcel definesObject: obj]		]</body><body package="OldBrowsers">nonMetaClass	"Answer the class that is currently selected (nil if none), even	if looking at the metaClass."	| classOrNil |	classOrNil := self selection.	(self isMeta and: [classOrNil notNil])		ifTrue: [classOrNil := classOrNil instanceBehavior].	^classOrNil</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">intializeListFull	| newList |	"why no filtering with no category?"	self category == nil ifTrue: [ ^super updateListFull ].	newList := (self generateListFull asSortedCollection: [ :a :b | a name &lt; b name ]) asList.	module setNewListSilently: ( self filter: newList )</body><body package="OldBrowsers">updateListFull	| newList |	newList := (self generateListFull asSortedCollection: [ :a :b | a name &lt; b name ]) asList.	module setNewList: ( self filter: newList )</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>Parcel actions</category><body package="OldBrowsers">moveSelectionToParcel: aParcel 	"Move the selected class into theParcel according to the current 	parcel and filtering. A Namespace move is not currently implemented."	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	self selection isForClass		ifTrue: [ self browser moveBehaviors: (Set with: self nonMetaClass with: self nonMetaClass class)				toParcel: aParcel ]		ifFalse: [ Dialog warn: (#NotImplemented &lt;&lt; #dialogs &gt;&gt; 'Not implemented.') ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers">textEmphasisForItem: anItem	anItem isSymbol ifTrue:[ ^Set new ].	^self emphasizer emphasisForClassOrNameSpace: anItem for: self browser id: selectionId.</body></methods><methods><class-id>Tools.ParcelNameSpaceGlobalCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">generateListFull	| env newList  |	env := self environment.	newList := env == nil		ifTrue: 			[ newList := Root withAllNameSpacesAndAllClasses ]		ifFalse:			[ self category == nil 				ifTrue: [Root withAllNameSpacesAndAllClasses]				ifFalse: [  newList := Root withAllNameSpacesAndAllClasses select:[:each | each category = self category].						].].	^newList.</body></methods><methods><class-id>Tools.ParcelNameSpaceGlobalCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">textForItem: aListEntry	^aListEntry displayString asText</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: aText from: aController 	"Recompile the method of the selected context."	| classOfMethod newSelector newMethod context selector |	context := self selection.	context == nil ifTrue: [^ false].	selector := (self definitionOf: context) selector.	classOfMethod := context mclass.	newSelector := classOfMethod parserClass new parseSelector: aText.	newSelector ~~ selector		ifTrue: [self notify: (#SelectorMustNotChange &lt;&lt; #dialogs &gt;&gt; 'selector must not change')].	Cursor execute showWhile:		[newSelector := classOfMethod				compile: aText				classified: ClassOrganizer defaultProtocol				notifying: aController].	newSelector == nil ifTrue: [^ false].	Cursor execute showWhile:		[newMethod := classOfMethod compiledMethodAt: newSelector.		self replaceContext: context forSelector: newSelector class: classOfMethod].	^ true</body><body package="OldBrowsers">replaceContext: context forSelector: selector class: aClass	| newMethod newContext pHandle |	pHandle := self browser processHandle.	newMethod := aClass compiledMethodAt: selector.	newContext := self homeContext: context.	pHandle cutbackTo: newContext.	newContext := newContext resizedWith: newMethod.	pHandle topContext: newContext.	pHandle interrupted: true.	module select: newContext whenFinished: [ module updateList ].</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForNoSelect	^#(#moreStack #proceed #copyStack)</body><body package="OldBrowsers">getListMenu: forMenuBar	| menu |	menu := super getListMenu: forMenuBar.	(menu atNameKey: #moreStack) enabled: self showsEverything not.	^menu</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">copyStack	^self browser copyStack</body><body package="OldBrowsers">moreStack	"If showing a short stack, expand the stack to include twice as many contexts."	self showsEverything		ifFalse: 			[stackSize := stackSize * 2].	module updateList</body><body package="OldBrowsers">proceed	^self browser proceed</body><body package="OldBrowsers">restart	^self browser restart</body><body package="OldBrowsers">send	^self browser send</body><body package="OldBrowsers">skipToCaret	^self browser skipToCaret</body><body package="OldBrowsers">step	^self browser step</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>testing</category><body package="OldBrowsers">isTopContextSelected	^module list selectionIndex = 1</body><body package="OldBrowsers">showsEverything	^stackSize = SmallInteger maxVal</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>initialize</category><body package="OldBrowsers">initialize	super initialize.	stackSize := 50</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">updateListFull	| ctxts c n |	self browser processHandle == nil		ifTrue: [^module setNewList: List new].	ctxts := List new: 100.	c := self browser processHandle topContext.	n := 0.	[c == nil or: [(n := n+1) &gt; stackSize]]		whileFalse:			[ctxts add: c.			c := c sender].	c == nil ifTrue: [stackSize := SmallInteger maxVal].	module setNewList: ctxts</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">definitionOf: aContext	^ContextDefinition new context: aContext</body><body package="OldBrowsers">homeContext: context	| method ctx |	context isBlockContext ifTrue: 		[method := context method homeMethod.		ctx := context sender.		[ctx == nil] whileFalse: 				[ctx method == method ifTrue: [^ctx].				ctx := ctx sender].		self error: (#BlockHomeNotOnStack &lt;&lt; #dialogs &gt;&gt; 'Unable to restart: block''s home context not on the current process''s stack.')].	^context</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#context</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">listMenu	| menu |	menu := self baseListMenu.	(menu atNameKey: #send) enablementSelector: #isTopContextSelected.	^menu</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">listMenuName	^#contextMenu</body><body package="OldBrowsers">menuHeader	^(#_Debug &lt;&lt; #menus &gt;&gt; '&amp;Debug') asString</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>initialize</category><body package="OldBrowsers">browser: aBrowser	browser := aBrowser</body><body package="OldBrowsers">forceSelection: aSelection	forcedValue := aSelection.	self setSelection: aSelection</body><body package="OldBrowsers">helper: aHelper	aHelper module: self.	helpers := List with: aHelper.</body><body package="OldBrowsers">helperType: aClass	self helpers: (Array with: aClass new)</body><body package="OldBrowsers">helpers: aList	helpers := aList.	aList do: [:i | i module: self].</body><body package="OldBrowsers">initialize	list := self allowsMultiSelect			ifTrue: [MultiSelectionInList new]			ifFalse: [SelectionInList new].	list selectionIndexHolder onChangeSend: #selectionChanged to: self.	specName := self defaultSpecName.	deselectNext := true</body><body package="OldBrowsers">nextModule: module	nextModule := module</body><body package="OldBrowsers">specName: name	specName := name</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>list accessing</category><body package="OldBrowsers">checkVisibility	| indices listView |	self builder == nil ifTrue: [^self].	indices := self listSelectionIndexes asArray.	listView := (builder componentAt: #list) widget.	indices size = 1 ifTrue: [listView makeVisible: indices first].	"Complete kludge to get around lists that have been scrolled.	 This sort of nonsense won't happen in Pollock or new tools."	listView		fixScrollingOffset;		invalidate</body><body package="OldBrowsers">deselect	self allowsMultiSelect		ifTrue: [list selectionIndexes: Set new]		ifFalse: [list selectionIndex: 0]</body><body package="OldBrowsers">list	^list</body><body package="OldBrowsers">postFilter: decoratedList	| hasType |	hasType := decoratedList inject: false into: [:b :ent | b or: [ent type notNil]].	hasType		ifTrue:			[decoratedList do: [:ent |				ent type == nil ifTrue: [ent type: #normal]]]</body><body package="OldBrowsers">select: selection whenFinished: updateBlock	selectionCandidates := Set with: (self decorate: selection).	updateBlock ensure: [selectionCandidates := nil]</body><body package="OldBrowsers">selectAll: selections whenFinished: updateBlock	selectionCandidates := selections asSet collect:			[:selection | self decorate: selection].	updateBlock ensure: [selectionCandidates := nil]</body><body package="OldBrowsers">selection	| sels |	sels := self listSelections.	^sels size = 1		ifTrue: [sels asArray first value]		ifFalse: [nil]</body><body package="OldBrowsers">selection: aValue	self allowsMultiSelect		ifTrue: [self list selections: (Set with: (self decorate: aValue))]		ifFalse: [self list selection: (self decorate: aValue)]</body><body package="OldBrowsers">selectionChanged	list selectionIndexHolder  retractInterestsFor: self.	[self currentHelper selectionChanged]		ensure: [list selectionIndexHolder onChangeSend: #selectionChanged to: self].	^self</body><body package="OldBrowsers">selectionIndex	| indx |	indx := self listSelectionIndexes.	^indx size = 1		ifTrue: [indx asArray first]		ifFalse: [nil]</body><body package="OldBrowsers">selections	^self listSelections collect: [:i | i value]</body><body package="OldBrowsers">setNewList: newList	| decoratedList |	decoratedList := newList collect: [:item | self decorate: item].	self postFilter: decoratedList.	self allowsMultiSelect		ifTrue: [list setList: decoratedList selecting: (selectionCandidates == nil					ifTrue: [list selections asSet]					ifFalse: [selectionCandidates asSet])]		ifFalse: [list setList: decoratedList selecting: (selectionCandidates == nil					ifTrue: [list selection]					ifFalse: [selectionCandidates asArray first])].	self checkVisibility</body><body package="OldBrowsers">setNewListSilently: t1 	| t2 |	list selectionIndexHolder retractInterestsFor: self.	t2 := t1 collect: [:t3 | self decorate: t3].	self postFilter: t2.	self allowsMultiSelect		ifTrue: [list setList: t2 selecting: (selectionCandidates == nil					ifTrue: [list selections asSet]					ifFalse: [selectionCandidates asSet])]		ifFalse: [list setList: t2 selecting: (selectionCandidates == nil					ifTrue: [list selection]					ifFalse: [selectionCandidates asArray first])].	self checkVisibility.	list selectionIndexHolder onChangeSend: #selectionChanged to: self.	^self</body><body package="OldBrowsers">updateList	^forcedValue == nil		ifTrue: [self currentHelper updateListFull]		ifFalse:			[self select: forcedValue				whenFinished: [self setNewList: (List with: forcedValue)]].</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>drag and drop</category><body package="OldBrowsers">addControllerDataTo: dict	"Answer the initial state of the list when a drag has begun within its 	bounds. The state will be used to re-establish the appearance of the list when 	a drag leaves."	|  ctrl |	ctrl := (self builder componentAt: #list) widget controller.	dict at: #ctrl put: ctrl.	dict at: #targetIndex put: ctrl view targetIndex.	dict at: #hasFocus put: ctrl view hasFocus.	ctrl view hasFocus: true.	^dict</body><body package="OldBrowsers">canAcceptDropFrom: aDC 	"Answer true if a drop can occur in the category list of a normal browser. Only 	accept drops from the same application for now."	aDC data contextApplication == self browser ifFalse:[^false].	^self currentHelper canAcceptDropFrom: aDC</body><body package="OldBrowsers">doDrag: aController	"Ask the helper to do the drag"	self currentHelper doDrag: aController</body><body package="OldBrowsers">dragEnter: aDragContext 	^self currentHelper dragEnter: aDragContext</body><body package="OldBrowsers">dragLeave: aDragContext ^self currentHelper dragLeave: aDragContext</body><body package="OldBrowsers">dragOver: aDragContext 	^self currentHelper dragOver: aDragContext</body><body package="OldBrowsers">drop: aDragContext	"A drop has occurred in the category list of a normal brower.	If the drop contained a class, move the class to the category targetted.	If the drop contained a category, the user has aborted a category	drag. Do nothing."^self currentHelper drop: aDragContext"	^#dropEffectNone"</body><body package="OldBrowsers">initialListDropState	"Answer the initial state of the list when a drag has begun within its 	bounds. The state will be used to re-establish the appearance of the list when 	a drag leaves."	| dict ctrl |	ctrl := (self builder componentAt: #list) widget controller.	dict := IdentityDictionary new.	dict at: #ctrl put: ctrl.	dict at: #targetIndex put: ctrl view targetIndex.	dict at: #hasFocus put: ctrl view hasFocus.	ctrl view hasFocus: true.	^dict</body><body package="OldBrowsers">restoreListStateFrom: aDictionary 	"Reset the state of the list"	| ctrl |	ctrl := aDictionary at: #ctrl.	ctrl view targetIndex: (aDictionary at: #targetIndex).	ctrl view hasFocus: (aDictionary at: #hasFocus)</body><body package="OldBrowsers">showDropFeedbackFor: aDragContext 	self showDropFeedbackForList: #list in: aDragContext</body><body package="OldBrowsers">showDropFeedbackForList: aSymbol in: aDragContext 	"Track the mouse with the target index while dragging in the list named 	aSymbol."	| wrap |	wrap := self builder componentAt: aSymbol.	wrap isNil 		ifFalse: [wrap widget showDropFeedbackIn: aDragContext allowScrolling: true]</body><body package="OldBrowsers">wantToDrag: aController	"ask the helper if he wants to drag"	^self currentHelper wantToDrag: aController</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>private-emphasis</category><body package="OldBrowsers">setVisualBlocksWith: aBuilder	"Set visual blocks to be used to determine the emphassis for list entries.	 Default implementation is to set-up the selected and unselected visual blocks."	| component |	(component := aBuilder componentAt: #list) isNil ifTrue: [^self].	component widget		visualBlock: self visualBlock;		selectedVisualBlock: self selectedVisualBlock</body><body package="OldBrowsers">textEmphasisForItem: anItem	^self currentHelper textEmphasisForItem: anItem</body><body package="OldBrowsers">textForItem: aListEntry	^self currentHelper textForItem: aListEntry</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>release</category><body package="OldBrowsers">release	super release.	list selectionIndexHolder removeDependent: self.	list selectionIndexHolder retractInterestsFor: self.	list list:#().	self cachedComponents notNil		ifTrue: [ self cachedComponents do: [ :ea | ea release ] ].	self browser: nil.</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>private-list</category><body package="OldBrowsers">howManySelections	^self listSelectionIndexes size</body><body package="OldBrowsers">listSelectionIndexes	^self allowsMultiSelect		ifTrue: [list selectionIndexes]		ifFalse: [list selectionIndex = 0				ifTrue: [Set new]				ifFalse: [Set with: list selectionIndex]]</body><body package="OldBrowsers">listSelectionIndexes: aSet	^self allowsMultiSelect		ifTrue: [list selectionIndexes: aSet]		ifFalse: [aSet size &gt; 1 ifTrue: [self error: (#TooManySelections &lt;&lt; #dialogs &gt;&gt; 'too many selections')].				list selectionIndex: (aSet size = 0 ifTrue: [0] ifFalse: [aSet asArray first])]</body><body package="OldBrowsers">listSelections	^self allowsMultiSelect		ifTrue: [list selections]		ifFalse: [list selectionIndex = 0				ifTrue: [OrderedCollection new]				ifFalse: [OrderedCollection with: list selection]]</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>private</category><body package="OldBrowsers">changeRequest	^browser changeRequest</body><body package="OldBrowsers">decorate: item	^self currentHelper decorate: item</body><body package="OldBrowsers">doesNotUnderstand: aMessage	^aMessage arguments size = 0		ifTrue: [ self dispatch: aMessage selector ]		ifFalse: 			[ aMessage arguments size = 1				ifTrue: [ self dispatch: aMessage selector with: aMessage arguments first ]				ifFalse: [ super doesNotUnderstand: aMessage ]			].</body><body package="OldBrowsers">enable: itemName on: menu	menu == nil ifTrue: [^false].	menu menuItems do: [:it |		it nameKey = itemName			ifTrue:				[it enable.				self menu: it submenu do: [:i | i enable].				^true].		(self enable: itemName on: it submenu)			ifTrue: [it enable]].	^false</body><body package="OldBrowsers">fileEncoding	^browser fileEncoding</body><body package="OldBrowsers">hardcopyStream: aStream	Cursor wait		showWhile: 			[aStream contents asComposedText hardcopy]</body><body package="OldBrowsers">interfaceWindow	^browser interfaceWindow</body><body package="OldBrowsers">listBrowserClass	^#{Tools.FullSystemBrowser} value</body><body package="OldBrowsers">logProtocolChange: aString	"Add aString, which is an executable account of the last protocol change (rename,	remove, selector move) to the changes file."	SourceFileManager default logChange: aString</body><body package="OldBrowsers">menu: menu do: aBlock	menu == nil ifTrue: [^self].	menu menuItems do: [:it |		aBlock value: it.		it submenu == nil			ifFalse: [self menu: it submenu do: aBlock]]</body><body package="OldBrowsers">methodCollector	^browser methodCollector</body><body package="OldBrowsers">prompt: promptString initially: initialString	"Prompt the user with the message question promptString, with initial 	answer initialString, and accept the answer either with the menu 	item accept or the keyboard press RETURN. Answer the string that 	the user provides."	^Dialog 		request: promptString		initialAnswer: initialString		for: self interfaceWindow</body><body package="OldBrowsers">selectedVisualBlock	"Supply the block that determins the appearance for selected list entries."	^[ :view :index | | aText anItem listEntry label |	   listEntry :=  view sequence at: index.	   anItem := listEntry value.	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).  	   (label:= listEntry displayLabel: aText) attributes: view textStyle; offset: label offset.	   label:= ReversingWrapper on: label.	   label reverse setValue: true.	   BoundedWrapper on: label]</body><body package="OldBrowsers">visualBlock	"Supply the block that determins the appearance for unselected list entries."	^[:view :index | | aText anItem listEntry label |	   listEntry := view sequence at: index.	   anItem := listEntry value.	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).	   (label := listEntry displayLabel: aText) attributes: view textStyle; offset: label offset.	   BoundedWrapper on: label]</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>menus accessing</category><body package="OldBrowsers">buildMenuBar: aMenu	| item |	item := MenuItem labeled: self menuHeader.	item submenu: [self getListMenu: true].	aMenu addItem: item</body><body package="OldBrowsers">buildToolBar: aMenu	self currentHelper buildToolBar: aMenu</body><body package="OldBrowsers">buildViewMenu: aMenu	self currentHelper buildViewMenu: aMenu</body><body package="OldBrowsers">dispatch: selector	^self currentHelper perform: selector</body><body package="OldBrowsers">dispatch: selector with: arg	^self currentHelper perform: selector with: arg</body><body package="OldBrowsers">getListMenu: forMenuBar	^self currentHelper getListMenu: forMenuBar</body><body package="OldBrowsers">listMenu	^[self getListMenu: false]</body><body package="OldBrowsers">menuHeader	"This doesn't change when the helper changes, so	we bind it to the first one."	^helpers first menuHeader</body><body package="OldBrowsers">module: mName action: action with: arg	self dispatch: action with: arg</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>accessing</category><body package="OldBrowsers">allowsMultiSelect	allowsMultiSelect == nil		ifTrue: [ allowsMultiSelect := true ].	^allowsMultiSelect.</body><body package="OldBrowsers">allowsMultiSelect: aBoolean	^allowsMultiSelect := aBoolean</body><body package="OldBrowsers">browser	^browser</body><body package="OldBrowsers">cachedComponents	^cachedComponents</body><body package="OldBrowsers">cachedComponents: aCollection	cachedComponents := aCollection</body><body package="OldBrowsers">currentHelper	"Subclasses may choose another helper based on context."	^helpers at: 1</body><body package="OldBrowsers">defaultSpecName	^self allowsMultiSelect		ifTrue: [ #listSpec ]		ifFalse: [ #listSpecSingleSelect ].</body><body package="OldBrowsers">deselectNextModuleOnReselect	^deselectNext</body><body package="OldBrowsers">deselectNextModuleOnReselect: aBoolean	deselectNext := aBoolean == true</body><body package="OldBrowsers">helpers	^helpers</body><body package="OldBrowsers">initialSelection	^self currentHelper initialSelection</body><body package="OldBrowsers">listSpec	^self class interfaceSpecFor: self specName</body><body package="OldBrowsers">nextModule	^nextModule</body><body package="OldBrowsers">numberOfLists	^forcedValue == nil ifTrue: [1] ifFalse: [0]</body><body package="OldBrowsers">selectedEnvironment	^browser selectedNameSpaceFor: #default</body><body package="OldBrowsers">specName	^specName</body><body package="OldBrowsers">windowLabel	^self currentHelper windowLabel</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>validating</category><body package="OldBrowsers">currentSubCanvas	^self</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>actions</category><body package="OldBrowsers">broadcastUpdate: aspect	self currentHelper broadcastUpdate: aspect</body><body package="OldBrowsers">intializeListFull	self currentHelper intializeListFull</body><body package="OldBrowsers">spawnBrowser	"Trigger the 'spawn' action, via a double-click.	If there are more than one types of spawning,	this may not necessarily be the same as the	'spawn' menu item."	self spawn</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>testing</category><body package="OldBrowsers">hasList	^forcedValue == nil</body><body package="OldBrowsers">testChangeSelection: controller	^self changeRequest</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	"Indicate that we didn't even try."	^self currentHelper acceptText: text from: textController</body><body package="OldBrowsers">doItEnvironment	^self currentHelper doItEnvironment</body><body package="OldBrowsers">doItReceiver	^self currentHelper doItReceiver</body><body package="OldBrowsers">explainFor: aController 	"Try to shed some light on what kind of entity the controller's	current selection is. 	The selection must be a single token or construct."	| targetClass selector |	(targetClass := self currentHelper explainerClass) == nil 		ifTrue: [targetClass := UndefinedObject].	(selector := self currentHelper selector) == nil ifTrue: [^self].	Explainer 		explain: aController selection string		class: targetClass		selector: selector		methodText: self text		for: self</body><body package="OldBrowsers">explainSpecial: string for: explainer	"Answer with a string explaining the code view selection if it is 	displaying one of the special edit functions."	^self currentHelper explainSpecial: string for: explainer</body><body package="OldBrowsers">formatFor: aController	self currentHelper formatFor: aController</body><body package="OldBrowsers">text	^self currentHelper text</body><body package="OldBrowsers">updateListForDefinedThing: class	^self currentHelper updateListForDefinedThing: class</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>templates</category><body package="OldBrowsers">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers">templateNameSpace: nameSpace category: category	^'&lt;1s&gt; defineNameSpace: #&lt;2s&gt;	private: false	imports: ''			&lt;3s&gt;.*			private Smalltalk.*			''	category: &lt;4p&gt;'		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfPool &lt;&lt; #browser &gt;&gt; 'NameOfPool'		with: #OtherNameSpace &lt;&lt; #browser &gt;&gt; 'OtherNameSpace'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>updating</category><body package="OldBrowsers">updateForSwapOut</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>copying</category><body package="OldBrowsers">postCopy	| old |	super postCopy.	builder := browser := nextModule := nil.	helpers := helpers collect: [:i | i copy module: self].	old := list.	list := self allowsMultiSelect			ifTrue: [MultiSelectionInList new]			ifFalse: [SelectionInList new].	list list: old list copy.	self allowsMultiSelect		ifTrue: [list selectionIndexes: old selectionIndexes copy]		ifFalse: [list selectionIndex: old selectionIndex].	list selectionIndexHolder onChangeSend: #selectionChanged to: self.</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>interface opening</category><body package="OldBrowsers">postBuildWith: aBuilder	self setVisualBlocksWith: aBuilder</body></methods><methods><class-id>Tools.SimpleBrowserModule class</class-id> <category>interface specs</category><body package="OldBrowsers">preferredSpec	^self listSpec</body><body package="OldBrowsers">preferredSpecName	^#listSpec</body></methods><methods><class-id>Tools.SimpleBrowserModule class</class-id> <category>instance creation</category><body package="OldBrowsers">multiSelect	"Answer an instance of the receiver set to multiple selection."	^self basicNew		allowsMultiSelect: true;		initialize;		yourself.</body><body package="OldBrowsers">singleSelect	"Answer an instance of the receiver set to single selection."	^self basicNew		allowsMultiSelect: false;		initialize;		yourself.</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>accessing</category><body package="OldBrowsers">allowsMultiSelect	^false</body><body package="OldBrowsers">defaultSpecName	^#listSpec</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>list accessing</category><body package="OldBrowsers">currentNodeSelection	^list currentNodeSelection</body><body package="OldBrowsers">selection: aValue	self allowsMultiSelect		ifTrue: [self list selections: (Set with: ( aValue))]		ifFalse: [ self list selection: ( aValue)]</body><body package="OldBrowsers">setNewList: newList 	| decoratedList |	decoratedList := newList.	list		setTree: decoratedList		selecting: (selectionCandidates == nil					ifTrue: [list selection]					ifFalse: [selectionCandidates asArray first])		childAccessor: #sortedChildren		childNameAccessor: #key.	self checkVisibility</body><body package="OldBrowsers">setNewListSilently: aList	| newlist |	newlist := aList.	 list selectionIndexHolder  retractInterestsFor: self.	list		setTree: newlist		selecting: (selectionCandidates == nil				ifTrue: [list selection]				ifFalse: [selectionCandidates asArray first])		childAccessor: #sortedChildren		childNameAccessor: #key.	self checkVisibility.	list selectionIndexHolder onChangeSend: #selectionChanged to: self.	^self</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>actions</category><body package="OldBrowsers">doubleClick	"Expand/collapse the current selection."	self list toggleCurrent</body><body package="OldBrowsers">setPresetWidthTo: anInteger	self builder isNil ifTrue:[^self].	(self builder componentAt: #list ) widget presetWidth: anInteger</body><body package="OldBrowsers">spawnBrowser	"Since this is a hierachy check first to see if we have some thing selected that is spawnable.	Trigger the 'spawn' action, via a double-click.	If there are more than one types of spawning,	this may not necessarily be the same as the	'spawn' menu item.""	self halt."	self selection isSymbol ifTrue:[self list toggleCurrent  ].	self spawn</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>initialize</category><body package="OldBrowsers">initialize	list := IndentedTreeSelectionInList newEmptyInstance."	list := self allowsMultiSelect			ifTrue: [MultiSelectionInList new]			ifFalse: [SelectionInList new]."	list selectionIndexHolder onChangeSend: #selectionChanged to: self.	specName := self defaultSpecName</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>private-emphasis</category><body package="OldBrowsers">postBuildWith: aBuilder	super postBuildWith: aBuilder. 	self setPresetWidthTo: 500</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>copying</category><body package="OldBrowsers">postCopy	| old |	super postCopy.	builder := browser := nextModule := nil.	helpers := helpers collect: [:i | i copy module: self].	old := list.		list := IndentedTreeSelectionInList new.	list list: old list copy.	self allowsMultiSelect		ifTrue: [list selectionIndexes: old selectionIndexes copy]		ifFalse: [list selectionIndex: old selectionIndex].	list selectionIndexHolder onChangeSend: #selectionChanged to: self.</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>release</category><body package="OldBrowsers">release	self breakDependents.	self releaseEventTable	list selectionIndexHolder removeDependent: self.	list selectionIndexHolder retractInterestsFor: self.	self cachedComponents notNil		ifTrue: [ self cachedComponents do: [ :ea | ea release ] ].	self browser: nil.</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>private</category><body package="OldBrowsers">selectedVisualBlock	"Supply the block that determins the appearance for selected list entries."	^[ :view :index | | aText anItem listEntry label |	   listEntry :=  view sequence at: index.	   anItem := listEntry .	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).  	   (label:= Label with: listEntry ) attributes: view textStyle; offset: label offset.	   label:= ReversingWrapper on: label.	   label reverse setValue: true.	   BoundedWrapper on: label]</body><body package="OldBrowsers">visualBlock	"Supply the block that determins the appearance for unselected list entries."	^[:view :index | | aText anItem listEntry label |	   listEntry := view sequence at: index.	   anItem := listEntry .	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).	   (label := Label with: listEntry ) attributes: view textStyle; offset: label offset.	   BoundedWrapper on: label]</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>testing</category><body package="OldBrowsers">testChangeSelection: controller 	self changeRequest ifFalse: [^false].	nextModule == nil 		ifTrue: [self list selectionIndexes: Set new]		ifFalse: [nextModule list selectionIndexes: Set new].	^true</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	"Indicate that we didn't even try."	^self selection == nil		ifTrue: [nil]		ifFalse: [self acceptDefinition: text from: textController]</body><body package="OldBrowsers">text	| item |	^( item := self  selectedNameSpace ) == nil		ifTrue: [ Text new ]		ifFalse: 	[ item definition  asText ]</body><body package="OldBrowsers">updateListForDefinedThing: thing	thing isForNameSpace ifTrue:[self module updateList].	self module selection: (thing isForNameSpace ifTrue:[thing] ifFalse:[thing environment]).	module nextModule updateListForDefinedThing: thing</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForMultiSelect	^#()</body><body package="OldBrowsers">actionsForNoSelect	^#(#find)</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addBinding	| env cat |	( env:= self  selectedNameSpace ) == nil		ifTrue: [ env := Smalltalk ].	cat := self category.	self browser defType value: #showDefinition.	module nextModule nextModule deselect.	"next module is categories...."	self browser text value: 		( self templateBinding: env category: cat )</body><body package="OldBrowsers">addClassBytes	"Display a template for adding a class of type bytes."	self addClassType: #bytes</body><body package="OldBrowsers">addClassFixedSize	"Display a template for adding a class of type fixed size (none)."	self addClassType: #none</body><body package="OldBrowsers">addClassVariableSize	"Display a template for adding a class of type bytes."	self addClassType: #objects</body><body package="OldBrowsers">addNameSpace	| env cat |	( env:= self  selectedNameSpace ) == nil		ifTrue: [ env := Smalltalk ].	cat := self category.	self browser defType value: #showDefinition.	module nextModule nextModule deselect.	"next module is categories...."	self browser text value: 		( self templateNameSpace: env category: cat )</body><body package="OldBrowsers">fileOut	| fileName fileManager nm |	nm := self selection == nil			ifTrue: [(#Definitions &lt;&lt; #dialogs &gt;&gt; 'Definitions') asString]			ifFalse: [self selection name asString].	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr]].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers">find	"Prompt for a name and position myself there."	| obj |	self changeRequest ifFalse: [^self].	obj := self findASomething: (#FindC &lt;&lt; #labels &gt;&gt; 'Find:').	obj == nil ifTrue: [^self].	obj isBindingReference		ifTrue:			[self browser batchUpdates:				[self browser metaShowData.				obj environment environment isNil					ifTrue: [self module setSelection: nil]					ifFalse: [self module selection: obj environment environment].				self browser selectCategory: obj environment category.				self browser selectBehavior: obj environment.				self browser selectProtocol: (obj environment asNameSpace categoryFor: obj name).				self browser selectMethod: obj name]]		ifFalse: 			[self module selection: obj environment.			module nextModule				select: obj category				whenFinished:					[module nextModule nextModule						select: obj						whenFinished: [module nextModule updateList]]]</body><body package="OldBrowsers">moveTo	| newSpace |	newSpace := NameSpaceNavigator				searchFrom: self defaultEnvironment				label: (#MoveToWhichEnvironmentQ &lt;&lt; #dialogs &gt;&gt; 'Move to which environment?').	newSpace == nil		ifTrue: [^self].	module selections do: 		[ :sel | sel relocateTo: newSpace].	module updateList</body><body package="OldBrowsers">remove	"Prompt the user to remove the namespace.  Answer if the namespace was removed or not."	| bindings parentEvironment| 	self changeRequest ifFalse: [^false].	bindings := module selections asArray collect:				[:nm | | ref |				(ref := ((BindingReference simpleName: nm name) home: nm environment)) isDefined					ifTrue: [ref]					ifFalse:						[Dialog warn: ((#CantRemoveObject1sNoLongerExists &lt;&lt; #dialogs &gt;&gt; 'Can''t remove the object. &lt;1s&gt; no longer exists.')										expandMacrosWith: nm asString)							for: self interfaceWindow.						nil]].	bindings := bindings copyWithout: nil.	bindings isEmpty ifTrue: [^false].	bindings := SystemUtils sortForLoading: bindings.	bindings reverseDo:		[:varRef |		(Dialog confirm: ((#DoYouWantToRemove1sQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you&lt;n&gt;want to remove &lt;1s&gt;?')					expandMacrosWith: varRef asString)				for: self interfaceWindow)			ifTrue: 				[(varRef subrequisites size = 0					or: [Dialog confirm: ((#HasDependentObjectsRemoveItAnywayQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dependent objects. Remove it anyway?')									expandMacrosWith: varRef asString)							for: self interfaceWindow])					ifTrue: [parentEvironment := varRef environment.							varRef removeFromSystem. 							module updateListFull.]]].self browser setAndUpdateEnvironment: parentEvironment. module list toggleSelection.		^false</body><body package="OldBrowsers">renameAs	| aString newName |	self changeRequest ifFalse: [^self].	aString := self				prompt: (#EnterNewName &lt;&lt; #dialogs &gt;&gt; 'Enter new name')				initially: self selection  name asString.	aString = '' ifTrue: [^self].	aString := SystemUtils validateStaticVariableName: aString					for: self interfaceWindow.	aString == nil ifTrue: [^self].	newName := aString asSymbol.	SmalltalkWorkbench		rename: module selection 		to: newName 		do: [:cls :nm | module select: cls whenFinished: [module updateList]]		for: self interfaceWindow		browser: self browser</body><body package="OldBrowsers">spawn	self selectionIsSymbol ifTrue: [^self].	self selectionIsClass ifTrue: [^super spawn].	self selectionIsNamespace ifTrue: 		[self browser spawnOnNameSpace: module selection]</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">addCategoryTreeToTree: aTree	| categoryTree |	categoryTree :=  AssociationTreeWithParent key: (#Categories &lt;&lt; #dialogs &gt;&gt; 'Categories') value: #category.	aTree addChild: categoryTree.</body><body package="OldBrowsers">addChildNamespace: aNamespace to: namespaceTree	aNamespace bindingsDo:[:var | |namespaceChild | 									var isForNameSpace ifTrue:[									namespaceChild := (AssociationTreeWithParent key: var value name value: var value).								  namespaceTree addChild: namespaceChild.									self addChildNamespace: var value to: namespaceChild.]].</body><body package="OldBrowsers">addNamespaceTreeToTree: aTree	| namespaceTree |	namespaceTree :=  AssociationTreeWithParent key: 'Root' value:  Root.	aTree addChild: namespaceTree.	self addChildNamespace: Root to: namespaceTree.</body><body package="OldBrowsers">addParcelNamespaceTreeToTree: aTree	| namespaceTree |	namespaceTree :=  AssociationTreeWithParent key: (#Namespaces &lt;&lt; #dialogs &gt;&gt; 'Namespaces') value:  #parcelNamespaces.	aTree addChild: namespaceTree.	self addChildNamespace: Root to: namespaceTree.</body><body package="OldBrowsers">addParcelTreeToTree: aTree	| parcelTree |	parcelTree :=  AssociationTreeWithParent key: (#Parcels &lt;&lt; #dialogs &gt;&gt; 'Parcels') value: #parcels.	aTree addChild: parcelTree.	Parcel parcels do:				[ :each | | parcelChild | 		parcelChild := AssociationTreeWithParent key: each listEntry value: each.		parcelTree addChild: parcelChild.			self addParcelNamespaceTreeToTree: parcelChild.		].</body><body package="OldBrowsers">currentNodeSelection	^module currentNodeSelection</body><body package="OldBrowsers">getEnvironmentForSelection		(self currentNodeSelection == nil	or: [self currentNodeSelection parent == nil])		ifTrue: [ ^nil ].	self selectionIsParcel ifTrue:[ ^self environment ].	self selectionIsNamespace ifTrue:[ ^self selection ].	^self environment</body><body package="OldBrowsers">intializeListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	self addParcelTreeToTree: tree.	self addCategoryTreeToTree: tree.	module setNewListSilently: tree</body><body package="OldBrowsers">selectedItem	| thing |	thing := self selection .	(self selectionIsClass and: [self browser meta value == #class])		ifTrue: [thing := thing class].	^thing</body><body package="OldBrowsers">selectionChanged	module nextModule == nil ifTrue: [^super selectionChanged].	self browser		batchUpdates:			[ | env |			env := self getEnvironmentForSelection.			self setSelection: env.  			module nextModule currentHelper searchChildNamespaces: env isNil.			module nextModule updateList.			self browser				updateWindowLabel;				updateButtonLabels]</body><body package="OldBrowsers">selectionIsClass	^(self selection notNil  and:[ self selection isSymbol not])		and: [self selection binding isForClass]</body><body package="OldBrowsers">selectionIsDefined	^(self selection notNil and:[ self selection isSymbol not]) and: [self selection binding isForGeneral not]</body><body package="OldBrowsers">selectionIsNames	^(self selection notNil and:[ self selection isSymbol not])		and: [self selection binding isForClass		or: [self selection binding isForNameSpace]]</body><body package="OldBrowsers">selectionIsNamespace	^(self selection notNil  and:[ self selection isSymbol not])		and: [self selection isNameSpace]</body><body package="OldBrowsers">selectionIsParcel	^(self selection notNil  and:[ self selection isSymbol not])		and: [self selection class name == #Parcel]</body><body package="OldBrowsers">selectionIsSymbol	^self selection isSymbol</body><body package="OldBrowsers">updateListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	self addParcelTreeToTree: tree.	self addCategoryTreeToTree: tree.	module setNewList: tree</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>templates</category><body package="OldBrowsers">addClassType: type	"Display a template for adding a class of type type."	| env cat |	( env:= self  selectedNameSpace ) == nil		ifTrue: [ env := Smalltalk ].	cat := self  category.	self browser defType value: #showDefinition.	module nextModule nextModule deselect.	"next module is categories...."	self browser text value: 		( self templateClass: env category: cat type: type )</body><body package="OldBrowsers">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers">templateClass: nameSpace category: category type: type	^'&lt;1p&gt; defineClass: #&lt;2s&gt;	superclass: #{&lt;3s&gt;}	indexedType: #&lt;4s&gt;	private: false	instanceVariableNames: ''&lt;5s&gt;''	classInstanceVariableNames: ''''	imports: ''''	category: &lt;6p&gt;' 		expandMacrosWithArguments: (OrderedCollection new			add: (nameSpace namedReferent unambiguousName);			add: #NameOfClass &lt;&lt; #browser &gt;&gt; 'NameOfClass';			add: #NameOfSuperclass &lt;&lt; #browser &gt;&gt; 'NameOfSuperclass';			add: type;			add: (type == #bytes				ifTrue: ['']				ifFalse: [(#instVarName1InstVarName2 &lt;&lt; #browser &gt;&gt; 'instVarName1 instVarName2')]);			add: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString]);			yourself)</body><body package="OldBrowsers">templateNameSpace: nameSpace category: category	^'&lt;1s&gt; defineNameSpace: #&lt;2s&gt;	private: false	imports: ''			&lt;3s&gt;.*			private Smalltalk.*			''	category: &lt;4p&gt;'		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfPool &lt;&lt; #browser &gt;&gt; 'NameOfPool'		with: #OtherNameSpace &lt;&lt; #browser &gt;&gt; 'OtherNameSpace'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">canAcceptDropFrom: aDC	^false</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#environment</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">defaultEnvironment	^Smalltalk</body><body package="OldBrowsers">selectedThingsWithOrder: aBlock	| things |	things := OrderedCollection new.	things add: self selection.	things addAll: (self selection allClasses ).	things addAll: (self selection allNameSpaces ).	things := SystemUtils sortForLoading: things.	aBlock value: things</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">selectedNameSpace	^self  selection == nil		ifTrue: [ nil ]		ifFalse: 			[ self selection isSymbol				ifTrue: [ Root ]				ifFalse: [ self selection ]			  ]</body><body package="OldBrowsers">windowLabel	^(#NameSpaceHierarchyBrowserOn1p &lt;&lt; #dialogs &gt;&gt; 'NameSpaceHierarchy Browser on &lt;1p&gt;') expandMacrosWith: self selection value</body></methods><methods><class-id>Tools.HierarchyBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">menuHeader	^(#Namespace &lt;&lt; #menus &gt;&gt; '&amp;Namespace') asString</body></methods><methods><class-id>Tools.BlankUI</class-id> <category>aspects</category><body package="OldBrowsers">blankList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blankList isNil		ifTrue:			[blankList := SelectionInList new]		ifFalse:			[blankList]</body><body package="OldBrowsers">specName	^self class preferredSpecName</body></methods><methods><class-id>Tools.BlankUI</class-id> <category>responding</category><body package="OldBrowsers">buildMenuBar: menu	"here so we can respond but do nothing with any menu."</body><body package="OldBrowsers">menuHeader^nil</body></methods><methods><class-id>Tools.BlankUI class</class-id> <category>interface specs</category><body package="OldBrowsers">preferredSpecName	^#windowSpec</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>initialize</category><body package="OldBrowsers">baseList: aList	baseList := aList</body><body package="OldBrowsers">initialSelection: aString	initialSelection := aString</body><body package="OldBrowsers">label: aLabel	label := aLabel</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">remove	"Override to remember the nearest selection"	| indices listSize max min choice result |	indices := module listSelectionIndexes.	listSize := module list list size.	(indices isEmpty	or: [indices size = listSize]) ifTrue: [^super remove].	indices := indices asSortedCollection.	min := indices first.	max := indices last.	choice := max - min + 1 &gt; indices size "must be an interior unselected element, use the first one as the next selection"				ifTrue:					[| priorEntries interior |					 priorEntries := 0. "Count of how many selections before the first interior unselected element"					 interior := (min to: max) detect: [:n| priorEntries := priorEntries + 1. (indices at: n - min + 1) ~= n].					interior - priorEntries]				ifFalse:					[max &lt; listSize						ifTrue: [min] "after removals min is the index of the entry after last selection"						ifFalse: [min - 1]]. "no entries after last; choose one before first removal"	(result := super remove) ifTrue:		[module listSelectionIndexes: (Set with: choice)].	^result</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">definitionOf: anItem	^anItem</body><body package="OldBrowsers">updateListFull	baseList := baseList select: [:md | md isBindingReference ifTrue:[true] ifFalse:[md method notNil]].	module setNewList: (List withAll: baseList)</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">initialSelection	^initialSelection</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">targetClass	"Answer the browsers currently selected class."	^self selection implementingClass</body><body package="OldBrowsers">targetClassOrNameSpace	"Answer the browsers currently selected class, namespace or classes namespace."	^self selection isBindingReference		ifTrue: [ self selection environment asNameSpace ]		ifFalse: [ self targetClass ]</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">windowLabel	^label == nil		ifTrue: [(#Methods &lt;&lt; #dialogs &gt;&gt; 'Methods')]		ifFalse: [label]</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: text from: textController	| selection newSelector newMethod  |	(selection := self selection) isBindingReference ifTrue: [^nil].	selection isNil ifTrue: 		[Dialog warn: (#SelectMethodAsExampleForNewMethod &lt;&lt; #dialogs &gt;&gt; 'Select a method first. The new method will belongto the same class and protocol as the selected one.').		textController textHasChanged: true.		^false].	newSelector := selection implementingClass				compile: text				classified: selection protocol				notifying: textController.	newSelector == nil ifTrue: [^false].	newMethod := MethodDefinition					class: selection implementingClass					selector: newSelector.	(baseList includes: newMethod) ifFalse: [baseList add: newMethod].	module		select: newMethod		whenFinished: [module updateList].	^true</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>accessing</category><body package="OldBrowsers">action	^action</body><body package="OldBrowsers">doAction	self perform: action value</body><body package="OldBrowsers">finalSelection	^list selection == nil		ifTrue: [path selection == nil			ifTrue: [home value]			ifFalse: [path selection value]]		ifFalse: [list selection value]</body><body package="OldBrowsers">home	^home</body><body package="OldBrowsers">list	^list</body><body package="OldBrowsers">openSelection	list selection == nil		ifTrue: [path selection == nil			ifTrue: []			ifFalse: [home value: path selection value]]		ifFalse: [home value: list selection value]</body><body package="OldBrowsers">path	^path</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>searching</category><body package="OldBrowsers">addList: model lines: maxLines validation: valid	| height layout field grid font scrollW max fullMax |	height := builder window displayBox height.	layout := LayoutFrame new.	layout leftOffset: 16.	layout rightFraction: 1 offset: -16.	layout topOffset: height.	field := SequenceViewSpec model: model menu: nil layout: layout.	field selectionType: #normalSelection.	builder add: field.	builder wrapper widget controller setDispatcher:		(UIDispatcher new doubleClick: [valid value ifTrue: [self doubleClickList]]).	builder wrapper widget setValidTargetIndex: model selectionIndex.	scrollW := builder wrapper decorator scrollerComponent.	scrollW preferredBoundsBlock:				[:sw | | rect |				rect := sw component preferredBounds						translatedBy: sw translation.				rect height: maxLines*sw scrollGrid y.				rect].	font := builder wrapper widget textStyle defaultFont.	font := Screen default defaultFontPolicy findFont: font.	max := model list inject: 0 into: [:i :str | i max: str size].		"Instead of exactly measuring every string, we		assume that $o will be a fairly representative		character.  Actually, $o will probably be wider		than the average, but this will usually be OK."	max := (font widthOf: $o) * max.		"Don't let the dialog get too wide."	fullMax := 350.	max &gt; fullMax		ifTrue:			[max := fullMax.			builder wrapper decorator useHorizontalScrollBar.			builder wrapper widget measureWidth: true].	grid := builder wrapper preferredBounds height.	layout bottomOffset: height+grid.	self addGap: grid.	self minWidth: max + 48.	^builder wrapper</body><body package="OldBrowsers">addNoCloseLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean	| num maxButtonWidth maxButtonHeight separation buttonWAs buttonWidth window box layout left top actualColumns actualRows |	num := labels size.	maxButtonWidth := 0.	maxButtonHeight := 0.	separation := 20.	buttonWAs := OrderedCollection new.	window := builder window.	box := window displayBox.	actualColumns := SmallInteger maxVal min: labels size.	actualRows := (num + actualColumns - 1) // actualColumns.	"We have to create and place the buttons before we can ask them their	preferred bounds and refine their spacing."	layout := LayoutFrame new.	layout		leftFraction: 0.5;		rightFraction: 0.5.	builder newComposite.	1 to: num		do: 			[:index |			| lbl val buttonSpec buttonW bExt |			lbl := labels at: index.			val := values at: index.			(buttonSpec := ActionButtonSpec						model: (result == nil ifTrue: [val] ifFalse: [[result value: val]])						label: lbl						layout: (0 @ 0 extent: 1 @ 1))				defaultable: (values includes: defaultValue);				isDefault: val == defaultValue.			builder add: buttonSpec.			buttonW := builder wrapper.			(takeKeyboard and: [val == defaultValue])				ifTrue: [builder keyboardProcessor setActive: buttonW widget controller].			maxButtonWidth := maxButtonWidth max: (bExt := buttonW preferredExtent) x.			maxButtonHeight := maxButtonHeight max: bExt y.			buttonWAs add: buttonW -&gt; bExt].	buttonWidth := eqBoolean				ifTrue: [actualColumns * maxButtonWidth + ((actualColumns - 1) * separation)]				ifFalse: 					[buttonWAs inject: separation negated						into: [:x :assoc | x + assoc value x + separation]].	layout		topOffset: box height;		bottomOffset: box height + (actualRows * maxButtonHeight).	layout		leftOffset: 0 - ((buttonWidth + 1) // 2);		rightOffset: (buttonWidth + 1) // 2.	builder endCompositeLayout: layout.	left := 0.	top := 0.	1 to: num		do: 			[:index |			| bttnWA width |			bttnWA := buttonWAs at: index.			width := eqBoolean ifTrue: [maxButtonWidth] ifFalse: [bttnWA value x].			bttnWA key newLayout: (Rectangle						left: left						right: left + width						top: top						bottom: top + maxButtonHeight) asLayout.			index \\ actualColumns = 0				ifTrue: 					[left := 0.					top := top + maxButtonHeight]				ifFalse: [left := left + width + separation]].	self addGap: maxButtonHeight * actualRows.	buttonWidth := buttonWidth + separation.	self minWidth: buttonWidth.	^builder wrapper</body><body package="OldBrowsers">doubleClickList	list selection == nil		ifTrue: [path selection == nil			ifFalse: [home value: path selection value]]		ifFalse: [home value: list selection value].</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>initialize</category><body package="OldBrowsers">initialize	super initialize.	home := nil asValue.	home onChangeSend: #updateList to: self.	action := nil asValue.	action onChangeSend: #doAction to: self.	list := SelectionInList new.	path := SelectionInList new.	list selectionIndexHolder onChangeSend: #maybeNoPath to: self.	path selectionIndexHolder onChangeSend: #maybeNoList to: self.</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>updating</category><body package="OldBrowsers">maybeNoList	path selectionIndex = 0		ifTrue: [(list selectionIndex = 0 and: [path list size ~= 0])			ifTrue: [path selectionIndex: path list size]]		ifFalse: [list selectionIndex: 0]</body><body package="OldBrowsers">maybeNoPath	list selectionIndex = 0		ifTrue: [path list size = 0			ifFalse: [path selection: path list last]]		ifFalse: [path selectionIndex: 0]</body><body package="OldBrowsers">updateList	| vars newPath |	vars := SortedCollection new.	home value bindingsDo: [:var |		var isForNameSpace			ifTrue: [vars add: var]].	list list: vars asList.	newPath := List with: home value.	[newPath first environment == nil]		whileFalse: [newPath addFirst: newPath first environment].	newPath := newPath collect: [:env | #{Tools.BrowserListEntry} value new value: env].	1 to: newPath size do: [:i |		(newPath at: i) offset: i-1*12@0].	path list: newPath.	path selection: newPath last</body></methods><methods><class-id>Tools.NameSpaceNavigator class</class-id> <category>searching</category><body package="OldBrowsers">searchFrom: aNameSpace label: label	"NameSpaceNavigator searchFrom: Smalltalk			label: 'Move to which environment?' "	| sd spec listW buttons |	sd := self new.	sd home value: aNameSpace.	spec := (sd class interfaceSpecFor: #emptySpec).	sd builder add: spec window.	sd builder add: spec component.	sd setInitialGap.	sd addMessage: label centered: true. 	sd addGap: 8.	sd		addList: sd path		lines: 4		validation: [sd path selectionIndex &gt; 0].	sd addGap: 8.	listW := sd			addList: sd list			lines: 8			validation: [sd list selectionIndex &gt; 0].	listW widget setValidTargetIndex: sd list selectionIndex.	sd addGap: 4.	buttons := sd addOK: [true].	sd addGap: 15.	sd addNoCloseLabels: (Array with: (#Open &lt;&lt; #dialogs &gt;&gt; 'Open'))		values: #(#openSelection)		default: nil		storeInto: sd action		takeKeyboard: true		equalize: true.	sd addGap: 6.	sd bottomAlignLowerEdge: listW.	sd bottomAlign: (Array with: buttons).	sd preOpen.	sd builder openDialogWithExtent: sd builder window displayBox extent.	^sd accept value		ifTrue: [sd finalSelection]		ifFalse: [nil]</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">baseClass	baseClass == nil		ifTrue: [ baseClass := self targetClass ].	^baseClass.</body><body package="OldBrowsers">baseClass: aClass	^baseClass := aClass</body><body package="OldBrowsers">windowLabel	^(#HierarchyBrowserOn1p &lt;&lt; #labels &gt;&gt; 'Hierarchy Browser on &lt;1p&gt;') expandMacrosWith: self baseClass</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">decorate: item	| thing |	thing := super decorate: item.	thing offset: (self nesting: item)@0.	^thing</body><body package="OldBrowsers">generateHierarchy	| newList |	newList := List new.	self generateSuper: self baseClass into: newList.	self generateSubs: self baseClass into: newList.	^newList</body><body package="OldBrowsers">generateSubs: cls into: newList	| subs |	cls == nil ifTrue: [^self].	subs := cls subclasses.	subs := subs asSortedCollection: [:c1 :c2 | c1 fullName &lt; c2 fullName].	subs do: [:cl |		cl isMeta			ifFalse:				[newList add: cl.				self generateSubs: cl into: newList]]</body><body package="OldBrowsers">generateSuper: cls into: newList	cls == nil		ifFalse:			[self generateSuper: cls superclass into: newList.			cls isMeta ifFalse:[newList add: cls ]]</body><body package="OldBrowsers">howManySuperclasses: item	^(item isBehavior	 and: [item superclass ~~ nil])		ifTrue: [(self howManySuperclasses: item superclass) + 1]		ifFalse: [0]</body><body package="OldBrowsers">nesting: item	^(self howManySuperclasses: item ) * 12</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">setEnablement: menu	"Set the menu's items enabled/disabled state."	super setEnablement: menu.		(menu atNameKey: #add) disable.	^menu</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">updateListFull	| newList |	(self baseClass == nil	or: [self baseClass isObsolete])		ifTrue: [newList := List new]		ifFalse: [newList := self generateHierarchy].	module setNewList: newList</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">acceptText: aText from: textController	| currentParcel textMode |	(currentParcel := self currentParcel) isNil ifTrue: [^nil].	textMode := self browser parcelDefType value.	textMode == #parcelComment ifTrue:		[currentParcel comment: aText string.		self updateListFull.		^true].	textMode == #parcelVersion ifTrue:		[currentParcel version: aText string.		self updateListFull.		^true].	textMode == #parcelNotice ifTrue:		[currentParcel propertyAt: #notice put: aText string.		self updateListFull.		^true].	textMode == #parcelPrerequisites ifTrue:		[currentParcel prerequisiteParcels: (Compiler new								evaluate: aText string								in: nil								allowReceiver: true								receiver: currentParcel								environment: nil								notifying: textController								ifFail: [^false]).		self updateListFull.		^true].	textMode == #parcelDefintion		ifTrue: [ ^self acceptDefinition: aText from: textController ].	^nil</body><body package="OldBrowsers">text	| currentParcel textMode |	(currentParcel := self currentParcel) isNil ifTrue: [^'' asText].	textMode := self browser parcelDefType value.	textMode = #parcelDefintion		ifTrue: [ textMode := #parcelComment ].		"Should be something"	textMode == #parcelSummary ifTrue:		[^('Parcel ', (currentParcel listEntry), '\\' withCRs) asText, currentParcel summary asText].	textMode == #parcelComment ifTrue: [^currentParcel comment asText].	textMode == #parcelVersion ifTrue: [^currentParcel version asText].	textMode == #parcelNotice ifTrue:		[^(currentParcel			propertyAt: #notice			ifAbsent: ['Copyright Â© &lt;1p&gt; ????. All Rights Reserved.' expandMacrosWith: Date today year]) asText].	textMode == #parcelPrerequisites ifTrue:		[^('"Supply Parcel prerequisites as Parcel name, Version string pairs.  E.g.\	#(#(''Foo'' ''0.1'')\	  #(''Bar'' ''0.2''))"\\' withCRs asText emphasizeAllWith: #italic), currentParcel prerequisiteParcels storeString asText].	textMode == #parcelProperties ifTrue:		[ | properties s |		properties := currentParcel properties.		s := (String new: 64) writeStream.		(properties keys asSortedCollection asOrderedCollection			remove: #name;			addFirst: #name;			yourself) do:				[:key| | value source |				value := properties at: key.				value isString ifFalse: [value := value printString].				s	cr;					nextPut: key first asUppercase;					nextPutAll: (key copyFrom: 2 to: key size);					nextPut: $:;					space;					nextPutAll: value.				key == #sourceIndex ifTrue:					[source := SourceFileManager default nameStringAt: (properties at: key).					source := source isNil ifTrue: [source printString] ifFalse: [source].					s space; nextPut: $(; nextPutAll: source; nextPut: $)]].		^s contents asText].	textMode == #parcelDanglingReferences ifTrue:		[| s |		s := (String new: 64) writeStream.		Cursor wait showWhile:			[currentParcel danglingReferencesIfUnloadedDo: [:referer :referent|				referer isBehavior ifTrue:					[s nextPutAll: referer printString; nextPutAll: ' subclasses '; nextPutAll: referent printString] ifFalse:					[referer isSymbol ifTrue:					[s nextPutAll: referer; nextPutAll: ' extends '; nextPutAll: referent printString] ifFalse:					[referer printNameOn: s inClass: referer mclass.					s nextPutAll: ' refers to '; nextPutAll: referent printString]].				s cr]].		s isEmpty ifTrue: [s nextPutAll: 'none'].		^s contents asText].	^nil</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers">actionsForMultiSelect	^#()</body><body package="OldBrowsers">actionsForNoSelect	^#(selectHelp newParcel loadParcel filter updateBrowser find)</body><body package="OldBrowsers">buildViewMenu: aMenu	| menu |	menu := self class defTypeMenu.	menu menuItems do: 		[ :i | i indication: ( self browser parcelDefType value = i value ) ].	aMenu addPart: menu</body><body package="OldBrowsers">doesNotUnderstand: aMessage	| browser |	(self browser respondsTo: #currentTabApplication ) ifTrue:[ ^self browser perform: aMessage selector withArguments: aMessage arguments].	((browser := self browser) respondsTo: aMessage selector) ifFalse:		[^super doesNotUnderstand: aMessage].	^browser perform: aMessage selector withArguments: aMessage arguments</body><body package="OldBrowsers">getListMenu: forMenuBar	| menu browser filterSubMenu |	menu := super getListMenu: forMenuBar.	menu selectionMemory: nil.	browser := self browser.	filterSubMenu := (menu atNameKey: #filter) submenu.	(filterSubMenu atNameKey: #showOnlyParceled)		indication: browser isParcelFilterOn.	(filterSubMenu atNameKey: #showOnlyUnparceled)		indication: browser isUnparceledFilterOn.	(filterSubMenu atNameKey: #showMultiplyParceled)		indication: browser isConflictsFilterOn.	(menu atNameKey: #doUndo) enablementSelector: #canUndo.	^menu</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">addChangeSet	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	self selectedParcel addChangeSet: ChangeSet current.	self browser updateLists</body><body package="OldBrowsers">addToChanges	"Add the Parcel's contents to the current ChangeSet."	self selectedParcel cleanse.	ChangeSet current addChangeSet: self currentParcel</body><body package="OldBrowsers">browseChangedMethods	"Browse all methods that have changed in the currently selected parcel.	 Changed is defined as not having the same source file as the Parcel."	| extensions fileIndex sfm |	((self selectedParcel propertyAt: #hideSource) notNil	and: [self selectedParcel propertyAt: #hideSource]) ifTrue: [^Dialog warn: (#ParcelSourceHidden &lt;&lt; #dialogs &gt;&gt; 'Parcel source is hidden.  Cannot determine changed methods')].	extensions := SortedCollection new.	fileIndex := self selectedParcel propertyAt: #sourceIndex.	sfm := SourceFileManager default.	self currentParcel methodsDo:		[:cm| | def |		(fileIndex ~= (sfm fileIndexFor: cm sourcePointer)		and: [(def := cm definition) ~~ nil]) ifTrue:			[extensions add: def]].	self methodCollector		openListBrowserOn: extensions		label: ((#ChangedMethodsIn1s &lt;&lt; #dialogs &gt;&gt; 'Changed methods in &lt;1s&gt;')			expandMacrosWith: self selectedParcel name)		initialSelection: nil</body><body package="OldBrowsers">browseClassExports	"Browse references in the system to classes or names of classes	 exported from this Parcel.  Open a list browser on references from	 methods and a category browser for references from subclasses"	Cursor execute showWhile:		[| names references subclassExports |		names := self selectedParcel definedClasses collect: [:ea| ea name].		references := Set new.		SystemUtils allBehaviorsDo: [:class| | extends |			extends := self selectedParcel definesOrExtendsBehavior: class.			class selectorsAndMethodsDo: [:sel :meth|				(extends				and: [self currentParcel definesSelector: sel forClass: class]) ifFalse:					[meth allLiteralsDo: [:lit| | litVal |						"If the method refers to more than one class then the set will						 eliminate multiple entries for this method."						((lit isSymbol						and: [names includes: lit])						or: [lit isVariableBinding							and: [(litVal := lit value) isBehavior							and: [self selectedParcel definesClass: litVal]]]) ifTrue:							[references add: ((MethodDefinition class: class selector: sel) extraText: ((#Exports1p &lt;&lt; #dialogs &gt;&gt; ' exports: &lt;1p&gt;') expandMacrosWith: litVal))]]]]].		subclassExports := IdentitySet new.		self selectedParcel definedClasses do: [:class|			subclassExports addAll: (class subclasses select: [:subclass|				| pcls |				(pcls := self manager parcelsForClassOrNameSpace: subclass) size = 0				or: [pcls contains: [:p| p ~= self selectedParcel and: [p definesClass: subclass]]]])].		(references isEmpty		and: [subclassExports isEmpty]) ifTrue:			[^Dialog warn: (#NoExports &lt;&lt; #dialogs &gt;&gt; 'No exports')].		references isEmpty ifFalse:			[self methodCollector				openListBrowserOn: references asSortedCollection 				label: ((#ReferencesToClassesExportedFrom1sParcel &lt;&lt; #dialogs &gt;&gt; 'References to Classes Exported from &lt;1s&gt; Parcel') expandMacrosWith: self currentParcel name)				initialSelection: nil].		subclassExports isEmpty ifFalse:			[self notYetImplemented.			"org := SystemOrganizer new.			subclassExports do:				[:class|				org classify: class fullName					under: 'Inherited Class Exports From ', self currentParcel name, ' Parcel'].			self class openOn: (ParcelBrowser new on: org)"]]</body><body package="OldBrowsers">browseClassImports	"Browse references to classes defined by the rest of the system from within this Parcel."	Cursor execute showWhile:		[| references superclassImports extendedImports |		references := Set new.		superclassImports := IdentitySet new.		extendedImports := IdentitySet new.		SystemUtils allBehaviorsDo: [:class| | defines extends |			((defines := self selectedParcel definesClass: class)			and: [class superclass notNil			and: [(self selectedParcel definesClass: class superclass) not]]) ifTrue:				[superclassImports add: class instanceBehavior superclass].			(extends := self selectedParcel extendsBehavior: class) ifTrue:				[extendedImports add: class instanceBehavior].			class selectorsAndMethodsDo: [:sel :meth|				(defines				or: [extends					and: [self selectedParcel definesSelector: sel forClass: class]]) ifTrue:					[meth allLiteralsDo: [:lit| | litVal |						"If the method refers to more than one class then the set will						 eliminate multiple entries for this method."						(lit isVariableBinding						and: [(litVal := lit value) isBehavior						and: [(self selectedParcel definesClass: litVal) not]]) ifTrue:							[references add: ((MethodDefinition class: class selector: sel) extraText: ((#ImportsColon1p &lt;&lt; #dialogs &gt;&gt; ' imports: &lt;1p&gt;') expandMacrosWith: litVal))]]]]].		(references isEmpty		and: [superclassImports isEmpty		and: [extendedImports isEmpty]]) ifTrue:			[^Dialog warn: (#NoImports &lt;&lt; #dialogs &gt;&gt; 'No imports')].		references isEmpty ifFalse:			[self methodCollector				openListBrowserOn: references asSortedCollection				label: ((#ReferencesToClassesImportedBy1sParcel &lt;&lt; #dialogs &gt;&gt; 'References to Classes Imported by &lt;1s&gt; Parcel') expandMacrosWith: self currentParcel name)				initialSelection: nil].		superclassImports isEmpty ifFalse:			[self notYetImplemented.			"org := SystemOrganizer new.			superclassImports do:				[:class|				org classify: class fullName					under: 'Class Imports into ', self currentParcel name, ' Parcel'].			self class openOn: (ParcelBrowser new on: org)"].		extendedImports isEmpty ifFalse:			[self notYetImplemented.			"org := SystemOrganizer new.			extendedImports do:				[:class|				org classify: class fullName					under: 'Classes Extended by ', currentParcel name, ' Parcel'].			self class openOn: (ParcelBrowser new on: org)"]]</body><body package="OldBrowsers">browseDanglingReferences	"Browse references in the system to classes or names of classes 	exported from this Parcel. Open a list browser on references from 	methods and a category browser for references from subclasses"	Cursor execute showWhile: 		[| references subclassExports |		references := Set new.		subclassExports := IdentitySet new.		self selectedParcel danglingReferencesIfUnloadedDo:			[:referer :referent|				referer isBehavior ifTrue:					[subclassExports add: referer] ifFalse:					[referer isSymbol ifTrue:					[references add: (MethodDefinition class: referent selector: referer)] ifFalse:					[references add: (referer definition										extraText: ' -&gt; ', referent fullName;										yourself)]]].		(references isEmpty		and: [subclassExports isEmpty]) ifTrue:			[^Dialog warn: (#NoDanglingReferences &lt;&lt; #dialogs &gt;&gt; 'No dangling references')].		references isEmpty ifFalse:			[self methodCollector				openListBrowserOn: references asSortedCollection				label: ((#ClassRefsInParcel &lt;&lt; #dialogs &gt;&gt; 'References to Classes in &lt;1s&gt; Parcel')					expandMacrosWith: self currentParcel name)				initialSelection: nil].		subclassExports isEmpty ifFalse:			[| namespace |			namespace := NameSpace new name: ((#InheritedClassRefs &lt;&lt; #dialogs &gt;&gt; 'Inheriting Class References From &lt;1s&gt;') asString					expandMacrosWith: self currentParcel name).			subclassExports do: [:class | namespace addBinding: (class environment bindingFor: class name)].			self browser spawnOnNameSpace: namespace]]</body><body package="OldBrowsers">browseExclusiveMethodImports	"Browse methods imported by this Parcel and unused elsewhere."	| danglingMethods |	Cursor execute showWhile:		[danglingMethods := self computeExclusiveMethodImports].	self methodCollector		openListBrowserOn: danglingMethods asSortedCollection		label: ((#PossibleDanglingMethods &lt;&lt; #dialogs &gt;&gt; 'Methods Used Only by &lt;1s&gt; but not in &lt;2s&gt;')			expandMacrosWith: self selectedParcel name			with: self currentParcel name)		initialSelection: nil</body><body package="OldBrowsers">browseExtensionMethods	"Browse all extension methods in the currently selected parcel."	| extensions |	extensions := SortedCollection new.	self currentParcel extensionsDo:		[:aClass :aSelector|		extensions add: (MethodDefinition class: aClass selector: aSelector)].	self methodCollector		openListBrowserOn: extensions		label: ((#ExtensionMethodsIn1s &lt;&lt; #dialogs &gt;&gt; 'Extension methods in &lt;1s&gt;')			expandMacrosWith: self currentParcel name)		initialSelection: nil</body><body package="OldBrowsers">browseImplementorsOf	"Prompt the user for a selector or selector pattern.  If only one existing	message selector matches that selector (case insensitive) or pattern,	then browse all implementors of that selector.  If more than one match, 	then present a menu of the matching selectors and browse all implementors	of the selected one."	| trial coll selector mc |	"Two things; a) this should open a Parcel Method List Browser, b) the prompting for selectors should be in some central place"	trial := Dialog request: (#BrowseImplementorsOfWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse implementors of what?').	trial isEmpty ifTrue: [^self].	coll := OrderedCollection new.	Cursor wait showWhile:		[Symbol allSymbolsDo:			[:sym | (trial match: sym) ifTrue: [coll add: sym]]].	coll isEmpty ifTrue:		[^Dialog warn: (#NoMatchingMessages &lt;&lt; #dialogs &gt;&gt; 'No matching messages')].	selector := coll size = 1				ifTrue: [coll first]				ifFalse:					[Dialog						choose: (#FindAllImplementorsOfDot &lt;&lt; #dialogs &gt;&gt; 'Find all implementors of...')						fromList: (coll collect: [:sel | sel asString])						values: coll						lines: 20						cancel: [^self]].	mc := self methodCollector.	mc browseSelect: (mc parcel: self currentParcel) &amp; (mc implementorsOf: selector)</body><body package="OldBrowsers">browseOverriddenByOthers	"Browse all methods in the currently selected parcel that are overridden	 by other parcels.  These methods prevent a parcel from being saved."	| overrides current currentParcel |	currentParcel := self currentParcel.	( overrides := currentParcel overrides ) isEmpty 		ifTrue: [ ^Dialog warn: (#NothingOverriddenByOthers &lt;&lt; #dialogs &gt;&gt; 'Nothing overridden by others') ].	current := OrderedCollection new.	overrides do:		[ :over |		over isForMethod			ifTrue: [ 	current add: ( MethodDefinition class: over owner selector: over selector) ]		].	#{Tools.OverrideList} value new 		listName: ((#OverriddenDefsInParcel &lt;&lt; #dialogs &gt;&gt; 'Definitions in &lt;1s&gt; overridden by others')			expandMacrosWith: currentParcel name);		checkSystem: #code;		showConflicts: true;		openOn: overrides.	current isEmpty		ifFalse: 			[ self methodCollector				openListBrowserOn: current asSortedCollection				label: ((#CurrentMethodOverridden &lt;&lt; #dialogs &gt;&gt; 'Current method overridden in &lt;1s&gt;')					expandMacrosWith: self currentParcel name)				initialSelection: nil			].</body><body package="OldBrowsers">browseOverriddenExtensions	"Browse all methods in the currently selected parcel that are overrides of previous versions. 	 To allow comparison of the old and the new open up a ChangeList switched to conflicts	 containing the original versions.  To allow parcelling, open up a MethodListParcelBrowser."	| overrides current currentParcel |	currentParcel := self currentParcel.	( overrides := Override overriddenByComponent: currentParcel ) isEmpty 		ifTrue: [ ^Dialog warn: (#NoOverriddenExtensions &lt;&lt; #dialogs &gt;&gt; 'No overridden extensions') ].	current := OrderedCollection new.	overrides do:		[ :over |		over isForMethod			ifTrue: [ 	current add: ( MethodDefinition class: over owner selector: over selector) ]		].	#{Tools.OverrideList} value new 		listName: ((#DefinitionsOverriddenByParcel &lt;&lt; #dialogs &gt;&gt; 'Definitions overridden by &lt;1s&gt; parcel')			expandMacrosWith: self currentParcel name);		checkSystem: #code;		showConflicts: true;		openOn: overrides.	current isEmpty		ifFalse: 			[ self methodCollector				openListBrowserOn: current asSortedCollection				label: ((#CurrentMethodOverrides &lt;&lt; #dialogs &gt;&gt; 'Current method overrides defined in &lt;1s&gt;')					expandMacrosWith: self currentParcel name)				initialSelection: nil			].</body><body package="OldBrowsers">browseSendersOf	"Prompt the user for a selector or selector pattern.  If only one existing	message selector matches that selector (case insensitive) or pattern,	then browse all senders of that selector.  If more than one match, 	then present a menu of the matching selectors and browse all senders	of the selected one."	| trial coll selector mc |	"Two things; a) this should open a Parcel Method List Browser, b) the prompting for selectors should be in some central place"	trial := Dialog request: (#BrowseSendersOfWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse senders of what?').	trial isEmpty ifTrue: [^self].	coll := OrderedCollection new.	Cursor wait showWhile:		[Symbol allSymbolsDo:			[:sym | (trial match: sym) ifTrue: [coll add: sym]]].	coll isEmpty ifTrue:		[^Dialog warn: (#NoMatchingMessages &lt;&lt; #dialogs &gt;&gt; 'No matching messages')].	selector := coll size = 1				ifTrue: [coll first]				ifFalse:					[Dialog						choose: (#FindAllSendersOfDot &lt;&lt; #dialogs &gt;&gt; 'Find all senders of...')						fromList: (coll collect: [:sel | sel asString])						values: coll						lines: 20						cancel: [^self]].	mc := self methodCollector.	mc browseSelect: (mc parcel: self currentParcel) &amp; (mc referencesTo: selector)</body><body package="OldBrowsers">browseUnparceledMethodsOnDefinedClasses	"Browse methods on classes defined by this Parcel that are not in the Parcel."	^self methodCollector		openListBrowserOn: self computeUnparceledMethodsOnDefinedClasses asSortedCollection		label: ((#UnparcelledMethods &lt;&lt; #dialogs &gt;&gt; 'Unparcelled methods in classes defined in &lt;1s&gt;')			expandMacrosWith: self currentParcel name)		initialSelection: nil</body><body package="OldBrowsers">discardParcel	"Discard the selected parcel.  This discards the Parcel but does not remove its code."	self changeRequest ifFalse: [^self].	(Dialog confirm: (#DiscardBbutNotUnloadParcelQ &lt;&lt; #dialogs &gt;&gt; 'Really discard (but not unload) the parcel?')) ifTrue:		[ self manager destroyParcelNamed: self currentParcel name.		self updateListFull.		self selectParcel: nil		]</body><body package="OldBrowsers">emptyParcel	"Empty the current parcel, but do not remove the code it defined from the system."	self changeRequest ifFalse: [^self].	self currentParcel uiForEmpty 		ifTrue:	[self browser updateLists]</body><body package="OldBrowsers">fileIntoParcel	| fileName |	self changeRequest ifFalse: [^self].	fileName := Dialog		requestFileName: (#FileInFromFileNamed &lt;&lt; #dialogs &gt;&gt; 'File in from file named')		default: '*.st'		version: #mustBeOld		ifFail: [nil]		for: self browser builder window.	fileName size = 0 ifTrue: [^self].	self currentParcel fileIntoFrom: fileName.	self browser updateLists</body><body package="OldBrowsers">fileOutParcel	self changeRequest ifFalse: [^self].	self currentParcel fileOutAsFor: nil.			"builder window"</body><body package="OldBrowsers">find	"Prompt for a name and position myself there."	| obj parcelSet found |	self changeRequest ifFalse: [^self].	obj := self findASomething: (#FindC &lt;&lt; #labels &gt;&gt; 'Find:').	obj == nil ifTrue: [^self]."if we can't see it, we can't select it....."	obj isBindingReference		ifTrue:			[self browser batchUpdates:				[self browser metaShowData.				self browser setAndUpdateEnvironment: obj environment environment.				self browser selectCategory: obj environment category.				self browser selectBehavior: obj environment.				self browser selectProtocol: (obj environment asNameSpace categoryFor: obj name).				self browser selectMethod: obj name]]		ifFalse: 			[self environment == nil &amp; (self category == nil)				ifFalse: 					[self browser setAndUpdateEnvironment: obj environment.					self category == obj category ifFalse:						[module nextModule							select: obj category							whenFinished: ["module nextModule updateList"]]].			found := self browser manager parcelsForClassOrNameSpace: obj.			found isEmpty ifFalse:				[|foundCollection|				foundCollection := found asOrderedCollection.				parcelSet := foundCollection select: [:each | (each definesClass: obj) or: [each definesObject: obj]].				parcelSet isEmpty ifTrue: [parcelSet := foundCollection]].			found notEmpty ifTrue:				[self module					select: parcelSet first					whenFinished: [module updateList]].			module nextModule nextModule				select: obj				whenFinished: [self browser updateBrowser]]</body><body package="OldBrowsers">inspectParcel	self selectedParcel inspect</body><body package="OldBrowsers">loadParcel	self changeRequest ifFalse: [ ^self ].	self manager loadParcelFor:  nil.			"builder window."	self browser updateParcelLists.	self browser updateNamespaceListFull.</body><body package="OldBrowsers">newParcel	"Pop dialog to prompt user for new name. Tell def mgr to make it"	| newName currentParcel |	self changeRequest ifFalse: [^self].	newName := Dialog						request: (#EnterNameForNewParcel &lt;&lt; #dialogs &gt;&gt; 'Enter name for the new parcel')						initialAnswer: ''						onCancel: [nil].	newName := self manager normalizedNameFor: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(self manager parcelNamed: newName) notNil ifTrue:		[Dialog warn: (#parcelExists &lt;&lt; #dialogs &gt;&gt; 'A parcel with this name already exists').		^self].	currentParcel := self manager createParcelNamed: newName.	currentParcel == nil 		ifFalse: 			[ self browser updateLists.			self module selection: currentParcel			]</body><body package="OldBrowsers">openParcelProperties	PackagePropertiesDialog on: self currentParcel</body><body package="OldBrowsers">removeChangeSet	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	self currentParcel removeChangeSet: ChangeSet current.	self browser updateLists</body><body package="OldBrowsers">removeFromChanges	"Remove the Parcel's contents from the current ChangeSet."	self currentParcel cleanse.	ChangeSet current removeChangeSet: self currentParcel</body><body package="OldBrowsers">removeParcel	"Remove the currently selected parcel.  This unloads the Parcel's code	 and updates the current change set with the removals."	self changeRequest ifFalse: [^self].	(Dialog confirm: (#UnloadAndRemoveParcelCodeQ &lt;&lt; #dialogs &gt;&gt; 'Really unload (and remove) the parcel''s code?')) ifTrue:		[Cursor wait showWhile:			[self currentParcel hasDanglingReferencesIfUnloaded ifTrue:				[(Dialog confirm: ((#HasDanglingReferencesRemoveParcelQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to remove the parcel''s code?') expandMacrosWith: self currentParcel name)) ifFalse: [^self]].			(self manager removeParcelNamed: self currentParcel name) ifTrue:				[self postUnloadParcel]]].	self browser updateParcelLists</body><body package="OldBrowsers">renameParcel	self changeRequest ifFalse: [^self].	"Remember currentParcel because rename sets currentParcel to nil"	self currentParcel uiForRename 		ifTrue:	[ self updateLists ]</body><body package="OldBrowsers">saveParcelDialog	"Put up a Dialog that allows the user to save the Parcel in various forms."	self changeRequest ifFalse: [^self].	self currentParcel saveParcelDialogFor: nil	.		"builder window."	self browser updateLists</body><body package="OldBrowsers">showComputedPrerequisites	| prerequisites |	self changeRequest ifFalse: [^self].	prerequisites := self computePrerequisites.	self parcelTextMode: #parcelPrerequisites		value: ((#EditAndAcceptPrereqs &lt;&lt; #dialogs &gt;&gt; '"Edit as required and then choose accept to set the parcel''s prerequisites."&lt;nn&gt;&lt;1s&gt;')			expandMacrosWith: ((prerequisites asSortedCollection: [:p1 :p2 | p1 name &lt;= p2 name]) asArray collect: [:p | Array with: p name with: (p propertyStringAt: #version)]) storeString asText)</body><body package="OldBrowsers">showSummary	self browser parcelTextMode: #parcelSummary</body><body package="OldBrowsers">spawn	"Not supported."	Dialog warn: (#NotImplemented &lt;&lt; #dialogs &gt;&gt; 'Not implemented.')</body><body package="OldBrowsers">unloadParcel	self changeRequest ifFalse: [^self].	self currentParcel isNil		ifTrue:			[| parcels unloaded |			parcels := self manager parcels select: [:ea| ea isLoaded].			parcels := SimpleDialog new						chooseMultiple: (#SelectParcelsToUnload &lt;&lt; #dialogs &gt;&gt; 'Select parcels to unload.')						fromList: (parcels collect: [:p| p listEntry])						values: parcels						buttons: #() values: #()						lines: 8						cancel: []						for: Dialog defaultParentWindow.			parcels notNil ifTrue:				[unloaded := false.				Cursor wait showWhile:					[(SystemUtils sortForLoading: parcels) reverseDo:						[:p|						p hasDanglingReferencesIfUnloaded ifTrue:							[(Dialog confirm: ((#ParcelHasDanglingRefs &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to unload the parcel''s code?') expandMacrosWith: p name)) ifFalse: [^self]].						(self manager unloadParcelNamed: p name) ifTrue:							[unloaded := true]].				unloaded ifTrue: [self postUnloadParcel]]]]		ifFalse:			[(Dialog confirm: (#UnloadAndDiscardParcelCodeQ &lt;&lt; #dialogs &gt;&gt; 'Really unload (and discard) the parcel''s code?')) ifTrue:				[Cursor wait showWhile:					[self currentParcel hasDanglingReferencesIfUnloaded ifTrue:						[(Dialog confirm: ((#ParcelHasDanglingRefs &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to unload the parcel''s code?') expandMacrosWith: self currentParcel name)) ifFalse: [^self]].					(self manager unloadParcelNamed: self currentParcel name) ifTrue:						[self postUnloadParcel]]]].	self browser updateParcelLists</body><body package="OldBrowsers">updateBrowser	self browser updateBrowser</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">canAcceptDropFrom: aDC 	"respond to objects that can be added to a Parcel"	^aDC key == self classOrNamespaceKey or: [  aDC key == self selectorOrStaticKey]</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>private</category><body package="OldBrowsers">buildPlatformFilename: aString	| oldSeparator |	oldSeparator := (aString includes: UnixFilename separator)		ifTrue:	[ UnixFilename separator ]		ifFalse:	[ (aString includes: PCFilename separator)					ifTrue:	[ PCFilename separator ]					ifFalse:	[ nil ] ].	aString replaceAll: oldSeparator with: Filename separator.	^aString copyWithout: Character space.</body><body package="OldBrowsers">computeExclusiveMethodImports	"The algorithm computes a fixed point of the methods used	  by the parcel which are unused outside it.  The algorithm is			compute messages sent within parcel			repeat until at a fixed point:				compute intersection of this with methods implemented outside parcel				compute messages sent outside parcel not within the intersection				remove these from intersection"	| parcelMessages "&lt;IdentitySet of: Symbol&gt;							messages sent within this parcel"	  externalMethods "&lt;Set of: MethodDescription&gt;							methods implemented outside this parcel"	  danglingMethods "&lt;Set of: MethodDescription&gt;							methods importeded only by this parcel"	  previousDangling "&lt;Set of: MethodDescription&gt;							intermediate value of danglingMethods (for determining if fixed point is reached)"	  danglingMessages "&lt;Set of: Symbol&gt; selectors of methods in danglingMethods"	  noLongerDangling "&lt;Set of: Symbol&gt; selectors to be moved from dangling" |	parcelMessages := IdentitySet new.	self currentParcel methodsDo:		[:meth| parcelMessages addAll: meth allSymbolLiterals].	"compute starting points for danglingMethods and externalMethods"	danglingMethods := Set new: 50.	externalMethods := Set new: 20000.	SystemUtils allBehaviorsDo:		[:aBehavior| | extends |		(self currentParcel definesClass: aBehavior) ifFalse:			[extends := self currentParcel extendsBehavior: aBehavior.			aBehavior selectorsAndMethodsDo:				[:sel :meth|				(extends				and: [self currentParcel definesSelector: sel forClass: aBehavior]) ifFalse:					[((parcelMessages includes: sel)						ifTrue: [danglingMethods]						ifFalse: [externalMethods])							add: (MethodDefinition class: aBehavior selector: sel)]]]].	["Now iterate to the fixed-point.  Any method in dangling with a selector sent	  in external must be moved into external until dangling reaches its fixed point."	previousDangling := danglingMethods copy.	danglingMessages := danglingMethods collect: [:md| md selector].	noLongerDangling := Set new: danglingMethods size.	externalMethods do:		[:md|		md method allSymbolLiteralsDo:			[:l|			(danglingMessages includes: l) ifTrue:				[noLongerDangling add: l]]].	externalMethods := danglingMethods select: [:md| noLongerDangling includes: md selector].	danglingMethods removeAll: externalMethods.	danglingMethods size ~= previousDangling size] whileTrue.	^danglingMethods</body><body package="OldBrowsers">computePrerequisites	"Compute the Parcel's prerequisites and display them in the text pane;	 The programmer can then edit and accept."	| importedClasses prerequisites |	importedClasses := IdentitySet new.	"Collect imported classes.  These are the superclasses of	 classes in the parcel, the classes extended by the parcel,	 and any classes referred to by methods in the parcel."	self currentParcel definedClasses do:		[:class| | superclass |		((superclass := class superclass) notNil		and: [(self currentParcel definesClass: superclass) not]) ifTrue:			[importedClasses add: superclass]].	importedClasses addAll: self currentParcel extendedClasses.	self currentParcel methodsDo:		[:meth|		meth allLiteralsDo:			[:lit| | thing |			(lit isSymbol and: [lit size &gt; 0])				ifTrue:					[((thing := Smalltalk at: lit ifAbsent: []) isBehavior					and: [(self currentParcel definesClass: thing) not]) ifTrue:						[importedClasses add: thing]]				ifFalse:					[(lit isVariableBinding					and: [(thing := lit value) isBehavior					and: [(self currentParcel definesClass: thing) not]]) ifTrue:						[importedClasses add: thing]]]].	prerequisites := Set new.	importedClasses do:		[:class| | parcels |		parcels := self manager parcelsForClassOrNameSpace: class.		parcels notNil ifTrue: [prerequisites addAll: (parcels select: [:p| p definesClass: class])]].	prerequisites remove: self currentParcel ifAbsent: nil.	^prerequisites</body><body package="OldBrowsers">computeUnparceledMethodsOnDefinedClasses	"Answer a Set of methods on classes defined by this Parcel that are not in the Parcel."	| references |	references := Set new.	SystemUtils allBehaviorsDo: [:class|		(self currentParcel definesClass: class) ifTrue:			[class selectorsAndMethodsDo: [:sel :meth|				(self currentParcel definesSelector: sel forClass: class) ifFalse:					[references add: (MethodDefinition class: class selector: sel)]]]].	^references</body><body package="OldBrowsers">postUnloadParcel	"Clean-up after unloading a Parcel."	self component1 updateListFull.	self component2 updateListFull.	self browser updateLists.	(Dialog confirm: (#removeCategoriesAndPurge &lt;&lt; #dialogs &gt;&gt; 'Remove empty categories and purge Undeclared?')) ifTrue:		[ Cursor execute showWhile:			[ Root allNameSpaces do: [ :ns | ns organization removeEmptyCategories ].			ClassOrganizer allInstancesDo: [ :clo| clo removeEmptyCategories ].			Undeclared purgeUnusedBindings ]		]</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#parcel</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">selectParcel: aParcel	| newSelection |	(newSelection := aParcel) == nil		ifTrue: [ module deselect ].	self module selection: newSelection</body><body package="OldBrowsers">selectionChanged	self setSelection.	self browser updateButtonLabels.	self nextModule updateList</body><body package="OldBrowsers">textForItem:  aParcel	^aParcel listEntry asText</body><body package="OldBrowsers">updateListFull	"Must cleanse all parcels to make sure they're current."	|pList|	self manager parcels do: [ :aParcel | aParcel cleanse ].	pList := SortedCollection withAll: self manager parcels sortBlock: [:p1 :p2 | p1 name &lt; p2 name].	module setNewList: pList asList. 		"parcelNameList"</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers">windowLabel	^self currentParcel isNil		ifTrue: [#Parcel &lt;&lt; #labels &gt;&gt; 'Parcel']		ifFalse: [#x1sParcel &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; Parcel'			expandMacrosWith: self currentParcel name]</body></methods><methods><class-id>Tools.ParcelListBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers">menuHeader	^(#Par_cel &lt;&lt; #menus &gt;&gt; 'Par&amp;cel') asString</body></methods><methods><class-id>Tools.MorphingBrowserModule</class-id> <category>accessing</category><body package="OldBrowsers">currentHelper	| primary |	primary := helpers first selected: #environment.	primary == nil		ifTrue: [ ^helpers first ].	^( primary isBehavior and: [ browser isData not ] )		ifTrue: [ helpers first ]		ifFalse: [ helpers at: 2 ]</body><body package="OldBrowsers">meta	^self browser meta</body></methods><methods><class-id>Tools.MorphingBrowserModule class</class-id> <category>interface specs</category><body package="OldBrowsers">preferredSpec	^self listSpecProtocols</body><body package="OldBrowsers">preferredSpecName	^#listSpecProtocols</body></methods><methods><class-id>Tools.BrowserListEntry</class-id> <category>comparing</category><body package="OldBrowsers">= anEntry	^self class == anEntry class		and: [self value = anEntry value		and: [self typeForComparing = anEntry typeForComparing]]</body><body package="OldBrowsers">hash	^self value hash</body><body package="OldBrowsers">typeForComparing	"#normal and nil are different graphically, but they are	equivalent semantically."	^type == nil		ifTrue: [#normal]		ifFalse: [type]</body></methods><methods><class-id>Tools.BrowserListEntry</class-id> <category>accessing</category><body package="OldBrowsers">displayLabel: string 	^self type == nil		ifTrue: [Label with: string offset: self offset]		ifFalse: [(LabelAndIcon with: string offset: self offset) icon: self icon]</body><body package="OldBrowsers">icon	| icon |	icon := self class icon: self type.	^icon</body><body package="OldBrowsers">offset	^offset == nil		ifTrue: [0@0]		ifFalse: [offset]</body><body package="OldBrowsers">offset: aPoint	offset := aPoint</body><body package="OldBrowsers">type	^type</body><body package="OldBrowsers">type: aType	type := aType</body></methods><methods><class-id>Tools.BrowserListEntry</class-id> <category>printing</category><body package="OldBrowsers">displayLabel	^self type == nil		ifTrue: [Label with: self value displayString offset: self offset]		ifFalse: [(LabelAndIcon with: self value displayString offset: self offset) icon: self icon]</body><body package="OldBrowsers">displayString	^self value displayString</body></methods><methods><class-id>Tools.BrowserListEntry class</class-id> <category>instance creation</category><body package="OldBrowsers">value: val type: type	^self new value: val; type: type</body></methods><methods><class-id>Tools.BrowserListEntry class</class-id> <category>initialize</category><body package="OldBrowsers">initialize 	"Initialize the class." 	"BrowserListEntry initialize"  	| variableIcon signalIcon folderIcon canvasIcon imageIcon menuIcon regionsIcon modelIcon queryIcon normalIcon |	variableIcon := OpaqueImage figure: self CVariableIcon 						shape: self MskVariableIcon. 	signalIcon := OpaqueImage figure: self CSignalIcon 						shape: self MskSignalIcon. 	folderIcon := OpaqueImage figure: self CFolderIcon 						shape: self MskFolderIcon. 	canvasIcon := OpaqueImage figure: self CcanvasIcon 						shape: self MskCanvasIcon. 	imageIcon := OpaqueImage figure: self CiconIcon 						shape:  self MskIconIcon. 	menuIcon := OpaqueImage figure:  self CMenuIcon 						shape:  self MskMenuIcon. 	regionsIcon := OpaqueImage figure: self CRegionsIcon						shape: self MskIconIcon.	modelIcon := OpaqueImage figure:  self CModelIcon 						shape:  self MskModelIcon. 	queryIcon := OpaqueImage figure:  self CQueryIcon 						shape:  self MskQueryIcon.	normalIcon := CachedImage on: queryIcon shape asImage copyEmpty.	#{Tools.BrowserListEntry.Map} value: (Dictionary new			at: #nameSpace put: folderIcon;			at: #exception put: signalIcon;			at: #variable put: variableIcon;			at: #canvas put: canvasIcon;			at: #image put: imageIcon;			at: #menu put: menuIcon;			at: #hotRegions put: regionsIcon;			at: #model put: modelIcon;			at: #query put: queryIcon;			at: #normal put: normalIcon;			yourself)</body></methods><methods><class-id>Tools.BrowserListEntry class</class-id> <category>accessing</category><body package="OldBrowsers">icon: aName	^#{Tools.BrowserListEntry.Map} value at: aName ifAbsent: [nil]</body></methods><methods><class-id>Tools.NameSpaceHierarchyBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers">canAcceptDropFrom: aDC	^aDC key == self  classOrNamespaceKey</body><body package="OldBrowsers">drop: aDragContext	"A drop has occured in the Namespace l list of the browser. see if we can accept and if so move the class(es)."	| ctrl idx cNameArray |	(self canAcceptDropFrom: aDragContext) ifFalse:[^#dragEffectNone ].	self browser changeRequest ifFalse: [^#dropEffectNone].	"Locate the target namspace's index"	ctrl := aDragContext clientData at: #ctrl.	idx := ctrl view targetIndex.	idx = 0 ifTrue: [^#dropEffectNone].	"If the data is not available in the correct format, do not drop."	cNameArray := aDragContext sourceData clientData 				at: self classOrNamespaceKey ifAbsent: [^#dropEffectNone].	"Move the class or namspace to the new Namespace"	"The class name is in the clientData of the dropSource"	cNameArray do:[:eachCName |  eachCName relocateTo: (self module list selectionForIndex: idx).		ChangeSet changeClass: eachCName ].	"Restore the state of the list before leaving."	self restoreListStateFrom: aDragContext clientData.	aDragContext clientData: nil.	self nextModule updateList.	^#dropEffectMove</body></methods><methods><class-id>Tools.NameSpaceHierarchyBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers">doItEnvironment	| selection |	(selection := self selection) isNil ifTrue: [^nil].	^selection environment = Root		ifTrue: [self defaultEnvironment]		ifFalse: [selection environment]</body><body package="OldBrowsers">doItReceiver	"The receiver's selection can be nil, and that is an acceptable 	receiver for evaluation."	^self selection</body></methods><methods><class-id>Tools.NameSpaceHierarchyBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers">intializeListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	module setNewListSilently: tree.	"Lets be nice and show all namespaces within Smalltalk"	module list deepOpenCurrentTo:3.</body><body package="OldBrowsers">selectionIsClass	^self selection isBehavior</body><body package="OldBrowsers">updateListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	module setNewList: tree</body></methods><methods><class-id>Tools.PickASomethingDialog class</class-id> <category>interface specs</category><body package="OldBrowsers">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 728 554 924 781 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.00440529 0 0.989796 0 0.814978 ) 					#name: #list 					#flags: 15 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #doubleClick ) 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0918367 0 0.85022 0 0.357143 0 0.960352 ) 					#name: #ok 					#model: #doAccept 					#label: #(#{Kernel.UserMessage} #key: #OK #catalogID: #labels #defaultString: 'OK') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.642857 0 0.85022 0 0.908163 0 0.960352 ) 					#name: #cancel 					#model: #closeCancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #catalogID: #labels #defaultString: 'Cancel') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>private</category><body package="OldBrowsers">menuMethodPragmas	&lt;pragmas: #instance&gt;	^Menu pragmas</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">openResourceEditor	&lt;menuItem: #(#EditResource #menus '&amp;Edit Resource')		nameKey: nil		menu: #(#listMenu)		position: 35.1&gt;	| resource editorName meth |	self targetClassOrNameSpace isForNameSpace		ifTrue: [^Dialog warn: (#SharedVariablesHaveNoEditor &lt;&lt; #dialogs &gt;&gt; 'Shared variables have no editor') for: self interfaceWindow].	meth := self definitionOf: self selection.	resource := meth method resourceType.	resource == nil ifTrue: [^Dialog warn: (#ThisMethodHasNoEditor &lt;&lt; #dialogs &gt;&gt; 'This method has no editor') for: self interfaceWindow].	resource = #canvas		ifTrue: [editorName := #{UIPainter}].	resource = #menu		ifTrue: [editorName := #{MenuEditor}].	resource = #image		ifTrue: [editorName := #{UIMaskEditor}].	resource = #dataModel		ifTrue: [editorName := #{LensEditor}].	resource = #query		ifTrue: [editorName := #{QueryEditor}].	editorName == nil		ifTrue:			[^Dialog warn: ((#ThisBrowserDoesNotKnowEditorFor &lt;&lt; #dialogs &gt;&gt; 'This browser does not know the editor for &lt;1p&gt;')						expandMacrosWith: resource)				for: self interfaceWindow].	self open: editorName		on: meth implementingClass instanceBehavior		selector: meth selector.	^resource</body></methods><methods><class-id>Tools.MethodsBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDot 					#defaultString: 'File &amp;Out As...' 					#catalogID: #menus ) 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Hardcopy 					#defaultString: '&amp;Hardcopy' 					#catalogID: #menus ) 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Spawn 					#defaultString: '&amp;Spawn' 					#catalogID: #menus ) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Se_nders 					#defaultString: 'Se&amp;nders' 					#catalogID: #menus ) 				#nameKey: #allSenders ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Im_plementors 					#defaultString: 'Im&amp;plementors' 					#catalogID: #menus ) 				#nameKey: #allImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #HierarchylSen_ders 					#defaultString: 'Hierarchy Sen&amp;ders' 					#catalogID: #menus ) 				#nameKey: #localSenders ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #HierarchyImp_lementors 					#defaultString: 'Hierarchy Imp&amp;lementors' 					#catalogID: #menus ) 				#nameKey: #localImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #MoveToDot 					#defaultString: '&amp;Move To...' 					#catalogID: #menus ) 				#nameKey: #move 				#value: #move ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RemoveDot 					#defaultString: '&amp;Remove...' 					#catalogID: #menus ) 				#nameKey: #remove 				#value: #remove ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InitializeVariable 					#defaultString: '&amp;Initialize Variable' 					#catalogID: #menus ) 				#nameKey: #initializeStatic 				#value: #initializeStatic ) ) #(3 4 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.BrowserTabApplication class</class-id> <category>resources</category><body package="OldBrowsers">blankIcon	"UIMaskEditor new openOnClass: self andSelector: #blankIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: (Core.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue red; at: 2 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 0 255 255 255 0 255 255 255 0 247 251 255 0 243 243 255 0 249 231 255 0 252 207 255 0 254 95 255 0 255 63 255 0 255 63 255 0 254 31 255 0 254 223 255 0 252 207 255 0 249 231 255 0 243 243 255 0 243 243 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0])</body><body package="OldBrowsers">categoryIcon	"UIMaskEditor new openOnClass: self andSelector: #categoryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (Core.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 2 put: Graphics.ColorValue black; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 0); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 170 170 170 170 128 0 0 2 170 170 170 170 128 0 0 0 0 0 0 0 0 0 0 2 170 170 170 170 128 0 0 2 170 170 170 170 128 0 0 0 0 0 0 0 0 0 0 1 85 85 85 85 64 0 0 1 85 85 85 85 64 0 0 0 0 0 0 0 0 0 0 2 170 170 170 170 128 0 0 2 170 170 170 170 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.ParcelTabApplication class</class-id> <category>resources</category><body package="OldBrowsers">parcelIcon	"UIMaskEditor new openOnClass: self andSelector: #parcelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (Core.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 2 put: Graphics.ColorValue black; at: 3 put: Graphics.ColorValue yellow; at: 4 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 0); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 89 80 0 0 0 0 0 31 239 212 0 0 0 0 0 127 191 116 0 0 0 0 2 170 169 244 0 0 0 0 7 251 246 244 0 0 0 0 31 239 222 244 0 0 0 0 85 149 126 244 0 0 0 0 127 191 126 208 0 0 0 0 127 191 126 64 0 0 0 0 127 191 125 0 0 0 0 0 127 191 116 0 0 0 0 0 127 191 80 0 0 0 0 0 85 85 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="OldBrowsers">parcelSubMenu	"MenuEditor new openOnClass: self andSelector: #parcelSubMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddTo #catalogID: #menus #defaultString: '&amp;Add To') 				#nameKey: #parcelAddTo				#value: #addSelectionToParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RemoveFrom #catalogID: #menus #defaultString: '&amp;Remove From') 				#nameKey: #parcelRemoveFrom				#value: #removeSelectionFromParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveTo #catalogID: #menus #defaultString: '&amp;Move To')				#nameKey: #parcelMoveTo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Locate #catalogID: #menus #defaultString: '&amp;Locate')				#nameKey: #parcelLocate ) ) #(3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>interface specs</category><body package="OldBrowsers">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #windowLabel 			#min: #(#Point 265 317 ) 			#max: #(#Point 265 317 ) 			#bounds: #(#Rectangle 260 120 525 437 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 2 0 2 0 -2 1 -2 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="OldBrowsers">windowMenuSpec	"UIPainter new openOnClass: self andSelector: #windowMenuSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#min: #(#{Point} 378 325 ) 			#bounds: #(#{Rectangle} 244 138 622 463 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 2 0 40 0 -2 1 -2 1 ) 					#name: #notebook ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 2 0 8 0 -2 0.5 33 0 ) 					#model: #preferenceChoice 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#menu: #preferenceTopMenu ) ) ) )</body><body package="OldBrowsers">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#min: #(#{Point} 523 340 ) 			#bounds: #(#{Rectangle} 186 175 762 517 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{TabControlSpec} 					#layout: #(#{LayoutFrame} 2 0 5 0 -6 1 -3 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>UI.PackagePropertiesDialog class</class-id> <category>interface specs</category><body package="OldBrowsers">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 265 317 ) 			#max: #(#{Core.Point} 418 452 ) 			#bounds: #(#{Graphics.Rectangle} 206 74 595 526 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 33 0 1 0 29 1 -3 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="OldBrowsers">deploymentPropertiesSpec	"UIPainter new openOnClass: self andSelector: #deploymentPropertiesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 335 182 728 599 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #deploymentPropertiesAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #deploymentPropertiesReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #deploymentPropertiesRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0305344 0 0.0479616 ) 					#label: #(#{UserMessage} #key: #warningSuppression #catalogID: #labels #defaultString: 'Warning Suppression Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 -121 0.4 -66 1 -157 0.8 ) 					#name: #warningSuppressionText 					#model: #warningSuppressionText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers">generalPropertiesSpec	"UIPainter new openOnClass: self andSelector: #generalPropertiesSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Point} 274 270 ) 			#bounds: #(#{Rectangle} 890 209 1286 657 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 10 0 40 0 0 0.9 0 0.8 ) 					#flags: 0 					#majorKey: #{ParcelPropertiesInspector} 					#minorKey: #windowSpec 					#clientKey: #generalProperties ) 				#(#{LabelSpec} 					#layout: #(#{Point} 10 10 ) 					#label: #(#{UserMessage} #key: #generalPropertiesInspector #catalogID: #labels #defaultString: 'General Properties Inspector' )) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.1 0 0.9 ) 					#name: #acceptButton 					#flags: 40 					#model: #generalPropertiesAccept 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.4 0 0.9 ) 					#name: #resetButton 					#flags: 40 					#model: #generalPropertiesReset 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset') 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.7 0 0.9 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) ) ) )</body><body package="OldBrowsers">loadOptionsSpec	"UIPainter new openOnClass: self andSelector: #loadOptionsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 327 176 720 593 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #loadOptionsAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #loadOptionsReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #loadOptionsRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0305344 0 0.0479616 ) 					#label: #(#{UserMessage} #key: #warningSuppression #catalogID: #labels #defaultString: 'Warning Suppression Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 -121 0.4 -66 1 -157 0.8 ) 					#name: #warningSuppressionText 					#model: #warningSuppressionText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers">loadSpec	"UIPainter new openOnClass: self andSelector: #loadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 601 376 999 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preLoadAction #catalogID: #labels #defaultString: 'Pre-load Action:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 6 0.4 ) 					#label: #(#{UserMessage} #key: #postLoadAction #catalogID: #labels #defaultString: 'Post-load Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #preloadText 					#model: #preloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #postloadText 					#model: #postloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #loadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #loadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset')					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #loadRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) ) ) )</body><body package="OldBrowsers">preReadSpec	"UIPainter new openOnClass: self andSelector: #preReadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 46 67 444 516 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preReadAction #catalogID: #labels #defaultString: 'Pre-read Action:' )) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 6 0.4 ) 					#label: #(#{UserMessage} #key: #PreReqVersion #catalogID: #labels #defaultString: 'Prerequisite Version Selection Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #preReadText 					#model: #preReadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #versionSelectionText 					#model: #versionSelectionText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #preReadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #preReadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #preReadRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) ) ) )</body><body package="OldBrowsers">prerequisitesSpec	"UIPainter new openOnClass: self andSelector: #prerequisitesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 316 176 709 593 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #prerequisitesAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #prerequisitesReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #prerequisitesRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0356234 0 0.028777 ) 					#label: #(#{UserMessage} #key: #deploymentPrerequisites #catalogID: #labels #defaultString: 'Deployment Prerequisites:' ) )				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #deploymentPrerequisitesText 					#model: #deploymentPrerequisitesText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0407125 0 0.414868 ) 					#label: #(#{UserMessage} #key: #developmentPrerequisites #catalogID: #labels #defaultString: 'Development Prerequisites:' )) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #developmentPrerequisitesText 					#model: #developmentPrerequisitesText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers">saveSpec	"UIPainter new openOnClass: self andSelector: #saveSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 601 376 999 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #saveAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #saveReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #saveRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preSaveAction #catalogID: #labels #defaultString: 'Pre-save Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #presaveText 					#model: #presaveText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers">unloadSpec	"UIPainter new openOnClass: self andSelector: #unloadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 601 376 999 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #unloadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #unloadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #unloadRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #preunloadText 					#model: #preunloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #postunloadText 					#model: #postunloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preUnloadAction #catalogID: #labels #defaultString: 'Pre-unload Action:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 6 0.4 ) 					#label: #(#{UserMessage} #key: #postUnloadAction #catalogID: #labels #defaultString: 'Post-unload Action:' ) ) ) ) )</body><body package="OldBrowsers">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 523 340 ) 			#bounds: #(#{Graphics.Rectangle} 260 158 830 633 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 5 0 -35 1 -18 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>Tools.FullSystemBrowser class</class-id> <category>resources</category><body package="OldBrowsers">acceptCancel	"MenuEditor new openOnClass: self andSelector: #acceptCancel"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #menus ) 				#value: #accept ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Cancel 					#defaultString: '&amp;Cancel' 					#catalogID: #menus ) 				#value: #cancel ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">editGroup	"MenuEditor new openOnClass: self andSelector: #editGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDots 					#defaultString: '&amp;Replace...' 					#catalogID: #menus ) 				#value: #replace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Undo 					#defaultString: '&amp;Undo' 					#catalogID: #menus ) 				#value: #undo ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #menus ) 				#value: #cut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #menus ) 				#value: #paste ) ) #(2 1 3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">evaluateGroup	"MenuEditor new openOnClass: self andSelector: #evaluateGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PrintIt 					#defaultString: '&amp;Print it' 					#catalogID: #menus ) 				#value: #printIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt ) ) #(4 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">hardcopyGroup	"MenuEditor new openOnClass: self andSelector: #hardcopyGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Hardcopy 					#defaultString: '&amp;Hardcopy' 					#catalogID: #menus ) 				#value: #hardcopy ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">menuBarEnd        "MenuEditor new openOnClass: self andSelector: #menuBarEnd"        &lt;resource: #menu&gt;        ^#(#{UI.Menu} #(                #(#{UI.MenuItem}                        #rawLabel:                        #(#{Kernel.UserMessage}                                #key: #_Help                                #defaultString: '&amp;Help'                                #catalogID: #menus )                        #value: #openHelpBrowser                        #submenu: #(#{UI.Menu} #(                                #(#{UI.MenuItem}                                        #rawLabel: #(#{Kernel.UserMessage} #key: #_Topics #defaultString: '&amp;Topics' #catalogID: #menus)                                        #value: #displayHelp ) )                                #(1 ) nil ) ) )                #(1 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">menuBarStart	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarStart"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Browser 					#defaultString: '&amp;Browser' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Update 								#defaultString: '&amp;Update' 								#catalogID: #menus ) 							#value: #updateLists ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #menus ) 							#value: #closeRequest ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #edit ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #view ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">textMenuExtras	"Tools.MenuEditor new openOnClass: self andSelector: #textMenuExtras"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Format 					#defaultString: '&amp;Format' 					#catalogID: #menus ) 				#value: #format				#command: #format ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Explain 					#defaultString: '&amp;Explain' 					#catalogID: #menus ) 				#value: #explain				#command: #explain ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FullSystemBrowser class</class-id> <category>interface specs</category><body package="OldBrowsers">windowSpec0	"UIPainter new openOnClass: self andSelector: #windowSpec0"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Rectangle} 363 313 917 712 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu ) ) ) )</body><body package="OldBrowsers">windowSpec1	"UIPainter new openOnClass: self andSelector: #windowSpec1"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 470 369 1024 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -1 0.4 ) 					#name: #component1 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.4 0 1 2 0.4 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 25 					#minBelowSize: 25 					#aboveWidgets: 'component1' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 2 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#tabRequiresControl: true ) ) ) )</body><body package="OldBrowsers">windowSpec2	"UIPainter new openOnClass: self andSelector: #windowSpec2"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 470 369 1024 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.5 -1 0.4 ) 					#name: #component1 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.5 0 0 2 0.5 -1 0.4 ) 					#name: #ResizingSplitter2 					#horizontal: false 					#minAboveSize: 120 					#minBelowSize: 30 					#aboveWidgets: 'component1' 					#belowWidgets: 'component2' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 -1 0.4 ) 					#name: #component2 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.4 0 1 2 0.4 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 50 					#minBelowSize: 25 					#aboveWidgets: 'component1 component2 ResizingSplitter2' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 2 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#tabRequiresControl: true ) ) ) )</body><body package="OldBrowsers">windowSpec3	"UIPainter new openOnClass: self andSelector: #windowSpec3"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 470 369 1024 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.333 -1 0.4 ) 					#name: #component1 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.333 0 0 0 0.667 -1 0.4 ) 					#name: #component2 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.667 0 0 0 1 -1 0.4 ) 					#name: #component3 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.4 0 1 2 0.4 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 50 					#minBelowSize: 25 					#aboveWidgets: 'component1 component2 component3' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 2 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#tabRequiresControl: true ) ) ) )</body><body package="OldBrowsers">windowSpec4	"UIPainter new openOnClass: self andSelector: #windowSpec4"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 470 369 1024 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.25 -1 0.4 ) 					#name: #component1 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.25 0 0 0 0.5 -1 0.4 ) 					#name: #component2 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 0 0.75 -1 0.4 ) 					#name: #component3 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.75 0 0 0 1 -1 0.4 ) 					#name: #component4 					#flags: 0 					#minorKey: #list4 					#clientKey: #component4 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.4 0 1 2 0.4 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 50 					#minBelowSize: 25 					#aboveWidgets: 'component1 component2 component3 component4' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 2 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#tabRequiresControl: true ) ) ) )</body><body package="OldBrowsers">windowSpec5	"UIPainter new openOnClass: self andSelector: #windowSpec5"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Rectangle} 169 558 723 957 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0 0 0 0 0.2 0 0.4 ) 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.2 0 0 0 0.4 0 0.4 ) 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.4 0 0 0 0.6 0 0.4 ) 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.6 0 0 0 0.8 0 0.4 ) 					#flags: 0 					#minorKey: #list4 					#clientKey: #component4 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.8 0 0 0 1 0 0.4 ) 					#flags: 0 					#minorKey: #list5 					#clientKey: #component5 ) 				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 1 0 1 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu ) ) ) )</body><body package="OldBrowsers">windowSpec6	"UIPainter new openOnClass: self andSelector: #windowSpec6"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Rectangle} 169 558 723 957 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0 0 0 0 0.2 0 0.4 ) 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.2 0 0 0 0.4 0 0.4 ) 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.4 0 0 0 0.6 0 0.4 ) 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.6 0 0 0 0.8 0 0.4 ) 					#flags: 0 					#minorKey: #list4 					#clientKey: #component4 ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0.8 0 0 0 1 0 0.4 ) 					#flags: 0 					#minorKey: #list5 					#clientKey: #component5 ) 				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 1 0 1 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu ) ) ) )</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">browseFieldAssignments	"Show a menu of all instance variables of the currently selected class  	and its superclasses.  Browse all methods which assign to the variable selected."	&lt;menuItem: #(#InstVarAssignmentsDot #menus 'Inst Var &amp;Assignments...')		nameKey: #instVarAssign		menu: #(#listMenu #browse)		position: 10.011 &gt;	| name |	name := self forClass: self selectedItem			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	self methodCollector		baseClass: self selectedItem;		browseAllAccessesTo: name type: #write</body><body package="OldBrowsers">browseFieldReads	"Show a menu of all instance variables of the currently selected class	 and its superclasses.  Browse all methods which read the variable selected."	&lt;menuItem: #(#InstVarReadsDot #menus 'Inst Var &amp;Reads...')		nameKey: #instVarRead		menu: #(#listMenu #browse)		position: 10.012 &gt;	| name |	name := self forClass: self selectedItem			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	self methodCollector		baseClass: self selectedItem;		browseAllAccessesTo: name type: #read</body><body package="OldBrowsers">browseLocalCallsOn	"Spawn a Browser on references to anObject within the current class.."	&lt;menuItem: #(#LocalReferencesToDot #menus 'Local References &amp;To...')		nameKey: nil		menu: #(#listMenu #browse)		position: 21.01 &gt;	| aLiteral |	aLiteral := SmalltalkWorkbench				promptForSelector: (#BrowseLocalReferencesToWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse local references to what?')				for: self interfaceWindow.	aLiteral isNil ifTrue: [^self].	^self methodCollector		baseClass: self selectedItem instanceBehavior;		browseAllReferencesTo: aLiteral</body><body package="OldBrowsers">browseLocalImplementorsOf	"Spawn a Browser on references to anObject within the current class.."	&lt;menuItem: #(#LocalImplementorsOfDot #menus 'Local Implementors &amp;Of...')		nameKey: nil		menu: #(#listMenu #browse)		position: 21.015 &gt;	| aLiteral |	aLiteral := SmalltalkWorkbench				promptForSelector: (#BrowseLocalImplementorsOfWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse local implementors of what?')				withinHierarchyOf: self selectedItem instanceBehavior				for: self interfaceWindow.	aLiteral isNil ifTrue: [^self].	^self methodCollector		baseClass: self selectedItem instanceBehavior;		browseAllImplementorsOf: aLiteral</body><body package="OldBrowsers">initializeSelections	"Any of the selections which may be initialized will be initialized here."	&lt;menuItem: #(#Initialize #menus 'Initialize')		nameKey: nil		menu: #(#listMenu)		position: 30.038 &gt;	self selections do: 		[ :selection |		selection isForClass	ifTrue: [ selection initialize ]		]</body><body package="OldBrowsers">searchForStringInSource	"Spawn a Browser on all methods which contain a specified string."	&lt;menuItem: #(#MethodsWithPhraseDot #menus 'Methods with &amp;Phrase...')		nameKey: nil		menu: #(#listMenu #browse) 		position: 21.03 &gt;	| string class selectors classes allSelectorsMDs |Cursor wait showWhile:[ 	(class := self targetClassOrNameSpace) isNil ifTrue: [^self].	class isForNameSpace ifTrue:[ classes := class allClasses ] ifFalse: [ classes := Array with: class].	string := Dialog request: (#ShowMethodsWithSourceCodeContainingColon &lt;&lt; #dialogs &gt;&gt; 'Show methods with source code containing:') for: self interfaceWindow.	string isEmpty ifTrue: [^self].	allSelectorsMDs := OrderedCollection new: 1000.	classes do:[:eachClass | 	selectors := eachClass selectors.	selectors := selectors select: [:sel| | s |								nil ~~ (s := eachClass sourceCodeAt: sel)								and: [(s indexOfSubCollection: string										startingAt: 1) &gt; 0]].	allSelectorsMDs addAll: (selectors collect: [:sel| (MethodDefinition class: eachClass selector: sel)])].].	^self methodCollector		openListBrowserOn: allSelectorsMDs asSortedCollection asArray		label: ((#SourceIn1sContaining2s &lt;&lt; #dialogs &gt;&gt; 'Source in &lt;1s&gt; containing &lt;2s&gt;')			expandMacrosWith: class printString			with: string)		initialSelection: string</body></methods><methods><class-id>Tools.ClassesBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">commentIconColor	"UIMaskEditor new openOnClass: self andSelector: #commentIconColor"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 255 0 240 1 255 0 247 252 255 0 247 253 127 0 246 85 191 0 247 253 223 0 246 148 15 0 247 255 239 0 246 42 111 0 247 255 239 0 246 84 239 0 247 255 239 0 246 138 111 0 247 255 239 0 246 42 175 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 240 0 15 0 255 255 255 0])</body><body package="OldBrowsers">commentIconMask	"UIMaskEditor new openOnClass: self andSelector: #commentIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 15 254 0 0 15 255 0 0 15 255 128 0 15 255 192 0 15 255 224 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 0 0 0 0])</body><body package="OldBrowsers">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 				#(#UserMessage 					#key: #showHierarchy 					#defaultString: '&amp;Hierarchy' 					#catalogID: #menus ) 				#nameKey: #hierarchy 				#value: #showHierarchy 				#labelImage: #(#ResourceRetriever #ClassesBrowserHelper #hierarchyIcon ) ) 			#(#MenuItem 				#rawLabel: 				#(#UserMessage 					#key: #showDefinition 					#defaultString: '&amp;Definition' 					#catalogID: #menus ) 				#nameKey: #definition 				#value: #showDefinition 				#labelImage: #(#ResourceRetriever #ClassesBrowserHelper #definitionIcon ) ) 			#(#MenuItem 				#rawLabel: 				#(#UserMessage 					#key: #showComment 					#defaultString: 'Co&amp;mment' 					#catalogID: #menus ) 				#nameKey: #comment 				#value: #showComment 				#labelImage: #(#ResourceRetriever #ClassesBrowserHelper #commentIcon ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">definitionIconColor	"UIMaskEditor new openOnClass: self andSelector: #definitionIconColor"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue blue; at: 4 put: ColorValue white; yourself)) usingBits: #[255 255 255 255 255 255 0 0 255 255 255 255 255 255 0 0 253 85 127 213 85 255 0 0 253 255 127 223 253 255 0 0 193 255 64 31 253 255 0 0 253 255 127 223 253 255 0 0 253 255 127 223 253 255 0 0 253 85 127 213 85 255 0 0 255 243 255 255 63 255 0 0 255 243 255 255 63 255 0 0 255 243 255 255 63 255 0 0 255 243 255 255 63 255 0 0 255 234 255 213 85 255 0 0 255 174 191 223 253 255 0 0 254 191 175 223 253 255 0 0 250 255 224 31 253 255 0 0 254 191 175 223 253 255 0 0 255 174 191 213 85 255 0 0 255 234 255 255 255 255 0 0 255 243 255 255 255 255 0 0 255 0 63 255 255 255 0 0 255 192 255 255 255 255 0 0 255 243 255 255 255 255 0 0 255 255 255 255 255 255 0 0])</body><body package="OldBrowsers">definitionIconMask	"UIMaskEditor new openOnClass: self andSelector: #definitionIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 135 240 0 31 135 240 0 127 255 240 0 31 135 240 0 31 135 240 0 31 135 240 0 2 0 128 0 2 0 128 0 2 0 128 0 2 0 128 0 7 7 240 0 15 135 240 0 31 199 240 0 63 255 240 0 31 199 240 0 15 135 240 0 7 0 0 0 2 0 0 0 15 128 0 0 7 0 0 0 2 0 0 0 0 0 0 0])</body><body package="OldBrowsers">hierarchyIconColor	"UIMaskEditor new openOnClass: self andSelector: #hierarchyIconColor"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 0); at: 4 put: ColorValue white; at: 5 put: ColorValue red; yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3H"H"H"H"L3L3L3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3@QDQDQDQL3L3L3L3@3@3L3L3L3L3L3L3@3@3L3L3L3L3L3L3@3ADQDQDQDL3L3L3@3@3L3L3L3L3L3L3@3@3L3L3L3L3L3L3@3ADQDQDQDL3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3@QDQDQDQL3L3L3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3ADQDQDQDL3L3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3ADQDQDQDL3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3'))</body><body package="OldBrowsers">hierarchyIconMask	"UIMaskEditor new openOnClass: self andSelector: #hierarchyIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 254 0 0 2 0 0 0 2 0 0 0 3 255 192 0 2 64 0 0 2 64 0 0 2 127 248 0 2 64 0 0 2 64 0 0 2 127 248 0 2 0 0 0 2 0 0 0 3 255 192 0 0 64 0 0 0 64 0 0 0 127 248 0 0 64 0 0 0 64 0 0 0 127 248 0 0 0 0 0 0 0 0 0])</body><body package="OldBrowsers">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hardcopy #catalogID: #menus #defaultString: '&amp;Hardcopy') 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #S_pawnHierarchy #catalogID: #menus #defaultString: 'S&amp;pawn Hierarchy') 				#nameKey: #spawnHierarchy 				#value: #spawnHierarchy ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddClass #catalogID: #menus #defaultString: '&amp;Add Class') 				#nameKey: #add 				#value: #addClassVariableSize 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FixedSize #catalogID: #menus #defaultString: '&amp;Fixed Size') 							#nameKey: #addClassFixedSize 							#value: #addClassFixedSize ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Indexed #catalogID: #menus #defaultString: '&amp;Indexed') 							#nameKey: #addClassVariableSize 							#value: #addClassVariableSize ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ByteIndexed #catalogID: #menus #defaultString: '&amp;Byte Indexed') 							#nameKey: #addClassBytes 							#value: #addClassBytes ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Browse #catalogID: #menus #defaultString: '&amp;Browse') 				#nameKey: #browse 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InstVarReferencesDot #catalogID: #menus #defaultString: '&amp;Inst Var References...') 							#nameKey: #browseFieldReferences 							#value: #browseFieldReferences ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SharedVarReferencesDot #catalogID: #menus #defaultString: '&amp;Shared Var References...') 							#nameKey: #browseClassVariables 							#value: #browseClassVariables ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ClassReferences #catalogID: #menus #defaultString: '&amp;Class References') 							#nameKey: #browseClass 							#value: #browseClassReferences ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveToDot #catalogID: #menus #defaultString: '&amp;Move To...') 				#nameKey: #move 				#value: #move 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #CategoryDot #catalogID: #menus #defaultString: '&amp;Category...') 							#nameKey: #move 							#value: #move ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #NamespaceDot #catalogID: #menus #defaultString: '&amp;Namespace...') 							#nameKey: #moveNameSpace 							#value: #moveNameSpace ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_ParcelDot #catalogID: #menus #defaultString: '&amp;Parcel...') 							#nameKey: #moveNewParcel 							#value: #moveNewParcel ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #rename 				#value: #rename ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) ) #(4 2 3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">metaMenu	"MenuEditor new openOnClass: self andSelector: #metaMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #InstanceDefinitions 					#defaultString: '&amp;Instance Methods' 					#catalogID: #menus ) 				#nameKey: #instance 				#value: #metaOff ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #ClassDefinitions 					#defaultString: '&amp;Class Methods' 					#catalogID: #menus ) 				#nameKey: #class 				#value: #metaOn ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #Data 					#defaultString: '&amp;Shared Variables' 					#catalogID: #menus ) 				#nameKey: #data 				#value: #metaShowData ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ProtocolBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hardcopy #catalogID: #menus #defaultString: '&amp;Hardcopy') 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddDot #catalogID: #menus #defaultString: '&amp;Add...') 				#nameKey: #add 				#value: #add ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #rename 				#value: #rename ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FindDots #catalogID: #menus #defaultString: '&amp;Find...') 				#nameKey: #findMethod 				#value: #findMethod ) ) #(3 3 1 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">metaMenu	"MenuEditor new openOnClass: self andSelector: #metaMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InstanceDefinitions 					#defaultString: '&amp;Instance Methods' 					#catalogID: #menus ) 				#nameKey: #instance 				#value: #instance ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ClassDefinitions 					#defaultString: '&amp;Class Methods' 					#catalogID: #menus ) 				#nameKey: #class 				#value: #class ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Data 					#defaultString: '&amp;Shared Variables' 					#catalogID: #menus ) 				#nameKey: #data 				#value: #data ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hardcopy #catalogID: #menus #defaultString: '&amp;Hardcopy') 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddDot #catalogID: #menus #defaultString: '&amp;Add...') 				#nameKey: #add 				#value: #addCategory ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #rename 				#value: #rename ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #FindClassDot #catalogID: #menus #defaultString: '&amp;Find Class...') 				#nameKey: #findClass 				#value: #findClass ) ) #(3 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.NamespaceTabApplication class</class-id> <category>resources</category><body package="OldBrowsers">folderIcon	"UIMaskEditor new openOnClass: self andSelector: #folderIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@17 depth: 2 bitsPerPixel: 2 palette: (Core.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue yellow; at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 170 168 170 170 170 168 170 170 170 168 128 42 170 168 38 64 0 0 0 25 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 0 0 0 0 170 170 170 168])</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">browseClass	"Browse the class of the context's receiver"	&lt;menuItem: #(#BrowseClassDot #menus 'Browse Class...')		nameKey: nil		menu: #(#contextMenu)		position: 20.045&gt;	| ctxt |	(ctxt := self browser context) notNil ifTrue:		[(ctxt homeReceiver isNil		 and: [ctxt homeReceiver class ~~ ctxt mclass])			ifTrue: [ctxt mclass instanceBehavior browse]			ifFalse: [ctxt homeReceiver browse]]</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">baseListMenu	"MenuEditor new openOnClass: self andSelector: #baseListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoreStack #defaultString: '&amp;More Stack' #catalogID: #menus) 				#nameKey: #moreStack 				#value: #moreStack ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Proceed #defaultString: '&amp;Proceed' #catalogID: #menus) 				#nameKey: #proceed 				#value: #proceed 				#shortcutKeyCharacter: #F7 				#shortcutModifiers: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Restart #defaultString: '&amp;Restart' #catalogID: #menus) 				#nameKey: #restart 				#value: #restart ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Senders #defaultString: '&amp;Senders' #catalogID: #menus) 				#nameKey: #allSenders ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Implementors #defaultString: '&amp;Implementors' #catalogID: #menus) 				#nameKey: #allImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #LocalSe_nders #defaultString: 'Local Se&amp;nders' #catalogID: #menus) 				#nameKey: #localSenders ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #LocalI_mplementors #defaultString: 'Local I&amp;mplementors' #catalogID: #menus) 				#nameKey: #localImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SkipToCaret #defaultString: 'Skip to &amp;Caret' #catalogID: #menus) 				#nameKey: #skipToCaret 				#value: #skipToCaret ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Step #defaultString: 'Ste&amp;p' #catalogID: #menus) 				#nameKey: #step 				#value: #step 				#shortcutKeyCharacter: #F4 				#shortcutModifiers: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Send #defaultString: 'Sen&amp;d' #catalogID: #menus) 				#nameKey: #send 				#value: #send 				#shortcutKeyCharacter: #F5 				#shortcutModifiers: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyStack #defaultString: 'Copy Stac&amp;k' #catalogID: #menus) 				#nameKey: #copyStack 				#value: #copyStack ) ) #(3 4 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.SimpleBrowserModule class</class-id> <category>interface specs</category><body package="OldBrowsers">listSpec	"UIPainter new openOnClass: self andSelector: #listSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Rectangle} 458 440 658 640 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#properties: 					#(#{PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#name: #list 					#model: #list 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#doubleClickSelector: #spawnBrowser 						#requestValueChangeSelector: #testChangeSelection: ) 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #normalSelection ) ) ) )</body><body package="OldBrowsers">listSpecProtocols	"UIPainter new openOnClass: self andSelector: #listSpecProtocols"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 1 -41 1 ) 					#name: #list 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #spawnBrowser 						#requestValueChangeSelector: 						#testChangeSelection: ) 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #normalSelection ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -30 1 0 0.5 ) 					#name: #instanceButton 					#model: #meta 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #instance #defaultString: 'instance' #catalogID: #labels) 					#select: #instance ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.6 -30 1 0 0.5 ) 					#name: #classButton 					#model: #meta 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #class #defaultString: 'class' #catalogID: #labels) 					#select: #class ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -10 1 0 0.5 ) 					#name: #dataButton 					#model: #meta 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #sharedVariables #defaultString: 'shared variables' #catalogID: #labels) 					#select: #data ) ) ) )</body><body package="OldBrowsers">listSpecProtocolsSingleSelect	"UIPainter new openOnClass: self andSelector: #listSpecProtocolsSingleSelect"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 1 -41 1 ) 					#name: #list 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #spawnBrowser 						#requestValueChangeSelector: 						#testChangeSelection: ) 					#menu: #listMenu 					#multipleSelections: false 					#useModifierKeys: true 					#selectionType: #normalSelection ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -30 1 0 0.5 ) 					#name: #instanceButton 					#model: #meta 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #instance #defaultString: 'instance' #catalogID: #labels) 					#select: #instance ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.6 -30 1 0 0.5 ) 					#name: #classButton 					#model: #meta 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #class #defaultString: 'class' #catalogID: #labels) 					#select: #class ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 5 0 -10 1 0 0.5 ) 					#name: #dataButton 					#model: #meta 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #sharedVariables #defaultString: 'shared variables' #catalogID: #labels) 					#select: #data ) ) ) )</body><body package="OldBrowsers">listSpecSingleSelect	"UIPainter new openOnClass: self andSelector: #listSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Rectangle} 339 318 539 518 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#properties: 					#(#{PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#name: #list 					#model: #list 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#doubleClickSelector: #spawnBrowser 						#requestValueChangeSelector: 						#testChangeSelection: ) 					#menu: #listMenu 					#multipleSelections: false 					#selectionType: #normalSelection ) ) ) )</body></methods><methods><class-id>Tools.HierarchicalBrowserModule class</class-id> <category>interface specs</category><body package="OldBrowsers">listSpec	"UIPainter new openOnClass: self andSelector: #listSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 324 227 524 427 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.HierarchicalViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0 0 0.99 0 1.0 ) 					#name: #list 					#flags: 15 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #doubleClick 						#requestValueChangeSelector: 						#testChangeSelection: ) 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #normalSelection ) ) ) )</body></methods><methods><class-id>Tools.HierarchyBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Add #catalogID: #menus #defaultString: '&amp;Add') 				#nameKey: #add 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Namespace #catalogID: #menus #defaultString: '&amp;Namespace') 							#nameKey: #addNameSpace 							#value: #addNameSpace ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SharedVariable #catalogID: #menus #defaultString: '&amp;Shared Variable') 							#nameKey: #addBinding 							#value: #addBinding ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveToDot #catalogID: #menus #defaultString: '&amp;Move To...') 				#nameKey: #moveTo 				#value: #moveTo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #renameAs 				#value: #renameAs ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FindDots #catalogID: #menus #defaultString: '&amp;Find...') 				#nameKey: #find 				#value: #find ) ) #(2 1 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.BlankUI class</class-id> <category>interface specs</category><body package="OldBrowsers">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Point} 20 20 ) 			#bounds: #(#{Rectangle} 260 292 460 492 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#model: #blankList ) ) ) )</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers">browseClass	"Spawn a Browser on the selected method's class.."	&lt;menuItem: #(#BrowseClass #menus 'Browse Class')		nameKey: nil		menu: #(#listMenu)		position: 20.1 &gt;	| definition |	SmalltalkWorkbench browseClass: ((definition := self selection) isBindingReference											ifTrue: [definition environment]											ifFalse: [definition implementingClass]) instanceBehavior</body></methods><methods><class-id>Tools.ParcelListBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ParcelComment #defaultString: 'Parcel comment' #catalogID: #menus) 				#nameKey: #parcelComment 				#value: #parcelComment ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #parcelSummary 					#defaultString: 'Parcel summary' 					#catalogID: #menus ) 				#nameKey: #parcelSummary 				#value: #parcelSummary ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DanglingReferences #defaultString: 'Dangling references' #catalogID: #menus) 				#nameKey: #parcelDanglingReferences 				#value: #parcelDanglingReferences ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDot 					#defaultString: '&amp;New...' 					#catalogID: #menus ) 				#nameKey: #newParcel 				#value: #newParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_LoadDot 					#defaultString: '&amp;Load...' 					#catalogID: #menus ) 				#nameKey: #loadParcel 				#value: #loadParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_SaveDot 					#defaultString: '&amp;Save...' 					#catalogID: #menus ) 				#nameKey: #saveParcelDialog 				#value: #saveParcelDialog ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileOutAsDot 					#defaultString: 'File &amp;Out As...' 					#catalogID: #menus ) 				#nameKey: #fileOutParcel 				#value: #fileOutParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_nameAsDot 					#defaultString: 'Re&amp;name As...' 					#catalogID: #menus ) 				#nameKey: #renameParcel 				#value: #renameParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #UnloadDot 					#defaultString: '&amp;Unload...' 					#catalogID: #menus ) 				#nameKey: #unloadParcel 				#value: #unloadParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RemoveDot 					#defaultString: '&amp;Remove...' 					#catalogID: #menus ) 				#nameKey: #removeParcel 				#value: #removeParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Discard 					#defaultString: '&amp;Discard' 					#catalogID: #menus ) 				#nameKey: #discardParcel 				#value: #discardParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Empty 					#defaultString: '&amp;Empty' 					#catalogID: #menus ) 				#nameKey: #emptyParcel 				#value: #emptyParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BuildDot 					#defaultString: '&amp;Build...' 					#catalogID: #menus ) 				#nameKey: #buildSubMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddFileIn 								#defaultString: 'Add &amp;File-In' 								#catalogID: #menus ) 							#nameKey: #fileIntoParcel 							#value: #fileIntoParcel ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddChanges 								#defaultString: 'Add &amp;Changes' 								#catalogID: #menus ) 							#nameKey: #addChangeSet 							#value: #addChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveChanges 								#defaultString: '&amp;Remove Changes' 								#catalogID: #menus ) 							#nameKey: #removeChangeSet 							#value: #removeChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddToChanges 								#defaultString: 'Add &amp;to Changes' 								#catalogID: #menus ) 							#nameKey: #addToChanges 							#value: #addToChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveFromChanges 								#defaultString: 'Remove &amp;from Changes' 								#catalogID: #menus ) 							#nameKey: #removeFromChanges 							#value: #removeFromChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ComputePrerequisites 								#defaultString: '&amp;Compute Prerequisites' 								#catalogID: #menus ) 							#nameKey: #showComputedPrerequisites 							#value: #showComputedPrerequisites ) ) #(3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Browse 					#defaultString: '&amp;Browse' 					#catalogID: #menus ) 				#nameKey: #browseSubMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ImportedClassReferences 								#defaultString: '&amp;Imported Class References' 								#catalogID: #menus ) 							#value: #browseClassImports ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExportedClassReferences 								#defaultString: '&amp;Exported Class References' 								#catalogID: #menus ) 							#value: #browseClassExports ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #UnparcelledMethodsUsedExclusively 								#defaultString: 'Unparcelled Methods &amp;Used Exclusively' 								#catalogID: #menus ) 							#value: #browseExclusiveMethodImports ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #UnparcelledMethodsInDefinedClasses 								#defaultString: 'Unparcelled Methods in &amp;Defined Classes' 								#catalogID: #menus ) 							#value: #browseUnparceledMethodsOnDefinedClasses ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExtensionMethods 								#defaultString: '&amp;Extension Methods' 								#catalogID: #menus ) 							#value: #browseExtensionMethods ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OverriddenExtensions 								#defaultString: '&amp;Overridden Extensions' 								#catalogID: #menus ) 							#value: #browseOverriddenExtensions ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsOverriddenByOthers 								#defaultString: '&amp;Methods Overridden by Others' 								#catalogID: #menus ) 							#nameKey: #browseOverriddenByOthers 							#value: #browseOverriddenByOthers ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangedMethods 								#defaultString: 'C&amp;hanged Methods' 								#catalogID: #menus ) 							#value: #browseChangedMethods ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Dan_glingReferences 								#defaultString: 'Dan&amp;gling References' 								#catalogID: #menus ) 							#value: #browseDanglingReferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReferencesToDot 								#defaultString: '&amp;References to...' 								#catalogID: #menus ) 							#value: #browseSendersOf ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ImplementorsOfDot 								#defaultString: '&amp;Implementors of...' 								#catalogID: #menus ) 							#value: #browseImplementorsOf ) ) #(4 3 2 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Filter 					#defaultString: 'Fi&amp;lter' 					#catalogID: #menus ) 				#nameKey: #filter 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowOnlyParceled 								#defaultString: 'Show Only &amp;Parceled' 								#catalogID: #menus ) 							#nameKey: #showOnlyParceled 							#value: #toggleParceled ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowOnlyUnparceled 								#defaultString: 'Show Only &amp;Unparceled' 								#catalogID: #menus ) 							#nameKey: #showOnlyUnparceled 							#value: #toggleUnparceled ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowMultiplyParceled 								#defaultString: 'Show &amp;Multiply Parceled' 								#catalogID: #menus ) 							#nameKey: #showMultiplyParceled 							#value: #toggleConflicts ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #PropertiesDot 					#defaultString: '&amp;Properties...' 					#catalogID: #menus ) 				#value: #openParcelProperties ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #UndoLastParcelling 					#defaultString: '&amp;Undo Last Parcelling' 					#catalogID: #menus ) 				#nameKey: #doUndo 				#value: #doUndo ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#value: #inspectParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Update 					#defaultString: '&amp;Update' 					#catalogID: #menus ) 				#nameKey: #updateBrowser 				#value: #updateBrowser ) ) #(2 2 3 2 3 3 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MorphingBrowserModule class</class-id> <category>resources</category><body package="OldBrowsers">metaMenu	"MenuEditor new openOnClass: self andSelector: #metaMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #InstanceDefinitions 					#defaultString: '&amp;Instance Methods' 					#catalogID: #menus ) 				#nameKey: #instance 				#value: #instance ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #ClassDefinitions 					#defaultString: '&amp;Class Methods' 					#catalogID: #menus ) 				#nameKey: #class 				#value: #class ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #Data 					#defaultString: '&amp;Shared Variables' 					#catalogID: #menus ) 				#nameKey: #data 				#value: #data ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.BrowserListEntry class</class-id> <category>resources</category><body package="OldBrowsers">CFolderIcon	"UIMaskEditor new openOnClass: self andSelector: #CFolderIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 128 42 170 168 38 64 0 0 0 25 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 0 0 0 0 170 170 170 168])</body><body package="OldBrowsers">CMenuIcon	"UIMaskEditor new openOnClass: self andSelector: #CMenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4369); at: 3 put: ColorValue yellow; at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 8191); yourself)) usingBits: #[51 51 51 51 51 51 51 48 51 48 0 0 0 0 0 48 51 48 34 34 34 34 32 48 51 48 0 0 0 0 0 48 51 48 51 51 51 3 51 48 51 48 17 17 17 3 51 48 51 48 68 68 68 3 51 48 51 48 17 17 17 3 51 48 51 48 51 51 51 3 51 48 51 48 17 17 17 3 51 48 51 48 51 51 51 3 51 48 51 48 0 0 0 3 51 48 51 51 51 51 51 51 51 48 51 51 51 51 51 51 51 48 ])</body><body package="OldBrowsers">CModelIcon	"UIMaskEditor new openOnClass: self andSelector: #CModelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue cyan; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: #[170 170 170 168 170 168 0 40 170 131 255 192 170 132 0 16 170 133 85 80 170 165 85 80 168 0 5 80 168 162 133 64 168 0 4 40 168 162 138 168 168 0 10 168 168 162 138 168 168 0 10 168 170 170 170 168 ])</body><body package="OldBrowsers">CQueryIcon	"UIMaskEditor new openOnClass: self andSelector: #CQueryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue cyan; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: #[170 170 42 168 170 168 10 168 170 160 2 168 170 170 42 168 170 130 32 168 168 62 47 8 168 66 32 72 168 86 37 72 168 86 37 72 168 86 37 72 168 85 149 72 170 5 84 40 170 160 2 168 170 170 170 168 ])</body><body package="OldBrowsers">CRegionsIcon	"UIMaskEditor new openOnClass: self andSelector: #CRegionsIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 170 168 168 0 0 40 168 0 0 40 168 21 64 40 168 21 64 40 168 21 84 40 168 5 84 40 168 5 84 40 168 5 84 40 168 0 0 40 168 0 0 40 170 170 170 168 170 170 170 168])</body><body package="OldBrowsers">CSignalIcon	"UIMaskEditor new openOnClass: self andSelector: #CSignalIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; yourself)) usingBits: #[170 160 2 168 170 161 82 168 170 133 74 168 170 133 42 168 170 21 2 168 170 1 82 168 170 161 74 168 170 133 42 168 170 132 170 168 170 20 10 168 170 1 74 168 170 161 42 168 170 132 170 168 170 130 170 168])</body><body package="OldBrowsers">CVariableIcon	"UIMaskEditor new openOnClass: self andSelector: #CVariableIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 3 put: ColorValue yellow; at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 0); yourself)) usingBits: #[51 51 51 0 3 51 51 48 51 51 0 68 64 3 51 48 51 0 68 68 68 64 3 48 48 4 68 68 68 68 0 48 48 32 4 68 68 0 32 48 48 18 16 4 0 18 16 48 48 33 33 32 33 33 32 48 48 18 18 16 18 18 16 48 48 33 33 32 33 33 32 48 48 18 18 16 18 18 16 48 48 1 33 32 33 33 0 48 51 48 2 16 18 0 51 48 51 51 48 0 0 51 51 48 51 51 51 48 51 51 51 48])</body><body package="OldBrowsers">CcanvasIcon	"UIMaskEditor new openOnClass: self andSelector: #CcanvasIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 160 42 168 170 168 170 168 168 0 0 168 170 25 152 168 170 6 102 40 170 137 153 136 170 130 100 8 170 161 128 168 170 160 8 168 170 168 138 40 170 170 138 168 170 170 170 168 170 170 170 168 ])</body><body package="OldBrowsers">CiconIcon	"UIMaskEditor new openOnClass: self andSelector: #CiconIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 4369 scaledBlue: 0); at: 3 put: ColorValue magenta; at: 4 put: ColorValue white; at: 5 put: ColorValue blue; yourself)) usingBits: #[51 51 51 51 51 51 51 48 51 51 51 51 51 51 51 48 51 48 0 0 0 0 3 48 51 48 51 1 16 51 3 48 51 48 51 1 16 51 3 48 51 48 0 0 0 0 3 48 51 48 34 3 48 51 3 48 51 48 34 3 48 51 3 48 51 48 0 0 0 0 3 48 51 48 51 4 64 51 3 48 51 48 51 4 64 51 3 48 51 48 0 0 0 0 3 48 51 51 51 51 51 51 51 48 51 51 51 51 51 51 51 48 ])</body><body package="OldBrowsers">MskCanvasIcon	"UIMaskEditor new openOnClass: self andSelector: #MskCanvasIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 3 128 0 0 1 0 0 0 31 240 0 0 15 240 0 0 15 248 0 0 7 252 0 0 7 252 0 0 3 240 0 0 3 208 0 0 1 72 0 0 0 64 0 0 0 0 0 0 0 0 0 0 ])</body><body package="OldBrowsers">MskFolderIcon	"UIMaskEditor new openOnClass: self andSelector: #MskFolderIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 120 0 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 0 0 0 0])</body><body package="OldBrowsers">MskIconIcon	"UIMaskEditor new openOnClass: self andSelector: #MskIconIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 0 0 0 0 0 0 0 0 ])</body><body package="OldBrowsers">MskMenuIcon	"UIMaskEditor new openOnClass: self andSelector: #MskMenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 0 0 0 0 0 0 0 0 ])</body><body package="OldBrowsers">MskModelIcon	"UIMaskEditor new openOnClass: self andSelector: #MskModelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 248 0 0 7 254 0 0 7 254 0 0 7 254 0 0 3 254 0 0 31 254 0 0 31 254 0 0 31 248 0 0 31 192 0 0 31 192 0 0 31 192 0 0 31 192 0 0 0 0 0 0 ])</body><body package="OldBrowsers">MskQueryIcon	"UIMaskEditor new openOnClass: self andSelector: #MskQueryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 128 0 0 1 192 0 0 3 224 0 0 0 128 0 0 7 240 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 15 248 0 0 3 224 0 0 0 0 0 0 ])</body><body package="OldBrowsers">MskSignalIcon	"UIMaskEditor new openOnClass: self andSelector: #MskSignalIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 224 0 0 3 224 0 0 7 192 0 0 7 128 0 0 15 224 0 0 15 224 0 0 3 192 0 0 7 128 0 0 7 0 0 0 15 192 0 0 15 192 0 0 3 128 0 0 7 0 0 0 6 0 0 0])</body><body package="OldBrowsers">MskVariableIcon	"UIMaskEditor new openOnClass: self andSelector: #MskVariableIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 128 0 0 15 224 0 0 63 248 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 31 240 0 0 7 192 0 0 1 0 0 0])</body></methods><initialize><class-id>UI.PackagePropertiesDialog</class-id></initialize><initialize><class-id>Tools.BrowserListEntry</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GeneralMethodDefinition</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>